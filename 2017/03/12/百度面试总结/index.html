<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="红楼记事,实习面试," />





  <link rel="alternate" href="/atom.xml" title="Free Will" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/img/favicon.ico?v=5.1.0" />






<meta name="description" content="第一次去BAT面试数据挖掘岗实习生，面试过程中考察了很多基础的知识点，深度没有想象中的深，主要是考察的范围非常广，后来看了一些面经，这个岗位大致会考察你几个部分，分别是数据结构与算法、编码实现能力、项目实现与业务理解。慢慢地积累，一块一块地突破。其实面试关倒可以短时间内补补课就过去了，关键是笔试部分，这几天做了一些OJ，想想是任重而道远了。加油吧，少年！把面试中考察到的知识点整理如下。">
<meta name="keywords" content="红楼记事,实习面试">
<meta property="og:type" content="article">
<meta property="og:title" content="百度面试回归记">
<meta property="og:url" content="http://yoursite.com/2017/03/12/百度面试总结/index.html">
<meta property="og:site_name" content="Free Will">
<meta property="og:description" content="第一次去BAT面试数据挖掘岗实习生，面试过程中考察了很多基础的知识点，深度没有想象中的深，主要是考察的范围非常广，后来看了一些面经，这个岗位大致会考察你几个部分，分别是数据结构与算法、编码实现能力、项目实现与业务理解。慢慢地积累，一块一块地突破。其实面试关倒可以短时间内补补课就过去了，关键是笔试部分，这几天做了一些OJ，想想是任重而道远了。加油吧，少年！把面试中考察到的知识点整理如下。">
<meta property="og:image" content="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-09%20%E4%B8%8A%E5%8D%888.49.45.png">
<meta property="og:image" content="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-09%20%E4%B8%8A%E5%8D%889.15.53.png">
<meta property="og:image" content="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-09%20%E4%B8%8A%E5%8D%8810.42.28.png">
<meta property="og:image" content="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-09%20%E4%B8%8B%E5%8D%882.12.47.png">
<meta property="og:image" content="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-09%20%E4%B8%8B%E5%8D%882.12.57.png">
<meta property="og:image" content="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-10%20%E4%B8%8B%E5%8D%8812.50.56.png">
<meta property="og:image" content="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-10%20%E4%B8%8A%E5%8D%889.47.14.png">
<meta property="og:image" content="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-10%20%E4%B8%8A%E5%8D%8810.03.24.png">
<meta property="og:updated_time" content="2017-04-11T11:34:57.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="百度面试回归记">
<meta name="twitter:description" content="第一次去BAT面试数据挖掘岗实习生，面试过程中考察了很多基础的知识点，深度没有想象中的深，主要是考察的范围非常广，后来看了一些面经，这个岗位大致会考察你几个部分，分别是数据结构与算法、编码实现能力、项目实现与业务理解。慢慢地积累，一块一块地突破。其实面试关倒可以短时间内补补课就过去了，关键是笔试部分，这几天做了一些OJ，想想是任重而道远了。加油吧，少年！把面试中考察到的知识点整理如下。">
<meta name="twitter:image" content="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-09%20%E4%B8%8A%E5%8D%888.49.45.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"hide"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>







  <title> 百度面试回归记 | Free Will </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Free Will</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-yiyu">
          <a href="/yiyu" rel="section">
            
            呓语
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/12/百度面试总结/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="狗皮膏药">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/img/v.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Free Will">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Free Will" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                百度面试回归记
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-12T22:14:45+08:00">
                2017-03-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/红楼记事/" itemprop="url" rel="index">
                    <span itemprop="name">红楼记事</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>第一次去BAT面试数据挖掘岗实习生，面试过程中考察了很多基础的知识点，深度没有想象中的深，主要是考察的范围非常广，后来看了一些面经，这个岗位大致会考察你几个部分，分别是数据结构与算法、编码实现能力、项目实现与业务理解。慢慢地积累，一块一块地突破。其实面试关倒可以短时间内补补课就过去了，关键是笔试部分，这几天做了一些OJ，想想是任重而道远了。加油吧，少年！<br>把面试中考察到的知识点整理如下。</p>
<a id="more"></a>
<h2 id="一、搜索结果满意度度量"><a href="#一、搜索结果满意度度量" class="headerlink" title="一、搜索结果满意度度量"></a>一、搜索结果满意度度量</h2><ul>
<li>是否翻页：如果无法在第一个页面找到满意的网页，就会进行翻页操作。如果翻页了，说明搜索引擎的排序并不是自己想要的。</li>
<li>是否重新输入查询词：</li>
<li>查准率：这个相当重要，搜到的东西即使又多又快，但你想要的结果不知道要翻多少页菜能找到，那么搜索结果几乎没有意义。</li>
<li>相关度：请受过训练的人来评估每个引擎的前几个结果是否相关，评估时不参考结果的来源、引擎的品牌等。</li>
<li>速度：就是输入搜索词，得到结果的时间。很多测试告诉我们0.2秒的速度会导致用户满意度的落差，和未来使用的频率。</li>
<li>新鲜度：就是能爬到多新的内容，而且要有一定规模（只有新闻内容不算够新）。</li>
<li><a href="http://www.infoq.com/cn/articles/cyw-evaluate-seachengine-result-quality" target="_blank" rel="external"><code>怎样量化评价搜索引擎的结果质量</code></a></li>
</ul>
<h2 id="二、网站用户满意度指标"><a href="#二、网站用户满意度指标" class="headerlink" title="二、网站用户满意度指标"></a>二、网站用户满意度指标</h2><ul>
<li><strong>流量数据：</strong>在该网站消耗的流量越多，说明对该网站的需求越多。</li>
<li><strong>访问时长：</strong>用户访问网站的停留时间。如果用户不喜欢网站的内容，可能稍微看一眼就关闭网页了，那么访问时长就很短;如果用户对网站的内容很感兴趣，一连看了很多内容，或者在网站停留了很长时间，访问时长就很长。较长的访问时长表明访问者与您的网站进行了较为广泛的互动。</li>
<li><strong>访问页数：</strong>用户访问该网站的浏览页数。访问页数较少，说明访客进入你的网站后访问少数几个页面就离开了，满意度并不是很高。</li>
<li><strong>用户是否直接跳出：</strong>指访客来到网站后，只访问了一个页面就离开网站的访问次数占总访问次数的百分比。跳出率=只访问一个页面就离开网站的访问次数/总访问次数，跳出率越低说明流量质量越好，用户对网站的内容越感兴趣。用户进入网站后的满意度会影响其进一步使用的决定。分析跳出率的优点是容易探查，分析简单。缺点是难以进一步分析原因，无法对跳出用户进行跟踪。<ul>
<li>点击后退按钮 （最常见）；关闭浏览器 （窗口/标签）；输入一个新的URL ；什么也不做 （会话超过30分钟后）</li>
<li>对于单页营销的网站来说，跳出率只能是100%，因为用户只有一个页面可以访问，所以单页营销网站不必考虑这个指标。在百度搜索推广中跳出率和平均访问时长可以反映出网站推广关键词的选择是否精准，创意的撰写是否优秀，着陆页的设计是否符合用户体验。</li>
</ul>
</li>
<li><strong>推荐率：</strong>非常重要的满意度指标。对于很多应用或网站也可以看作是分享率。根据kano模型，产品对用户需求的满足分三个层面，基本、期望、兴奋。当产品品质高于用户期望，用户会乐于向身边的人分享。所以正常运营中的产品的用户自然推荐率可以反映满意度。</li>
<li><strong>站内点击次数</strong></li>
</ul>
<h2 id="三、排序算法"><a href="#三、排序算法" class="headerlink" title="三、排序算法"></a>三、排序算法</h2><h3 id="3-1-冒泡排序"><a href="#3-1-冒泡排序" class="headerlink" title="3.1 冒泡排序"></a>3.1 冒泡排序</h3><ul>
<li>冒泡排序(bubble sort)：每个回合都从第一个元素开始和它后面的元素比较，如果比它后面的元素更大的话就交换，一直重复，直到这个元素到了它能到达的位置。每次遍历都将剩下的元素中最大的那个放到了序列的“最后”(除去了前面已经排好的那些元素)。注意检测是否已经完成了排序，如果已完成就可以退出了。</li>
<li>冒泡排序的关键字比较次数与数据元素的初始状态无关。第一趟的比较次数为n-1，第i趟的比较次数为n-i，第n-1趟（最后一趟）的比较次数为1，因此冒泡排序总的比较次数为$n(n-1)/2$</li>
<li>冒泡排序的数据元素移动次数与序列的初始状态有关。在最好的情况下，移动次数为0次；在最坏的情况下，移动次数为$n(n-1)/2$</li>
<li>冒泡排序的时间复杂度为<strong>$O(n^2)$</strong>。冒泡排序不需要辅助存储单元，其空间复杂度为$O(1)$。如果关键字相等，则冒泡排序不交换数据元素，他是一种稳定的排序方法。</li>
<li><p>Python支持对两个数字同时进行交换。a,b = b,a就可以交换a和b的值了。</p>
 <center> <img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-09%20%E4%B8%8A%E5%8D%888.49.45.png" alt="屏幕快照 2017-03-09 上午8.49.45"></center>

</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(lists)</span>:</span></div><div class="line">    count = len(lists)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, count):</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, count):</div><div class="line">            <span class="keyword">if</span> lists[i] &gt; lists[j]:</div><div class="line">                lists[i], lists[j] = lists[j], lists[i]</div><div class="line">    <span class="keyword">return</span> lists</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    a_list=[<span class="number">20</span>, <span class="number">40</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">80</span>, <span class="number">70</span>, <span class="number">60</span>, <span class="number">110</span>, <span class="number">100</span>]</div><div class="line">    bubble_sort(a_list)</div><div class="line">    print(a_list)</div></pre></td></tr></table></figure>
<h3 id="3-2-选择排序"><a href="#3-2-选择排序" class="headerlink" title="3.2 选择排序"></a>3.2 选择排序</h3><ul>
<li>每个回合都选择出剩下的元素中最大的那个，选择的方法是首先默认第一元素是最大的，如果后面的元素比它大的话，那就更新剩下的最大的元素值，找到剩下元素中最大的之后将它放入到合适的位置就行了。和冒泡排序类似，只是找剩下的元素中最大的方式不同而已。</li>
<li>对具有$n$个数据元素的序列进行排序时，选择排序需要进行$n-1$趟选择。进行第$i$趟选择时，后面已经有$i-1$个数据元素排好序，第$i$趟从剩下的$n-i+1$个数据元素中选择一个关键字最大的数据元素，并将它与第$i$个数据元素交换，这样即可使后面的$i$个数据元素排好序。</li>
<li>选择排序的关键字比较次数与序列的初始状态无关。对n个数据元素进行排序时，第一趟的比较次数为$n-1$，第$i$趟的比较次数是$n-1$次，第$n-1$趟（最后一趟）的比较次数是1次。因此，总的比较次数为$n(n-1)/2$</li>
<li>选择排序每一趟都可能移动一次数据元素，其总的移动次数与序列的初始状态有关。当序列已经排好序时，元素的移动次数为0。当每一趟都需要移动数据元素时，总的移动次数为$n-1$</li>
<li><p>选择排序的时间复杂度为$O(n^2)$。选择排序不需要辅助的存储单元，其空间复杂度为$O(1)$。选择排序在排序过程中需要在不相邻的数据元素之间进行交换，它是一种不稳定的排序方法。</p>
 <center>    <img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-09%20%E4%B8%8A%E5%8D%889.15.53.png" alt="屏幕快照 2017-03-09 上午9.15.53">   </center>

</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(list)</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(list)):</div><div class="line">        min=i</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(list)):</div><div class="line">            <span class="keyword">if</span> list[min]&gt;list[j]:</div><div class="line">                min=j</div><div class="line">        list[min],list[i]=list[i],list[min]</div><div class="line">    <span class="keyword">return</span> list</div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    a_list = [<span class="number">20</span>, <span class="number">40</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">80</span>, <span class="number">70</span>, <span class="number">60</span>, <span class="number">110</span>, <span class="number">100</span>]</div><div class="line">    select_sort(a_list)</div><div class="line">    print(a_list)</div></pre></td></tr></table></figure>
<h3 id="3-3-直接插入排序"><a href="#3-3-直接插入排序" class="headerlink" title="3.3 直接插入排序"></a>3.3 直接插入排序</h3><ul>
<li>对具有$n$个数据元素的序列进行排序时，直接插入排序需要进行$n-1$趟插入。进行第$j（1≤j≤n-1）$趟插入时，前面已经有$j$个元素排好序了，第$j$趟将$a_{j+1}$插入到已经排好序的序列中，这样即可使前面的$j+1$个数据排好序。</li>
<li>直接插入排序关键字比较次数和数据元素移动次数与数据元素的初始状态有关。在最好的情况下，待排序的序列是已经排好序的，每一趟插入，只需要比较一次就可以确定待插入的数据元素的位置，需要移动两次数据元素。因此总的关键字比较次数为$n-1$,总的数据元素移动次数为$2(n-1)$</li>
<li>在最坏的情况下，待排序的序列是反序的，每一趟中，待插入的数据元素需要与前面已排序序列的每一个数据元素进行比较，移动次数等于比较次数。因此，总的比较次数和移动次数都是$n(n-1)/2$</li>
<li>直接插入排序的时间复杂度为$O(n^2)$。直接插入排序需要一个单元的辅助存储单元，空间复杂度为$O(1)$。直接插入排序只在相邻的数据元素之间进行交换，它是一种稳定的排序方法。 <center><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-09%20%E4%B8%8A%E5%8D%8810.42.28.png" alt="屏幕快照 2017-03-09 上午10.42.28">   </center>


</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">########直接插入排序########</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(lists)</span>:</span></div><div class="line">    count = len(lists)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, count):</div><div class="line">        key = lists[i]</div><div class="line">        j = i - <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span>:</div><div class="line">            <span class="keyword">if</span> lists[j] &gt; key:</div><div class="line">                lists[j + <span class="number">1</span>] = lists[j]</div><div class="line">                lists[j] = key</div><div class="line">            j -= <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> lists</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    a_list = [<span class="number">20</span>, <span class="number">40</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">80</span>, <span class="number">70</span>, <span class="number">60</span>, <span class="number">110</span>, <span class="number">100</span>]</div><div class="line">    insert_sort(a_list)</div><div class="line">    print(a_list)</div></pre></td></tr></table></figure>
<h3 id="3-4-归并排序"><a href="#3-4-归并排序" class="headerlink" title="3.4 归并排序"></a>3.4 归并排序</h3><ul>
<li>典型的是二路合并排序，将原始数据集分成两部分(不一定能够均分)，分别对它们进行排序，然后将排序后的子数据集进行合并，这是典型的分治法策略。</li>
<li>在归并排序中，进行一趟归并需要的关键字比较次数和数据元素移动次数最多为$n$，需要归并的趟数$log_{2}n$，故归并排序的时间复杂度为$O(nlog_{2}n)$。归并排序小长度等于序列长度为$n$的辅助存储单元，故归并排序的空间复杂度为$O(n)$。归并排序是稳定的排序算法。</li>
</ul>
<center><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-09%20%E4%B8%8B%E5%8D%882.12.47.png" alt="屏幕快照 2017-03-09 下午2.12.47"></center><br><center><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-09%20%E4%B8%8B%E5%8D%882.12.57.png" alt="屏幕快照 2017-03-09 下午2.12.57"></center>


<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(a_list)</span>:</span></div><div class="line">    print(<span class="string">"Splitting "</span>, a_list)</div><div class="line">    <span class="keyword">if</span> len(a_list) &gt; <span class="number">1</span>:</div><div class="line">        mid = len(a_list) // <span class="number">2</span></div><div class="line">        left_half = a_list[:mid]</div><div class="line">        right_half = a_list[mid:]</div><div class="line">        merge_sort(left_half)</div><div class="line">        merge_sort(right_half)</div><div class="line">        i=<span class="number">0</span>;j=<span class="number">0</span>;k=<span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> i &lt; len(left_half) <span class="keyword">and</span> j &lt; len(right_half):</div><div class="line">            <span class="keyword">if</span> left_half[i] &lt; right_half[j]:</div><div class="line">                a_list[k] = left_half[i]</div><div class="line">                i=i+<span class="number">1</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                a_list[k] = right_half[j]</div><div class="line">                j=j+<span class="number">1</span></div><div class="line">            k=k+<span class="number">1</span></div><div class="line">        <span class="keyword">while</span> i &lt; len(left_half):</div><div class="line">            a_list[k] = left_half[i]</div><div class="line">            i=i+<span class="number">1</span></div><div class="line">            k=k+<span class="number">1</span></div><div class="line">        <span class="keyword">while</span> j &lt; len(right_half):</div><div class="line">            a_list[k] = right_half[j]</div><div class="line">            j=j+<span class="number">1</span></div><div class="line">            k=k+<span class="number">1</span></div><div class="line">    print(<span class="string">"Merging "</span>, a_list)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    a_list = [<span class="number">54</span>, <span class="number">26</span>, <span class="number">93</span>, <span class="number">17</span>, <span class="number">77</span>, <span class="number">31</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">20</span>]</div><div class="line">    merge_sort(a_list)</div><div class="line">    print(a_list)</div></pre></td></tr></table></figure>
<h3 id="3-5-快速排序"><a href="#3-5-快速排序" class="headerlink" title="3.5 快速排序"></a>3.5 快速排序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(lists, left, right)</span>:</span></div><div class="line">    <span class="keyword">if</span> left &gt;= right:</div><div class="line">        <span class="keyword">return</span> lists</div><div class="line">    key = lists[left]</div><div class="line">    low = left</div><div class="line">    high = right</div><div class="line">    <span class="keyword">while</span> left &lt; right:</div><div class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> lists[right] &gt;= key:</div><div class="line">            right -= <span class="number">1</span></div><div class="line">        lists[left] = lists[right]</div><div class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> lists[left] &lt;= key:</div><div class="line">            left += <span class="number">1</span></div><div class="line">        lists[right] = lists[left]</div><div class="line">    lists[right] = key</div><div class="line">    quick_sort(lists, low, left - <span class="number">1</span>)</div><div class="line">    quick_sort(lists, left + <span class="number">1</span>, high)</div><div class="line">    <span class="keyword">return</span> lists</div></pre></td></tr></table></figure>
<h3 id="3-6-各种排序方法的时空复杂度"><a href="#3-6-各种排序方法的时空复杂度" class="headerlink" title="3.6 各种排序方法的时空复杂度"></a>3.6 各种排序方法的时空复杂度</h3>   <center><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-10%20%E4%B8%8B%E5%8D%8812.50.56.png" alt="屏幕快照 2017-03-10 下午12.50.56">   </center>



<h2 id="四、斐波那契数列"><a href="#四、斐波那契数列" class="headerlink" title="四、斐波那契数列"></a>四、斐波那契数列</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">########递归实现效率低下##########</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib1</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span></div><div class="line">    <span class="keyword">elif</span> n == <span class="number">1</span>:</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> fib1(n - <span class="number">1</span>) + fib1(n - <span class="number">2</span>)</div><div class="line"><span class="keyword">print</span> fib1(<span class="number">40</span>)</div><div class="line"></div><div class="line"><span class="comment">########通过将计算的值保存到一个dict中，</span></div><div class="line">后面计算时直接拿来使用，这种方式成为备忘(memo)，</div><div class="line">则会发现效率大大提高。<span class="comment">########</span></div><div class="line">known = &#123;<span class="number">0</span>: <span class="number">0</span>, <span class="number">1</span>: <span class="number">1</span>&#125;</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib2</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> known:</div><div class="line">        <span class="keyword">return</span> known[n]</div><div class="line">    res = fib2(n - <span class="number">1</span>) + fib2(n - <span class="number">2</span>)</div><div class="line">    known[n] = res</div><div class="line">    <span class="keyword">return</span> known[n]</div><div class="line"><span class="keyword">print</span> fib2(<span class="number">40</span>)</div><div class="line"></div><div class="line"><span class="comment">#########前面的Fibonacci函数都是树形递归的实现，哪怕是学一点算法就应该知道这种递归的低效了。在这里从树形递归改为对应的迭代可以把效率提升不少。</span></div><div class="line">Python的元组赋值特性是我很喜欢的一个东东，这玩意可以把代码简化不少。举个例子，以前的tmp=a;a=b;b=tmp;可以直接用一句a,b=b,a实现，既简洁又明了。<span class="comment">########</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></div><div class="line"> x,y=<span class="number">0</span>,<span class="number">1</span></div><div class="line"> <span class="keyword">while</span>(n):</div><div class="line">  x,y,n=y,x+y,n<span class="number">-1</span></div><div class="line"> <span class="keyword">return</span> x</div><div class="line"><span class="keyword">print</span> fib(<span class="number">40</span>)</div><div class="line"></div><div class="line"><span class="comment">########基本的逻辑和上面的例子一样，都是尾递归写法。主要的区别就是利用了Python提供的默认参数和三元操作符，从而把代码简化至一行。#######</span></div><div class="line"></div><div class="line">fib=<span class="keyword">lambda</span> n,x=<span class="number">0</span>,y=<span class="number">1</span>:x <span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">else</span> fib(n<span class="number">-1</span>,y,x+y)</div><div class="line"><span class="keyword">print</span> fib(<span class="number">40</span>)</div></pre></td></tr></table></figure>
<h2 id="五、哈希树"><a href="#五、哈希树" class="headerlink" title="五、哈希树"></a>五、哈希树</h2><ul>
<li>如果在数据元素与其存储位置之间建立对应关系，则可以根据数据元素直接找到其存储位置，避免进行关键字比较，答复提高查找效率，这就是哈希查找的思想。</li>
<li>哈希查找方法的基本过程如下：选取一个函数，用数据元素的关键字作为参数计算该元素的存储位置，该存储位置称为哈希地址，并将数据元素存储在该位置。查找时，用待查找数据元素的关键字作为参数计算一个存储位置，然后查找该位置的数据元素以确定查找是否成功。</li>
<li>哈希查找方法又称为杂凑法、散列法，其中选取的函数称为哈希函数，按照此方法建立的数据元素存储表称为哈希表，哈希表存储单元的数量称为哈希表长。</li>
<li>理想的情况是，对于具有n个数据元素的集合，选取一个关键字与存储位置一一对应的函数每个数据元素都对应一个存储位置，且每一个存储位置只对应一个数据元素。但是，当关键字不是连续分布且跨度很大时会浪费很多存储空间。有时，不同的关键字会映射到同一个存储地址，这种现象称为冲突。映射到同一个存储位置的关键字称为同义词。</li>
<li>哈希方法需解决以下问题：<ul>
<li>构造哈希函数，哈希函数（线性函数直接定址、模哈希函数、平方取中法、折叠法）应尽可能简单，以提高计算速度；根据哈希函数计算的存储地址应该尽可能均匀分布，减少冲突现象。； 设计解决冲突的方案（开放定址法（线性探测法、二次探测法））。</li>
</ul>
</li>
</ul>
<h2 id="六、Mapreduce"><a href="#六、Mapreduce" class="headerlink" title="六、Mapreduce"></a>六、Mapreduce</h2><h3 id="6-1-MapReduce工作原理-1"><a href="#6-1-MapReduce工作原理-1" class="headerlink" title="6.1 MapReduce工作原理(1)"></a>6.1 MapReduce工作原理(1)</h3>   <center><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-10%20%E4%B8%8A%E5%8D%889.47.14.png" alt="屏幕快照 2017-03-10 上午9.47.14">   </center>

<p><strong>流程分析：</strong></p>
<p><code>1.</code>在客户端启动一个作业。<br><code>2.</code>向JobTracker请求一个Job ID。<br><code>3.</code>将运行作业所需要的资源文件复制到HDFS上，包括MapReduce程序打包的JAR文件、配置文件和客户端计算所得的输入划分信息。这些文件都存放在JobTracker专门为该作业创建的文件夹中。文件夹名为该作业的Job ID。JAR文件默认会有10个副本（mapred.submit.replication属性控制）；输入划分信息告诉了JobTracker应该为这个作业启动多少个map任务等信息。<br><code>4.</code>JobTracker接收到作业后，将其放在一个作业队列里，等待作业调度器对其进行调度（这里是不是很像微机中的进程调度呢，呵呵），当作业调度器根据自己的调度算法调度到该作业时，会根据输入划分信息为每个划分创建一个map任务，并将map任务分配给TaskTracker执行。对于map和reduce任务，TaskTracker根据主机核的数量和内存的大小有固定数量的map槽和reduce槽。这里需要强调的是：map任务不是随随便便地分配给某个TaskTracker的，这里有个概念叫：数据本地化（Data-Local）。意思是：将map任务分配给含有该map处理的数据块的TaskTracker上，同时将程序JAR包复制到该TaskTracker上来运行，这叫“运算移动，数据不移动”。而分配reduce任务时并不考虑数据本地化。<br><code>5.</code> taskTracker每隔一段时间会给JobTracker发送一个心跳，告诉JobTracker它依然在运行，同时心跳中还携带着很多的信息，比如当前map任务完成的进度等信息。当JobTracker收到作业的最后一个任务完成信息时，便把该作业设置成“成功”。当JobClient查询状态时，它将得知任务已完成，便显示一条消息给用户。</p>
<p>以上是在客户端、JobTracker、TaskTracker的层次来分析MapReduce的工作原理的，下面我们再细致一点，从map任务和reduce任务的层次来分析分析吧。</p>
<h3 id="6-2-MapReduce工作原理-2"><a href="#6-2-MapReduce工作原理-2" class="headerlink" title="6.2 MapReduce工作原理(2)"></a>6.2 MapReduce工作原理(2)</h3>   <center><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-10%20%E4%B8%8A%E5%8D%8810.03.24.png" alt="屏幕快照 2017-03-10 上午10.03.24">   </center>

<p><strong>流程分析</strong></p>
<p><code>Map端：</code></p>
<p><code>1．</code>每个输入分片会让一个map任务来处理，默认情况下，以HDFS的一个块的大小（默认为64M）为一个分片，当然我们也可以设置块的大小。map输出的结果会暂且放在一个环形内存缓冲区中（该缓冲区的大小默认为100M，由io.sort.mb属性控制），当该缓冲区快要溢出时（默认为缓冲区大小的80%，由io.sort.spill.percent属性控制），会在本地文件系统中创建一个溢出文件，将该缓冲区中的数据写入这个文件。</p>
<p><code>2．</code>在写入磁盘之前，线程首先根据reduce任务的数目将数据划分为相同数目的分区，也就是一个reduce任务对应一个分区的数据。这样做是为了避免有些reduce任务分配到大量数据，而有些reduce任务却分到很少数据，甚至没有分到数据的尴尬局面。其实分区就是对数据进行hash的过程。然后对每个分区中的数据进行排序，如果此时设置了Combiner，将排序后的结果进行Combia操作，这样做的目的是让尽可能少的数据写入到磁盘。</p>
<p><code>3．</code>当map任务输出最后一个记录时，可能会有很多的溢出文件，这时需要将这些文件合并。合并的过程中会不断地进行排序和combia操作，目的有两个：1.尽量减少每次写入磁盘的数据量；2.尽量减少下一复制阶段网络传输的数据量。最后合并成了一个已分区且已排序的文件。为了减少网络传输的数据量，这里可以将数据压缩，只要将mapred.compress.map.out设置为true就可以了。</p>
<p><code>4．</code>将分区中的数据拷贝给相对应的reduce任务。有人可能会问：分区中的数据怎么知道它对应的reduce是哪个呢？其实map任务一直和其父TaskTracker保持联系，而TaskTracker又一直和JobTracker保持心跳。所以JobTracker中保存了整个集群中的宏观信息。只要reduce任务向JobTracker获取对应的map输出位置就ok了哦。</p>
<p>到这里，map端就分析完了。那到底什么是Shuffle呢？Shuffle的中文意思是“洗牌”，如果我们这样看：一个map产生的数据，结果通过hash过程分区却分配给了不同的reduce任务，是不是一个对数据洗牌的过程呢？呵呵。</p>
<p><code>Reduce端</code></p>
<p><code>1．</code>Reduce会接收到不同map任务传来的数据，并且每个map传来的数据都是有序的。如果reduce端接受的数据量相当小，则直接存储在内存中（缓冲区大小由mapred.job.shuffle.input.buffer.percent属性控制，表示用作此用途的堆空间的百分比），如果数据量超过了该缓冲区大小的一定比例（由mapred.job.shuffle.merge.percent决定），则对数据合并后溢写到磁盘中。</p>
<p><code>2．</code>随着溢写文件的增多，后台线程会将它们合并成一个更大的有序的文件，这样做是为了给后面的合并节省时间。其实不管在map端还是reduce端，MapReduce都是反复地执行排序，合并操作，现在终于明白了有些人为什么会说：排序是hadoop的灵魂。</p>
<p><code>3．</code>合并的过程中会产生许多的中间文件（写入磁盘了），但MapReduce会让写入磁盘的数据尽可能地少，并且最后一次合并的结果并没有写入磁盘，而是直接输入到reduce函数。</p>
<p>到这里，MapReduce工作原理终于分析完了，不过我还会继续深入研究，请关注我的后续hadoop相关的博客。</p>
<h3 id="6-3-mapreduce实现wordcount"><a href="#6-3-mapreduce实现wordcount" class="headerlink" title="6.3 mapreduce实现wordcount"></a>6.3 mapreduce实现wordcount</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">############mapper########</span></div><div class="line"></div><div class="line"><span class="comment">#! /usr/bin/python</span></div><div class="line"><span class="keyword">import</span> sys  </div><div class="line"></div><div class="line"><span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin:  <span class="comment"># input comes from STDIN (standard input)  </span></div><div class="line">    line = line.strip()   <span class="comment"># remove leading and trailing whitespace  </span></div><div class="line">    words = line.split()   <span class="comment"># split the line into words  </span></div><div class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> words:     <span class="comment"># increase counters  </span></div><div class="line">          <span class="keyword">print</span> <span class="string">'%s\t%s'</span> % (word, <span class="number">1</span>)</div><div class="line">         <span class="comment"># write the results to STDOUT (standard output);  </span></div><div class="line">        <span class="comment"># what we output here will be the input for the  </span></div><div class="line">        <span class="comment"># Reduce step, i.e. the input for reducer.py  </span></div><div class="line">        <span class="comment">#  </span></div><div class="line">        <span class="comment"># tab-delimited; the trivial word count is 1  </span></div><div class="line">        </div><div class="line">        </div><div class="line"><span class="comment">############reducer#########</span></div><div class="line"><span class="comment">#! /usr/bin/python</span></div><div class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line">word2count = &#123;&#125;<span class="comment"># maps words to their counts</span></div><div class="line"> </div><div class="line"><span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin:<span class="comment"># input comes from STDIN</span></div><div class="line">      line = line.strip() <span class="comment"># remove leading and trailing whitespace</span></div><div class="line">        word, count = line.split() <span class="comment"># parse the input we got from mapper.py</span></div><div class="line">     <span class="keyword">try</span>:</div><div class="line">        count = int(count) <span class="comment"># convert count (currently a string) to int</span></div><div class="line">        word2count[word] = word2count.get(word, <span class="number">0</span>) + count</div><div class="line">    <span class="keyword">except</span> ValueError:</div><div class="line">        <span class="keyword">pass</span> <span class="comment"># count was not a number, so silently</span></div><div class="line">               <span class="comment"># ignore/discard this line</span></div><div class="line">sorted_word2count = sorted(word2count.items(), key=itemgetter(<span class="number">0</span>))</div><div class="line"> <span class="comment"># sort the words lexigraphically;</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># this step is NOT required, we just do it so that our</span></div><div class="line"><span class="comment"># final output will look more like the official Hadoop</span></div><div class="line"><span class="comment"># word count examples</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> word, count <span class="keyword">in</span> sorted_word2count:</div><div class="line">    <span class="keyword">print</span> <span class="string">'%s\t%s'</span>% (word, count)<span class="comment"># write the results to STDOUT (standard output)</span></div></pre></td></tr></table></figure>
<h2 id="七、海量数据寻找中位数"><a href="#七、海量数据寻找中位数" class="headerlink" title="七、海量数据寻找中位数"></a>七、海量数据寻找中位数</h2><ul>
<li>具体思路：用一个最大堆存放比中位数小（或等于）的元素，用一个最小堆存放比中位数大（或等于）的元素。这里关键的方法是insert()，每当要插入一个元素时，根据判断条件将它插入最大堆或是最小堆，并更新最大堆和最小堆，使得最大堆和最小堆中元素的个数之差不超过1，这样中位数就是最大堆或最小堆的堆顶元素。当最大堆和最小堆中元素个数不同（个数相差为1）时，元素个数多的那个堆的堆顶元素即为中位数；如果两者元素个数相同，那么中位数可以是最大堆和最小堆的堆顶元素的值取平均。下面的程序代码中，当两者元素个数相同时，将最大堆的堆顶元素看做中位数。</li>
<li>插入（insert） <ul>
<li>（1）如果最大堆为空，将元素插入最大堆；</li>
<li>（2）如果最小堆为空，将元素插入最小堆；</li>
<li>（3）如果元素比最大堆的堆顶元素小且最大堆中元素个数不大于最小堆中元素个数，将元素插入最大堆；如果如果元素比最大堆的堆顶元素小但最大堆中元素个数大于最小堆中元素个数，那么先把最大堆的堆顶元素插入最小堆，然后删除最大堆的堆顶元素，最后把元素插入最大堆；</li>
<li>（4）如果元素比最小堆的堆顶元素大且最小堆中元素个数不大于最大堆中元素个数，将元素插入最小堆；如果如果元素比最小堆的堆顶元素大但最小堆中元素个数大于最大堆中元素个数，那么先把最小堆的堆顶元素插入最大堆，然后删除最小堆的堆顶元素，最后把元素插入最小堆；</li>
<li>（5）如果最大堆中元素个数小于最小堆中元素个数，将元素插入最大堆；否则将元素插入最大堆。</li>
</ul>
</li>
</ul>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/红楼记事/" rel="tag"># 红楼记事</a>
          
            <a href="/tags/实习面试/" rel="tag"># 实习面试</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/03/15/机器学习算法系列（15）：EM算法/" rel="next" title="机器学习算法系列（15）：EM算法">
                <i class="fa fa-chevron-left"></i> 机器学习算法系列（15）：EM算法
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/03/08/机器学习算法系列（14）：关联分析/" rel="prev" title="机器学习算法系列（14）：关联分析">
                机器学习算法系列（14）：关联分析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/img/v.png"
               alt="狗皮膏药" />
          <p class="site-author-name" itemprop="name">狗皮膏药</p>
          <p class="site-description motion-element" itemprop="description">在隆冬，我终于知道，我身上有一个不可战胜的夏天</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">54</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">71</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、搜索结果满意度度量"><span class="nav-text">一、搜索结果满意度度量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、网站用户满意度指标"><span class="nav-text">二、网站用户满意度指标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、排序算法"><span class="nav-text">三、排序算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-冒泡排序"><span class="nav-text">3.1 冒泡排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-选择排序"><span class="nav-text">3.2 选择排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-直接插入排序"><span class="nav-text">3.3 直接插入排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-归并排序"><span class="nav-text">3.4 归并排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-快速排序"><span class="nav-text">3.5 快速排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-各种排序方法的时空复杂度"><span class="nav-text">3.6 各种排序方法的时空复杂度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、斐波那契数列"><span class="nav-text">四、斐波那契数列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五、哈希树"><span class="nav-text">五、哈希树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六、Mapreduce"><span class="nav-text">六、Mapreduce</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-MapReduce工作原理-1"><span class="nav-text">6.1 MapReduce工作原理(1)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-MapReduce工作原理-2"><span class="nav-text">6.2 MapReduce工作原理(2)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-mapreduce实现wordcount"><span class="nav-text">6.3 mapreduce实现wordcount</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#七、海量数据寻找中位数"><span class="nav-text">七、海量数据寻找中位数</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">狗皮膏药</span>
</div>



        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->



  



  




	




  
  

  
  


  

  

  


</body>
</html>

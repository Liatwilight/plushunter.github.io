<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Free Will</title>
  <icon>https://www.gravatar.com/avatar/5210824d1d63b2352ab190a38412be77</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-12-28T14:37:22.151Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>狗皮膏药</name>
    <email>934825769@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>日知录（3）：人大应统学长倾心经验贴</title>
    <link href="http://yoursite.com/2017/12/16/%E4%BA%BA%E5%A4%A7%E5%BA%94%E7%BB%9F%E5%AD%A6%E9%95%BF%E5%80%BE%E5%BF%83%E7%BB%8F%E9%AA%8C%E8%B4%B4/"/>
    <id>http://yoursite.com/2017/12/16/人大应统学长倾心经验贴/</id>
    <published>2017-12-16T02:19:10.000Z</published>
    <updated>2017-12-28T14:37:22.151Z</updated>
    
    <content type="html"><![CDATA[<p>2016人大考研总算是落下了帷幕，大半年来的努力终于落定。在北京的春天里，窗外飘着杨絮，在图书馆的沙发上码下这难忘时光的的锤炼与凝结。</p>  <a id="more"></a><ul><li><p><strong>初试成绩：</strong>总分392（政治68、英语73、数学三121、统计学130）</p></li><li><p><strong>复试成绩：</strong>总分292（英语笔试40、英语面试40、专业课笔试77、专业课面试135）</p></li></ul><ul><li><p><strong>复习起始：</strong>初试： 8月10日-12月26日   |      复试：   2月20日-3月11日</p></li><li><p><strong>日常安排</strong></p></li></ul><div class="table-container"><table><thead><tr><th>时刻</th><th>事项</th></tr></thead><tbody><tr><td>6:30-7:30</td><td>起床洗漱早餐、七点半准时到海洋楼坐定，考研四个小伙伴轮流占座。</td></tr><tr><td>7:30-8:30</td><td>扇贝单词打卡一小时（这个习惯坚持到了考研最后一天还是蛮给力的）</td></tr><tr><td>8:30-11:00</td><td>数学（雷打不动的看书做题）</td></tr><tr><td>11:00-11:30</td><td>午餐（总会看到一个法兰西女孩，像西西里的美丽传说里的莫妮卡一样风姿卓越，食欲大增）</td></tr><tr><td>11:30-13:00</td><td>数学（消化午餐的同时还能做做数学）</td></tr><tr><td>13:00-14:00</td><td>午睡（这个是每日必备良药，不午睡下午的效率等于0）</td></tr><tr><td>14:00-17:00</td><td>英语（有几天没午睡，这段时间就会是睡过去的）</td></tr><tr><td>17:00-17:30</td><td>晚餐（晚餐的时候见不到那个法兰西女孩，食欲大减）</td></tr><tr><td>17:30-20:00</td><td>政治（每天两个半小时足够了）</td></tr><tr><td>20:00-23:00</td><td>专业课（因为跨专业、这个是真的有很努力在学）</td></tr></tbody></table></div><p>当然每天都不会完完全全的严丝合缝的来，到后期就是固定这个模式了，考研的四个小伙伴也是在不断地磨合中才基本保持了一致的计划，抱团的作用就在于此，当你投入不进去的时候，自然会有外力来催促你，除非你的个人毅力可以抵制该死的懒癌，你求知的欲望超过你对舒适的渴求，否则，建议抱团。</p><h2 id="一、考研专业选择"><a href="#一、考研专业选择" class="headerlink" title="一、考研专业选择"></a>一、考研专业选择</h2><p>本科学的工科，学的不精，但对计算机有接触，算是有点编程的底子，慢慢的了解到大数据专业，自己也摸索着学习了一些有关数据挖掘的模型算法，蛮感兴趣的。最近在拜读吴军博士的《数学之美》，科普下这个领域，更深入的也正处于摸索阶段，之前在人大大数据老胡学长那里要到了几本大块头的书，英文版，头疼中，坚持啃完。当然敲代码的日子我想应该就会换来蓬头垢面的自己吧。</p><p>个人对这种跨领域的东西特别着迷，就像最近博弈论的发展方向，复旦韦森教授总结道：“沿着道德哲学、政治哲学把休谟、卢梭、康德到罗尔斯的思想和理论程式化，致力于回复经济学的亚当·斯密的古典传统，即从审慎推理（prudential reasoning——即目前经济学家所言的理性最大化推理）和道德推理（moral reasoning）两个维度研究人们的经济与社会行为，并从中折射出制度的伦理维度和道德基础来。在这个研究向量上的经济学家主要有已过世的诺奖得主哈森伊、宾默尔以及萨金。笔者也发现，由一些谙熟现代博弈论分析工具的一些当代思想家——如美国加州大学洛杉矶分校的人类学家Rob Boyd，美国麻省大学的经济学家Herbert Gintis，慕尼黑大学的经济学家Ernst Fehr，以及麻省理工学院的著名博弈论大师弗登博格（DrewFudenberg）等，最近从文化、互惠合作（reciprocity）、利己和利他行为的产生及其在社会选择中作用等相关领域的探索非常值得我们注意。笔者这里贸然推断，这些文化人类学、经济学和博弈论的跨学科的合作研究，也许在不久的将来会汇合哈森伊、宾默尔以及萨金在伦理与社会选择探索向量上的已有理论探索。这一研究向量的理论从任何当今一门社会科学的学科视角来看均无疑代表了人类认识社会和自身的目前最前沿思考，且与经济学的制度分析的最深层基础密切相关联（这是我把他们的工作也视作为经济学的制度分析的主要理由）。笔者目前甚至乐观地估计，如果在这一研究向量中以哈森伊、宾默尔所代表的“经济学—伦理学—政治哲学—博弈论的交叉分析”与另一方面的“文化人类学—经济学—博弈论”的跨学科研究汇融起来的话，这又将会在二十一世纪谱写并演奏出一首宏大与辉煌的“理论交响曲”，从而极大地推进人类对自身所处的社会和人本身的认识和理解。”</p><p>之所以摘录那么长一段，是因为个人对于像韦森教授的文本话语中所展现出来的厚重的学术穿透力，像何怀宏教授这样的对正义美好的生活崇尚、像香港中文大学周保松教授对自由民主的理性而温柔的认可与支持、像钱理群教授对生命的关切和对知识的渴求所呈现的高尚的个人品格尤为佩服，他们的精神与智慧必将永远的接续下去，徜徉于他们的文字中，我最为真切感受到的莫过于他们所严肃实践的一种生活理念，这是一种热切的关怀、是一种直抵生命深处的质问、亦是一种现实世界中的身体力行的实践思想，它们似乎与主流思维相悖，这种影响逐渐在我们这一辈的学子中发生，生根发芽，我们开始从无数年被灌输出来的满脑子“绝对真理”中走出来，开始接受世界的丰富性，这即是自由的开端。感谢他们这样的勇士。</p><h2 id="二、考研院校选择"><a href="#二、考研院校选择" class="headerlink" title="二、考研院校选择"></a>二、考研院校选择</h2><p>本科在北京，这个学校唯一让我眷恋的就是，他可能是全中国最幸福的院校，从学校出发去北大人大，半小时车程，清华徒步即可，那时候挚爱哲学，跑去北大人大哲学院蹭课，每个老师的课都会零零碎碎的听一点，北大戴锦华老师、人大周濂老师的课尤为喜爱。北大国家发展研究院（ccer）的课也去蹭了一学期，那时候汪丁丁的新政治经济学和行为经济学，第一次去上课的时候，斗胆坐在第一排，捧着那本融合了脑神经学、认知心理学、经济学、哲学、政治学、社会学、伦理学、宗教和神秘主义的《新政治经济学》，扑面而来的知识模块，令人头晕目眩，结果便是全程睡过去的，万圣书园刘苏里称道他或许是我们这个时代少有的文艺复兴式的知识人，考研完了再次拜读老师的书，书中呈现出来的渊博之魅让人瞠目结舌。北京最让人眷恋的便是这种藏匿在深处的知识图景，学识对撞的读书会、严肃学术的研讨会、陶冶人心的音乐会、感同身受的小剧场话剧，纵然周围是雾霾缭绕，但当你挖掘到内核，或许就再也不想离开。对北京的这种念想让我毅然决然的选择了北京的研究生院，考研之前，对高校的应用统计专业略微地进行了考查。</p><ul><li><p>人大：经济统计、精算、医学统计、国民经济这几块人大是老字号了，在全国都名列前茅。但最让我热血沸腾的是近两年刚开办的五校协同交叉培养大数据方向专业硕士，对于这个平台，袁卫老师有很赞的叙述：“5所学校参与培养，就是出于学科交叉的考虑。中国人民大学统计学院的学科、专业设置是综合的、应用的，理论和应用兼而有之，应用领域涉及卫生、健康、经济、社会、管理等，总体实力较强。而北京大学和中国科学院大学，大家都知道，他们在计算机、数学和统计理论研究方面相当强，掌握大数据分析技术的前沿。中央财经大学和首都经贸大学是财经类为主的院校，这两所学校侧重于应用人才的培养，特别是面向经济、管理、社会这样的领域。他们和很多行业企业、金融机构有着密切联系。这5所高校分别属于教育部直属高校、中国科学院的高校和地方高校3种类型，各有特色，优势互补，能够建成一个很好的、学科交叉的人才培养协同体。”所以，心里其实早就锁定这个了。</p></li><li><p>清华：招生人数太少，信息严重不对称，也清楚认识到自己没那么强悍的能力，就没怎么考虑。</p></li><li><p>北大：之前在网上看到北大444哥考应用统计的雄文，看得我是荷尔蒙暴增，一冲动就买来了所有的参考书，结果发现，专业课的难度自己很难把握。而且北大分数线蛮高的，几乎每年都在390左右。学长应该是毕业了，感谢他，因为我的很多经验都会参考他，当时是打印出来一个字一个字拜读。给出他的经验贴链接吧：<a href="http://bbs.kaoyan.com/t5174553p1" target="_blank" rel="noopener">我的444分北大考研成功经验谈</a></p></li><li><p>其他：考研帮有个帖子，比较全面的分析了全国各考研院校的应用统计专业，大家可以参考下：<a href="http://bbs.kaoyan.com/t6974015p1" target="_blank" rel="noopener">应用统计全国高校分析</a></p></li></ul><h2 id="三、各科复习方法"><a href="#三、各科复习方法" class="headerlink" title="三、各科复习方法"></a>三、各科复习方法</h2><h3 id="3-1-英语"><a href="#3-1-英语" class="headerlink" title="3.1 英语"></a>3.1 英语</h3><p><strong>复习用书：</strong></p><ul><li>扇贝APP</li><li>张剑考研真题黄皮书</li><li>张剑阅读理解150篇</li><li>王江涛高分写作</li></ul><p><strong>复习方案：</strong></p><ul><li><p><strong>单词</strong>：没有用很厚的单词书，感觉会压垮自己，所以选择了app来背，一开始使用的是新东方的乐词，但是亲测效果不佳，后来经研友推荐上了扇贝的船，从此每天早上就开始打卡背诵，保证一个小时的量。特别要注意的是背单词必须要保持连续性，不能中间隔开半个月或者一个月搁置在那里而不背单词了，每天背，这是一个积少成多的过程，我就是一个反面例子，中间有段时间特别抵触背单词，荒了快一个月，结果就是做阅读的时候单词在耳边就是想不起来意思。到考研前要达到的效果就是看到一个单词就立马反应过来，背上三四遍之后就比较省力了，有的时候一小时可以背诵七百个，当然这是建立在前期不断反复不断反复的基础上，基本每个单词app都是依照记忆曲线帮你安排任务，所以也不用担心会漏背或者背不熟。</p></li><li><p><strong>完形填空、新题型、翻译：</strong>这三部分分值占的比较小，基本上每个人都可以得到个基本分数，所以就没太花时间在这上面，只做了历年真题里面的这些部分，然后看黄皮书的分析，掌握一些技巧即可。</p></li><li><p><strong>阅读：</strong> 张剑黄皮书系列的真题基本上是人手一册，真题的研究对于阅读来说是至关重要的，至少要保证两遍以上的联系和琢磨，网上都说英语考80分以上的都是真题研究了四遍五遍的，这是有一定的道理的，阅读的正确与你对命题老师的出题思路的熟悉程度正相关，基本上每一类题都会有特定的规律性，只有当你顺应了老师们的思维模式，在琢磨选项的正误时你都可以类似于套圈子一样套进去，这正是真题的重要性所在，我们可以接受这种思维模式训练的第一手资料就是真题，任何模拟题都无法与之比拟。当然不是说模拟题不需要，在这里推荐张剑的150篇，还是比较贴近真题的，但他的功效仅仅在于提高对新篇章文本的适应性，在考场上难免会遇到和历年真题风格不一致的文章，这就是模拟题的优势所在，这本书基本涵盖了考研英语阅读出现率比较高的话题，你可以拿它当做拓宽英语话语体系的佐料。我当时是花了大约一个月的时间来做这本书，每天下午四十分钟左右做两篇阅读，其他的时间研究前一天做的那两篇，一直循环下去。这里还要说下怎么研究模拟题和真题。拿到一篇文章，按照你的方法做完，然后就是挨个查单词，分析长难句，挨个解读选项和分析，自己从文中找出依据来，最好自己搭建一个文章的框架。</p></li><li><p><strong>作文：</strong>今年的作文幸亏了王江涛，一开始心存侥幸想背个模板就完事了，后来越来越不安，觉得模板作文我难以驾驭的好，如果成篇的万能句型上去，老师必然不买账，估计就是个低分的下场。当然如果真的可以把一个模板变通到炉火纯青，那也一样OK。但对于我这样四级飘过的，六级未过的naïve青年来说怎么会有那么好的英语修养呢，所以最最后一个月算是逼着自己按照王道长的指示安安分分的背诵了8篇范文，滚瓜烂熟，倒背如流，只能这样。道长说了，英语作文看的是你的语言功底，只要和主题搭上边了，没啥语法错误，词汇量足够，还能写出漂亮的句型来，那就不会差到哪里去。所以，背诵历年真题就是最好的办法，踏踏实实的背诵、默写、仿写，王江涛在书里说的都很清楚。</p></li><li><p><strong>友情提醒：</strong>再一次华丽丽的证明了自己的心理素质是多么不堪一击，哈哈，我边上的童鞋老抖腿，以至于我总是有意无意的要观察他的抖腿频率，这让我几近奔溃，没举报老师怪我太善良，结果就是做阅读完全不在状态，基本上就靠语感在做了，我谢谢他全家，我不造其他人被影响到没，怪只怪自己心理素质就像一块薄冰，一碰就会碎。故，学弟学妹们在考场上一定要杜绝这种危害社会健康的事情发生，一经发现，向朝阳群众学习，立马举报上级。</p></li></ul><hr><h3 id="3-2-政治"><a href="#3-2-政治" class="headerlink" title="3.2 政治"></a>3.2 政治</h3><p>考了68，不敢拿出来献丑，对于这种被人戏谑的学科，其实是拒绝介绍经验的，先说几个好玩的政治段子：“靠别人，你永远是右倾投降主义，靠自己你才是工农武装割据”、“如果全世界都对你恶语相加，我愿对你说上一世纪社会主义核心价值观”、“你我之间本无缘分，全靠党的章程死撑”、“别低头！GDP会掉！别落泪！资本主义会笑”、“想和你谈一场弘扬社会主义正能量的恋爱，你却要我好好做自己的中国梦”。茶余饭后看点段子还是蛮有意思的。</p><p><strong>复习用书：</strong>（按出场顺序排列）</p><ul><li>《思想政治理论考研大纲解析》</li><li>肖秀荣《命题人1000题》</li><li>风中劲草《冲刺背诵核心考点》</li><li>肖秀荣《命题人冲刺八套卷》</li><li>启航《20天20题》</li><li>肖秀荣《命题人形势与政策》</li><li>肖秀荣《终极预测四套卷》、任汝芬《最后四套卷》、任燕翔《考前预测4套卷》</li></ul><p><strong>复习方案：</strong></p><ul><li><p><strong>9月5日-10月10日：</strong>九月份考研大纲解析发布，开始快马加鞭的看，一块让人厌恶的砖头，不过你还是得静下心来去啃，尝试着一字一句的过，网上流传着一张图，内容是这样的：恩格斯问大胡子马克思先生：“你在干嘛呢”。马克思心平气和的回答道：“管他呢，反正又不是我背”。中国学生对其抵触的心理可见一斑。但其实真正的马克思先生的思想很可贵，以至于20世纪法国解构主义哲学大师德里达在他的著作《马克思的幽灵》中写道：“不能没有马克思，没有马克思，没有对马克思的记忆，没有马克思的遗产，也就没有将来；无论如何得有某个马克思，得有他的才华，至少得有他的某种精神。现在该维护马克思的幽灵们了。”只是在这个极权盛行的国度，马克思变成了鬼魂，笼罩这苍茫的大地，最后沦落为官方口腔，这才是知识分子真正的悲哀，依附于权力而放弃说理。言归正传，大纲解析的脉络其实是很清晰的，看不懂也没有大碍，拿出肖秀荣先生的《1000题》，看完大纲一个章节的内容你就要把《1000题》上对应的章节的选择题给做了，不要看书，把答案写在一张A4上，注意1000题是要做三遍的，第一遍做都会错的惨不忍睹，错了没事，切忌欺骗自己看看答案把错的题给改对了，因为学长就是这样喜欢自我欺骗的前车之鉴哈哈。马克思主义和毛中特部分或许会让你略微头疼，这种理论性质的东西充斥着新闻联播的气质，但也务必沉住气，到后面解决史纲和思修就是分分钟的事，在高中阶段谁都学过维新变法、辛亥革命之类的，学起来还可能会让你增生一些兴趣。在这里安利一部良心巨制《走向共和》，看完这部电视剧会让你对中国近代史的基本脉络有一个清晰的呈现，记得本科的时候看徐中约先生的《中国近代史》，看得我是心力交瘁，后经学长推荐才去看的这部戏，看完后再回头看那本书，不适感就下降很多。下一步要做的事很重要，就是把你做错的题目，从大纲解析里面找答案，用晨光彩色标记笔标注出来。好了这一遍下来，务必请你自己做一个粗略的知识回顾和框架的搭建，每个章节在讲什么内容，拿毛中特部分举个例子，第一章提纲挈领先介绍了马克思主义中国化的两大理论：毛爷爷思想和中特理论体系，也是同上一部分的马克思主义的衔接，然后从第二章开始，分别是第二章新民主主义革命（1919-1949），第三章社会主义改造（1949-1956），第四章社会主义建设（1956-1978），第五章和第六章插播了总依据和总任务，因为接下来的是第七章改革开放了（1978-不知道啥时候结束），再然后是考研政治的重点，第八章总布局，这章内容及其丰富，包括中特经济、政治、文化、社会、生态文明。紧接着就是祖国统一、外交国际战略，最后两章是建设中特的相关问题，总结陈词就是党好党棒棒哒领导好领导棒棒哒。你可以自己建立一个思维导图，带着这个脉络你可以顺利的进入到下一关，这些基础工作是为后期服务的。</p></li><li><p><strong>10月10日-11月5日：</strong>第二遍重复上一步的内容，看大纲，做1000题，纠错回大纲标注。注意第二遍的时候你可以把答案写在1000题上了，然后看1000题后面的答案，把错的以及你觉得好的题的解析在题目边上标注下，要知道为什么错，举一反三。</p></li><li><p><strong>11月6日-考研结束：</strong>刷完了两编大纲和1000题，这时候会出现一本震撼人心的资料出现—风中劲草，这本书的编排和印刷是下了一番功夫的，他的细节之处可以让你真的佩服这本书的作者，跟进大纲，条理清晰，标注分明，重点突出，考研资料中的扛鼎之作。所以，你一定要把这本书当做是你考研政治的制胜法宝，你该怎么做呢？看，一个字一个字的看，我当时就有种心态，自己可以假装看懂普鲁斯特的《追忆似水年华》，我就必须要看透杨杰先生的《风中劲草》，两个时代的回响多璀璨。直到考研之前，你也不要放下这本书，看的遍数越积越多，你就会达到你自己都意想不到的层次，就是合上书，你大概可以知道哪个知识点在那一页的哪块位置。我保持的速度大概是1天15页左右，15天一本书，到考研结束加起来看了三遍。马原毛中特部分你可以多看几遍，四遍五遍无上限。对了，这时候我还同时做了一件事，就是第一遍的时候只是把1000题上的每一道题都在风中劲草上标注，若是单选题第一题，就标注“单1”，多选类推，同时用彩色笔标注。此外，肖秀荣的《形势与政策》也出来了，买来利用空余时间看两遍。</p></li><li><p><strong>12月15日-考研结束：</strong>各种模拟预测题纷纷登场，这里首推肖秀荣的《8套卷》和《4套卷》，可以去学校打印店购买，便宜实惠，八套卷你都要当做考试一样对待，基本上三十分钟就可以完成一套，完成一套之后看下答案分析，纠错，在风中劲草上标注，如肖秀荣第三套第1题，就标注“肖8三1”。因为之前咱们已经完成了以下任务：大纲解析两遍，1000题两遍，风中劲草两遍左右，再加上不断的标注，8套卷就是检验你复习成果的最佳试题，肖秀荣老师编的资料都棒呆，个人灰常喜欢他的讲课风格，一口流利的方言普通话，考研期间要随时关注肖老师的微博微信，都是同步的，关注一个就可以，把它发布的一些重要文件下载下来，打印研究。八套卷你可以做两遍三遍，注意要举一反三，尤其是错题。然后过几天4套卷就会隆重登场，基本是人手一套，不要迟疑，买来赶紧把客观题做了，按照之前的流程对待客观题。接下来就是万众瞩目的主观题，大家从开始到现在还没有接触过主观题，4套卷就是专门为了主观题准备的，如果你不想留太多的时间和精力在政治上（毕竟政治只有100分，数学和专业课才是重中之重），那就建议你只背诵4套卷的主观题，之前提到的启航20天20题可以翻翻，虽然好，但知识点太多，没时间应付，咱们把赌注押在肖秀荣的4套卷上，背诵的时候主要要挑关键词背诵，自己想法子变通式的背下来，切忌原封不动的机械背诵，虽然这几年老爷子押原题的能力衰弱了，但每年的知识点还是压得相当准的，当然像今年很多人说蒋中挺几乎全压中原题了，没怎么看过他的资料，不予置评。</p></li><li><p><strong>考场上：</strong>考政治的时候觉得选择题so easy啊，做到主观题，有点懵逼了，肖大大押中的题的答案全变成了考研的题干，只能硬着头皮上了，相关的知识点全答上去了，生死未卜的赶脚，有一道家庭美德的就全靠扯了。所以，我的复习方案可以给大家敲响警钟，要是想要考高分的，主观题也是要早点准备的，尽量多参考几个考研机构的预测卷，稍微整理下答题的思路，预防真题出现一些偏题。</p></li><li><p><strong>说在后面：</strong>考研政治的时效性特别明显，16年开了十八届五中全会，那么有关它的内容一定会是考研的重头戏，今年客观题和主观题都有一定的体现，而且比重还不低。所以，形势与政治也要多加注意，有时间就多看几遍，尤其是考前那几天，加深印象，有的关键词列点背诵。肖大大解答过考研命题人如何出题：先确定要考的知识点，然后去报纸和杂志上找相应的材料。所以，我们必须要对知识点分外敏感，在不同的模拟题中间总结出知识点来。</p></li><li><p>另外推荐几个<strong>不错的复习资料</strong>：</p><ul><li><p>肖秀荣的<strong>【马克思主义基本原理概论逻辑图】</strong>，哲学的主观题就全靠这个资料来沥青脉络了。</p></li><li><p>肖秀荣的<strong>【近代史时间轴】</strong>：把近代发生的事件按照时间顺序排列，一些重要的知识点也有叙述。</p></li><li><p>肖秀荣的<strong>《知识点提要》八个附录</strong>：网上也有，可以看看背背啥的。</p></li></ul></li></ul><p>这样下来政治需要看的东西也蛮多的，时间要自己控制好，到了后期，专业课要背，英语作文要背，政治也要背，别被他们压垮，挺过去！</p><h3 id="3-3-数学三"><a href="#3-3-数学三" class="headerlink" title="3.3 数学三"></a>3.3 数学三</h3><p> <strong>复习资料</strong></p><ul><li>张宇数学三的视频课</li><li>《李永乐复习全书》大红色</li><li>《李永乐660题》</li><li>《李永乐历年真题》</li><li>40套模拟题（《张宇8套卷》、《4套卷》、《永乐6套卷》、《历年合工大最后五套卷》、《400题》）</li></ul><p><strong>复习方案：</strong></p><ul><li><strong>8月10日-9月1日：</strong>花了将近一个月的时间来看张宇的视频，他的整个讲解的框架体系蛮成熟的，按照他的指示把笔记全部抄下来，然后自己尝试着背诵，这样下来就可以搭建起数学三的整体的脉络，知道要考的知识点和题型。我个人认为这个框架的搭建对于学习数学来说太重要了，他可以帮助你以一种高屋建瓴的视角来面对你所遇见的各种题型，而不至于迷失在茫茫的题海中无法自拔，它就像在你的脑海中植入了一份详尽的探险地图，遇见一个题，你可以将其归入体系中的某个知识点，这样的训练增加之后，对你的做题速度和准确率也会有很大的提升。一定要有这样的意识将知识归整而不是碎片化存在于你的大脑中，一个成熟的知识体系都会是如此，麻省理工大学的数学大咖林达华在讲解自己的数学体系时，必然脑海中有这样的一个完备的详尽的清晰的图景。</li></ul><ul><li><p><strong>9月1日-10月15日：</strong>进入考研攻坚期，复习全书是必备的，因为数学是上午考，我也象征性的把复习时间安排在了上午，每天看10页左右，消化不了太多，一些原则：1、必须自己拿笔写，切忌眼高手低以为看看就会了/2、切忌还没怎么思考就看答案解析，不会做没事，自己思考的过程尤为关键，在每道题的边上写下自己的思考推算过程以及这道题的关键之处、3、琢磨好久都搞不明白的，可以询问大神研友，或者自己做个标记，以后来解决（我后来忘记我曾经有不会的题了，就是这么大马哈）。数学其实有点像练书法，一开始可能你的水准只能够临摹大师们的作品，还只能学个皮毛，但重复训练达到一定的层次之后，你会形成自己的笔法（数学思维方式），在之后对于从未涉猎的新帖（新题型）也可以驾轻熟重。</p></li><li><p><strong>10月16日-11月10日：</strong>复习全书完了之后，一本虐人无数的660题登场，别以为他全是选择题和填空题，但他的每一道题都是精心锤炼过得，所体现的数学思想方法绝对会让你获益匪浅，他的题目的设置真的恰到好处，细细的琢磨每一道题的精髓，虽然真题是绝对达不到这样的难度的，关键的是思想方法。我大概刷了20多天，但有些题后来又忘记回过头去考虑了，这就落下不少病根，    所以建议复习的早一点，可以有更多的时间来调整自己的复习计划。</p></li><li><p><strong>11月11日-11月20日：</strong>从光棍节那天清晨开始，我拿起了真题，花了十天时间每天完成一套卷子，因为很多题其实在你做全书的时候已经遇到过了，所以其实真题对于真实水平的评估还是有很大偏差的，对完答案，订正，错的题的解题思路思考一遍就完事，当时的分数基本保持在120-140之间，也没有太大的失常，第一，历年真题相对于之前的训练还是简单一些的，第二，平时的训练不紧张，三个小时基本上都是轻松愉快的度过的，那时候每天早上起床就盼着可以做数学真题了，就像恋爱一样。</p></li><li><p><strong>11月20日-12月23日：</strong>接下来来到了我个人最为推崇的一种方法，就是数学套卷模拟，在这个阶段中，每做一套模拟题，就可以把所有的章节的重要内容复习一遍，尽管无法覆盖每一个知识点，但模拟题的编写还是有一定的规律的，可以让你随机的复习到一些重要的知识点。要遵守几个原则：1.三小时一套，时间到了就停止答题，然后根据答案自己批分数。2.必须严格遵守考研数学设定的考场规则，不能看书，不能交头接耳，不能询问学神研友，不能嚼口香糖。3.交叉训练法，每个老师出题的风格可能不一样，你可以先做两套张宇的，再做两套李永乐的，这样循环着做，可以增强你的适应能力，亲测有效。至于该做哪些模拟题，我推荐的都在上边写着，这个方法也是借鉴北大444哥的。为什么要建议这个办法呢，因为考研数学今年风格大变，像线性代数和概率论与数理统计的大题都是很难遇到的，那怎么办呢，就是不断地训练模拟题，不断地遇到新题，不断地提高自己的解题能力，而且这样的实战模拟也会让你开始意识到考场上的时间分配是何其重要，3个小时，挑大肉吃，有的是在太难的，抛开也无妨，考场的战略是需要在平时的训练中积累的。此外，你的书写也需要在这段时间里训练，张宇的8套卷和4套卷都提供了和考研一模一样的答题纸，不要大手大脚的乱答题，解题的条理性要注意。合工大的那几套题真的很不错，今年在考场上做高数的时候相当顺利的原因就是这些题型基本都在那15套卷子里遇到过了，所以，直到高数大题做完，我只花了1个小时20分钟，最后剩下一个半小时左右的时间来解决线代和概率大题，但是，我真是个天生的考场悲剧制造者，详情见下。</p></li></ul><p><strong>考场上：</strong></p><ul><li>因为考研期间基本上很少运动，打个球跑个步都是奢侈的不行，散步也成了浪费时间的活儿，后来自己也尝到恶果了，我的小心脏承受不住了，有时候会突然之间心跳加速到200多次每分钟，去校医院检查的时候医生说说是有阵发性室上性心动过速，吓得我够呛，问医生为啥，他说是我的心脏短路了，很多时候是因为焦虑不安或者过度兴奋造成的，好吧，那时候都到了考研的冲刺期，我也只能硬挺着，反正医生说没什么生命危险，然后就听到了考研的那天。在考研数学的考场上，我因为一个小时十分钟就完成了高数部分，high的不行了，一兴奋，犯病了，心跳开始砰砰砰的上去，以至于我无法正常答题，短时间治愈这个病的办法就是蹲下去深呼吸，于是我就申请去走廊自己做深蹲，然后深呼吸，深蹲深呼吸，当时真的快要奔溃了，以为这场试就这么完蛋了。深蹲深呼吸了好久，大约过了十五分钟，还是没有恢复过来，感觉真的没救了，老师也一直在边上看着我，该咋办，我的天哪，情急之下我开始捶自己的胸部，一锤倒是好了，但是背部还是有明显的不适感，总觉得有东西在怼我，就在这样的状态下，勉强答完了题，再加上线代和概率题和之前的训练风格太不一样了，我就有点崩溃了，连时间都看错了，原本是11点半结束，我却以为11点就结束了，情急之下把线代大题答得满卷子都是，感觉都看不清楚了，菩萨保佑吧，希望老师可以手下留情。所以，从我身上可以吸取的教训就是平时要注意身体，有时间就去跑跑步打打球，千万不能输在身体上。最后数学考了121分，也算是谢天谢地了。</li></ul><h3 id="3-4-432统计学"><a href="#3-4-432统计学" class="headerlink" title="3.4 432统计学"></a>3.4 432统计学</h3><p><strong>复习用书：</strong></p><ul><li>贾俊平《统计学》第四版（经管类）</li><li>贾俊平《统计学》第六版（21世纪统计学系列教材）</li><li>何晓群《多元统计分析》</li><li>王燕  《时间序列分析》</li><li>何晓群《应用回归分析》</li></ul><p><strong>复习方案：</strong></p><ul><li><p><strong>贾俊平《统计学》：</strong>一开始看的是第六版，作为门外汉的我觉得这本书还是蛮简单的，因为之前学过数理统计的一些课程，所以理解起来也不难，而且框架体系也比较清晰，基本上一个章节一天就OK，看了两遍，然后整理了自己的笔记。后来了解到原来第四版的内容更饱满一些，就把第六版没有的内容补看了下，做了笔记。而且今年出事的时候出了一道实验设计的题，最后阶段预测的时候是万万没有想到会出这个题，所以，建议看第四版，内容全。但我又比较喜欢第六版的表述，两本结合着看吧，但是第六版上没有的内容一定要补全，像实验设计、哑变量、指数平滑、主成分和因子分析、聚类分析（这俩个属于多元统计分析）都要添加上去。非参数统计我看了一遍，整理了下笔记，稍微背诵了下，不过复试的时候有人被问到了，所以也要好好看。复试的时候老师问了我关于哑变量的，幸好看了第四版。</p></li><li><p><strong>何晓群《多元统计分析》：</strong>说实在的这本书写得像哲学，感觉是直接从英文版翻译过来的，很多表述没有那么通俗易懂。我只看到了第八章典型相关分析，真的很难说会不会考之后那几章，就目前来看是小概率事件。这本书最关键的是统计分析方法的基本理论原理、分析步骤和以及去对应可以解决的问题，不需要去死抠推导过程，这不是432需要重视的，但是对于理解还是有帮助的，有兴趣的可以推推看。16年没考这部分内容，但不能预计17年会不会考，要复习的全面一些。一些问答题都要结合历年真题自己根据课本进行总结。</p></li><li><p><strong>王燕《时间序列分析》：</strong>这本书的编写就相对好得多，条理很清晰，思路引导很顺畅，一些例题也比较易懂，重点是各种预测描述模型，今年考了一道08年学硕考过的题：有趋势有季节变动可建立的模型，写出模型形式并简要说明。可见学硕的历年真题也是很有借鉴意义的。之前也考过差分运算的，复习的时候也要注意这种细节，但是这本书里面的例子特别好，几道题对应相应的知识点，只要你一点点看下来理解了，然后把笔记整理好，后期再背诵下，应该没啥问题。</p></li><li><p><strong>何晓群《应用回归分析》:</strong>一直以为何晓群老师是个女老师，后来复试的时候才了解到并非如此。这本书写的也很有条理，多重共线性的后果诊断处理已经多次考到，自相关性和异方差还没出过，今年考了一个判定系数的解释，当时预测了几道觉得会考的题，里面就有判定系数和回归模型的综合评价，初试的时候就考到了，这个虽然比较简单，但可以尝试的方法就是在考试之前，自己预测一些题，自己给自己出题做，涵盖面广一些，会有意想不到的结果的。</p></li><li><p><strong>关于真题：</strong>真题强调上百遍都不夸张，他对于你复习的方向有很大的启示作用。我当时的做法就是把真题整理成八个专题，分别是：《专题一：图表展示与概括性度量》、《专题二：统计量与抽样分布》、《专题三：参数估计与假设检验》、《专题四：分类数据分析》、《专题五：方差分析与实验设计》、《专题六：回归分析》、《专题七：时间序列分析》、《专题八：多元统计分析》，学硕和专硕的历年真题都要整理分类，基本上人大每年考的都包含在八个专题之间，你需要做的就是自己认认真真的从课本上找出答案来，然后总结一遍，一些学硕要求的比较偏数理的可以忽略，需要明确的是，重点一定会反反复复的考，而且乐此不疲，像今年时序和回归的题都是曾经考过的，几乎一模一样。</p></li></ul><ul><li><p><strong>关于笔记：</strong>自己整理的笔记的字迹一定要清晰，条理要很清楚，但这是建立在你把书看了几遍理解透了之后才可以做到的事，当然一开始不理解，到后面反复的背诵就会逐渐清晰起来了。当时我是和真题一样分了八个专题，参照人大大数据陈思聪学长的笔记整理了手写的笔记，学长的笔记结构完整，内容完善，当时是如获至宝，每天看着它整理自己的笔记的心情相当愉悦，对我的专业课起到了至关重要的作用，在这里谢谢学长。在复习过程中，我发现自己常常会对知识的首次记忆有所偏颇，只知其一不知其二，以为已经完全理解了其确切的意思，但其实当我在复试复习的时候再回过头来看往往会有更多新奇的发现，此时的知识域相对来说也会完善一些。</p></li><li><p><strong>关于背诵：</strong>心理学中有一个广为认可的记忆机制，即：我们在记忆的时候将许多线索（诸如对一个原理的发散性理解、当时联想的事物的多样性）一并编码进入记忆中，能否长时间的保持知识的新鲜感或者说在大脑中的活跃度，取决于这些线索是否足够丰富，这就为理解记忆提供了有力的证词。贯彻于专业课的背诵上，其实各个统计方法知识中包含了精确的概念、严谨的逻辑、一般的原则、生动的背景等无数的记忆线索，而并非是孤立的、任意的文本序列，各个点之间具有并列、递进、相互排斥的种种关系，推导和演绎出这种联系，从而由点到面，搭建成一个大的框架体系，就是我个人比较推崇的思维导图，如此进行下去到考研前几天可以看着那张大的框架图自己逐条背诵，口头表达可以和原文范本有出入，但是关键词必须要锁定，大致意思要接近。</p></li><li><strong>其他：</strong>大家如果有专业课的问题，可以向我询问，我尽力解答。最近也在恶补专业知识，毕竟是跨专业，害怕一进人大就被各路大神碾压，大家互相学习吧，或许我的专业素养还比不上学弟学妹呢。和考研小伙伴一起建立了一个微信群，大家伙可以加进来在群里分享应用统计的资料、讨论复习过程中遇到的难题、分享考研路上的酸甜苦辣，啥啥啥都可以。因为微信群已满100人，可以加我的个人微信：<strong><em>zhanghua63170140</em></strong>，拉学弟学妹进群。</li></ul><h2 id="四、QA"><a href="#四、QA" class="headerlink" title="四、QA"></a>四、QA</h2><p><strong>师妹皱着眉头问：</strong></p><p>师哥好，我也想考人大统计，本科统计，但只是普通一本。旁边人都说人大太难考，因为我是师范学校，而且我们数科院好几年没有人考到人大，感觉挺迷茫的，也不知道该不该换个学校，但是总觉得不甘心，为什么别人能考上我不能啊？</p><p><strong>师兄皱着眉头答：</strong></p><p>在现实世界中，我们的决策往往会倚赖过往的历史经验，就像你所述的，你所在的师范学校的数科院没有人考入过人大统计学院，看到这么惨淡的景象，畏惧心理在所难免，既然他们已经为你趟过这条深水，且已证明这不是一条容易的路，那为何我还要继续当做下一个被湍急的河流卷走的“微弱的个体”呢？且不说投入进去的时间成本以及其他一些不可控因素给自身带来难以计数的艰难险阻，万一这一年的所有努力在成绩出来的那一刹那都付之一炬，名校梦从而化为泡影，岂不是做了一次失败的买卖吗？</p><p>可我想告诫你的却是，人大必须要去考，而且要义无反顾的前往，不要有所畏惧，从你的描述中得知并没有太多的现实因素的阻挠，你仅仅在惧怕强大而无耻的经验施加在你身上的不能承受的阻抗。先说说你会在这条幽深曲折的路上看到哪些曼妙的风景，你或许可以涉猎到从未踏入的知识盲区，当你被无数的知识模块所充盈，你会感受到这样的缓慢累积会给你带来前所未有的愉悦与渴求欲的满足，我们时代的知识分隔已经异常凸显出来了，每一个领域会将拥有一套成熟的体系，而当你掌控着庞大细密的知识网时，你便拥有了铠甲，他将带你在众人面前展示话语的力量，那种力量就是需要这些知识来支撑的。其次，你可能可以收获几个志同道合的朋友，网络的延伸将你的诉求与宣告呈现在他们面前，就像现在我正在尝试着与你促膝长谈一样，也必定会有无数的这样的人尝试着与你建立精神上的关联与挂钩，你们摸索着同一片黑夜，也凝望着同一片蓝天，为这笃定的信念挥汗。你要坚信，总有一天，你会与你精神气质相合的那些可爱的人相聚，就像家人一样聚在一起，所以，不要抗拒孤独，那仅仅是你还没有那样强烈的遇见。最后，也是最重要的，你将迎来新的人生，你说你想考人大统计，我相信你的内心必然会有一股洪荒之力在不断地催促着你，会有一种声音在耳边呼唤你，那便是我们最大的动力，这样的声音会在你颓然之时支起你的躯体，无论什么样的生活的贫乏无趣都驱散不了这种称之为信仰的东西，只要你持续地温存这样的声音，去战胜所有的困惑与不安，正是这种不甘让我们变成一个撑起自己所有维度的勇士。是的，你会变成一个勇士，即使被现实迫害的遍体鳞伤，你也依然可以坚毅地挺立原地，然后，舔舐自己的伤口，继续热烈地往前走。那种热烈，只能自己亲手栽培，别人无法给予，你也不能凭空取得，那是一个个白天黑夜的伏案所换来的最盛大的生命花园，你要在漫长的年华里种上玫瑰、植入梧桐、嵌进宝石，让它灿烂的更彻底点吧，即使荒败了，也要在极度的繁盛中逝去。</p><hr><p><strong>酷酷的师弟问：</strong></p><p>师兄，我是跨专业，感觉对专业课比较迷惘，不知如何下手，可不可以建议一个比较摸得着套路的专业课复习方案呀？</p><p><strong>严肃的师兄答：</strong></p><p>432统计学复习流程建议</p><ol><li><strong>贾俊平《统计学》第六版+圣才《贾俊平统计学 笔记与课后习题详解》：</strong>花费20天左右的时间进行全篇阅读，不遗漏任何一个点，包括概念、公式、解释、注释、表格、图片、例题，每一个字都要盯上至少一秒钟。每看完一章节的所有内容之后，在A4纸上写下课后思考题与练习题的答案，可以翻阅课本，但必须要自己动手整理归纳或者解答一遍，切记眼高手低，能写入教科书的例题就必然会有其存在的必要性，它可以帮助你梳理课本知识，也可以帮你抓住章节重点，整理这些问答题和计算题的过程也是再一次深入理解知识点的过程，绝不可废弃之。课后的思考题和练习题的答案可以在圣才出版的《贾俊平统计学 笔记与课后习题详解》找到，我只找到了第五版对应的（一共331页），已经上传到网盘里。大家也可以参考人大配套的学习指导书，网上可以买到。这样一遍下来对这本书的框架有一定的了解，强烈建议看完每一章节之后画一张框架结构图，理清知识脉络。重点章节是”第3章：数据的图表展示“、”第4章：数据的概括性度量“（这两个章节联合起来会在真题中考察一道大题）；第6章，统计量概念和中心极限定理是重点；第7-13章，所有的都是重点。第1、2、5、14章可以粗略看一下，非重点。</li><li><p><strong>贾俊平《统计学》第二遍：</strong>第二遍依旧要有如第一遍的细致程度，且在第一遍的基础上加深理解，争取可以简单的使用自己的话简述一遍，同时要开始做笔记，按照书本的结构组织笔记，且必须要把这本笔记当做是一样艺术品，用心编排、用心写字、用心画图，重点分明、内容完整、结构清晰，切不可潦草糊弄过关，这本笔记是你在日后的复习中常常会碰面的，翻阅起来可以大大地提高效率，而且看起来愉悦舒心一目了然，何乐而不为？切勿盲目求快，做笔记是一个梳理知识点、更深入理解知识点的过程，欲速则不达，抄一遍了事对理解没有丝毫的助益，下笔之前想明白这句话所指涉的是什么、是否还存留我尚未领会的含义、我能否清晰的在脑海里梳理分析流程等等等，这些都可以增益你对细节的深入探索，慢工出细活，相信我，循序渐进的来，一定会有很大的成效。同时这一遍笔记要把管理学第四版中出现的新知识补充到笔记中，其中的新知识点包括：正态性的评估、实验设计、哑变量回归、非参数统计（注：时间序列分析和多元统计分析的部分内容会在其他两本书中会详细展开，不添加进去也无妨）。</p></li><li><p><strong>《应用回归分析》：</strong>这本书囿于时间只看了前八章，也就是到主成分回归与偏最小二乘估计这一章为止，因为在《统计学》书中已经对这部分的内容有了基本的了解，加上《应用回归分析》书中的推导也不是特别艰深，基本上每一步思路都很清晰，大家可以尝试着推导一遍，加深理解，但这并不是重点，重点在于诸如违背回归方程基本假设条件的三种情况（异方差、自相关、多重共线性）的原因、影响、诊断、处理这类偏向论述、步骤与原理的知识点，所以，如果推导有困难，也不必强求。但其实后两章的非线性回归与定性变量回归模型也比较容易理解，虽然初试考察的概率不大，但为兼顾知识结构的完整性以及复试的时候有可能被老师问及，看一下肯定是有好处的。这本《应用回归分析》也是要看一遍，再做一遍笔记，做笔记的方法与上述一样，不再赘述。</p></li><li><p><strong>《应用时间序列分析》：</strong>这本书的条理狠清晰，大致就是平稳时间序列分析、非平稳时间序列的确定性分析和非平稳时间序列的随机性分析三块内容，考试重点在于若干个时间序列分析模型的结构与性质，譬如AR模型、MA模型、ARMA模型、ARIMA模型、指数平滑法、分解模型、含哑变量的多元回归预测模型等等，要搞清楚每一种模型所适用的时间序列类型、模型中每一个参数代表的含义以及分析的思路与步骤，其他的重点包括差分运算、一些基础的概念等。最后一章考的概率不高，但时间序列最后一章内容在时序分析所占地位是很高的（虚假回归、单位根检验、单整与协整）要是想扩充知识点，，也建议看一遍。同样，整个过程也是看一遍书，整理一遍笔记。</p></li><li><p><strong>《多元统计分析》：</strong>聚类分析、判别分析、主成分分析、因子分析、对应分析、典型相关分析必看，后几章个人认为考的几率不大，看个人时间分配。重点考点是这些多元统计分析方法的基本思想、过程细节、重点性质之类的，历年考过因子分析、判别分析、典型相关分析的相关内容，考的概率蛮大的，绝不能弃看。过程还是一样，第一遍，看书、理解、适当推导，第二遍，做笔记，再次理解，加深印象。</p></li><li><p><strong>八个专题整理：</strong>这是学长根据历年真理的考题分布情况总结出来的八个专题，已经在上述的复习中有所呈现，依次是：“专题一：数据的图表展示与概括性度量”；“专题二：统计量与抽样分布”；“专题三：参数估计与假设检验”；“专题四：分类数据分析”；“专题五：方差分析与实验设计”；“专题六：相关分析与回归分析”；“专题七：时间序列分析”；“专题八：多元统计分析”。几乎每一年都是在这八个专题中抽取七个专题的知识点，例如2015年432真题的排布分别为：第一题属于专题一（数据的图表展示与概括性度量）、第二题属于专题四（分类数据分析）、第三题属于专题五（方差分析与实验设计）、第四题属于专题八（多元统计分析）、第五题属于专题三（参数估计与假设检验）、第六题属于专题六（相关分析与回归分析）、第七题属于专题七（时间序列分析）。还是比较有代表性的，其他年份的分布学弟学妹们也都可以总结一下规律，有助于自主预测考题。大家可以以这个思路去归纳整理自己最终的一份笔记，八个专题，每一个专题都要有结构框架，可以借助思维导图这个工具，每一个专题包括四个部分（第一部分：这一专题的课本内容有序的整理；第二部分：重要问答题整理；第三部分：属于这一专题的真题整理（每一道题的答案一定要完整有序地整理）；第四部分：这一专题的思维导图）。整理完这份专题笔记之后时间也就剩下一个月左右，接下来的时间就是背背背，当然要理解地去背，把笔记与思维导图结合起来，背到滚瓜烂熟，背到天昏地暗，到最后阶段会特别难熬，英语作文要背，政治大题要背，专业课要背，抗住压力就是了。</p></li></ol><hr><p><strong>可爱的小师妹问：</strong><br>你的专业课思维导图咋搞咯？还有专业课的复习时间怎么分配？难点不懂怎么办？师兄你有笔记吗？：</p><p><strong>依旧严肃的师兄答：</strong></p><p>这八个专题的思维导图我已经整理完并放置在百度云群里了，这里给出百度云链接，<a href="https://pan.baidu.com/s/1nva2ydN" target="_blank" rel="noopener">人大432专业课思维导图</a> 密码: pwu9。当然思维导图要随时自己更新，如果自己觉得需要补充的，可以在思维导图上添加。要想使这个思维导图的效用最大化，就得把框架熟记在心中，在答题的时候一定会有帮助的，会让你的答案有结构有条理，列点回答更加轻松自如，不知道怎么把题目答得全面闪亮？只需把思维导图的一个个点用书本的内容或者你整理的笔记来填充就好啦。不过，话说在前头，理解才是关键。它只是一个框架工具，核心在于知识点。</p><p><strong>时间怎么分配呢</strong>？：基本上每天我都会花三个小时复习专业课，有的时候白天数学的任务没完成，也会适当压缩专业课的时间，大致的时间安排是《统计学》阅读及笔记25天、《应用回归分析》阅读及笔记20天、《应用时间序列分析》阅读及笔记20天、《多元统计分析》阅读及笔记20天、《八个专题整理》25天、背诵30天。</p><p><strong>难点不懂咋办办？</strong>：在多元统计分析或者时序分析中会出现一些自己无法理解的地方，诸如推导过程和计算证明，这些确实不是432统计学的考察重点，但是如果不搞清楚这些，对知识点就会感觉隔着一层迷雾，无法透彻地解析整个过程总会叫人不爽快，不求甚解是深层次理解知识点的大敌。但是，时间所迫，实在搞不懂这些玩意儿咋办呢，那就只能退而求其次，可以大概的知道这个推导是在干什么以及它在整个过程中的作用。也足够应对432统计学了。</p><p><strong>学长你有笔记吗？</strong>：哈哈哈，到最后了学长要黄婆卖瓜自卖自夸了，简要说下学长的专业课笔记，笔记分为七个部分其中前六份都是亲手整理的，就是依据上述的复习过程一步步整理下来，并且经过了精心的排版，保证大家的用户体验一级棒。如果想深入了解资料的细节，可以私聊学长，随时等候你的到来。欢迎添加个人微信：<strong>zhanghua63170140</strong></p><h2 id="五、写在最后"><a href="#五、写在最后" class="headerlink" title="五、写在最后"></a>五、写在最后</h2><p>这一路下来，感谢的人很多，人大陈思聪学长（见过学长本人，沉稳贴心哈哈，考研的时候不会的题去问他都会耐心解答），小杰克学长（这个群真的建设的太赞了，复试的资料是向学长要的，帮助很大），老胡学长（最近给我发了好几本砖头书，全英文版，据说是装逼神器），以及在中海洋读研的王淼淼童鞋（跨专业考统计真心不容易，磕磕碰碰了很多次，王淼淼鼎力相助；我后期整理了一个专业课思维导图，也是王淼淼给我的灵感），在幼儿园种花种草的冯涵小朋友，三个考研小伙伴大象、赫姐还有小姨妈（每次拿小姨妈开玩笑真的屡试不爽），还有强悍的北大444哥（他的经验贴真的是棒呆）。最后想感谢的是我的女朋友，她脸上的笑容总能够化解我的忧愁与不安，每次复习到夜深，想起在这座城市的另一边有那么一个人与我一同牵手向前，就会充满力量。 </p><p>在本科期间，我们所接受的更多的是老师所教授的知识，而到了研究生期间，我们要准备开始制造新的知识，更高层次的目标便是对人类普遍的知识有所贡献，而达到如此境界的来源正是你对知识的渴求与不断地追索，你不再满足于单一的知识面，而渴望搭建更坚固的知识架构。我们不能功利的对待这场磨练你意志的战役，不能仅仅把它看成是获取更多外在利益的工具，虽然确实可以达到这样的效果，但这样的动力绝对不会持久的催促你往更高的知识领域探索。</p><p>很多人在中途放弃或是马马虎虎的应付，就是自己内心缺乏行动的信念支撑，倘若只是觉得考上研就一劳永逸了，就没有必要花费那么厚重的时间成本了，因为，考上研只是一个起点，更艰难的路，在前方。</p><p>祝愿学弟学妹可以在考研路上发现更多的风景，顺利考上人大。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2016人大考研总算是落下了帷幕，大半年来的努力终于落定。在北京的春天里，窗外飘着杨絮，在图书馆的沙发上码下这难忘时光的的锤炼与凝结。&lt;/p&gt;
    
    </summary>
    
      <category term="日知录" scheme="http://yoursite.com/categories/%E6%97%A5%E7%9F%A5%E5%BD%95/"/>
    
    
      <category term="人大应统" scheme="http://yoursite.com/tags/%E4%BA%BA%E5%A4%A7%E5%BA%94%E7%BB%9F/"/>
    
      <category term="考研" scheme="http://yoursite.com/tags/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>日知录（2）：心理账户</title>
    <link href="http://yoursite.com/2017/12/12/%E6%97%A5%E7%9F%A5%E5%BD%95%EF%BC%882%EF%BC%89%EF%BC%9A%E5%BF%83%E7%90%86%E8%B4%A6%E6%88%B7/"/>
    <id>http://yoursite.com/2017/12/12/日知录（2）：心理账户/</id>
    <published>2017-12-12T15:14:45.000Z</published>
    <updated>2017-12-28T14:39:58.538Z</updated>
    
    <content type="html"><![CDATA[<p>2002年10月9日，瑞典皇家科学院将诺贝尔经济学奖授予普林斯顿大学心理学教授DannielKahneman和乔治·梅森大学经济学教授VernonSmith。根据瑞典皇家科学院的新闻公报，卡尼曼“将心理学的深入分析融入到了经济学中，从而为一个崭新的经济学研究领域奠定了基础”。1981年，DannielKahneman及其合作者AmosTversky在《科学》杂志发表论文，研究人们决策过程的认知心理规律。文章介绍了“演出实验”</p><a id="more"></a><ul><li>【实验情境A】：你打算去剧院看一场演出，票价是10美元，在你到达剧院的时候，发现自己丢了一张10美元的钞票。你是否会买票看演出？实验表明：88%的调查对象选择会；12%的调查对象选择不会。（调查对象为183人）</li><li>【实验情境B】：你打算去看一场演出而且花10美元钱买了一张票。在你到达剧院的时候，发现门票丢了。如果你想看演出，必须再花10美元，你是否会买票？实验结果表明：46%的调查对象选择会，54%的调查对象不会。（调查对象为200人）</li></ul><p>Kahneman和Tversky认为:两种实验情境出现明显不同结果的原因在于:在考虑情境A的决策结果时，人们把丢失的10美元钞票和买演出票的10美元分别考虑；而在情境B中，则把已经购买演出票的钱和后来买票的钱放在同一个账户估价，一部分人觉得“太贵了”改变自己的选择。为此，Kahneman和Tversky引入理查德·萨勒教授（RichardThaler）提出的“心理账户”概念，对实验结果进行了深入的分析。</p><h2 id="一、概念发展"><a href="#一、概念发展" class="headerlink" title="一、概念发展"></a>一、概念发展</h2><h3 id="1-1-理查德·萨勒"><a href="#1-1-理查德·萨勒" class="headerlink" title="1.1 理查德·萨勒"></a>1.1 理查德·萨勒</h3><p>1980年，芝加哥大学著名行为金融和行为经济学家理查德·萨勒（RichardThaler）首次提出“Psychic Accounting（心理账户）”概念，用于解释个体在消费决策时为什么会受到“沉没成本效应（sunk cost effert）”的影响。萨勒认为：人们在消费行为中之所以受到“沉没成本”的影响，一个可能的解释是卡尼曼教授等提出的“前景理论”，另一个可能的解释就是推测个体潜意识中存在的“心理账户系统”（Psychic Accounting system）。人们在消费决策时把过去的投入和现在的付出加在一起作为总成本，来衡量决策的后果。这种对金钱分门别类的分账管理和预算的心理过程就是“心理账户”的估价过程。</p><h3 id="1-2-丹尼尔·卡尼曼"><a href="#1-2-丹尼尔·卡尼曼" class="headerlink" title="1.2 丹尼尔·卡尼曼"></a>1.2 丹尼尔·卡尼曼</h3><p>1981年，丹尼尔·卡尼曼和特韦尔斯基(Amos Tversky)在对“演出实验”的分析中使用“Psychological Account(心理账户)”概念，表明消费者在决策时根据不同的决策任务形成相应的心理账户。卡尼曼认为，心理账户是人们在心理上对结果(尤其是经济结果)的分类记账、编码、估价和预算等过程。</p><p>1984年，卡尼曼教授和特韦尔斯基教授认为“心理账户”概念用“mental account”表达更贴切。卡尼曼认为:人们在做出选择时，实际上就是对多种选择结果进行估价的过程。究竟如何估价，最简单也最基本的估价方式就是把选择结果进行获益与损失(得失)的评价。因此，他提出了“值函数”假设和“决策权重”函数来解释人们内在的得失评价机制。</p><h3 id="1-3-理查德·萨勒"><a href="#1-3-理查德·萨勒" class="headerlink" title="1.3 理查德·萨勒"></a>1.3 理查德·萨勒</h3><p>1985年，萨勒教授发表“心理账户与消费者行为选择”一文，正式提出“心理账户”理论，系统地分析了心理账户现象，以及心理账户如何导致个体违背最简单的经济规律。萨勒认为:小到个体、家庭，大到企业集团，都有或明确或潜在的心理账户系统。在作经济决策时，这种心理账户系统常常遵循一种与经济学的运算规律相矛盾的潜在心理运算规则，其心理记账方式与经济学和数学的运算方式都不相同。因此经常以非预期的方式影响着决策，使个体的决策违背最简单的理性经济法则。萨勒列举了4个典型现象阐明心理账户对传统经济规律的违背，并提出了心理账户的“非替代性”特征。</p><h3 id="1-4-特韦尔斯基"><a href="#1-4-特韦尔斯基" class="headerlink" title="1.4 特韦尔斯基"></a>1.4 特韦尔斯基</h3><p>1996年Tversky提出，心理账户是一种认知幻觉，这种认知幻觉影响金融市场的投资者，使投资者们失去对价格的理性关注，从而产生非理性投资行为。Kivetz(1999)认为，心理账户是人们根据财富的来源不同进行编码和归类的心理过程，在这一编码和分类过程中“重要性-非重要性”是人们考虑的一个维度。有学者从行为的角度对“心理账户”进行定义，认为心理账户是个人或家庭用来管理、评估和记录经济活动的一套认知操作系统，这套认知操作系统导致一系列非理性的“心理账户”决策误区。</p><h3 id="1-5-理查德·萨勒"><a href="#1-5-理查德·萨勒" class="headerlink" title="1.5 理查德·萨勒"></a>1.5 理查德·萨勒</h3><p>1999年，萨勒发表“mental accounting matters”一文，这是对近20年“心理账户”研究的一个总结。在文章中，萨勒认为:心理账户的三个部分最受关注，首先是对于决策结果的感知以及决策结果的制定及评价，心理账户系统提供了决策前后的损失——获益分析;第二个部分涉及特定账户的分类活动，资金根据来源和支出划分成不同的类别(住房、食物等)，消费有时要受制于明确或不明确的特定账户的预算;第三个部分涉及账户评估频率和选择框架，账户可以是以每天、每周或每年的频率进行权衡，时间限定可宽可窄。因此，“心理账户”是人们在心理上对结果(尤其是经济结果)的编码、分类和估价的过程，它揭示了人们在进行(资金)财富决策时的心理认知过程。</p><h2 id="二、心理账户的非替代性（non-fungibility）"><a href="#二、心理账户的非替代性（non-fungibility）" class="headerlink" title="二、心理账户的非替代性（non-fungibility）"></a>二、心理账户的非替代性（non-fungibility）</h2><p>按照传统的微观经济学理论，金钱不会被贴上标签，它具有替代性(fungibility)，事实上，越来越多的实证研究表明:</p><blockquote><p>人们并不是把所有的财富放在一个整体账户进行管理，每一元钱与每一元钱可以很好的替换与转移。相反，人们根据财富来源与支出划分成不同性质的多个分账户，每个分账户有单独的预算和支配规则，金钱并不能容易地从一个账户转移到另一个账户。</p></blockquote><p>萨勒将这种金钱不能很好转移，不能完全替换的特点称之为“非替代性”。萨勒教授在研究中发现金钱非替代性的一些表现:</p><ol><li>【不同来源】：由不同来源的财富而设立的心理账户之间具有非替代性，例如意外之财和辛苦得来的钱不具替代性。一般来说，人们会把辛苦挣来的钱存起来不舍得花，而如果是一笔意外之财，可能很快就花掉。</li><li>【不同消费项目】：不同消费项目而设立的心理账户之间具有非替代性。我们来看一个案例:王先生非常中意商场的一件羊毛衫，价格为1250元，他觉得贵而舍不得买。月底的时候他妻子买下羊毛衫作为生日礼物送给他，他非常开心。尽管王先生的钱和他的妻子的钱是同一家庭的钱，为什么同样的钱以不同的理由开支心理感觉不同?研究表明:自己花费购买羊毛衫，属于生活必需开支，1250元太贵了;而作为生日礼物送给丈夫，属于情感开支。因此人们欣然接受昂贵的礼品却未必自己去买昂贵的物品。可见，为不同的消费项目设立的心理账户之间具有非替代性。</li><li>【不同存储方式】：不同存储方式导致心理账户的非替代性。萨勒教授举的一个实例。约翰先生一家存了15000美元准备买一栋理想的别墅，他们计划在5年以后购买，这笔钱放在商业账户上的利率是10%;可最近他们刚刚贷款11000美元买了一部新车，新车贷款3年的利率是15%，为什么他不用自己的15000美元存款买新车呢?通常，人们对已经有了预定开支项目的金钱，不愿意由于临时开支挪用这笔钱，对这个家庭来说，存起来买房的钱，已经放在了购房这一预定账户上，如果另外一项开支(买车)挪用了这笔钱，这笔钱就不存在了。从理性上说，家庭的总财富不变。但因为财富改变了存放的位置，固定账户和临时账户具有非替代性，人们的心理感觉不一样。</li></ol><h2 id="三、心理账户的运算规则"><a href="#三、心理账户的运算规则" class="headerlink" title="三、心理账户的运算规则"></a>三、心理账户的运算规则</h2><p>在日常经济活动中，人们是如何操纵和管理心理账户，这些经济交易在人们心里是如何评估和被体验的呢?萨勒认为:人们在进行各个账户的心理运算时，实际上就是对各种选择的损失-获益进行估价，称之为“得与失的构架(the framing of gains and losses)”，人们在心理运算的过程中并不是追求理性认知上的效用最大化，而是追求情感上的满意最大化。</p><p>情感体验在人们的现实决策中起着重要的作用，他将这种运算称之为“享乐主义的加工”（hedonic editing）</p><h3 id="3-1-值函数的假设"><a href="#3-1-值函数的假设" class="headerlink" title="3.1 值函数的假设"></a>3.1 值函数的假设</h3><p>为了更好地探讨心理账户的价值运算如何影响人们的经济决策行为，卡尼曼教授在“前景理论”中提出了“值函数”(value function)这一概念。与以往经济理论中的“效用函数”(utility function)相比，值函数有三个重要的特征。</p><ol><li>值函数是人们在决策行为时对于某个参照点的相对得失的详细说明，人们的“得与失”是个相对概念而不是期望效用理论的绝对概念。人们对某一决策结果的主观判断是相对于某个自然参照点而言，而不是绝对的财富或经济。因此，参照点的变化会引起人们主观估价的变化，人们更关注的是围绕参照点引起的改变而不是绝对水平。</li><li>“得与失”都表现出敏感性递减的规律。值函数的曲线是一条近似“S”形的曲线，右上角的盈利曲线为下凹形(concave)，左下角的亏损曲线为上凸形(convex)(如图所示)。离参照点(坐标交叉的原点)愈近的差额人们愈加敏感，越是远离参照点的差额越不敏感。因此，不管是获得还是损失，人们感觉到10元到20元的差额似乎比1000元到1010元的差额更大，这反映了价值曲线的边际递减特征。</li><li>损失规避。卡尼曼教授认为:同等数量的损失比获益对人的影响更大，因此在决策的时候人们尽量回避损失，表现在价值函数曲线上，损失曲线的斜率比获益曲线的斜率更大(如图1所示)，用公式表示为V(X)&lt;-V(-X)。例如损失1000元钱所带来的痛苦比获得1000元奖金而带来的愉悦更强烈。因此，面临损失时，人们是风险偏好的;面临获得时，人们是风险规避的。</li></ol><p><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-12-19 下午4.00.29.png" alt="屏幕快照 2017-12-19 下午4.00.29"></p><p>由于值函数的三个典型特征，对心理账户的运算规则至少有三个启示:</p><ol><li>相同的决策结果表述为损失或者获益会改变人们的风险决策偏好;</li><li>设计不同的参照点会改变人们对决策结果的认知;</li><li>同样的价格差额在不同的原始价格下，影响作用是不同的。</li></ol><h3 id="3-2-得与失的编码规则"><a href="#3-2-得与失的编码规则" class="headerlink" title="3.2 得与失的编码规则"></a>3.2 得与失的编码规则</h3><p>根据上述值函数的特点，萨勒在关于心理账户的研究中，将值函数在得与失的不同组合结果中的偏好情况作了分析。</p><blockquote><p>规则一：两笔盈利应分开</p></blockquote><p>假如两笔收入X、Y均为正，分开价值为$V(X)+V(Y)$，整合值为$V(X+Y)$。因价值曲线在右上角为凸形，所以$V(X)+V(Y)&gt;V(X+Y)$，个体更偏好分开体验(如图)。假如想送朋友两件礼物——一套衣服和一个健身器，最好分两次送。每次送一件礼物所带来的心理体验比一次送两件礼物的心理体验高。</p><blockquote><p>规则二：两笔损失应整合</p></blockquote><p>两笔支出对个体而言是“损失”，因价值曲线在左下角为凹形，所以$V(-X)+V(-Y)&lt;V(-X-Y)$，个体更偏好整合价值。这一规律可以解释生活中的很多现象，比如开会收取会务费时，最好一次收齐并留有余地，若有额外开支一次次增收，虽然数量不多，会员仍会牢骚满腹。</p><blockquote><p>规则三:大得小失应整合</p></blockquote><p>两笔收入一正一负:X，-Y，且余额为正，即$X&gt;Y$，从价值曲线看应是$V(X)+V(-Y)&lt;V(X-Y)$，所以人们更偏好整合。这条规则给人们的启示是，如果你有一个大的好消息和一个小的坏消息，应该把这两个消息一起告诉别人。如此整合，坏消息带来的痛苦会被好消息带来的快乐所冲淡，负面效应也就小得多。</p><blockquote><p>规则四:小得大失应具体分析</p></blockquote><p>两笔收入一正一负:X，-Y，且余额为负，即X&lt;Y，此时应分两种情况:</p><p>其一，小得大失且悬殊很大，应分开估价。从图中看出$V(X)+V(-Y)&gt;V(X-Y)$，因此，分开估价的心理体验要好，这种现象称为“银衬里(silver lining)”规则。例如(40，-6000)，人们更愿意分开估价，因为价值曲线在-6000元附近相对较平缓，40元的获得与6000元的损失相比几乎没有减少损失的作用，分开估价还能得到40元收益的感觉。</p><p>其二，小得大失且悬殊不大，应整合。如(40，-50)，人们更偏好整合价值。表现为$V(X-Y)&gt;V(X)+V(-Y)$。整合估价时，人们在心理会把损失从50元降低到10元，这样的损失就显得小了，心理体验更好，整合估价的作用体现出来。</p><p>萨勒进一步把这四条规则概括为:</p><ol><li>分离收益;</li><li>整合损失;</li><li>把小损失与大收益整合一起;</li><li>把小收益从大损失中分离出来。</li></ol><p>以上心理账户的运算规则对于理解和解释现实经济决策行为有重要的指导意义。</p><h2 id="四、应用研究"><a href="#四、应用研究" class="headerlink" title="四、应用研究"></a>四、应用研究</h2><h3 id="4-1-价格感知——绝对值优惠与相对值优惠"><a href="#4-1-价格感知——绝对值优惠与相对值优惠" class="headerlink" title="4.1 价格感知——绝对值优惠与相对值优惠"></a>4.1 价格感知——绝对值优惠与相对值优惠</h3><p>1982年，特维尔斯基教授和卡尼曼教授通过设计以下情景实验引入“心理账户”与消费者购买决策行为的研究。</p><ul><li>【实验情景A】:假定你要买一件夹克和一个计算器。在某商场夹克的价格是125美元，计算器的价格是15美元。这时候有人告诉你，开车二十分钟后另一个街区的一家商场计算器的价格是10美元。请问:你会去另一个商场买计算器吗?</li><li>【实验情景B】:假定你要买一件夹克和一个计算器。在某商场夹克的价格是15美元，计算器的价格是125美元。这时候有人告诉你，开车二十分钟后另一个街区的一家商场计算器的价格是120美元。请问:你会去另一个商场买计算器吗?</li></ul><p>在这两个情境中，其实都是对“是否开车20分钟从140美元的总购物款中节省5美元”做出选择。然而，实验对象在两个情境中的回答却不一样。在情境A中，68%的实验对象选择去另一家商场;而在情境B中，只有29%的实验对象选择开车去另一家商场。选择偏好发生了逆转。</p><p>卡尼曼提出，消费者在感知价格的时候，是从三个不同的心理账户进行得失评价的。一个是最小账户(minimal account)，就是不同方案所优惠的绝对值。在本实验中的最小账户就是5美元。另一个是局部账户(topical account)，也可称为相对值账户。例如，在实验情境A中开车前往另一家店的“局部账户”表现为计算器价格从15美元降为10美元(相对差额为1/3);而在实验情境B中的“局部账户”表现为计算器价格从125美元降为120美元(相对差额为1/25)。第三个是综合账户(comprehensive account)，综合账户就是总消费账户，该实验的综合账户为140美元。</p><p>卡尼曼认为，在上面的实验中，消费者是自发运用了局部账户，即通过相对优惠值来感知价格。情境A有33.3%的优惠;而情境B仅有4%的优惠。因此，人们的购买行为发生了反转。表现为在实验情境A中，68%的实验对象选择去另一家商场;而在实验情境B中，却只有29%。</p><p>此后，Philip Moon,Kevin Keasey,Darren Duxbury对卡尼曼的研究进行了重复实验并且提出，当优惠超过某个阈限值的时候，消费者对绝对优惠值同样非常敏感。绝对值优惠与相对值优惠之间存在一种关系。</p><h3 id="4-2-行为生命周期理论——心理账户在消费领域的应用"><a href="#4-2-行为生命周期理论——心理账户在消费领域的应用" class="headerlink" title="4.2 行为生命周期理论——心理账户在消费领域的应用"></a>4.2 行为生命周期理论——心理账户在消费领域的应用</h3><p>经典的生命周期假说和持久收入假说是凯恩斯以后消费函数理论最重要的发展，但他们的理论是建立在完全理性人的假设之上的。例如，生命周期假说就认为:人总是能够深谋远虑，在任何时候都会考虑几十年以后的长远利益，并站在这种高度，根据一生的总财富来合理安排一生中每个阶段的消费，使一生的总效用达到最大。这显然和人们实际的消费行为不符，这种过于理性化的理论也无法解释现实中的许多经济现象。</p><p>1988年Shefrin和Thaler提出行为生命周期理论(behavior life cycle hypothesis)修正了传统的生命周期假说，使之能更好地描述现实中人们的消费行为。行为生命周期理论的两个最重要的概念是自我控制和心理账户。</p><p>行为生命周期理论引入“心理账户”理论解释消费行为。消费者根据生命周期不同财富的来源和形式，将它们划分为三个心理账户:现期可花费的现金收入账户(I)，现期资产账户(A)和未来收入账户(F)。行为生命周期理论认为:不同账户的财富对消费者的决策行为是不同的。现金收入账户消费的诱惑力最大，因此，将这个账户的收入不消费而储蓄起来的心理成本也最大;现期资产账户的诱惑力和储蓄的心理成本居中;未来收入账户的诱惑力和储蓄的心理成本最小。由于不同的心理账户对消费者的诱惑不同，所以，消费者倾向于较多地通过现金收入账户消费，而较少通过现期资产账户消费，几乎不通过未来收入账户消费。不仅不同的心理账户对消费者的诱惑是不同的，而且同一个心理账户，其中的财富余额不同，对消费者的诱惑也不同。财富余额越多，诱惑越大。</p><p>行为生命周期理论的消费函数可表示为$C=f(I,A,F)$，且有:$1≈C/I&gt;C/A&gt;C/F≈0$。这就是说，现金收入账户的边际消费倾向最大，接近于1;现期资产账户次之;未来收入账户最小，接近0。和生命周期持久收入假说的消费函数相比，行为生命周期理论在分析消费者行为时强调的是心理方面的因素，这些心理因素主要是通过心理账户加以描述。所以，心理账户的划分及其性质是理解行为生命周期理论的关键。</p><h3 id="4-3-关于消费预算的研究"><a href="#4-3-关于消费预算的研究" class="headerlink" title="4.3 关于消费预算的研究"></a>4.3 关于消费预算的研究</h3><p>1994年Heath和Soll发现，消费者有为不同的消费支出账户设置心理预算的倾向，并且严格控制该项目支出不超过合适的预算。例如，每个月的娱乐支出300元，每个月的日常餐饮消费1000元等。如果一段时间购买同一支出项目的总消费额超过了预算，人们会停止购买该类产品。即使在同一个消费项目中，不同的消费有不同的预算标准，同是娱乐消费，看电影的消费是200元人民币，买一本武打小说的消费是50元人民币。他们通过实验证明:人们当前在某一类项目的消费支出会减少他们未来在同一类项目的支出，而对其他项目的支出几乎没有什么影响。这是心理账户对每个消费项目会设定一个预算控制。</p><p>1996年，Chip和Soll研究认为，心理账户通过心理预算调节人们的消费行为。表现在:人们会为不同的消费设置预算，但预算通常会低估或者高估购买特定商品的价格，因此常使人们产生“穷鬼”和“大富翁”的认知错觉，从而出现消费不足和过度消费的消费误区。他们通过三个实验证明了心理账户的分类预算对消费决策的重要作用。</p><p>2006年，EldarShafir和RichardThaler发表Investnow,drinklater,spendnever一文，研究表明:在购买和消费暂时分离的商品交易中，人们会建构多种框架的心理账户。奢侈品的购买更多的被认为是一种“投资”而不是一种消费，因此，当消费很早以前购买的高档产品时，通常被编码为“免费”的或者是储蓄。但如果消费方式不是按原意愿进行时，对该产品的消费预算就会发挥作用。</p><h3 id="4-4-行为资产组合理论（BPT）——心理账户在金融投资领域的应用"><a href="#4-4-行为资产组合理论（BPT）——心理账户在金融投资领域的应用" class="headerlink" title="4.4 行为资产组合理论（BPT）——心理账户在金融投资领域的应用"></a>4.4 行为资产组合理论（BPT）——心理账户在金融投资领域的应用</h3><p>心理账户在金融投资决策领域最广泛的应用是投资组合结构的运用。根据理性投资组合理论，投资者应该只关心他们投资组合的期望收益，而不应该关注某个特定投资部分的收益。可事实相反，投资者倾向于把他们的资金分成安全账户(保障他们的财富水平)和风险账户(试图作风险投机的买卖)。</p><p>1997 年 Fisher 和 Statman 提出:人们在投资时会把 资金分别放在不同的投资账户中，即使是基金公司 也建议投资者建立一个资产投资的金字塔，把现金放在金字塔的最低层，把基金放在中间层，把股票放在金字塔的最高层。2000年，Shefrin和Statman提出了行为资产组合理论（Behavioral portfolio theory，BPT-MA）下图就是一个典型的分层金字塔结构，从底端到顶端是按照其风险程度由低到高排列的，从右到左是按其收入价值由低到高 的顺序排列[14]。模型中的每层是根据安全性、潜力 性和期望值这三者相关的投资需求设计的。底层是 为投资者提供安全性而设计的证券，包括货币市场 基金和银行存款保证，上一层是债券，再上一层是 股票和房地产。<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-12-20 上午10.04.40.png" alt="屏幕快照 2017-12-20 上午10.04.40"></p><p>在行为金融理论中，行为投资组合理论是建立 在卡尼曼和特维尔斯基的前景理论之上的一个框架 体系。它认为投资者的资产结构应该是金字塔式的 分层结构(这里的层就是心理账户)，投资者对其 资产分层进行管理，每一层对应投资者的一个目标。 底层是投资者为避免贫穷而设立的，所以，其投资 对象通常是短期国债、大额可转让存单、货币市场 基金等有稳定收益、风险小的证券;高层是为使其 富有而设立的，其投资对象通常是外国股票、成长 性股票、彩票等高风险、高收益证券。Shefrin 和 Statman 设计了投资者只有一个心理账户和两个心 理账户的行为资产组合模型，并给出了模型的最优 解。当投资者有两个心理账户时，他们分别在低期 望水平和高期望水平两个心理账户建立投资模型， 并在两个账户之间分配资金。</p><p>此外，巴比雷斯和黄明(Barberis and Ming Huang)于 2001 年发表了题为“心理账户、损失规 避与个股回报”的论文，提出了一个较为完整的、 具体的刻画投资者心态的投资模型。并研究了在 两种心理账户下公司股票的均衡回报:一种是投资 者只对所持有的个股价格波动损失规避;另一种是 投资者对所持有的证券组合价格波动损失规避。该 模型在结合心理学、信息学和社会学研究成果的基 础上，对投资者与外部信息之间的互动关系做了崭 新的诠释，对投资者的心态及其决策过程做了具体 的刻画。为人们对投资决策的研究和资产定价的研 究提供了新的思路。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2002年10月9日，瑞典皇家科学院将诺贝尔经济学奖授予普林斯顿大学心理学教授DannielKahneman和乔治·梅森大学经济学教授VernonSmith。根据瑞典皇家科学院的新闻公报，卡尼曼“将心理学的深入分析融入到了经济学中，从而为一个崭新的经济学研究领域奠定了基础”。1981年，DannielKahneman及其合作者AmosTversky在《科学》杂志发表论文，研究人们决策过程的认知心理规律。文章介绍了“演出实验”&lt;/p&gt;
    
    </summary>
    
      <category term="日知录" scheme="http://yoursite.com/categories/%E6%97%A5%E7%9F%A5%E5%BD%95/"/>
    
    
      <category term="卡尼曼" scheme="http://yoursite.com/tags/%E5%8D%A1%E5%B0%BC%E6%9B%BC/"/>
    
      <category term="行为经济学" scheme="http://yoursite.com/tags/%E8%A1%8C%E4%B8%BA%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    
      <category term="心理账户" scheme="http://yoursite.com/tags/%E5%BF%83%E7%90%86%E8%B4%A6%E6%88%B7/"/>
    
      <category term="理查德·萨勒" scheme="http://yoursite.com/tags/%E7%90%86%E6%9F%A5%E5%BE%B7%C2%B7%E8%90%A8%E5%8B%92/"/>
    
  </entry>
  
  <entry>
    <title>自然语言处理系列（4）：Word2Vec</title>
    <link href="http://yoursite.com/2017/12/11/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%B3%BB%E5%88%97%EF%BC%884%EF%BC%89%EF%BC%9AWord2Vec/"/>
    <id>http://yoursite.com/2017/12/11/自然语言处理系列（4）：Word2Vec/</id>
    <published>2017-12-11T15:14:45.000Z</published>
    <updated>2017-12-28T14:38:14.775Z</updated>
    
    <content type="html"><![CDATA[<p>待完成······</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;待完成······&lt;/p&gt;

      
    
    </summary>
    
      <category term="自然语言处理" scheme="http://yoursite.com/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
    
      <category term="Skip-gram" scheme="http://yoursite.com/tags/Skip-gram/"/>
    
      <category term="CBOW" scheme="http://yoursite.com/tags/CBOW/"/>
    
      <category term="word2vec" scheme="http://yoursite.com/tags/word2vec/"/>
    
  </entry>
  
  <entry>
    <title>自然语言处理系列（3）：词向量和语言模型</title>
    <link href="http://yoursite.com/2017/12/10/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%B3%BB%E5%88%97%EF%BC%883%EF%BC%89%EF%BC%9A%E8%AF%8D%E5%90%91%E9%87%8F%E5%92%8C%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2017/12/10/自然语言处理系列（3）：词向量和语言模型/</id>
    <published>2017-12-10T15:14:45.000Z</published>
    <updated>2017-12-28T13:31:57.378Z</updated>
    
    <content type="html"><![CDATA[<p>转载自<a href="http://licstar.net/archives/328#comment-1630" target="_blank" rel="noopener">LICSTAR的博客</a></p><p>这篇博客是我看了半年的论文后，自己对Deep Learnimng在NLP领域中应用的理解和总结，在此分享。其中必然有局限性，欢迎各种交流，随便拍。</p><a id="more"></a><p>Deep Learning算法已经在图像和音频领域取得了惊人的成果，但是在NLP领域中尚未见到如此激动人心的结果。关于这个原因，引一条我比较赞同的微博。</p><blockquote><p>@王威廉：Steve Renals算了以下icassp录取文章题目中包含deep learning 的数量，发现有44偏，而naacl则有0篇。有一种说法是，语言（词、句子、篇章等）属于人类认知过程中产生的高层认知抽象实体，而语言和图像属于较为底层的原始输入信号，所以后两者更适合做deep learning来学习特征。</p></blockquote><p>第一句就先不用管了，毕竟今年的 ACL 已经被灌了好多 Deep Learning 的论文了。第二句我很认同，不过我也有信心以后一定有人能挖掘出语言这种高层次抽象中的本质。不论最后这种方法是不是 Deep Learning，就目前而言，Deep Learning 在 NLP 领域中的研究已经将高深莫测的人类语言撕开了一层神秘的面纱。</p><p>我觉得其中最有趣也是最基本的，就是“词向量”了。</p><p>将词用“词向量”的方式表示可谓是将 Deep Learning 算法引入 NLP 领域的一个核心技术。大多数宣称用了 Deep Learning 的论文，其中往往也用了词向量。</p><h2 id="一、词向量是什么？"><a href="#一、词向量是什么？" class="headerlink" title="一、词向量是什么？"></a>一、词向量是什么？</h2><p>自然语言理解的问题要转化为机器学习的问题，第一步肯定是要找一种方法把这些符号数学化。</p><p>NLP中最直观，也是到目前为止最常用的词表示方法是One-Hot Representation，这种方法把没歌词表示为一个很长的向量，这个向量的维度是词表大小，其中绝大多数元素为0，只有一个维度的值为1，这个维度就代表了当前的词。</p><p>举个例子：</p><p>“话筒”表示为[0 0 0 1 0 0 0  0 0 0 0  0 0 0 0····]<br>“麦克”表示为[0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0·····]<br>每个词都是茫茫0海中的一个1。</p><p>这种One-Hot Representation如果采用稀疏方式存储，会是非常的简介：也就是给每个词分配一个数字ID。比如刚才的例子中，话筒记为3，麦克记为8（假设从0开始记）。如果要编程实现的话，用Hash表给每个词分配一个编号就可以了。这么简洁的表示方式配合上最大熵、SVM、CRF等等算法已经很好地完成了NLP领域的各种主流任务。</p><p>当然这种表示方法也存在一个重要的问题就是“词汇鸿沟”现象：任意两个词之间都是孤立的。光从这俩个向量中看不出两个词是否有关系，哪怕是话筒和麦克这样的同义词也不能幸免于难。</p><p>Deep Learning中一般用到的词向量并不是刚才提到的用One-Hot Representation表示的那种很长很长的词向量，而是用Distrubuted Representation（不知道这个该怎么翻译，因为还存在一种叫“Distributional Representation”的表示方法，又是另一个不同的概念）表示的一种低维实数向量、这种向量一般长这个样子：[0.792,-0.177,-0.107,0.109,-0.542,…]。维度以50维和100维比较常见。这种向量的表示不是唯一的，后文会提到目前计算这种向量的主流方法。</p><p>（个人认为）DIstributed representation最大的贡献是让相关或者相似的词，在距离上更接近了。向量的距离可以用最传统的欧氏距离来衡量，也可以用cos夹角来衡量。用这种方式表示的向量，“麦克”和“话筒”的距离会远远小于“麦克”和“天气”。可能理想情况下“麦克”和“话筒”的表示应该是完全一样的，但是由于有些人会把英文名“迈克”也写成“麦克”，导致“麦克”一词带上了一些人名和语义，因此不会和“话筒”完全一致。</p><h2 id="二、词向量的来历"><a href="#二、词向量的来历" class="headerlink" title="二、词向量的来历"></a>二、词向量的来历</h2><p>Distributed representation最早是Hinton在1986年的论文《Learning distributed representation of concepts》中提出的。虽然这篇文章没有说要将词做Distributed representation，（甚至我很无厘头地猜想那篇文章是为了给他刚提出的BP网络打广告）但至少这种先进的思想在那个时候就在人们的心中埋下了火种，到2000年之后开始逐渐被人重视。</p><p>Distributed representation用来表示词，通常被称为“Word Representation”或“Word Embedding”，中文俗称“词向量”。这的只能叫俗称，算不上翻译。半年前我本想翻译的，但是硬是想不出Embedding应该怎么翻译的，后来就这么叫习惯了，如果有好的翻译欢迎提出。（更新：@南大周志华给出了一个合适的翻译：词嵌入）Embedding一次的意义可以参考维基百科的相应页面。后文提到的所有“词向量”都是指用Distributed Representation表示的词向量。</p><p>如果用传统的稀疏表示法表示词，在解决某些任务的时候（比如构建语言模型）会造成维数灾难[Bengio 2003]。使用低维的词向量就没这样的问题。同时从实践上看，高维的特征如果要套用Deep Learning，其复杂度几乎是难以接受的，因此低维的词向量在这里也饱受追捧。</p><p>同时如上一节提到的，相似词的词向量距离相近，这就让基于词向量设计的一些模型自带平滑功能，让模型看起来非常的漂亮。</p><h2 id="三、词向量的训练"><a href="#三、词向量的训练" class="headerlink" title="三、词向量的训练"></a>三、词向量的训练</h2><p>要介绍词向量是怎么训练的到的，就不得不提到语言模型。到目前为止我了解到的所有训练方法都是在训练语言模型的同时，顺便得到词向量的。</p><p>这也比较容易理解，要从一段无标注的自然文本中学习出一些东西，无非就是统计出词频、词的共现、词的搭配之类的信息。而要从自然文本中统计并建立一个语言模型，无疑是要求最为精确的一个任务（也不排除以后有人创造出更好更有用的方法）。既然构建语言模型这一任务要求这么高，其中必然也需要对语言进行更精细的统计和分析，同时也会需要更好的模型，更大的数据来支撑。目前最好的词向量都来自于此，也就不难理解了。</p><p>这里介绍的工作均为从大量未标注的普通文本数据中无监督地学习出词向量（语言模型本来就是基于这个想法而来的），可以猜测，如果用上了有标注的语料，训练词向量的方法肯定会更多。不过视目前的语料规模，还是使用未标注的方法靠谱一些。</p><p>词向量的训练最经典的有三个工作，C&amp;W 2008、M&amp;H 2008、Mikolov 2010。当然在说这些工作之前，不得不介绍一下这一系列中Bengio的经典之作。</p><h3 id="3-1-语言模型简介"><a href="#3-1-语言模型简介" class="headerlink" title="3.1 语言模型简介"></a>3.1 语言模型简介</h3><p>语言模型其实就是看一句话是不是正常人说出来的。这玩意儿很有用，比如机器翻译、语音识别得到若干候选之后，可以利用语言模型挑一个尽量靠谱的结果。在NLP的其他任务里也都能用到。</p><p>语言模型形式化的描述就是给定一个字符串，看它是自然语言的概率$P(w_1,w_2,···,w_t)$。$w_1$到$w_t$依次表示这句话中的各个词。有个很简单的推论是$P(w_1,w_2,…,w_t)=P(w_1)✖️P(w_2|w_1)✖️P(w_3|w_1,w_2)✖️…✖️P(w_t|w_1,w_2,…w_{t-1})$</p><p>常用的语言模型都是在近似地求$P(w_t|w_1,w_2,···,w_{t-1})$，比如$n-gram$模型就是用$P(w_t|w_{t-n+1},…,w_{t-1})$近似表示前者。</p><p>顺便提一句，由于后面要接受煎熬的每篇论文使用的符号差异太大，本博文尝试统一使用Bengio 2003的符号系统（略作简化），以便在各方法之间做对比和分析。</p><h3 id="3-2-Bengio的经典之作"><a href="#3-2-Bengio的经典之作" class="headerlink" title="3.2 Bengio的经典之作"></a>3.2 Bengio的经典之作</h3><p>用神经网络训练语言模型的思想最早由百度IDL的徐伟于2000提出。其论文《Can Artificial Neural Networks Learn Language Model？》提出一种用神经网络构建二元语言模型（即$P(w_t|w_{t-1})$）的方法。文中的基本思路和后续的语言模型的差别已经不大了。</p><p>训练语言模型的最经典之作，要数Bengio等人在2001年发表在NIPS上的文章《A Neural Probabilistic Language Model》。当然现在要看的话，肯定是要看他在2003年投到JMLR上的同名论文了。</p><p>Bengio用了一个三层的神经网络来构建语言模型，同样也是n-gram模型。如图<img src="http://omu7tit09.bkt.clouddn.com/15118521612179.png" alt=""></p><p>图中最下方的$w_{t-n+1}，…，w_{t-2},w_{t-1}$就是前$n-1$个词。现在需要根据这已知的$n-1$个词预测下一个词$w_t$。$C(w)$表示词$w$所对应的词向量，整个模型中使用的是一套唯一的词向量，存在矩阵$C$(一个$|V|×m$的矩阵)中。其中$|V|$表示词表的大小（语料中的总词数），m表示词向量的维度。$w$到$C(w)$的转化就是从矩阵中取出一行。</p><p>网络的第一层（输入层）是将$C(w_{t-n+1})，…，C(w_{t-2}),C(w_{t-1})$这n-1个向量首尾相拼接起来，形成一个$(n-1)m$维的向量，下面记为x。</p><p>网络的第二层（隐藏层）就如同普通的神经网络，直接使用$d+Hx$计算得到。d是一个偏置项。在此之后，使用tanh作为激活函数。</p><p>网络的第三层（输出层）一共$|V|$个节点，每个节点$y_i$表示下一个词为$i$的未归一化log概率。最后使用softmax激活函数将输出值y归一化成概率。最终，y的计算公式为：</p><script type="math/tex; mode=display">y=b+Wx+Utanh(d+Hx)</script><p>式子中的$U$(一个$V×h$的矩阵)是隐藏层到输出层的参数，整个模型的多数计算集中在U和隐藏层的矩阵乘法中。后文的提到的3个工作，都有对这一环节的简化，提升计算的速度。</p><p>式子中还有一个矩阵$W(|V|×(n-1)m)$,这个矩阵包含了从输入层到输出层的直连边。直连边就是从输入层直接到输出层的一个线性变换，好像也是神经网络中的一种常用技巧。如果不需要直连边的话，将W置为0就可以了。在最后的实验中，Bengio发现直连边虽然不能提升模型效果，但是可以少一半的迭代次数。同时他也猜想如果没有直连边，可能可以生成更好的词向量。</p><p>现在万事俱备，用随机梯度下降法把这个模型优化出来就可以了。需要注意的是，一般神经网络的输入层只是一个输入值，而在这里，输入层x也是参数（存在C中），也是需要优化的。优化结束之后，词向量有了，语言模型也有了。</p><p>这样得到的语言模型自带平滑，无需传统n-gram模型中那些复杂的平滑算法。Bengio在APNews数据集上做的对比试验也表明他的模型效果比精心设计平滑算法的普通n-gram算法要好10%到20%。</p><p>在结束介绍 Bengio 大牛的经典作品之前再插一段八卦。在其 JMLR 论文中的未来工作一段，他提了一个能量函数，把输入向量和输出向量统一考虑，并以最小化能量函数为目标进行优化。后来 M&amp;H 工作就是以此为基础展开的。</p><p>他提到一词多义有待解决，9 年之后 Huang 提出了一种解决方案。他还在论文中随口（不是在 Future Work 中写的）提到：可以使用一些方法降低参数个数，比如用循环神经网络。后来 Mikolov 就顺着这个方向发表了一大堆论文，直到博士毕业。</p><p>大牛就是大牛。</p><h3 id="3-3-C-amp-W的SENNA"><a href="#3-3-C-amp-W的SENNA" class="headerlink" title="3.3 C&amp;W的SENNA"></a>3.3 C&amp;W的SENNA</h3><p>Ronan Collobert 和 Jason Weston 在 2008 年的 ICML 上发表的《A Unified Architecture for Natural Language Processing: Deep Neural Networks with Multitask Learning》里面首次介绍了他们提出的词向量的计算方法。和上一篇牛文类似，如果现在要看的话，应该去看他们在 2011 年投到 JMLR 上的论文《Natural Language Processing (Almost) from Scratch》。文中总结了他们的多项工作，非常有系统性。这篇 JMLR 的论文题目也很霸气啊：从头开始搞 NLP。</p><p>他们还把论文所写的系统开源了，叫做 SENNA（<a href="http://ml.nec-labs.com/senna/" target="_blank" rel="noopener">主页链接</a>），3500 多行纯 C 代码也是写得非常清晰。我就是靠着这份代码才慢慢看懂这篇论文的。可惜的是，代码只有测试部分，没有训练部分。</p><p>实际上 C&amp;W 这篇论文主要目的并不是在于生成一份好的词向量，甚至不想训练语言模型，而是要用这份词向量去完成 NLP 里面的各种任务，比如词性标注、命名实体识别、短语识别、语义角色标注等等。</p><p>由于目的的不同，C&amp;W 的词向量训练方法在我看来也是最特别的。他们没有去近似地求 $P(w_t|w_1,w_2,…,w_{t−1})$，而是直接去尝试近似 $P(w_1,w_2,…,w_t)$。在实际操作中，他们并没有去求一个字符串的概率，而是求窗口连续 n 个词的打分 $f(w_{t−n+1},…,w_{t−1},w_t)$。打分 f 越高的说明这句话越是正常的话；打分低的说明这句话不是太合理；如果是随机把几个词堆积在一起，那肯定是负分（差评）。打分只有相对高低之分，并没有概率的特性。</p><p>有了这个对 f 的假设，C&amp;W 就直接使用 pair-wise 的方法训练词向量。具体的来说，就是最小化下面的目标函数。</p><script type="math/tex; mode=display">∑_{x∈𝔛}∑_{w∈𝔇}max \{0,1−f(x)+f(x^{(w)})\}</script><p>$𝔛$为训练集中的所有连续的n元短语，$𝔇$是整个字典。第一个求和枚举了训练语料中的所有的n元短语，作为正样本。第二个对字典的枚举是构建负样本。$x^{(w)}$是将短语x的最中间的那个词，替换成w。在大多数情况下，在一个正常短语的基础上随便找个词替换掉中间的词，最后得到的短语肯定不是正确的短语，所以这样构造的负样本是非常可用的（多数情况下确实是负样本，极少数情况下把正常短语当做负样本也不影响大局）。同时，由于负样本仅仅是修改了正样本中的一个词，也不会让分类面距离负样本太远而影响分类。再回顾这个式子，x是正样本，$x^{(w)}$是负样本，$f(x)$是对正样本的打分，$f(x^{(w)})$是对负样本的打分。最后希望正样本的打分要比负样本的打分至少高一分。</p><p>$f$函数的结构和Bengio 2003中提到的网络结构基本一致。同样是把窗口中的 nn 个词对应的词向量串成一个长的向量，同样是经过一层网络（乘一个矩阵）得到隐藏层。不同之处在于 C&amp;W 的输出层只有一个节点，表示得分，而不像 Bengio 那样的有 $|V|$个节点。这么做可以大大降低计算复杂度，当然有这种简化还是因为 C&amp;W 并不想做一个真正的语言模型，只是借用语言模型的思想辅助他完成 NLP 的其它任务。（其实 C&amp;W 的方法与 Bengio 的方法还有一个区别，他们为了程序的效率用 HardTanh代替 tanh 激活函数。）</p><p>他们在实验中取窗口大小 n=11，字典大小 |V|=130000，在维基百科英文语料和路透社语料中一共训练了 7 周，终于得到了这份伟大的词向量。</p><p>如前面所说 C&amp;W 训练词向量的动机与其他人不同，因此他公布的词向量与其它词向量相比主要有两个区别：</p><ul><li>1.他的词表中只有小写单词。也就是说他把大写开头的单词和小写单词当作同一个词处理。其它的词向量都是把他们当作不同的词处理的。</li><li>2.他公布的词向量并不直接是上述公式的优化结果，而是在此基础上进一步跑了词性标注、命名实体识别等等一系列任务的 Multi-Task Learning 之后，二次优化得到的。也可以理解为是半监督学习得到的，而非其他方法中纯无监督学习得到的。</li></ul><p>不过好在 Turian 在 2010 年对 C&amp;W 和 M&amp;H 向量做对比时，重新训练了一份词向量放到了网上，那份就没上面的两个“问题”（确切的说应该是差别），也可以用的更放心。后面会详细介绍 Turian 的工作。</p><p>关于这篇论文其实还是有些东西可以吐槽的，不过训练词向量这一块没有，是论文其他部分的。把吐槽机会留给下一篇博文了。</p><h3 id="3-4-M-amp-H-的-HLBL"><a href="#3-4-M-amp-H-的-HLBL" class="headerlink" title="3.4 M&amp;H 的 HLBL"></a>3.4 M&amp;H 的 HLBL</h3><p>Andriy Mnih 和 Geoffrey Hinton 在 2007 年和 2008 年各发表了一篇关于训练语言模型和词向量的文章。2007 年发表在 ICML 上的《Three new graphical models for statistical language modelling》表明了 Hinton 将 Deep Learning 战场扩展到 NLP 领域的决心。2008 年发表在 NIPS 上的《A scalable hierarchical distributed language model》则提出了一种层级的思想替换了 Bengio 2003 方法中最后隐藏层到输出层最花时间的矩阵乘法，在保证效果的基础上，同时也提升了速度。下面简单介绍一下这两篇文章。</p><p>Hinton 在 2006 年提出 Deep Learning 的概念之后，很快就来 NLP 最基础的任务上试了一把。果然，有效。M&amp;H 在 ICML 2007 上发表的这篇文章提出了“Log-Bilinear”语言模型。文章标题中可以看出他们其实一共提了 3 个模型。从最基本的 RBM 出发，一点点修改能量函数，最后得到了“Log-Bilinear”模型。</p><p>模型如果用神经网络的形式写出来，是这个样子：</p><script type="math/tex; mode=display">h = ∑_{i=1}^{t-1}H_iC(w_i)</script><script type="math/tex; mode=display">y_j=C(w_j)^Th</script><p>这里的两个式子可以合写成一个$y_j=∑_{i=1}^{n-1}C(w_j)^TH_iC(w_i)$。$C(w)$是词 w 对应的词向量，形如 $x^TMy$ 的模型叫做 Bilinear 模型，也就是 M&amp;H 方法名字的来历了。</p><p>为了更好地理解模型的含义，还是来看这两个拆解的式子。h 在这里表示隐藏层，这里的隐藏层比前面的所有模型都更厉害，直接有语义信息。首先从第二个式子中隐藏层能和词向量直接做内积可以看出，隐藏层的维度和词向量的维度是一致的（都是 m维）。$H_i$就是一个 $m×m$的矩阵，该矩阵可以理解为第 i个词经过 $H_i$ 这种变换之后，对第 t个词产生的贡献。因此这里的隐藏层是对前 $t−1$个词的总结，也就是说隐藏层 $h$ 是对下一个词的一种预测。</p><p>再看看第二个式子，预测下一个词为 $w_j$ 的 log 概率是 $y_j$，它直接就是 $C(w_j)$和 $h$ 的内积。内积基本上就可以反应相似度，如果各词向量的模基本一致的话，内积的大小能直接反应两个向量的 cos 夹角的大小。这里使用预测词向量 h 和各个已知词的词向量的相似度作为 log 概率，将词向量的作用发挥到了极致。这也是我觉得这次介绍的模型中最漂亮的一个。</p><p>这种“Log-Bilinear”模型看起来每个词需要使用上文所有的词作为输入，于是语料中最长的句子有多长，就会有多少个 H 矩阵。这显然是过于理想化了。最后在实现模型时，还是迫于现实的压力，用了类似 n-gram 的近似，只考虑了上文的 3 到 5 个词作为输入来预测下一个词。</p><p>M&amp;H 的思路如前面提到，是 Bengio 2003 提出的。经过大牛的实现，效果确实不错。虽然复杂度没有数量级上的降低，但是由于是纯线性模型，没有激活函数（当然在做语言模型的时候，最后还是对 $y_j$ 跑了一个 softmax），因此实际的训练和预测速度都会有很大的提升。同时隐藏层到输出层的变量直接用了词向量，这也就几乎少了一半的变量，使得模型更为简洁。最后论文中 M&amp;H 用了和 Bengio 2003 完全一样的数据集做实验，效果有了一定的提升。</p><p>2008 年 NIPS 的这篇论文，介绍的是“hierarchical log-bilinear”模型，很多论文中都把它称作简称“HLBL”。和前作相比，该方法使用了一个层级的结构做最后的预测。可以简单地设想一下把网络的最后一层变成一颗平衡二叉树，二叉树的每个非叶节点用于给预测向量分类，最后到叶节点就可以确定下一个词是哪个了。这在复杂度上有显著的提升，以前是对 $|V|$ 个词一一做比较，最后找出最相似的，现在只需要做 $log_2(|V|)$ 次判断即可。</p><p>这种层级的思想最初可见于 Frederic Morin 和 Yoshua Bengio 于 2005 年发表的论文《Hierarchical probabilistic neural network language model》中。但是这篇论文使用 WordNet 中的 IS-A 关系，转化为二叉树用于分类预测。实验结果发现速度提升了，效果变差了。</p><p>有了前车之鉴，M&amp;H 就希望能从语料中自动学习出一棵树，并能达到比人工构建更好的效果。M&amp;H 使用一种 bootstrapping 的方法来构建这棵树。从随机的树开始，根据分类结果不断调整和迭代。最后得到的是一棵平衡二叉树，并且同一个词的预测可能处于多个不同的叶节点。这种用多个叶节点表示一个词的方法，可以提升下一个词是多义词时候的效果。M&amp;H 做的还不够彻底，后面 Huang 的工作直接对每个词学习出多个词向量，能更好地处理多义词。</p><h3 id="3-5-Mikolov-的-RNNLM"><a href="#3-5-Mikolov-的-RNNLM" class="headerlink" title="3.5 Mikolov 的 RNNLM"></a>3.5 Mikolov 的 RNNLM</h3><p>前文说到，Bengio 2003 论文里提了一句，可以使用一些方法降低参数个数，比如用循环神经网络。Mikolov 就抓住了这个坑，从此与循环神经网络结下了不解之缘。他最早用循环神经网络做语言模型是在 INTERSPEECH 2010 上发表的《Recurrent neural network based language model》里。Recurrent neural network 是循环神经网络，简称 RNN，还有个 Recursive neural networks 是递归神经网络（Richard Socher 借此发了一大堆论文），也简称 RNN。看到的时候需要注意区分一下。不过到目前为止，RNNLM 只表示循环神经网络做的语言模型，还没有歧义。</p><p>在之后的几年中，Mikolov 在一直在RNNLM 上做各种改进，有速度上的，也有准确率上的。现在想了解 RNNLM，看他的博士论文《Statistical Language Models based on Neural Networks》肯定是最好的选择。</p><p>循环神经网络与前面各方法中用到的前馈网络在结构上有比较大的差别，但是原理还是一样的。网络结构大致如图。</p><p>左边是网络的抽象结构，由于循环神经网络多用在时序序列上，因此里面的输入层、隐藏层和输出层都带上了“(t)”。$w(t)$ 是句子中第 t 个词的 One-hot representation 的向量，也就是说 $w$ 是一个非常长的向量，里面只有一个元素是 1。而下面的 $s(t−1)$ 向量就是上一个隐藏层。最后隐藏层计算公式为：</p><script type="math/tex; mode=display">s(t)=sigmoid(Uw(t)+W_s(t−1))</script><p>从右图可以看出循环神经网络是如何展开的。每来一个新词，就和上一个隐藏层联合计算出下一个隐藏层，隐藏层反复利用，一直保留着最新的状态。各隐藏层通过一层传统的前馈网络得到输出值。</p><p>$w(t)$ 是一个词的 One-hot representation，那么 $Uw(t)$ 也就相当于从矩阵 $U $中选出了一列，这一列就是该词对应的词向量。</p><p>循环神经网络的最大优势在于，可以真正充分地利用所有上文信息来预测下一个词，而不像前面的其它工作那样，只能开一个 n 个词的窗口，只用前 n 个词来预测下一个词。从形式上看，这是一个非常“终极”的模型，毕竟语言模型里能用到的信息，他全用上了。可惜的是，循环神经网络形式上非常好看，使用起来却非常难优化，如果优化的不好，长距离的信息就会丢失，甚至还无法达到开窗口看前若干个词的效果。Mikolov 在 RNNLM 里面只使用了最朴素的 BPTT 优化算法，就已经比 n-gram 中的 state of the art 方法有更好的效果，这非常令人欣慰。如果用上了更强的优化算法，最后效果肯定还能提升很多。</p><p>对于最后隐藏层到输出层的巨大计算量，Mikolov 使用了一种分组的方法：根据词频将$|V|$个词分成 $\sqrt{|V|}$组，先通过$\sqrt{|V|}$次判断，看下一个词属于哪个组，再通过若干次判断，找出其属于组内的哪个元素。最后均摊复杂度约为 $o(\sqrt{|V|})$，略差于 M&amp;H 的 $o(log(|V|))$，但是其浅层结构某种程度上可以减少误差传递，也不失为一种良策。</p><p>Mikolov 的 RNNLM 也是开源的（<a href="http://www.fit.vutbr.cz/~imikolov/rnnlm/" target="_blank" rel="noopener">网址</a>）。非常算法风格的代码，几乎所有功能都在一个文件里，工程也很好编译。比较好的是，RNNLM 可以完美支持中文，如果语料存成 UTF-8 格式，就可以直接用了。</p><p>最后吐槽一句，我觉得他在隐藏层用 sigmoid 作为激活函数不够漂亮。因为隐藏层要和输入词联合计算得到下一个隐藏层，如果当前隐藏层的值全是正的，那么输入词对应的参数就会略微偏负，也就是说最后得到的词向量的均值不在 0 附近。总感觉不好看。当然，从实验效果看，是我太强迫症了。</p><h3 id="3-6-Huang的语义强化"><a href="#3-6-Huang的语义强化" class="headerlink" title="3.6 Huang的语义强化"></a>3.6 Huang的语义强化</h3><p>与前几位大牛的工作不同，Eric H. Huang 的工作是在 C&amp;W 的基础上改进而成的，并非自成一派从头做起。他这篇发表在 ACL 2012 上的《Improving Word Representations via Global Context and Multiple Word Prototypes》试图通过对模型的改进，使得词向量富含更丰富的语义信息。他在文中提出了两个主要创新来完成这一目标：（其实从论文标题就能看出来）第一个创新是使用全文信息辅助已有的局部信息，第二个创新是使用多个词向量来表示多义词。下面逐一介绍。</p><p>Huang 认为 C&amp;W 的工作只利用了“局部上下文（Local Context）”。C&amp;W 在训练词向量的时候，只使用了上下文各 5 个词，算上自己总共有 11 个词的信息，这些局部的信息还不能充分挖掘出中间词的语义信息。Huang 直接使用 C&amp;W 的网络结构计算出一个得分，作为“局部得分”。</p><p>然后 Huang 提出了一个“全局信息”，这有点类似传统的词袋子模型。词袋子模型是把文章中所有词的 One-hot Representation 加起来，形成一个向量（就像把词全都扔进一个袋子里），用来表示文章。Huang 的全局模型是将文章中所有词的词向量求个加权平均（权重是词的 idf），作为文章的语义。他把文章的语义向量和当前词的词向量拼接起来，形成一个两倍长度的向量作为输入，之后还是用 C&amp;W 的网络结构算出一个打分。</p><p>有了 C&amp;W 方法的得到的“局部得分”，再加上在 C&amp;W 方法基础上改造得到的“全局得分”，Huang 直接把两个得分相加，作为最终得分。最终得分使用 C&amp;W 提出的 pair-wise 目标函数来优化。</p><p>加了这个全局信息有什么用处呢？Huang 在实验中发现，他的模型能更好地捕捉词的语义信息。比如 C&amp;W 的模型中，与 markets 最相近的词为 firms、industries；而 Huang 的模型得到的结果是 market、firms。很明显，C&amp;W 的方法由于只考虑了临近词的信息，最后的结果是词法特征最相近的词排在了前面（都是复数形式）。不过我觉得这个可能是英语才有的现象，中文没有词形变化，如果在中文中做同样的实验还不知道会有什么效果。</p><p>Huang 论文的第二个贡献是将多义词用多个词向量来表示。Bengio 2003 在最后提过这是一个重要的问题，不过当时他还在想办法解决，现在 Huang 给出了一种思路。</p><p>将每个词的上下文各 5 个词拿出来，对这 10 个词的词向量做加权平均（同样使用 idf 作为权重）。对所有得到的上下文向量做 k-means 聚类，根据聚类结果给每个词打上标签（不同类中的同一个词，当作不同的词处理），最后重新训练词向量。</p><p>当然这个实验的效果也是很不错的，最后 star 的某一个表示最接近的词是 movie、film；另一个表示最接近的词是 galaxy、planet。</p><p>这篇文章还做了一些对比实验，在下一章评价里细讲。</p><h3 id="3-7-总结"><a href="#3-7-总结" class="headerlink" title="3.7 总结"></a>3.7 总结</h3><p>讲完了大牛们的各种方法，自己也忍不住来总结一把。当然，为了方便对比，我先列举一下上面提到的各个系统的现有资源，见下表。对应的论文不在表中列出，可参见最后的参考文献。</p><p>Turian 的工作前面只是提了一下，他在做 C&amp;W 向量与 H&amp;M 向量的对比实验时，自己按照论文重新实现了一遍他们的方法，并公布了词向量。后来 C&amp;W 在主页上强调了一下：尽管很多论文把 Turian 实现的结果叫做 C&amp;W 向量，但是与我发布的词向量是不同的，我这个在更大的语料上训练，还花了两个月时间呢！</p><p>Turian 公布的 H&amp;M 向量是直接请 Andriy Mnih 在 Turian 做好的语料上运行了一下 HLBL，所以没有代码公布。同时 Turian 自己实现了一份 LBL模型，但是没有公布训练出来的词向量。（这是根据他主页上描述推测的结果，从 Turian 的论文中看，他应该是实现了 HLBL 算法并且算出词向量的。）</p><p>RCV1 的词数两篇文章中所写的数据差距较大，还不知道是什么原因。</p><p>Holger Schwenk 在词向量和语言模型方面也做了一些工作，看起来大体相似，也没仔细读过他的论文。有兴趣的读者可以直接搜他的论文。</p><p>事实上，除了 RNNLM 以外，上面其它所有模型在第一层（输入层到隐藏层）都是等价的，都可以看成一个单层网络。可能形式最为特别的是 M&amp;H 的模型，对前面的每个词单独乘以矩阵 HiHi，而不是像其它方法那样把词向量串接起来乘以矩阵 HH。但如果把 HH 看成 HiHi 的拼接： $[H1H2…Ht]$，则会有以下等式：</p><p>这么看来还是等价的。</p><p>所以前面的这么多模型，本质是非常相似的。都是从前若干个词的词向量通过线性变换抽象出一个新的语义（隐藏层），再通过不同的方法来解析这个隐藏层。模型的差别主要就在隐藏层到输出层的语义。Bengio 2003 使用了最朴素的线性变换，直接从隐藏层映射到每个词；C&amp;W 简化了模型（不求语言模型），通过线性变换将隐藏层转换成一个打分；M&amp;H 复用了词向量，进一步强化了语义，并用层级结构加速；Mikolov 则用了分组来加速。</p><p>每种方法真正的差别看起来并不大，当然里面的这些创新，也都是有据可循的。下一章就直接来看看不同模型的效果如何。</p><h2 id="四、词向量的评价"><a href="#四、词向量的评价" class="headerlink" title="四、词向量的评价"></a>四、词向量的评价</h2><p>词向量的评价大体上可以分成两种方式，第一种是把词向量融入现有系统中，看对系统性能的提升；第二种是直接从语言学的角度对词向量进行分析，如相似度、语义偏移等。</p><h3 id="4-1-提升现有系统"><a href="#4-1-提升现有系统" class="headerlink" title="4.1 提升现有系统"></a>4.1 提升现有系统</h3><p>词向量的用法最常见的有两种：</p><ul><li>1）直接用于神经网络模型的输入层。如 C&amp;W 的 SENNA 系统中，将训练好的词向量作为输入，用前馈网络和卷积网络完成了词性标注、语义角色标注等一系列任务。再如 Socher 将词向量作为输入，用递归神经网络完成了句法分析、情感分析等多项任务。</li><li>2）作为辅助特征扩充现有模型。如 Turian 将词向量作为额外的特征加入到接近 state of the art 的方法中，进一步提高了命名实体识别和短语识别的效果。</li></ul><p>具体的用法理论上会在下一篇博文中细讲。</p><p>C&amp;W 的论文中有一些对比实验。实验的结果表明，使用词向量作为初始值替代随机初始值，其效果会有非常显著的提升（如：词性标注准确率从 96.37% 提升到 97.20%；命名实体识别 F 值从 81.47% 提升到 88.67%）。同时使用更大的语料来训练，效果也会有一些提升。</p><p>Turian 发表在 ACL 2010 上的实验对比了 C&amp;W 向量与 M&amp;H 向量用作辅助特征时的效果。在短语识别和命名实体识别两个任务中，C&amp;W 向量的效果都有略微的优势。同时他也发现，如果将这两种向量融合起来，会有更好的效果。除了这两种词向量，Turian 还使用 Brown Cluster 作为辅助特征做了对比，效果最好的其实是 Brown Cluster，不过这个已经超出本文的范围了。</p><h3 id="4-2-语言学评价"><a href="#4-2-语言学评价" class="headerlink" title="4.2 语言学评价"></a>4.2 语言学评价</h3><p>Huang 2012 的论文提出了一些创新，能提升词向量中的语义成分。他也做了一些实验对比了各种词向量的语义特性。实验方法大致就是将词向量的相似度与人工标注的相似度做比较。最后 Huang 的方法语义相似度最好，其次是 C&amp;W 向量，再然后是 Turian 训练的 HLBL 向量与 C&amp;W 向量。这里因为 Turian 训练词向量时使用的数据集（RCV1）与其他的对比实验（Wiki）并不相同，因此并不是非常有可比性。但从这里可以推测一下，可能更大更丰富的语料对于语义的挖掘是有帮助的。</p><p>还有一个有意思的分析是 Mikolov 在 2013 年刚刚发表的一项发现。他发现两个词向量之间的关系，可以直接从这两个向量的差里体现出来。向量的差就是数学上的定义，直接逐位相减。比如 $C(king)−C(queen)≈C(man)−C(woman)$。更强大的是，与 $C(king)−C(man)+C(woman)$最接近的向量就是 $C(queen)$。</p><p>为了分析词向量的这个特点， Mikolov 使用类比（analogy）的方式来评测。如已知 a 之于 b 犹如 c 之于 d。现在给出 a、b、c，看 $C(a)−C(b)+C(c)$最接近的词是否是 d。</p><p>在文章 Mikolov 对比了词法关系（名词单复数 good-better:rough-rougher、动词第三人称单数、形容词比较级最高级等）和语义关系（clothing-shirt:dish-bowl）。</p><p>在词法关系上，RNN 的效果最好，然后是 Turian 实现的 HLBL，最后是 Turian 的 C&amp;W。（RNN-80:19%；RNN-1600:39.6%；HLBL-100:18.7%；C&amp;W-100:5%；-100表示词向量为100维）</p><p>在语义关系上，表现最好的还是 RNN，然后是 Turian 的两个向量，差距没刚才的大。（RNN-80:0.211；C&amp;W-100:0.154；HLBL-100:0.146）</p><p>但是这个对比实验用的训练语料是不同的，也不能特别说明优劣。</p><p>这些实验结果中最容易理解的是：语料越大，词向量就越好。其它的实验由于缺乏严格控制条件进行对比，谈不上哪个更好哪个更差。不过这里的两个语言学分析都非常有意思，尤其是向量之间存在这种线性平移的关系，可能会是词向量发展的一个突破口。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>Yoshua Bengio, Rejean Ducharme, Pascal Vincent, and Christian Jauvin. A neural probabilistic language model. Journal of Machine Learning Research (JMLR), 3:1137–1155, 2003. [PDF]</p><p>Ronan Collobert, Jason Weston, Léon Bottou, Michael Karlen, Koray Kavukcuoglu and Pavel Kuksa. Natural Language Processing (Almost) from Scratch. Journal of Machine Learning Research (JMLR), 12:2493-2537, 2011. [PDF]</p><p>Andriy Mnih &amp; Geoffrey Hinton. Three new graphical models for statistical language modelling. International Conference on Machine Learning (ICML). 2007. [PDF]<br>Andriy Mnih &amp; Geoffrey Hinton. A scalable hierarchical distributed language model. The Conference on Neural Information Processing Systems (NIPS) (pp. 1081–1088). 2008. [PDF]</p><p>Mikolov Tomáš. Statistical Language Models based on Neural Networks. PhD thesis, Brno University of Technology. 2012. [PDF]</p><p>Turian Joseph, Lev Ratinov, and Yoshua Bengio. Word representations: a simple and general method for semi-supervised learning. Proceedings of the 48th Annual Meeting of the Association for Computational Linguistics (ACL). 2010. [PDF]</p><p>Eric Huang, Richard Socher, Christopher Manning and Andrew Ng. Improving word representations via global context and multiple word prototypes. Proceedings of the 50th Annual Meeting of the Association for Computational Linguistics: Long Papers-Volume 1. 2012. [PDF]</p><p>Mikolov, Tomas, Wen-tau Yih, and Geoffrey Zweig. Linguistic regularities in continuous space word representations. Proceedings of NAACL-HLT. 2013. [PDF]</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自&lt;a href=&quot;http://licstar.net/archives/328#comment-1630&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LICSTAR的博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇博客是我看了半年的论文后，自己对Deep Learnimng在NLP领域中应用的理解和总结，在此分享。其中必然有局限性，欢迎各种交流，随便拍。&lt;/p&gt;
    
    </summary>
    
      <category term="自然语言处理" scheme="http://yoursite.com/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
    
      <category term="Skip-gram" scheme="http://yoursite.com/tags/Skip-gram/"/>
    
      <category term="CBOW" scheme="http://yoursite.com/tags/CBOW/"/>
    
      <category term="word2vec" scheme="http://yoursite.com/tags/word2vec/"/>
    
  </entry>
  
  <entry>
    <title>日知录（1）：前景理论</title>
    <link href="http://yoursite.com/2017/12/10/%E6%97%A5%E7%9F%A5%E5%BD%95%EF%BC%881%EF%BC%89%EF%BC%9A%E5%89%8D%E6%99%AF%E7%90%86%E8%AE%BA/"/>
    <id>http://yoursite.com/2017/12/10/日知录（1）：前景理论/</id>
    <published>2017-12-10T15:14:45.000Z</published>
    <updated>2017-12-28T14:37:05.734Z</updated>
    
    <content type="html"><![CDATA[<p>所谓决策，就是在几个方案中选择一个方案，分为风险决策和非风险决策。在非风险决策中，各个方案的结果都是确定的。在风险决策中，有的方案有的结果是不确定的，即可能发生，也可能不发生。我们这里谈及的就是风险决策。</p><a id="more"></a><p>一般来说，风险决策研究有两个途径：</p><ul><li>一个是规范性途径，其基本问题是：人类的风险决策应该遵循怎样的规则？</li><li>一个是描述性途径，其基本问题是：人类的风险决策实际遵循怎样的规则？</li></ul><p>规范性途径往往被叫做决策逻辑学，描述性途径往往被叫做决策行为学或决策心理学。我们这里关注的是描述性途径。</p><p>关于风险决策的最早理论是期望效用理论，它最初只是规范性理论，但经济学家们逐渐把它当做描述性理论来使用——把它作为经济学中对人的决策行为的基本假定，即认为人的实际决策行为遵循期望效应理论，直到上世纪70年代处有的著名经济学家（如Arrow）仍然采取这种做法。</p><p>自1979年以来，Kahneman &amp; Tversky的一系列著作，对期望效用理论作为描述性理论的有效性提出了严峻的挑战，并提出前景理论作为合适的描述理论。由于前景理论能够精确解释、预言许多风险决策行为，它的影响越来越大；后来Kahneman把它应用于经济学领域，对经济学产生了深远的影响，为此，Kahneman于2002年获得了诺贝尔经济学奖。</p><p>这里首先介绍期望效用理论；然后介绍Kahneman等以实验事实对期望效用理论作为描述性理论的批评；最后介绍前景理论的主要内容。</p><h2 id="一、期望效用理论"><a href="#一、期望效用理论" class="headerlink" title="一、期望效用理论"></a>一、期望效用理论</h2><p>期望效用函数理论是20世纪50年代，冯·纽曼和摩根斯坦（von Neumann and Morgenstem）在公理化假设的基础上，运用逻辑和数学工具，建立了不确定条件下对理性人（rational actor）选择进行分析的框架。不过，该理论是将个体与群体合而为一的。后来，阿罗和德布鲁（Arrow and Debreu）将其吸收进瓦尔拉斯均衡的框架中，成为处理不确定决策问题的分析范式，进而构建起现代微观经济学并由此展开的包括宏观、金融、计量等在内的宏伟而又优美的理论大厦。</p><p>期望效用理论本来是作为规范性理论提出的，但后来在许多经济学著作中被应用为描述性理论，直到上个世纪70年代初仍然如此。</p><p>经济学上所使用的期望效用理论包括三方面的内容：Bayes框架；Savage公理；Bernoulli原则。它们分别由不同的人在不同的时期创建。以下分述之。</p><h3 id="1-1-Bayes框架"><a href="#1-1-Bayes框架" class="headerlink" title="1.1 Bayes框架"></a>1.1 Bayes框架</h3><p>早在1662年，Antoine Arnauld就写道：决定一个人必须做什么以获得好处或避免坏处，不仅必须考虑好处和坏处本身，而且必须考虑它发生或不发生的概率。</p><p>大约在100年之后出版的Bayes的遗著（1763）年把这个思想系统化、精确化，形成了所谓的风险决策的Bayes框架，其核心思想可以概括为两点：</p><ol><li>$ED(A_i)=\sum _jP_{ij}·D_{ij}$：即行动$A_i$的估计渴望度（estimated desirability，简称ED；后来改称期望效用，expected utility，EU）等于它的各个可能结果的渴望度$D_{ij}$乘以该可能结果出现的概率所得的积的和；或者说，行动$A_i$的估计渴望度等于它的各个结果的渴望度的加权和，权重为各个结果的概率。（注意，前提是各个可能结果互不相容。）</li><li>根据贝叶斯原则进行选择：选择有着最大估计渴望度的一个方案。</li></ol><p>请注意到Bayes决策框架所包含的两点假设：</p><ul><li>决策权重=概率本身</li><li>渴望度（效用）不依赖于参考点。Bayes决策框架并没有要求以一个参考点来衡量渴望度（效用）；实际上，在经济学中人们往往以财富的最终状态来计算效用。</li></ul><h3 id="1-2-Savage公理"><a href="#1-2-Savage公理" class="headerlink" title="1.2 Savage公理"></a>1.2 Savage公理</h3><p>Bayes决策框架一直沿用下来，并有进一步的发展。</p><p>Von Neumann &amp; Morgenstern（1944）发展出关于偏好（选择）的公理系统；而Ramsey（1931）和Savage（1954）继续发展了该公理系统，用主观概率代替客观概率，从而使概率理论和决策理论可以适用于更广泛的事情。Savage公理系统是这些公理系统中最为成熟的。其中的公理有：</p><ul><li>不变性公理（Invariance Axiom）：方案间的偏好顺序不依赖于方案的描述方式。</li><li>优势性公理（Dominance Axiom）：如果方案A在每个方面至少跟方案B一样好，而在至少一个方面比B更好，那么A应该比B更可取。</li><li>如果方案B由于方案A，那么它们与任一概率$p≠0$的结合所得的$(B,p)$一定优于$(A,p)$</li></ul><p>这些公理与直觉十分一致；也与Bayes决策框架完全一致。</p><h3 id="1-3-Bernoulli原则"><a href="#1-3-Bernoulli原则" class="headerlink" title="1.3 Bernoulli原则"></a>1.3 Bernoulli原则</h3><p>很早以前Bernoulli就指出人们通常是风险回避的。一个决策是风险回避的，是指：按照结果的表面值（如金额）计算，在确定的结果与有着相等或更高的期望值的不确定的结果之间，决策者选择了确定的结果，如，A. 确定得到80元；B.81%的可能得到100元，按结果的表面值计算，B的期望值高于A，按理应该选择B，但事实上大多数人们会选择A。</p><p>为了解释这个现象，Bernoulli提出：人们评价方案，不是用方案的金钱结果值，而是用这些金钱结果值的主观价值，而这个主观价值对于金钱值的函数曲线（效用曲线）是一条凹形的曲线，即$u’’(x)&lt;0$。通俗地说，随着x的不断增大，u的增长越来越慢。用这个原理能轻易解释上段提及的现象。假设80元的主观价值是72，由此可以推出100元的主观价值应该小于90（因为前面80元中每20元的主观价值是18，根据u增长越来越慢的原理，100元超出80元的那20元的主观价值应该小于18，因而100元的主观价值小于90），假设是85.于是，A方案的期望值是72，而B的期望值是$85*81%=68.85$。所以大多数人们选择了A方案。</p><p>于是，风险回避和$u’’(x)&lt;0$也成了一些经济学著作对人的决策行为的假定之一。</p><h3 id="1-4-小结与问题"><a href="#1-4-小结与问题" class="headerlink" title="1.4 小结与问题"></a>1.4 小结与问题</h3><p>经济学理论中常常把期望效用理论的上述Bayes框架，Savage公理和Bernoulli原则中的全部或部分作为对人的风险决策行为的基本假定，在此假定和其他假定的基础上构建经济学理论。</p><p>这种做法有明显的方法论问题：这些经验假定（经验命题）的真假并没有经过经验方法的系统判明。逻辑学家们提出Bayes框架，Savage公理的初衷是：高斯人们应该怎样决策，或者说怎样决策才是合乎理性的；他们并未考察人们的决策行为是否恰好符合这些规则。而Bernoulli原则知识根据某类风险决策事实归纳得出；并未建立在对各种类型的风险决策事实的全面考察上。人们的实际决策行为是否遵循上述规则，显然是个经验命题；而一个经验命题只有通过经验的方法才能判明它的真伪。而经济学家们，未经经验方法的判定，就把上述规则当做经验命题来使用，这种做法就存在方法论上的问题。</p><p>这种方法论上的问题使得采用期望效用理论作为描述性理论可能是错误的。而Kahneman &amp; Tversky的一系列实验表明：采用期望效用理论作为描述性理论确实是错误的。</p><h2 id="二、对期望效用理论的实验挑战"><a href="#二、对期望效用理论的实验挑战" class="headerlink" title="二、对期望效用理论的实验挑战"></a>二、对期望效用理论的实验挑战</h2><p>Kahneman &amp; Tversky的一系列实验对期望效用理论作为描述理论的有效性提出了挑战。下面是他们的部分实验。</p><h3 id="2-1-实验一"><a href="#2-1-实验一" class="headerlink" title="2.1 实验一"></a>2.1 实验一</h3><blockquote><p>期望效用理论的“决策权重=概率”成立吗？</p><p>问题一：<br>请选择：</p></blockquote><ul><li>A. 有80%的可能性得到4000元； 【20%】</li><li>B. 确定地得到3000元。【80%】</li></ul><p>方括号指的是该项被试的百分比，以下皆同。</p><blockquote><p>问题二：</p></blockquote><p>请选择：</p><ul><li>C. 有20%的可能性得到4000元；【65%】</li><li>D. 有25%的可能性得到3000元。【35%】</li></ul><blockquote><p>分析：</p></blockquote><p>如前1.1 所述，期望效用理论中，决策权重=概率。假设这点成立，那么有：</p><script type="math/tex; mode=display">U(A)=0.80*u(4000);</script><script type="math/tex; mode=display">U(B)=u(3000)</script><script type="math/tex; mode=display">U(C)=0.2*u(4000)</script><script type="math/tex; mode=display">U(D)=0.25*u(3000)</script><p>注意到$U(A),U(B)$分别乘以0.25就相应得到$U(C),U(D)$，所以有：<br>如果$U(A)<u(b)$，那么$u(c)<u(d)$；如果$u(a)>U(B)$，那么$U(C)&gt;U(D)$。即A、B之间的偏好顺序应该和C、D之间的偏好顺序相同。</u(b)$，那么$u(c)<u(d)$；如果$u(a)></p><p>但上述实验结果却是：虽然在A、B之间大部分偏好B；但在C、D之间大部分偏好C。即在集体水平上被试的偏好发生了逆转。另外，根据Kahneman &amp; Tversky的实验报告，在个体水平上，超过半数的被试的偏好也发生了逆转。</p><p>实验结果与假设推论相矛盾。可见，期望效用理论中的“决策权重=概率”这一假定并不符合人的真实的决策行为。</p><p>另外，由于C就是25%概率的A，D就是25% 的B，按照期望效用理论的替代性公理，A、B之间的偏好关系，与C、D之间的偏好关系相同，实验结果却是偏好发生了逆转。可见，期望效用理论的替代性公理在人们的实际行为中也不成立。</p><h3 id="2-2-实验二"><a href="#2-2-实验二" class="headerlink" title="2.2 实验二"></a>2.2 实验二</h3><blockquote><p>期望效用理论的不变性公理成立吗?</p></blockquote><p>下面是许多人都熟知的一个实验，但也许并非大家都知道其理论蕴涵。</p><blockquote><p>问题一：想象有一场流行病，预计将杀死600人。有两个预防方案，你希望哪个方案被征服采纳？</p></blockquote><ul><li>如果A方案被采纳，200人将被挽救； 【72%】</li><li>如果B方案被采纳，有 1/3 的可能性 600 人都被挽救，有 2/3 的可能性没有人能得到挽救。  【28%】</li></ul><blockquote><p>问题二：</p></blockquote><ul><li>如果方案 C 被采纳，400 人将死亡;  【22%】</li><li>如果方案 D 被采纳，有 1/3 的可能性没有人死亡并且有 2/3 的可能性 600 人都会死亡。  【78%】</li></ul><blockquote><p>分析</p></blockquote><p>期望效用理论的不变性公理认为:人们的选择不因描述方式不同而改变。 假设这点成立，那么，因为方案 A 等价于方案 C，而 B 等价于 D，所以 A,B 之间的偏好顺序与 C,D 之间的偏 好顺序应该是一样的。但事实上它们是相反的。假设有误。这说明人的决策行为并不遵循期望效用理论的不变性公理。</p><p>另外，上述偏好逆转发生的原因在于:在问题 1 中，被试被诱导把 600 人都会死作为参 考点，从而把问题表征为确定的 200 人被挽救与 1/3 可能的 600 人被挽救之比较;而在问题 2 中，被试被诱导把 0 人死亡作为参考点，从而把问题表征为确定的 400 人死亡与 2/3 可能 的 600 人死亡。问题表征上的这种不同进而导致了决策上的不同。由此我们看到:决策中， 人们并非以财富数值或生命个数的最终状态来计算主观价值，而是根据财富数值或生命个数 相对于参考点的值来计算主观价值。这也违反了期望效用理论。</p><h3 id="2-3-实验三"><a href="#2-3-实验三" class="headerlink" title="2.3 实验三"></a>2.3 实验三</h3><blockquote><p>期望效用理论的优势性公理成立吗?</p><p>问题一：<br>请选择</p></blockquote><ul><li>E.有25%的机会获得240元并有75%的机会失去760元； 【0%】</li><li>F. 有 25%的机会获得 250 元并有 75%的机会失去 750 元 。【100%】</li></ul><blockquote><p>问题二:</p></blockquote><p>假想你面临两组选择。请先仔细阅读两组选择，然后作出选择:</p><p>第一组选择：</p><ul><li>A. 固定得到 240 元【84%】</li><li>B. 25%的机会得到 1000 元，75%的机会得到 0 元。【16%】</li></ul><p>第二组选择：</p><ul><li>C.固定失去 750 元；【13%】</li><li>D.75%的机会失去 1000 元，25%的机会失去 0 元 【87%】</li></ul><blockquote><p>分析:</p></blockquote><p>期望效用理论的优势性公理认为:如果方案 A 在每个方面至少跟方案 B 一样好，而在至少一个方面比 B 更好，那么 A 应该比 B 更可取。假设这点成立，那么，由于 A 优于 B, D 优于 C，那么，A+D 应该优于 B+C;而注意到 A+D=E， B+C=F;所 以，E 应该优于 F。但事实相反，所有的被试都认为 F 优于 E。可见，人们的决策行为并不 遵循期望效用理论的优势性公理。</p><h3 id="2-4-实验四"><a href="#2-4-实验四" class="headerlink" title="2.4 实验四"></a>2.4 实验四</h3><blockquote><p>期望效用理论的“风险回避”原则总是成立吗?</p><p>问题一:</p></blockquote><p>请选择:</p><ul><li>A. 确定得到 1 元;</li><li>B. 1%的可能性得到 100 元，99%的可能性得到 0 元。 </li></ul><p>人们大多会选择 B.</p><blockquote><p>问题二：</p></blockquote><ul><li>C.确定失去 90 元;</li><li>D.有 90%的可能性失去 100 元，有 10%的可能性失去 0 元。</li></ul><p>人们大多会选择 D.</p><blockquote><p>分析</p></blockquote><p>经济学家所用的期望效用理论的“风险回避”原则认为:在按表面结果 值计算有着相等期望值的风险选项与确定选项之间，人们往往会选择确定项而回避风险项。但在上面这些决策问题上，大多数人们风险寻求，而非风险回避。可见期望效用理论的 “风险回避”原则在人们的实际决策行为中并不总是成立。</p><p>事实上，Kahneman 和 Tversky 的研究发现人们的风险态度有如下的模式:</p><div class="table-container"><table><thead><tr><th></th><th>中、大概率</th><th>小概率</th></tr></thead><tbody><tr><td>得</td><td>风险回避</td><td>风险寻求</td></tr><tr><td>失</td><td>风险寻求</td><td>风险回避</td></tr></tbody></table></div><h2 id="三、Kahneman和Tversky的前景理论"><a href="#三、Kahneman和Tversky的前景理论" class="headerlink" title="三、Kahneman和Tversky的前景理论"></a>三、Kahneman和Tversky的前景理论</h2><p>上述实验事实表明：人们的风险决策行为系统地偏离了期望效用理论。那么人们的风险决策行为究竟遵循怎样的规律呢？Kahneman和Tversky提出了前景理论（prospect theory）作为上述问题的答案。</p><p>前景理论的核心内容是：价值函数（曲线）与权重函数（曲线）。</p><h3 id="3-1-价值函数（曲线）"><a href="#3-1-价值函数（曲线）" class="headerlink" title="3.1 价值函数（曲线）"></a>3.1 价值函数（曲线）</h3><p>价值函数把表面价值如金额转化为决策价值，其具体形式是：</p><script type="math/tex; mode=display">v\left(x\right)=\left\{\begin{array}{l}    x^a \ (x>0)\\    -\lambda\left(-x\right)^{\beta}\ (x<0)\\end{array}\right.</script><p>其中x是表面价值如金额的得失，得为正，失为负；v为决策价值。在Kahneman &amp; Tversky的一个研究中，被试者们的中位参数$\alpha = \beta =0.88;\gamma = 2.25$；其他研究者也得到了相近的数值。</p><p>其曲线如下图所示：<br><img src="http://omu7tit09.bkt.clouddn.com/15135751972602.jpg" alt=""></p><p>它有如下特点：</p><ul><li>其定义域不是财富，而是财富的变化、得失，即财富相对于某个参考点的差距，这个参考点往往是当前的财富状态。</li><li>整个函数是个递增函数；$v(0) = 0$</li><li>在得（Gains）的区域呈凹形，在失（LOSSES）的区域呈凸形（即当$x&gt;0$时，$v’’(x)<0$;当$x<0$时，$v''(x)>0$）。用通俗的话来说就是，随着$|x|$的不断增大，$v$的变化越来越小。例如，从0元到10元所引起的价值上的变化，要大于从100元到110元所引起的价值上的变化。</0$;当$x<0$时，$v''(x)></li><li>在失的区域的曲线比在得的区域的曲线更加陡峭。通俗地说，失去100元所带来的痛苦的程度要大于100元所带来的快乐的程度。</li></ul><h3 id="3-2-权重函数（曲线）"><a href="#3-2-权重函数（曲线）" class="headerlink" title="3.2 权重函数（曲线）"></a>3.2 权重函数（曲线）</h3><p>权重函数把概率转化为决策权重。当风险前景为两个结果时，其具体的形式如下：<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-12-18 下午1.42.45.png" alt="屏幕快照 2017-12-18 下午1.42.45">    其中，p为概率，$w^+(p)$为得到时的决策权重，$w^-(p)$为失去时的决策权重。在Kahneman的一个实验中，求得被试们的中位参数$\lambda = 0.61,\delta =0.69$。其他研究者也得到相近的结果。</p><p>其曲线如下图所示：<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-12-18 下午1.50.18.png" alt="屏幕快照 2017-12-18 下午1.50.18"></p><ul><li>其中的$w^+$为得到时的权重，$w^-$为失去时的权重。当概率较小时，同等概率下，$w^+$大于$w^-$；当概率中等或较大时，同等概率下，$w^+$小于$w^-$</li></ul><p>无论$w^+$还是$w^-$都有以下特点：</p><ul><li>$w(0)=0$；$w(1)=1$；$w$是$p$的递增函数。</li><li>给予小概率以过高的权重（注意，并非高估小概率，因为被试清除地直到概率是多少；只是小概率所对应的权重高于高于概率本身）</li><li>给予中、高概率以较小的权重，即低于概率自身的权重。</li><li>次确定性：$w(p)+w(1-p)&lt;1$，其中$0&lt;p&lt;1$</li><li>次比例性：$\frac{w(pq)}{w(p)}≤\frac{w(pqr)}{w(pr)}$</li><li>次可加性，包括：<ul><li>下端次可加性：$w(p+q)≤w(p)+w(q)$，其中$p+q&lt;1$</li><li>上端次可加性：$w(1)-w(1-p)≥w(p+q)-w(q)$，其中$p≠0$</li></ul></li></ul><p>计算各个前景的价值，比较并作出选择。应用$v(x)$函数和$w(p)$函数，就能求出各个结果的$v$值和$w$值；把这些$v$值和$w$值代入$V$公式，就能求出各个前景的V值：</p><script type="math/tex; mode=display">V=\sum^n_{i=-m}w_iv(x_i)</script><p>其中V为一个前景的心理价值；$w_i$和$v(x_i)$分别是第i个结果的决策权重和决策价值；结果分得失即正负，所以结果的下标也分正负。然后比较各个前景的V值，选出最高V值的前景</p><p>以上就是前景理论所描述的人们的决策行为规律。</p><p>用上述规律，不仅能够轻易而一致地解释前面提到的各种违背期望效用理论的实验现象；还能很好地解释和预言大量的其他实验现象。Kahneman后来把这个理论应用于经济学领域，对经济学的微观基础产生了巨大的影响，为此，Kahneman获得了2002年的诺贝尔经济学奖。</p><h2 id="四、通俗解释"><a href="#四、通俗解释" class="headerlink" title="四、通俗解释"></a>四、通俗解释</h2><p>在《赌客信条》一书中，作者孙惟微将前景理论归纳为5句话：</p><ul><li>“二鸟在林，不如一鸟在手”，在确定的收益和“赌一把”之间，多数人会选择确定的好处。所谓“见好就收，落袋为安。称之为“确定效应”。</li><li>在确定的损失和“赌一把”之间，做一个抉择，多数人会选择“赌一把”。称之为“反射效应”。</li><li>白捡的100元所带来的快乐，难以抵消丢失100元所带来的痛苦。称之为“损失规避”。</li><li>很多人都买过彩票，虽然赢钱可能微乎其微，你的钱99.99%的可能支持福利事业和体育事业了，可还是有人心存侥幸搏小概率事件。称之为“迷恋小概率事件”。</li><li>多数人对得失的判断往往根据参照点决定，举例来说，在“其他人一年挣6万元你年收入7万元”和“其他人年收入为9万元你一年收入8万”的选择题中，大部分人会选择前者。称之为“参照依赖”。</li></ul><h3 id="4-1-确定效用"><a href="#4-1-确定效用" class="headerlink" title="4.1 确定效用"></a>4.1 确定效用</h3><p>所谓确定效应（certainty effect），就是在确定的好处（收益）和“赌一把”之间，做一个抉择，多数人会选择确定的好处。用一个词形容就是“见好就收”，用一句话打比方就是“二鸟在林，不如一鸟在手”，正所谓落袋为安。</p><p>让我们来做这样一个实验。</p><ul><li>A.你一定能赚30000元。</li><li>B.你有80%可能赚40000元，20%可能性什么也得不到。<br>你会选择哪一个呢？实验结果是，大部分人都选择A。</li></ul><p>传统经济学中的“理性人”这时会跳出来批判：选择A是错的，因为40000×80%=32000，期望值要大于30000。这个实验结果是对“原理1”的印证：大多数人处于收益状态时，往往小心翼翼、厌恶风险、喜欢见好就收，害怕失去已有的利润。卡尼曼和特韦斯基称为“确定效应”（certainty effect），即处于收益状态时，大部分人都是风险厌恶者。</p><p>“确定效应”表现在投资上就是投资者有强烈的获利了结倾向，喜欢将正在赚钱的股票卖出。投资时，多数人的表现是“赔则拖，赢必走”。在股市中，普遍有一种“卖出效应”，也就是投资者卖出获利的股票的意向，要远远大于卖出亏损股票的意向。这与“对则持，错即改”的投资核心理念背道而驰。</p><h3 id="4-2-反射效应"><a href="#4-2-反射效应" class="headerlink" title="4.2 反射效应"></a>4.2 反射效应</h3><p>面对两种损害，你是会选择躲避呢，还是勇往直前？当一个人在面对两种都损失的抉择时，会激起他的冒险精神。在确定的坏处（损失）和“赌一把”之间，做一个抉择，多数人会选择“赌一把”，这叫“反射效应”。用一句话概括就是“两害相权取其轻”。</p><p>让我们来做这样一个实验。</p><ul><li>A.你一定会赔30000元。</li><li>B.你有80%可能赔40000元，20%可能不赔钱。</li></ul><p>你会选择哪一个呢？投票结果是，只有少数人情愿“花钱消灾”选择A，大部分人愿意和命运抗一抗，选择B。</p><p>传统经济学中的“理性人”会跳出来说，两害相权取其轻，所以选B是错的，因为（-40000）×80%=-32000，风险要大于-30000元。现实是，多数人处于亏损状态时，会极不甘心，宁愿承受更大的风险来赌一把。也就是说，处于损失预期时，大多数人变得甘冒风险。卡尼曼和特韦斯基称为“反射效应”（reflectioneffect）。</p><p>“反射效应”是非理性的，表现在股市上就是喜欢将赔钱的股票继续持有下去。统计数据证实，投资者持有亏损股票的时间远长于持有获利股票。投资者长期持有的股票多数是不愿意“割肉”而留下的“套牢”股票。</p><h3 id="4-3-损失规避"><a href="#4-3-损失规避" class="headerlink" title="4.3 损失规避"></a>4.3 损失规避</h3><p>如何理解“损失规避”？用一句话打比方，就是“白捡的100元所带来的快乐，难以抵消丢失100元所带来的痛苦”。前景理论最重要也是最有用的发现之一是：当我们做有关收益和有关损失的决策时表现出的不对称性。对此，就连传统经济学的坚定捍卫者 保罗·萨缪尔森，也不得不承认：“增加100元收入所带来的效用，小于失去100元所带来的效用。”</p><p>这其实是前景理论的第3个原理，即“损失规避”（loss aversion）：大多数人对损失和获得的敏感程度不对称，面对损失的痛苦感要大大超过面对获得的快乐感。</p><p>行为经济学家通过一个赌局验证了这一论断。</p><p>假设有这样一个赌博游戏，投一枚均匀的硬币，正面为赢，反面为输。如果赢了可以获得50000元，输了失去50000元。请问你是否愿意赌一把？请做出你的选择。</p><ul><li>A.愿意</li><li>B.不愿意</li></ul><p>从整体上来说，这个赌局输赢的可能性相同，就是说这个游戏的结果期望值为零，是绝对公平的赌局。你会选择参与这个赌局吗？但大量类似实验的结果证明，多数人不愿意玩这个游戏。为什么人们会做出这样的选择呢？这个现象同样可以用损失规避效应解释，虽然出现正反面的概率是相同的，但是人们对“失”比对“得”敏感。想到可能会输掉50000元，这种不舒服的程度超过了想到有同样可能赢来50000元的快乐。由于人们对损失要比对相同数量的收益敏感得多，因此即使股票账户有涨有跌，人们也会更加频繁地为每日的损失而痛苦，最终将股票抛掉。一般人因为这种“损失规避”（loss aversion），会放弃本可以获利的投资。</p><h3 id="4-4-迷恋小概率事件"><a href="#4-4-迷恋小概率事件" class="headerlink" title="4.4 迷恋小概率事件"></a>4.4 迷恋小概率事件</h3><p>买彩票是赌自己会走运，买保险是赌自己会倒霉。这是两种很少发生的事件，但人们却十分热衷。前景理论还揭示了一个奇特现象，即人类具有强调小概率事件的倾向。</p><p>何谓小概率事件？就是几乎不可能发生的事件。如天上掉馅饼，这就是个小概率事件。掉的是馅饼固然好，但如果掉下来的不是馅饼而是陷阱呢？当然也属于小概率事件。</p><p>面对小概率的赢利，多数人是风险喜好者。面对小概率的损失，多数人是风险厌恶者。<br>事实上，很多人都买过彩票，虽然赢钱可能微乎其微，你的钱99.99%的可能支持福利事业和体育事业了，可还是有人心存侥幸搏小概率事件。</p><p>同时，很多人都买过保险，虽然倒霉的概率非常小，可还是想规避这个风险。人们的这种倾向，是保险公司经营下去的心理学基础。</p><p>在小概率事件面前人类对风险的态度是矛盾的，一个人可以是风险喜好者，同时又是风险厌恶者。传统经济学无法解释这个现象。</p><p>小概率事件的另一个名字叫运气。侥幸，就是企求好运，邀天之幸。孔子很反感这种事，他说：“小人行险以侥幸。”庄子认为孔子是个“灯下黑”，他借盗跖之口评价孔子：“妄作孝弟，而侥幸于封侯富贵者也。”对小概率事件的迷恋，连圣人也不能免俗。</p><p>前景理论指出，在风险和收益面前，人的“心是偏的”。在涉及收益时，我们是风险的厌恶者，但涉及损失时，我们却是风险喜好者。但涉及小概率事件时，风险偏好又会发生离奇的转变。所以，人们并不是风险厌恶者，他们在他们认为合适的情况下非常乐意赌一把。归根结底，人们真正憎恨的是损失，而不是风险。</p><p>这种损失厌恶而不是风险厌恶的情形，在股市中常常见到。比如，我们持有一只股票，在高点没有抛出，然后一路下跌，进入了彻彻底底的下降通道，这时的明智之举应是抛出该股票，而交易费用与预期的损失相比，是微不足道的。</p><p>扪心自问，如果现在持有现金，还会不会买这只股票？你很可能不会再买吧，那为什么不能卖掉它买别的更好的股票呢？也许，卖了它后损失就成了“事实”吧。</p><h3 id="4-5-参照依赖"><a href="#4-5-参照依赖" class="headerlink" title="4.5 参照依赖"></a>4.5 参照依赖</h3><p>假设你面对这样一个选择：在商品和服务价格相同的情况下，你有两种选择：</p><ul><li>A.其他同事一年挣6万元的情况下，你的年收入7万元。</li><li>B.其他同事年收入为9万元的情况下，你一年有8万元进账。</li></ul><p>卡尼曼的这调查结果出人意料：大部分人选择了前者。事实上，我们拼命赚钱的动力，多是来自同侪间的嫉妒和攀比。我们对得与失的判断，是来自比较。嫉妒总是来自自我与别人的比较，培根曾言：皇帝通常不会被人嫉妒，除非对方也是皇帝。对此，美国作家门肯早有妙论：“只要比你小姨子的丈夫（连襟）一年多赚1000块，你就算是有钱人了。”</p><p>传统经济学认为金钱的效用是绝对的，行为经济学则告诉我们，金钱的效用是相对的。这就是财富与幸福之间的悖论。到底什么是“得”，什么是“失”呢？你今年收入20万元，该高兴还是失落呢？假如你的奋斗目标是10万元，你也许会感到愉快；假如目标是100万元，你会不会有点失落呢？所谓的损失和获得，一定是相对于参照点而言的。卡尼曼称为“参照依赖”（Reference Dependence）。</p><p>老张最幸福的时候是他在20世纪80年代做“万元户”的时候，虽然现在自己的村镇已经改造成了城市，拆迁补贴也让自己成为了“百万元户”，但他感觉没有当年兴奋，因为邻里都是“百万元户”了。</p><p>讲这个故事的用意不难明白，我们就不再进行烦琐的论证了 得与失都是比较出来的结果。传统经济学的偏好理论（Preference theory）假设，人的选择与参照点无关。行为经济学则证实，人们的偏好会受到单独评判、联合评判、交替对比及语意效应等因素的影响。</p><p>参照依赖理论：多数人对得失的判断往往根据参照点决定。一般人对一个决策结果的评价，是通过计算该结果相对于某一参照点的变化而完成的。人们看的不是最终的结果，而是看最终结果与参照点之间的差额。一样东西可以说成是“得”，也可以说成是“失”，这取决于参照点的不同。非理性的得失感受会对我们的决策产生影响。</p><p>综上，前景理论引申出五个基本结论</p><ul><li>确定效应：处于收益状态时，多数人是风险厌恶者。</li><li>反射效应：处于损失状态时，多数人是风险喜好者。</li><li>迷恋小概率事件：面对小概率的赢利，多数人是风险喜好者；面对小概率的损失，多数人是风险厌恶者。</li><li>损失规避：多数人对损失比对收益敏感。</li><li>参照依赖：多数人对得失的判断往往由参照点决定。</li></ul><p>简言之，人在面临获利时，不愿冒风险；而在面临损失时，人人都成了冒险家。而损失和获利是相对于参照点而言的，改变评价事物时的参照点，就会改变对风险的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;所谓决策，就是在几个方案中选择一个方案，分为风险决策和非风险决策。在非风险决策中，各个方案的结果都是确定的。在风险决策中，有的方案有的结果是不确定的，即可能发生，也可能不发生。我们这里谈及的就是风险决策。&lt;/p&gt;
    
    </summary>
    
      <category term="日知录" scheme="http://yoursite.com/categories/%E6%97%A5%E7%9F%A5%E5%BD%95/"/>
    
    
      <category term="前景理论" scheme="http://yoursite.com/tags/%E5%89%8D%E6%99%AF%E7%90%86%E8%AE%BA/"/>
    
      <category term="卡尼曼" scheme="http://yoursite.com/tags/%E5%8D%A1%E5%B0%BC%E6%9B%BC/"/>
    
      <category term="行为经济学" scheme="http://yoursite.com/tags/%E8%A1%8C%E4%B8%BA%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>自然语言处理系列（2）：中文Wiki语料库词向量的训练</title>
    <link href="http://yoursite.com/2017/12/09/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%B3%BB%E5%88%97%EF%BC%882%EF%BC%89%EF%BC%9A%E4%B8%AD%E6%96%87Wiki%E8%AF%AD%E6%96%99%E5%BA%93%E8%AF%8D%E5%90%91%E9%87%8F%E7%9A%84%E8%AE%AD%E7%BB%83/"/>
    <id>http://yoursite.com/2017/12/09/自然语言处理系列（2）：中文Wiki语料库词向量的训练/</id>
    <published>2017-12-09T15:14:45.000Z</published>
    <updated>2017-12-26T08:59:57.999Z</updated>
    
    <content type="html"><![CDATA[<p>要通过计算机进行自然语言处理，首先就需要将这些文本数字化，目前用的最广泛的方法是词向量，根据训练使用算法的不同，目前主要有Word2Vec和GloVe两大方法，本文主要讲述通过这两个方法分别训练中文维基百科语料库的词向量。</p><a id="more"></a><h2 id="一、获取并处理中文维基百科语料库"><a href="#一、获取并处理中文维基百科语料库" class="headerlink" title="一、获取并处理中文维基百科语料库"></a>一、获取并处理中文维基百科语料库</h2><h3 id="1-1-下载"><a href="#1-1-下载" class="headerlink" title="1.1 下载"></a>1.1 下载</h3><p>中文维基百科语料库的下载链接为：<a href="https://dumps.wikimedia.org/zhwiki/" target="_blank" rel="noopener">https://dumps.wikimedia.org/zhwiki/</a>，本试验下载的是最新的<a href="https://dumps.wikimedia.org/zhwiki/latest/zhwiki-latest-pages-articles.xml.bz2" target="_blank" rel="noopener">zhwiki-latest-pages-articles.xml.bz2</a>。这个压缩包里面存的是标题、正文部分，该目录下还包括了其他类型的语料库，如仅包含标题，摘要等。</p><h3 id="1-2-抽取内容"><a href="#1-2-抽取内容" class="headerlink" title="1.2 抽取内容"></a>1.2 抽取内容</h3><p>Wikipedia Extractor是一个开源的用于抽取维基百科语料库的工具，由python携程，通过这个工具可以很容易地从语料库中抽取相关内容。使用方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git clone https://github.com/attardi/wikiextractor.git wikiextractor</div><div class="line">$ wikiextractor/WikiExtractor.py  -b 2000M -o zhwiki_extracted zhwiki-latest-pages-articles.xml.bz2</div></pre></td></tr></table></figure><p>由于这个工具就是一个python脚本，因此无需安装，<code>-b</code>参数指对提取出来的内容进行切片后每个文件的大小，如果要将所有内容保存在同一个文件，那么就需要把这个参数设置地大一点，<code>-o</code>的参数指提取出来的文件放置的目录，抽取出来的文件的路径为<code>zhwiki_extract/AA/wiki_00</code>。更多的参数可参考其github主页的说明。</p><p>抽取后的内容格式为每篇文章被一对<code>&lt;doc&gt;&lt;/doc&gt;</code>包起来，而<code>&lt;doc&gt;</code>中的包含了属性有文章的id、url和title属性，如<code>&lt;doc id=&quot;13&quot; url=&quot;https://zh.wikipedia.org/wiki?curid=13&quot; title=&quot;数学&quot;&gt;</code></p><h3 id="1-3-繁简转换"><a href="#1-3-繁简转换" class="headerlink" title="1.3 繁简转换"></a>1.3 繁简转换</h3><p>由上一步提取出来的中文维基百科中的语料中既有繁体字也有简体字，这里需要将其统一变为简体字，采用的工具也是开源的<a href="https://github.com/BYVoid/OpenCC" target="_blank" rel="noopener">OpenCC</a>转换器。安装使用方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; &lt; /dev/null 2&gt; /dev/null</div><div class="line">$ brew install opencc</div><div class="line">$ cd OpenCC</div><div class="line">$ opencc -i /Users/HuaZhang/Desktop/zhwiki_extracted/AA/zhwiki_extract/AA/wiki_00 -o zhwiki_extract/zhs_wiki -c /Users/HuaZhang/OpenCC/data/config/t2s.json</div></pre></td></tr></table></figure><p>其中<code>-i</code>表示输入文件路径，<code>-o</code>表示输出的文件，<code>-c</code>表示转换的配置文件，这里使用的繁体转简体的配置文件，OpenCC自带了一系列的转换配置文件，可以参考其github主页的说明。</p><h3 id="1-4-去除标点"><a href="#1-4-去除标点" class="headerlink" title="1.4 去除标点"></a>1.4 去除标点</h3><p>去除标点符号有两个问题需要解决，一个是像下面这种为了解决各地术语，名称不同的问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">他的主要成就包括Emacs及後來的GNU Emacs，GNU C 編譯器及-&#123;zh-hant:GNU 除錯器;zh-hans:GDB 调试器&#125;-。</div></pre></td></tr></table></figure><p>另外一个就是将所有标点符号替换成空字符，通过正则表达式均可解决这两个问题，下面是具体实现的python代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: utf-8 -*- </span></div><div class="line"></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> re</div><div class="line"><span class="keyword">import</span> io</div><div class="line"></div><div class="line">reload(sys)</div><div class="line">sys.setdefaultencoding(<span class="string">'utf-8'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">pre_process</span><span class="params">(input_file, output_file)</span>:</span></div><div class="line">    multi_version = re.compile(<span class="string">ur'-\&#123;.*?(zh-hans|zh-cn):([^;]*?)(;.*?)?\&#125;-'</span>)</div><div class="line">    punctuation = re.compile(<span class="string">u"[-~!@#$%^&amp;*()_+`=\[\]\\\&#123;\&#125;\"|;':,./&lt;&gt;?·！@#￥%……&amp;*（）——+【】、；‘：“”，。、《》？「『」』]"</span>)</div><div class="line">    <span class="keyword">with</span> io.open(output_file, mode = <span class="string">'w'</span>, encoding = <span class="string">'utf-8'</span>) <span class="keyword">as</span> outfile:</div><div class="line">        <span class="keyword">with</span> io.open(input_file, mode = <span class="string">'r'</span>, encoding =<span class="string">'utf-8'</span>) <span class="keyword">as</span> infile:</div><div class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> infile:</div><div class="line">                line = multi_version.sub(<span class="string">ur'\2'</span>, line)</div><div class="line">                line = punctuation.sub(<span class="string">''</span>, line.decode(<span class="string">'utf8'</span>))</div><div class="line">                outfile.write(line)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    <span class="keyword">if</span> len(sys.argv) != <span class="number">3</span>:</div><div class="line">        <span class="keyword">print</span> <span class="string">"Usage: python script.py input_file output_file"</span></div><div class="line">        sys.exit()</div><div class="line">    input_file, output_file = sys.argv[<span class="number">1</span>], sys.argv[<span class="number">2</span>]</div><div class="line">    pre_process(input_file, output_file)</div></pre></td></tr></table></figure><p>经过该步骤处理之后，得到了简体中文的纯净文本，如下所示：</p><p>&gt;<br>doc id13 urlhttpszhwikipediaorgwikicurid13 title数学<br>数学<br>数学是利用符号语言研究数量结构变化以及空间等概念的一门学科从某种角度看属于形式科学的一种数学透过抽象化和逻辑推理的使用由计数计算量度和对物体形状及运动的观察而产生数学家们拓展这些概念为了公式化新的猜想以及从选定的公理及定义中建立起严谨推导出的定理<br>·······<br>数学奖通常和其他科学的奖项分开数学上最有名的奖为菲尔兹奖创立于1936年每四年颁奖一次它通常被认为是数学的诺贝尔奖另一个国际上主要的奖项为阿贝尔奖创立于2003年两者都颁奖于特定的工作主题包括数学新领域的创新或已成熟领域中未解决问题的解答著名的23个问题称为希尔伯特的23个问题于1900年由德国数学家大卫希尔伯特所提出这一连串的问题在数学家之间有著极高的名望且至少有九个问题已经被解答了出来另一新的七个重要问题称为千禧年大奖难题发表于2000年对其每一个问题的解答都有著一百万美元的奖金而当中只有一个问题黎曼猜想和希尔伯特的问题重复<br>doc</p><h3 id="1-5-jieba分词"><a href="#1-5-jieba分词" class="headerlink" title="1.5 jieba分词"></a>1.5 jieba分词</h3><p>下面需要对其进行分词并且整理成每行一篇文本的格式，从而方便后续的处理。</p><p>分词采用 python 的分词工具 <a href="https://github.com/fxsjy/jieba" target="_blank" rel="noopener">jieba</a>，通过 <code>pip install jieba</code>安装即可。且将一篇文章分词后的结果存储在一行，由前面可知，每篇文章存储在一对<code>&lt;doc&gt;&lt;/doc&gt;</code>标签中，由于前面去掉了标点，所以现在变成了<code>doc doc</code>,所以只要判断当前行为doc时即可认为文章结束，从而开始在新的一行记录下一篇文章的分词结果。实现的python代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> io</div><div class="line"><span class="keyword">import</span> jieba</div><div class="line"></div><div class="line">reload(sys)</div><div class="line">sys.setdefaultencoding(<span class="string">'utf-8'</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">cut_words</span><span class="params">(input_file, output_file)</span>:</span></div><div class="line">    count = <span class="number">0</span></div><div class="line">    <span class="keyword">with</span> io.open(output_file, mode = <span class="string">'w'</span>, encoding = <span class="string">'utf-8'</span>) <span class="keyword">as</span> outfile:</div><div class="line">        <span class="keyword">with</span> io.open(input_file, mode = <span class="string">'r'</span>, encoding = <span class="string">'utf-8'</span>) <span class="keyword">as</span> infile:</div><div class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> infile:</div><div class="line">                line = line.strip()</div><div class="line">                <span class="keyword">if</span> len(line) &lt; <span class="number">1</span>:  <span class="comment"># empty line</span></div><div class="line">                    <span class="keyword">continue</span></div><div class="line">                <span class="keyword">if</span> line.startswith(<span class="string">'doc'</span>): <span class="comment"># start or end of a passage</span></div><div class="line">                    <span class="keyword">if</span> line == <span class="string">'doc'</span>: <span class="comment"># end of a passage</span></div><div class="line">                        outfile.write(<span class="string">u'\n'</span>)</div><div class="line">                        count = count + <span class="number">1</span></div><div class="line">                        <span class="keyword">if</span>(count % <span class="number">1000</span> == <span class="number">0</span>):</div><div class="line">                            print(<span class="string">'%s articles were finished.......'</span> %count)</div><div class="line">                    <span class="keyword">continue</span></div><div class="line">                <span class="keyword">for</span> word <span class="keyword">in</span> jieba.cut(line):</div><div class="line">                    outfile.write(word + <span class="string">' '</span>)</div><div class="line">    print(<span class="string">'%s articles were finished.......'</span> %count)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    <span class="keyword">if</span> len(sys.argv) &lt; <span class="number">3</span>:</div><div class="line">        <span class="keyword">print</span> <span class="string">"Usage: python script.py input_file output_file"</span></div><div class="line">        sys.exit()</div><div class="line">    input_file, output_file = sys.argv[<span class="number">1</span>], sys.argv[<span class="number">2</span>]</div><div class="line">    cut_words(input_file, output_file)</div></pre></td></tr></table></figure><h2 id="二、通过Word2Vec训练词向量"><a href="#二、通过Word2Vec训练词向量" class="headerlink" title="二、通过Word2Vec训练词向量"></a>二、通过Word2Vec训练词向量</h2><p>Word2vec中包含了两种训练词向量的方法：Continuous Bag of Words(CBOW)和Skip-gram。CBOW的目标是根据上下文来预测当前词语的概率。Skip-gram刚好相反，根据当前词语来预测上下文的概率。这两种方法都利用人工神经网络作为它们的分类算法。起初，每个单词都是一个随机N维向量。训练时，该算法利用CBOW或者Skip-gram的方法获得了每个单词的最优向量。</p><p>最初 Google 开源的 Word2Vec 是用C来写的，后面陆续有了Python ，Java 等语言的版本，这里采用的是 Python 版本的 gensim。通过 gensim 提供的 API 可以比较容易地进行词向量的训练。gensim的建议通过<code>conda install gensim</code>安装</p><p>下面是对上面处理后的语料库进行训练的一个简单例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line"># -*- coding: utf-8 -*-</div><div class="line"></div><div class="line">import os, sys</div><div class="line">import multiprocessing</div><div class="line">import gensim  </div><div class="line"></div><div class="line">reload(sys)</div><div class="line">sys.setdefaultencoding(&apos;utf-8&apos;)</div><div class="line"></div><div class="line"></div><div class="line">def word2vec_train(input_file, output_file):</div><div class="line">    sentences = gensim.models.word2vec.LineSentence(input_file)</div><div class="line">    model = gensim.models.Word2Vec(sentences, size=300, min_count=10, sg=0, workers=multiprocessing.cpu_count())</div><div class="line">    model.save(output_file)</div><div class="line">    model.wv.save_word2vec_format(output_file + &apos;.vector&apos;, binary=True)</div><div class="line"></div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    if len(sys.argv) &lt; 3:</div><div class="line">        print &quot;Usage: python script.py infile outfile&quot;</div><div class="line">        sys.exit()</div><div class="line">    input_file, output_file = sys.argv[1], sys.argv[2]</div><div class="line">    word2vec_train(input_file, output_file)</div></pre></td></tr></table></figure><p>上面的训练过程首先将输入的文件转为 <code>gensim</code>内部的 <code>LineSentence</code>对象，要求输入的文件的格式为每行一篇文章，每篇文章的词语以空格隔开。</p><p>然后通过<code>gensim.models.Word2Vec</code>初始化一个<code>Word2Vec</code>模型，<code>size</code>参数表示训练的向量的维数；<code>min_count</code>表示忽略那些出现次数小于这个数值的词语，认为他们是没有意义的词语，一般的取值范围为（0，100）；<code>sg</code>表示采用何种算法进行训练，取0时表示采用<code>CBOW</code>模型，取1表示采用<code>skip-gram</code>模型；<code>workers</code>表示开多少个进程进行训练，采用多进程训练可以加快训练过程，这里开的进程数与CPU的核数相等。</p><p>假设我们训练好了一个语料库的词向量，当一些新的文章加入这个语料库时，如何训练这些新增的文章从而更新我们的语料库？将全部文章再进行一次训练显然是费时费力的，gensim提供了一种类似于“增量训练”的方法。即可在原来的model基础上仅对新增的文章进行训练。如下所示为一个简单的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">model = gensim.models.Word2Vec.load(exist_model)</div><div class="line">model.train(new_sentences)</div></pre></td></tr></table></figure><p>上面的代码先加载了一个已经训练好的词向量模型，然后再添加新的文章进行训练，同样新增的文章的格式也要满足每行一篇文章，每篇文章的词语通过空格分开的格式。这里需要注意的是加载的模型只能 是通过<code>model.save()</code>存储的模型，从<code>model.save_word2vec_format()</code>恢复过来的模型只能用于查询.</p><h2 id="三、使用词向量模型"><a href="#三、使用词向量模型" class="headerlink" title="三、使用词向量模型"></a>三、使用词向量模型</h2><p>训练好的词向量可以供后续的多项自然语言处理工作使用，下面是通过gensim加载训练好的词向量模型并进行查询的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 加载模型</span></div><div class="line"><span class="keyword">import</span> gensim</div><div class="line">model = gensim.models.KeyedVectors.load_word2vec_format(<span class="string">'/Users/HuaZhang/Desktop/zhwiki_extracted/output_word2vec.vector'</span>,binary = <span class="keyword">True</span>)</div><div class="line"></div><div class="line"><span class="comment"># 词向量维度</span></div><div class="line">len(model[<span class="string">u'黑格尔'</span>])</div><div class="line"></div><div class="line"><span class="comment"># 相似度</span></div><div class="line">model.similarity(<span class="string">u'叔本华'</span>,<span class="string">u'康德'</span>)</div><div class="line"><span class="number">0.62428547493158093</span></div><div class="line"></div><div class="line"><span class="comment"># 找出相似度最高的词</span></div><div class="line">words = model.most_similar(<span class="string">u"哈耶克"</span>)</div><div class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</div><div class="line">    <span class="keyword">print</span> word[<span class="number">0</span>],word[<span class="number">1</span>]</div><div class="line">    </div><div class="line">米塞斯 <span class="number">0.776977062225</span></div><div class="line">叔本华 <span class="number">0.731572449207</span></div><div class="line">黑格尔 <span class="number">0.723797023296</span></div><div class="line">巴维克 <span class="number">0.723039865494</span></div><div class="line">门格尔 <span class="number">0.719911754131</span></div><div class="line">谢林 <span class="number">0.714867889881</span></div><div class="line">波普尔 <span class="number">0.714080870152</span></div><div class="line">马克思 <span class="number">0.711268663406</span></div><div class="line">尼采 <span class="number">0.710071563721</span></div><div class="line">博姆 <span class="number">0.705146193504</span></div><div class="line"></div><div class="line"><span class="comment"># 找出最不相关的词汇</span></div><div class="line"><span class="keyword">print</span>  model.doesnt_match(<span class="string">u"莎士比亚 卡夫卡 卢梭 爱因斯坦"</span>.split())</div><div class="line">爱因斯坦</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要通过计算机进行自然语言处理，首先就需要将这些文本数字化，目前用的最广泛的方法是词向量，根据训练使用算法的不同，目前主要有Word2Vec和GloVe两大方法，本文主要讲述通过这两个方法分别训练中文维基百科语料库的词向量。&lt;/p&gt;
    
    </summary>
    
      <category term="自然语言处理" scheme="http://yoursite.com/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
    
      <category term="词向量" scheme="http://yoursite.com/tags/%E8%AF%8D%E5%90%91%E9%87%8F/"/>
    
      <category term="Skip-gram" scheme="http://yoursite.com/tags/Skip-gram/"/>
    
      <category term="CBOW" scheme="http://yoursite.com/tags/CBOW/"/>
    
      <category term="Wiki" scheme="http://yoursite.com/tags/Wiki/"/>
    
      <category term="jieba" scheme="http://yoursite.com/tags/jieba/"/>
    
  </entry>
  
  <entry>
    <title>自然语言处理系列（1）：词向量与统计语言模型</title>
    <link href="http://yoursite.com/2017/12/08/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%B3%BB%E5%88%97%EF%BC%881%EF%BC%89%EF%BC%9A%E8%AF%8D%E5%90%91%E9%87%8F%E4%B8%8E%E7%BB%9F%E8%AE%A1%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2017/12/08/自然语言处理系列（1）：词向量与统计语言模型/</id>
    <published>2017-12-08T15:14:45.000Z</published>
    <updated>2017-12-26T09:01:21.007Z</updated>
    
    <content type="html"><![CDATA[<p>Word2Vec是Google在2013年年中开源的一款将词表征为实数值向量的高效工具，采用的模型有CBOW（Continuous Bag-Of-Words，即连续的词袋模型）和Skip-Gram两种。</p><a id="more"></a><p>word2vec一般被外界认为是一个Deep Learning（深度学习）的模型，究其原因，可能和word2vec的作者Tomas Mikolov的Deep Learning背景以及word2vec是一种神经网络模型相关，但我们谨慎认为该模型层次较浅，严格来说还不能算是深层模型。当然如果word2vec上层再套一层与具体应用相关的输出层，比如Softmax，此时更像是一个深层模型。</p><p>word2vec通过训练，可以把对文本内容的处理简化为K维向量空间中的向量运算，而向量空间上的相似度可以用来表示文本语义上的相似度。因此，word2vec输出的词向量可以被用来做很多NLP相关的工作，比如聚类、找同义词、词性分析等等。而word2vec被人广为传颂的地方是其向量的加法组合运算（Additive Compositionality），官网上的例子是：$vector(‘Paris’)-vector(‘France’)+vector(‘Italy’)≈vector(‘Rome’)$，$vector(‘king’)-vector(‘man’)+vector(‘women’)≈vector(‘queen’)$。但我们认为这个多少有点被过度炒作了，很多其他降维或主题模型在一定程度也能达到类似效果，而且word2vec也只是少量的例子完美符合这种加减法操作，并不是所有的case都满足。如果换个思路，把词当做feature，那么 word2vec 就可以把 feature映射到 K维向量空间，应该可以为现有模型提供更多的有用信息。</p><p>word2vec大受欢迎的另一个原因是其高效性，Mikolov在论文中指出一个优化的单机版本一天可训练上千亿个词。</p><h2 id="一、词向量"><a href="#一、词向量" class="headerlink" title="一、词向量"></a>一、词向量</h2><p>自然语言处理相关任务中，要将自然语言处理交给机器学习中的算法来处理，通常需要首先将语言数学化，因为机器不是人，机器只认得数学符合。向量是人把自然界的东西抽象出来交给机器处理的东西，基本上可以说向量是人对机器输入的主要方式了。</p><p>词向量就是用来将语言中的词进行数学化的一种方式，顾名思义，词向量就是把一个词表示成一个向量。主要有两种表示方式：</p><h3 id="1-1-One-Hot-Representation"><a href="#1-1-One-Hot-Representation" class="headerlink" title="1.1 One-Hot Representation"></a>1.1 One-Hot Representation</h3><p>一种最简单的词向量方式是One-Hot Representation，就是用一个很长的向量来表示一个词，向量的长度为词典的大小，向量的分量只有一个1，其他都为0，1的位置对应该词在词典中的位置。举个例子：“话筒”表示为[0001000000000000]“麦克风”表示[0000000010000000]。每一个词都是茫茫0海中的一个1.</p><p>这种One-Hot Representation如果采用稀疏方式存储，会非常地简洁，也就是给每个词分配一个数字ID。比如刚才的例子中，话筒为3，麦克风即为8（假设从0开始记）。如果要编程的话，用Hash表给每个词分配一个编号就可以了。这么简洁的表示方法配合上最大熵、SVM、CRF等等算法已经很好地完成了NLP领域的各种主流任务了。</p><p>但这种表示方法有两个缺点：（1）容易受维数灾难的困扰，尤其是将其用于Deep Learning的一些算法时不能很好地刻画词与词之间的相似性：任意两个词之间都是孤立的。光从这两个向量中看不出两个词是否有关系，哪怕是话筒和麦克风这样的同义词也不能幸免于难。</p><h3 id="1-2-Distributed-Representation"><a href="#1-2-Distributed-Representation" class="headerlink" title="1.2 Distributed Representation"></a>1.2 Distributed Representation</h3><p>另一种就是DistributedRepresentation 这种表示，它最早是 Hinton 于 1986 年提出的，可以克服 one-hot representation 的缺点。其基本想法是直接用一个普通的向量表示一个词，这种向量一般长成这个样子：[0.792, −0.177, −0.107, 0.109, −0.542, …]，也就是普通的向量表示形式。维度以 50 维和 100 维比较常见。</p><p>当然一个词怎么表示成这么样的一个向量是要经过一番训练的，训练方法较多，word2vec是其中一种，在后面会提到，这里先说它的意义。还要注意的是每个词在不同的语料库和不同的训练方法下，得到的词向量可能是不一样的。</p><p>词向量一般维数不高，很少有人闲着没事训练的时候定义一个10000维以上的维数，所以用起来维数灾难的机会现对于one-hot representation表示就大大减少了。</p><p>由于是用向量表示，而且用较好的训练算法得到的词向量的向量一般是有空间上的意义的，也就是说，将所有这些向量放在一起形成一个词向量空间，而每一向量则为该空间中的一个点，在这个空间上的词向量之间的距离度量也可以表示对应的两个词之间的“距离”。所谓两个词之间的“距离”，就是这两个词之间的语法，语义之间的相似性。</p><p>一个比较爽的应用方法是，得到词向量后，假如对于某个词A，想找出这个词最相似的词，这个场景对人来说都不轻松，毕竟比较主观，但是对于建立好词向量后的情况，对计算机来说，只要拿这个词的词向量跟其他词的词向量一一计算欧式距离或者cos距离，得到距离最小的那个词，就是它最相似的。</p><p>Distributed representation 最大的贡献就是让相关或者相似的词，在距离上更接近了。向量的距离可以用最传统的欧氏距离来衡量，也可以用 cos 夹角来衡量。用这种方式表示的向量，“麦克”和“话筒”的距离会远远小于“麦克”和“天气”。可能理想情况下“麦克”和“话筒”的表示应该是完全一样的，但是由于有些人会把英文名“迈克”也写成“麦克”，导致“麦克”一词带上了一些人名的语义，因此不会和“话筒”完全一致。</p><p>这样的特性使得词向量很有意义，自然就会吸引比较多的人去研究，前有Bengio发表在JMLR上的论文《A Neural Probabilistic Language Model》，又有Hinton的层次化Log-Bilinear模型，还有google的TomasMikolov 团队搞的word2vec等等。</p><p>词向量在机器翻译领域的一个应用，就是google的TomasMikolov 团队开发了一种词典和术语表的自动生成技术，该技术通过向量空间，把一种语言转变成另一种语言，实验中对英语和西班牙语间的翻译准确率高达90%。</p><p>其中在介绍算法原理的时候举了一个例子：考虑英语和西班牙语两种语言，通过训练分别得到它们对应的词向量空间 E 和 S。从英语中取出五个词 one，two，three，four，five，设其在 E 中对应的词向量分别为 v1，v2，v3，v4，v5，为方便作图，利用主成分分析（PCA）降维，得到相应的二维向量 u1，u2，u3，u4，u5，在二维平面上将这五个点描出来，如下图左图所示。类似地，在西班牙语中取出（与 one，two，three，four，five 对应的） uno，dos，tres，cuatro，cinco，设其在 S 中对应的词向量分别为 s1，s2，s3，s4，s5，用 PCA 降维后的二维向量分别为 t1，t2，t3，t4，t5，将它们在二维平面上描出来（可能还需作适当的旋转），如下图右图所示：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15000271279004.jpg" alt=""></p><p>观察左、右两幅图，容易发现：五个词在两个向量空间中的相对位置差不多，这说明两种语言对应向量空间结构之间具有相似性，从而进一步说明了在词向量空间利用刻画词之间相似性的合理性。</p><h2 id="二、语言模型"><a href="#二、语言模型" class="headerlink" title="二、语言模型"></a>二、语言模型</h2><h3 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h3><p>语言模型其实就是看一句话是不是正常人说出来的。这玩意很有用，比如机器翻译、语音识别得到若干候选之后，可以利用语言模型挑一个尽量靠谱的结果。在 NLP 的其它任务里也都能用到。<br>语言模型形式化的描述就是给定一个T个词的字符串s，看他是自然语言的概率$P(w_1,w_2,···w_t)$，$w_1$到$w_t$依次表示这句话中的各个词。有个很简单的推论是：</p><script type="math/tex; mode=display">P(s)=P(w_1,w_2,···w_T)=P(w_1)P(w_2|w_1)P(w_3|w_1,w_2)···P(w_t|w_1,w_2,···,w_{t-1})</script><p>上面这个概率表示的意义是：第一个词确定后，看后面的词在前面的词出现的情况下出现的概率。如一句话“大家喜欢吃苹果”，总共四个词“大家”、“喜欢”、“吃”<br>、“苹果”，怎么分词现在不讨论，总之词已经分好，就这四个。那么这句话是一个自然语言的概率是：</p><script type="math/tex; mode=display">P(大家，喜欢，吃，苹果)=P(大家)P(喜欢|大家)P(吃|大家，喜欢)P(苹果|大家，喜欢，吃)</script><p>其中，$P(大家)$表示“大家”这个词在语料库里面出现的概率；$P(喜欢|大家)$表示“喜欢”这个词出现在“大家喜欢”后面的概率；$P(吃|大家，喜欢)$表示“吃”这个词出现在“大家喜欢”后面的概率；$P(苹果|大家，喜欢，吃)$表示“苹果”这个词出现在“大家喜欢吃”后面的概率。把这些概率连乘起来，得到的就是这句话平时出现的概率。如果这个概率特别低，说明这句话不常出现，那么就不算是一句自然语言，因为在语料库中很少出现。如果出现的概率高，就说明是一句自然语言。</p><p>看到了上面的计算，看有多麻烦：只有四个词的一句话，需要计算的是$P(大家)$，$P(喜欢|大家)$，$P(吃|大家，喜欢)$，$P(苹果|大家，喜欢，吃)$这四个概率，这四个概率还要预先计算好，考虑词的数量，成千上万个，再考虑组合数，$P(吃|大家，喜欢)$这个有“大家”、“喜欢”、“吃”的组合，总会有上亿种情况吧；再考虑$P(苹果|大家,喜欢，吃)$这个概率，总共也会超过万亿种。</p><p>从上面的情况来看，计算起来是非常麻烦的，一般都用偷懒的方式。<br>为了表示简单，上面的公式可以用下面的方式表示</p><script type="math/tex; mode=display">P(s)=P(w_1,w_2,···w_t)=\prod_{i=1}^TP(w_i|context_i)</script><p>其中，如果context是空的话，就是它自己$P(w)$，另外如“吃”的context就是“大家”、“喜欢”，其余的对号入座。</p><h3 id="2-2-N-gram模型"><a href="#2-2-N-gram模型" class="headerlink" title="2.2 N-gram模型"></a>2.2 N-gram模型</h3><p>接下来说怎么计算$P(w_i|context_i)$，上面看的是根据这句话前面的所有词来计算，那么就得计算很多了，比如就得把语料库里面的组合“大家”、“喜欢”、“吃”、“苹果”这种情况全部统计一遍，那么为了计算这句话的概率，就上面那个例子，都得扫描四次语料库。这样一句话有多少个词就得扫描多少趟，语料库一般都比较大，越大的语料库越能提供准确的判断。这样的计算速度在真正使用的时候是万万不可接受的，线上扫描一篇文章是不是一推乱七八糟的没有序列的文字都得扫描很久，这样的应用根本没人考虑。</p><p>最好的办法就是直接把所有的$P(w_i|context_i)$提前算好了，那么根据排列组上面的来算，对于一个只有四个词的语料库，总共就有$4!+3!+2!+1!$个情况要计算，那就是24个情况要计算；换成1000个词的语料库，就是$\sum_{i=1}^{1000}i!$个情况需要统计，对于计算机来说，计算这些东西简直是开玩笑。</p><p>19世纪到20世纪初，俄罗斯有个数学家叫马尔科夫（Andrey Markov），他给了个偷懒但还颇为有效的方法，也就是每当遇见这种情况时，就假设任意一个词$w_i$出现的概率只同他前面的词$w_{t-1}$有关，于是问题就变得很简单了。这种假设在数学上称为马尔科夫假设。现在，s出现的概率就变得简单了：</p><script type="math/tex; mode=display">P(s)=P(w_i)P(w_2|w_1)···P(w_i|w_{i-1})···P(w_n|w_{n-1})</script><p>这个公式对应的统计语言模型是二元模型（Bigram Model）。</p><p>接下来的问题就是如何估计条件概率$P(w_i|w_{i-1})$。根据它的定义：</p><script type="math/tex; mode=display">P(w_i|w_{i-1})=\frac{P(w_{i-1},w_i)}{P(w_{i-1})}</script><p>。估计联合概率$P(w_{i-1},w_i)$和边缘概率$P(w_{i-1})$，现在变得很简单。因为有了大量机读文件，也就是专业人士讲的语料库，只要数一数$w_{i-1},w_i$这对词在统计的文本中前后相邻出现了多少次$ count (w_{i-1},w_i)$，以及$w_{i-1}$本身在同样的文本中出现了多少次$count (w_{i-1})$然后用两个数分别除以语料库的大小，即可得到这些词或二元组的相对频率：</p><script type="math/tex; mode=display">f(w_{i-1},w_i)=\frac{count (w_{i-1},w_i)}{count}</script><script type="math/tex; mode=display">f(w_{i-1})=\frac{count (w_{i-1})}{count}</script><p>根据大数定理，只要统计量足够，相对频率就等于概率，即</p><script type="math/tex; mode=display">P(w_{i-1},w_i)≈\frac{count (w_{i-1},w_i)}{count}</script><p>而$P(w_i|w_{i-1})$就是这两个数的比值，再考虑到上面的两个概率有相同的分母，可以约掉，因此</p><script type="math/tex; mode=display">P(w_i|w_{i-1})≈\frac{count (w_{i-1},w_i)}{count (w_{i-1})}</script><p>当然，也可以假设一个词由前面N-1个词决定，对应的模型稍微复杂些，被称为N元模型。而N=1的一元模型实际上是一个上下文无关的模型，也就是假定当前词出现的概率与前面的词无关。而在实际应用中最多的是N=3的三元模型，更高阶的模型就很少使用了。</p><p>为什么N一般取值都这么小呢？这里面主要有两个原因。首先，N元模型的大小（或者说空间复杂度）几乎是N的指数函数，即$O(|V|^N)$，这里$|V|$是一种语言词典的词汇量，一般在几万到几十万个。而使用N元模型的速度（或者说时间复杂度）也几乎是一个指数函数，即$O(|V|^{N-1})$。因此，N不能太大。当N从1到2，再从2到3时，模型的效果上升显著。而当模型从3到4时，效果的提升就不是很显著了，而资源的耗费增加却非常快。</p><p>所以N-gram存在几个问题，总结如下：</p><ol><li>n-gram 语言模型无法建模更远的关系，语料的不足使得无法训练更高阶的 语言模型。大部分研究或工作都是使用 Trigram，就算使用高阶的模型，其统计 到的概率可信度就大打折扣，还有一些比较小的问题采用 Bigram。</li><li>这种模型无法建模出词之间的相似度，有时候两个具有某种相似性的词， 如果一个词经常出现在某段词之后，那么也许另一个词出现在这段词后面的概率 也比较大。比如“白色的汽车”经常出现，那完全可以认为“白色的轿车”也可 能经常出现。</li><li>有些n元（n个词的组合，跟顺序有关的）在语料库里面没有出现过，对应出来的条件概率就是0，这样一整句话的概率都是0了，这是不对的，解决的方法主要有两种：<ul><li>平滑法：最简单的方法是把每个 n 元组的出现次数加 1，那么原来 出现 k 次的某个 n 元组就会记为 k+1 次，原来出现 0 次的 n 元组就会记为出现 1 次。这种也称为 Laplace 平滑。当然还有很多更复杂的其他平滑方法，其本质都 是将模型变为贝叶斯模型，通过引入先验分布打破似然一统天下的局面。而引入 先验方法的不同也就产生了很多不同的平滑方法。</li><li>回退法：即利用n-1的元组的概率去替代n元组的概率，有点像决策树中的后剪枝方法，即如果 n 元的概率不到， 那就往上回退一步，用 n-1 元的概率乘上一个权重来模拟。</li></ul></li></ol><h3 id="2-3-上下文无关模型"><a href="#2-3-上下文无关模型" class="headerlink" title="2.3 上下文无关模型"></a>2.3 上下文无关模型</h3><p>该模型仅仅考虑当前词本身的概率，不考虑该词所对应的上下文环境。这是一种最简单，易于实现，但没有多大实际应用价值的统计语言模型。</p><script type="math/tex; mode=display">𝑝(𝑤_𝑡|Context)= 𝑝(𝑤_𝑡)=\frac{𝑁_{𝑤_𝑡}}{N}</script><p>这个模型不考虑任何上下文信息，仅仅依赖于训练文本中的词频统计。它是 n-gram 模型中当 n=1 的特殊情形，所以有时也称作 Unigram Model(一元文法统 计模型)。实际应用中，常被应用到一些商用语音识别系统中。</p><h3 id="2-4-N-pos模型"><a href="#2-4-N-pos模型" class="headerlink" title="2.4 N-pos模型"></a>2.4 N-pos模型</h3><p>严格来说 n-pos 只是 n-gram 的一种衍生模型。n-gram 模型假定第 t 个词出现 概率条件依赖它前 N-1 个词，而现实中很多词出现的概率是条件依赖于它前面词 的语法功能的。n-pos 模型就是基于这种假设的模型，它将词按照其语法功能进 行分类，由这些词类决定下一个词出现的概率。这样的词类称为词性 (Part-of-Speech，简称为 POS)。n-pos 模型中的每个词的条件概率表示为:</p><script type="math/tex; mode=display">𝑝(s) = 𝑝(𝑤_1^𝑇)= 𝑝(𝑤_1,𝑤_2,...,𝑤_𝑇)=∏^𝑇_{𝑡=1}𝑝(𝑤_𝑡|𝑐(𝑤_{𝑡−n+1}),𝑐(𝑤_{𝑡−n+2}),...,𝑐(𝑤_{𝑡−1}))</script><p>c 为类别映射函数，即把 T 个词映射到 K 个类别(1=&lt;K&lt;=T)。实际上 n-Pos使用了一种聚类的思想，使得原来 n-gram 中$𝑤_{𝑡−n+1}, 𝑤_{𝑡−n+2},… , 𝑤_{𝑡−1}$中的可能为$T^{N-1}$ 减少到$𝑐(𝑤_{𝑡−n+1}),𝑐(𝑤_{𝑡−n+2}),…,𝑐(𝑤_{𝑡−1})$中的 $K^{N-1}$，同时这种减少还采用了语义有意义的类别。</p><h3 id="2-5-基于决策树的语言模型"><a href="#2-5-基于决策树的语言模型" class="headerlink" title="2.5 基于决策树的语言模型"></a>2.5 基于决策树的语言模型</h3><p>上面提到的上下文无关语言模型、N-gram语言模型、N-pos语言模型等等，都可以以统计决策树的形式表示出来。而统计决策树中每个结点的决策规则是一个上下文相关的问题。这些问题可以是“前一个词是w吗”“前一个词属于类别$c_i$吗”，当然基于决策树的语言模型还可以灵活一点，可以是一些“前一个是动词？”、“后面有介词吗”之类的复杂语法语义问题。</p><p>基于决策树的语言模型优点是：分布数不是预先固定好的，而是根据训练语料库中的实际情况确定，更为灵活。缺点是：构造通即决策树的问题很困难，且时空开销很大。</p><h3 id="2-6-最大熵模型"><a href="#2-6-最大熵模型" class="headerlink" title="2.6 最大熵模型"></a>2.6 最大熵模型</h3><p>最大熵原理是E.T. Jayness于上世纪50年代提出的，其基本思想是:对一个 随机事件的概率分布进行预测时，在满足全部已知的条件下对未知的情况不做任 何主观假设。从信息论的角度来说就是:在只掌握关于未知分布的部分知识时， 应当选取符合这些知识但又能使得熵最大的概率分布。</p><script type="math/tex; mode=display">P(w|context)=\frac{\sum_i\lambda _if_i(context,w)}{z(context)}</script><p>其中$𝜆_𝑖$是参数，$𝑍(𝐶𝑜𝑛𝑡𝑒𝑥𝑡)$为归一化因子，因为采用的是这种 Softmax 形式， 所以最大熵模型有时候也称为指数模型。</p><h3 id="2-7-自适应语言模型"><a href="#2-7-自适应语言模型" class="headerlink" title="2.7 自适应语言模型"></a>2.7 自适应语言模型</h3><p>前面的模型概率分布都是预先从训练语料库中估算好的，属于静态语言模型。 而自适应语言模型类似是 Online Learning 的过程，即根据少量新数据动态调整模 型，属于动态模型。在自然语言中，经常出现这样现象:某些在文本中通常很少 出现的词，在某一局部文本中突然大量地出现。能够根据词在局部文本中出现的 情况动态地调整语言模型中的概率分布数据的语言模型成为动态、自适应或者基 于缓存的语言模型。通常的做法是将静态模型与动态模型通过参数融合到一起， 这种混合模型可以有效地避免数据稀疏的问题。</p><p>还有一种主题相关的自适应语言模型，直观的例子为:专门针对体育相关内容训练一个语言模型，同时保留所有语料训练的整体语言模型，当新来的数据属于体育类别时，其应该使用的模型就是体育相关主题模型和整体语言模型相融合的混合模型。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Word2Vec是Google在2013年年中开源的一款将词表征为实数值向量的高效工具，采用的模型有CBOW（Continuous Bag-Of-Words，即连续的词袋模型）和Skip-Gram两种。&lt;/p&gt;
    
    </summary>
    
      <category term="自然语言处理" scheme="http://yoursite.com/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
    
      <category term="词向量" scheme="http://yoursite.com/tags/%E8%AF%8D%E5%90%91%E9%87%8F/"/>
    
      <category term="语言模型" scheme="http://yoursite.com/tags/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>机器学习算法系列（40）：机器学习中的数据清洗与特征处理综述</title>
    <link href="http://yoursite.com/2017/09/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%8840%EF%BC%89%EF%BC%9A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%8E%E7%89%B9%E5%BE%81%E5%A4%84%E7%90%86%E7%BB%BC%E8%BF%B0/"/>
    <id>http://yoursite.com/2017/09/08/机器学习算法系列（40）：机器学习中的数据清洗与特征处理综述/</id>
    <published>2017-09-08T15:14:45.000Z</published>
    <updated>2017-12-26T08:04:53.390Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>随着美团交易规模的逐步增大，积累下来的业务数据和交易数据越来越多，这些数据是美团做为一个团购平台最宝贵的财富。通过对这些数据的分析和挖掘，不仅能给美团业务发展方向提供决策支持，也为业务的迭代指明了方向。目前在美团的团购系统中大量地应用到了机器学习和数据挖掘技术，例如个性化推荐、筛选排序、搜索排序、用户建模等等，为公司创造了巨大的价值。<br>本文主要介绍在美团的推荐与个性化团队实践中的数据清洗与特征挖掘方法。主要内容已经在内部公开课”机器学习InAction系列”讲过，本博客的内容主要是讲座内容的提炼和总结。</p><a id="more"></a><h2 id="二、综述"><a href="#二、综述" class="headerlink" title="二、综述"></a>二、综述</h2><p><img src="http://omu7tit09.bkt.clouddn.com/15049332797637.png" alt=""><br>如上图所示是一个经典的机器学习问题框架图。数据清洗和特征挖掘的工作是在灰色框中框出的部分，即“数据清洗=&gt;特征，标注数据生成=&gt;模型学习=&gt;模型应用”中的前两个步骤。<br>灰色框中蓝色箭头对应的是离线处理部分。主要工作是</p><ul><li>从原始数据，如文本、图像或者应用数据中清洗出特征数据和标注数据。</li><li>对清洗出的特征和标注数据进行处理，例如样本采样，样本调权，异常点去除，特征归一化处理，特征变化，特征组合等过程。最终生成的数据主要是供模型训练使用。</li></ul><p>灰色框中绿色箭头对应的是在线处理的部分。所做的主要工作和离线处理的类似，主要的区别在于1.不需要清洗标注数据，只需要处理得到特征数据，在线模型使用特征数据预测出样本可能的标签。2.最终生成数据的用处，最终生成的数据主要用于模型的预测，而不是训练。<br>在离线的处理部分，可以进行较多的实验和迭代，尝试不同的样本采样、样本权重、特征处理方法、特征组合方法等，最终得到一个最优的方法，在离线评估得到好的结果后，最终将确定的方案在线上使用。<br>另外，由于在线和离线环境不同，存储数据、获取数据的方法存在较大的差异。例如离线数据获取可以将数据存储在Hadoop，批量地进行分析处理等操作，并且容忍一定的失败。而在线服务获取数据需要稳定、延时小等，可以将数据建入索引、存入KV存储系统等。后面在相应的部分会详细地介绍。</p><p>本文以点击下单率预测为例，结合实例来介绍如何进行数据清洗和特征处理。首先介绍下点击下单率预测任务，其业务目标是提高团购用户的用户体验，帮助用户更快更好地找到自己想买的单子。这个概念或者说目标看起来比较虚，我们需要将其转换成一个技术目标，便于度量和实现。最终确定的技术目标是点击下单率预估，去预测用户点击或者购买团购单的概率。我们将预测出来点击或者下单率高的单子排在前面，预测的越准确，用户在排序靠前的单子点击、下单的就越多，省去了用户反复翻页的开销，很快就能找到自己想要的单子。离线我们用常用的衡量排序结果的AUC指标，在线的我们通过ABTest来测试算法对下单率、用户转化率等指标的影响。</p><h2 id="三、特征使用方案"><a href="#三、特征使用方案" class="headerlink" title="三、特征使用方案"></a>三、特征使用方案</h2><p>在确定了目标之后，下一步，我们需要确定使用哪些数据来达到目标。需要事先梳理哪些特征数据可能与用户是否点击下单相关。我们可以借鉴一些业务经验，另外可以采用一些特征选择、特征分析等方法来辅助我们选择。具体的特征选择，特征分析等方法我们后面会详细介绍。从业务经验来判断，可能影响用户是否点击下单的因素有：</p><ul><li>距离，很显然这是一个很重要的特征。如果购买一个离用户距离较远的单子，用户去消费这个单子需要付出很多的代价。 当然，也并不是没有买很远单子的用户，但是这个比例会比较小。</li><li>用户历史行为，对于老用户，之前可能在美团有过购买、点击等行为。<br>用户实时兴趣。</li><li>单子质量，上面的特征都是比较好衡量的，单子质量可能是更复杂的一个特征。</li><li>是否热门，用户评价人数，购买数等等。</li></ul><p>在确定好要使用哪些数据之后，我们需要对使用数据的可用性进行评估，包括数据的获取难度，数据的规模，数据的准确率，数据的覆盖率等，</p><ul><li>数据获取难度：例如获取用户id不难，但是获取用户年龄和性别较困难，因为用户注册或者购买时，这些并不是必填项。即使填了也不完全准确。这些特征可能是通过额外的预测模型预测的，那就存在着模型精度的问题。</li><li>数据覆盖率：数据覆盖率也是一个重要的考量因素，例如距离特征，并不是所有用户的距离我们都能获取到。PC端的就没有距离，还有很多用户禁止使用它们的地理位置信息等。</li><li>用户历史行为，只有老用户才会有行为。</li><li>用户实时行为，如果用户刚打开app，还没有任何行为，同样面临着一个冷启动的问题。<br>数据的准确率</li><li>单子质量，用户性别等，都会有准确率的问题。</li></ul><h2 id="四、特征获取方案"><a href="#四、特征获取方案" class="headerlink" title="四、特征获取方案"></a>四、特征获取方案</h2><p>Ok，在选定好要用的特征之后，我们需要考虑一个问题。就是这些数据从哪可以获取？只有获取了这些数据我们才能用上。否则，提一个不可能获取到的特征，获取不到，提了也是白提。下面就介绍下特征获取方案。</p><ul><li>离线特征获取方案：离线可以使用海量的数据，借助于分布式文件存储平台，例如HDFS等，使用例如MapReduce，Spark等处理工具来处理海量的数据等。</li><li>在线特征获取方案：在线特征比较注重获取数据的延时，由于是在线服务，需要在非常短的时间内获取到相应的数据，对查找性能要求非常高，可以将数据存储在索引、kv存储等。而查找性能与数据的数据量会有矛盾，需要折衷处理，我们使用了特征分层获取方案，如下图所示。<img src="http://omu7tit09.bkt.clouddn.com/15049333997560.png" alt="">出于性能考虑。在粗排阶段，使用更基础的特征，数据直接建入索引。精排阶段，再使用一些个性化特征等。</li></ul><h2 id="五、特征与标注数据清洗"><a href="#五、特征与标注数据清洗" class="headerlink" title="五、特征与标注数据清洗"></a>五、特征与标注数据清洗</h2><p>在了解特征数据放在哪儿、怎样获取之后。下一步就是考虑如何处理特征和标注数据了。下面3节都是主要讲的特征和标注处理方法</p><h3 id="5-1-标注数据清洗"><a href="#5-1-标注数据清洗" class="headerlink" title="5.1 标注数据清洗"></a>5.1 标注数据清洗</h3><p>首先介绍下如何清洗特征数据，清洗特征数据方法可以分为离线清洗和在线清洗两种方法。</p><ul><li>离线清洗数据：离线清洗优点是方便评估新特征效果，缺点是实时性差，与线上实时环境有一定误差。对于实时特征难以训练得到恰当的权重。</li><li>在线清洗数据：在线清洗优点是实时性强，完全记录的线上实际数据，缺点是新特征加入需要一段时间做数据积累。</li></ul><h3 id="5-2-样本采样与样本过滤"><a href="#5-2-样本采样与样本过滤" class="headerlink" title="5.2 样本采样与样本过滤"></a>5.2 样本采样与样本过滤</h3><p>特征数据只有在和标注数据合并之后，才能用来做为模型的训练。下面介绍下如何清洗标注数据。主要是数据采样和样本过滤。</p><p>数据采样，例如对于分类问题：选取正例，负例。对于回归问题，需要采集数据。对于采样得到的样本，根据需要，需要设定样本权重。当模型不能使用全部的数据来训练时，需要对数据进行采样，设定一定的采样率。采样的方法包括随机采样，固定比例采样等方法。</p><p>除了采样外，经常对样本还需要进行过滤，包括</p><ul><li>1.结合业务情况进行数据的过滤，例如去除crawler抓取，spam，作弊等数据。</li><li>2.异常点检测，采用异常点检测算法对样本进行分析，常用的异常点检测算法包括<br>偏差检测，例如聚类，最近邻等。<ul><li>基于统计的异常点检测算法</li><li>例如极差，四分位数间距，均差，标准差等，这种方法适合于挖掘单变量的数值型数据。全距(Range)，又称极差，是用来表示统计资料中的变异量数(measures of variation) ，其最大值与最小值之间的差距；四分位距通常是用来构建箱形图，以及对概率分布的简要图表概述。</li><li>基于距离的异常点检测算法，主要通过距离方法来检测异常点，将数据集中与大多数点之间距离大于某个阈值的点视为异常点，主要使用的距离度量方法有绝对距离 ( 曼哈顿距离 ) 、欧氏距离和马氏距离等方法。</li><li>基于密度的异常点检测算法，考察当前点周围密度，可以发现局部异常点，例如LOF算法</li></ul></li></ul><h2 id="六、特征分类"><a href="#六、特征分类" class="headerlink" title="六、特征分类"></a>六、特征分类</h2><p>在分析完特征和标注的清洗方法之后，下面来具体介绍下特征的处理方法，先对特征进行分类，对于不同的特征应该有不同的处理方法。</p><p>根据不同的分类方法，可以将特征分为(1)Low level特征和High level特征。(2)稳定特征与动态特征。(3)二值特征、连续特征、枚举特征。</p><p>Low level特征是较低级别的特征，主要是原始特征，不需要或者需要非常少的人工处理和干预，例如文本特征中的词向量特征，图像特征中的像素点，用户id，商品id等。Low level特征一般维度比较高，不能用过于复杂的模型。High level特征是经过较复杂的处理，结合部分业务逻辑或者规则、模型得到的特征，例如人工打分，模型打分等特征，可以用于较复杂的非线性模型。Low level 比较针对性，覆盖面小。长尾样本的预测值主要受high level特征影响。 高频样本的预测值主要受low level特征影响。</p><p>稳定特征是变化频率(更新频率)较少的特征，例如评价平均分，团购单价格等，在较长的时间段内都不会发生变化。动态特征是更新变化比较频繁的特征，有些甚至是实时计算得到的特征，例如距离特征，2小时销量等特征。或者叫做实时特征和非实时特征。针对两类特征的不同可以针对性地设计特征存储和更新方式，例如对于稳定特征，可以建入索引，较长时间更新一次，如果做缓存的话，缓存的时间可以较长。对于动态特征，需要实时计算或者准实时地更新数据，如果做缓存的话，缓存过期时间需要设置的较短。</p><p>二值特征主要是0/1特征，即特征只取两种值：0或者1，例如用户id特征：目前的id是否是某个特定的id，词向量特征：某个特定的词是否在文章中出现等等。连续值特征是取值为有理数的特征，特征取值个数不定，例如距离特征，特征取值为是0~正无穷。枚举值特征主要是特征有固定个数个可能值，例如今天周几，只有7个可能值：周1，周2，…，周日。在实际的使用中，我们可能对不同类型的特征进行转换，例如将枚举特征或者连续特征处理为二值特征。枚举特征处理为二值特征技巧：将枚举特征映射为多个特征，每个特征对应一个特定枚举值，例如今天周几，可以把它转换成7个二元特征：今天是否是周一，今天是否是周二，…，今天是否是周日。连续值处理为二值特征方法：先将连续值离散化（后面会介绍如何离散化)，再将离散化后的特征切分为N个二元特征，每个特征代表是否在这个区间内。</p><h3 id="6-1-特征归一化，离散化，缺省值处理"><a href="#6-1-特征归一化，离散化，缺省值处理" class="headerlink" title="6.1 特征归一化，离散化，缺省值处理"></a>6.1 特征归一化，离散化，缺省值处理</h3><p>主要用于单个特征的处理。</p><ul><li><p>归一化<br>不同的特征有不同的取值范围，在有些算法中，例如线性模型或者距离相关的模型像聚类模型、knn模型等，特征的取值范围会对最终的结果产生较大影响，例如二元特征的取值范围为[0，1]，而距离特征取值可能是[0，正无穷)，在实际使用中会对距离进行截断，例如[0，3000000]，但是这两个特征由于取值范围不一致导致了模型可能会更偏向于取值范围较大的特征，为了平衡取值范围不一致的特征，需要对特征进行归一化处理，将特征取值归一化到［0，1］区间。常用的归一化方法包括1.函数归一化，通过映射函数将特征取值映射到［0，1］区间，例如最大最小值归一化方法，是一种线性的映射。还有通过非线性函数的映射，例如log函数等。2.分维度归一化，可以使用最大最小归一化方法，但是最大最小值选取的是所属类别的最大最小值，即使用的是局部最大最小值，不是全局的最大最小值。3.排序归一化，不管原来的特征取值是什么样的，将特征按大小排序，根据特征所对应的序给予一个新的值。</p></li><li><p>离散化<br>在上面介绍过连续值的取值空间可能是无穷的，为了便于表示和在模型中处理，需要对连续值特征进行离散化处理。常用的离散化方法包括等值划分和等量划分。等值划分是将特征按照值域进行均分，每一段内的取值等同处理。例如某个特征的取值范围为[0，10]，我们可以将其划分为10段，[0，1)，[1，2)，…，[9，10)。等量划分是根据样本总数进行均分，每段等量个样本划分为1段。例如距离特征，取值范围［0，3000000］，现在需要切分成10段，如果按照等比例划分的话，会发现绝大部分样本都在第1段中。使用等量划分就会避免这种问题，最终可能的切分是[0，100)，[100，300)，[300，500)，..，[10000，3000000]，前面的区间划分比较密，后面的比较稀疏。</p></li><li><p>缺省值处理<br>有些特征可能因为无法采样或者没有观测值而缺失，例如距离特征，用户可能禁止获取地理位置或者获取地理位置失败，此时需要对这些特征做特殊的处理，赋予一个缺省值。缺省值如何赋予，也有很多种方法。例如单独表示，众数，平均值等。</p></li></ul><h3 id="6-2-特征降维"><a href="#6-2-特征降维" class="headerlink" title="6.2 特征降维"></a>6.2 特征降维</h3><p>在介绍特征降维之前，先介绍下特征升维。在机器学习中，有一个VC维理论。根据VC维理论，VC维越高，打散能力越强，可容许的模型复杂度越高。在低维不可分的数据，映射到高维是可分。可以想想，给你一堆物品，人脑是如何对这些物品进行分类，依然是找出这些物品的一些特征，例如：颜色，形状，大小，触感等等，然后根据这些特征对物品做以归类，这其实就是一个先升维，后划分的过程。比如我们人脑识别香蕉。可能首先我们发现香蕉是黄色的。这是在颜色这个维度的一个切分。但是很多东西都是黄色的啊，例如哈密瓜。那么怎么区分香蕉和哈密瓜呢？我们发现香蕉形状是弯曲的。而哈密瓜是圆形的，那么我们就可以用形状来把香蕉和哈密瓜划分开了，即引入一个新维度：形状，来区分。这就是一个从“颜色”一维特征升维到二维特征的例子。</p><p>那问题来了，既然升维后模型能力能变强，那么是不是特征维度越高越好呢？为什么要进行特征降维&amp;特征选择？主要是出于如下考虑：1. 特征维数越高，模型越容易过拟合，此时更复杂的模型就不好用。2. 相互独立的特征维数越高，在模型不变的情况下，在测试集上达到相同的效果表现所需要的训练样本的数目就越大。 3. 特征数量增加带来的训练、测试以及存储的开销都会增大。4.在某些模型中，例如基于距离计算的模型KMeans，KNN等模型，在进行距离计算时，维度过高会影响精度和性能。5.可视化分析的需要。在低维的情况下，例如二维，三维，我们可以把数据绘制出来，可视化地看到数据。当维度增高时，就难以绘制出来了。在机器学习中，有一个非常经典的维度灾难的概念。用来描述当空间维度增加时，分析和组织高维空间，因体积指数增加而遇到各种问题场景。例如，100个平均分布的点能把一个单位区间以每个点距离不超过0.01采样；而当维度增加到10后，如果以相邻点距离不超过0.01小方格采样单位超一单位超正方体，则需要10^20 个采样点。</p><p>正是由于高维特征有如上描述的各种各样的问题，所以我们需要进行特征降维和特征选择等工作。特征降维常用的算法有PCA，LDA等。特征降维的目标是将高维空间中的数据集映射到低维空间数据，同时尽可能少地丢失信息，或者降维后的数据点尽可能地容易被区分</p><ul><li><p>PCA算法<br>通过协方差矩阵的特征值分解能够得到数据的主成分，以二维特征为例，两个特征之间可能存在线性关系（例如运动的时速和秒速度），这样就造成了第二维信息是冗余的。PCA的目标是发现这种特征之间的线性关系，并去除。</p></li><li><p>LDA算法<br>考虑label，降维后的数据点尽可能地容易被区分</p></li></ul><h3 id="6-3-特征选择"><a href="#6-3-特征选择" class="headerlink" title="6.3 特征选择"></a>6.3 特征选择</h3><p>特征选择的目标是寻找最优特征子集。特征选择能剔除不相关(irrelevant)或冗余(redundant )的特征，从而达到减少特征个数，提高模型精确度，减少运行时间的目的。另一方面，选取出真正相关的特征简化模型，协助理解数据产生的过程。</p><p>特征选择的一般过程如下图所示：<br><img src="http://omu7tit09.bkt.clouddn.com/15049336032351.png" alt=""><br>主要分为产生过程，评估过程，停止条件和验证过程。</p><h4 id="6-3-1-特征选择-产生过程和生成特征子集方法"><a href="#6-3-1-特征选择-产生过程和生成特征子集方法" class="headerlink" title="6.3.1 特征选择-产生过程和生成特征子集方法"></a>6.3.1 特征选择-产生过程和生成特征子集方法</h4><blockquote><p>完全搜索(Complete)</p></blockquote><ul><li>广度优先搜索( Breadth First Search )：广度优先遍历特征子空间。枚举所有组合，穷举搜索，实用性不高。</li><li>分支限界搜索( Branch and Bound )：穷举基础上加入分支限界。例如：剪掉某些不可能搜索出比当前最优解更优的分支。</li><li>其他，如定向搜索 (Beam Search )，最优优先搜索 ( Best First Search )等</li></ul><blockquote><p>启发式搜索(Heuristic)</p></blockquote><ul><li>序列前向选择( SFS ， Sequential Forward Selection )：从空集开始，每次加入一个选最优。</li><li>序列后向选择( SBS ， Sequential Backward Selection )：从全集开始，每次减少一个选最优。</li><li>增L去R选择算法 ( LRS ， Plus-L Minus-R Selection )：从空集开始，每次加入L个，减去R个，选最优（L&gt;R)或者从全集开始，每次减去R个，增加L个，选最优(L&lt;R)。</li></ul><p>其他如双向搜索( BDS ， Bidirectional Search )，序列浮动选择( Sequential Floating Selection )等</p><blockquote><p>随机搜索(Random)</p></blockquote><ul><li>随机产生序列选择算法(RGSS， Random Generation plus Sequential Selection)</li><li>随机产生一个特征子集，然后在该子集上执行SFS与SBS算法。</li><li>模拟退火算法( SA， Simulated Annealing )：以一定的概率来接受一个比当前解要差的解，而且这个概率随着时间推移逐渐降低</li><li>遗传算法( GA， Genetic Algorithms )：通过交叉、突变等操作繁殖出下一代特征子集，并且评分越高的特征子集被选中参加繁殖的概率越高。</li></ul><p>随机算法共同缺点:依赖随机因素，有实验结果难重现。</p><h4 id="6-3-2-特征选择－有效性分析"><a href="#6-3-2-特征选择－有效性分析" class="headerlink" title="6.3.2 特征选择－有效性分析"></a>6.3.2 特征选择－有效性分析</h4><p>对特征的有效性进行分析，得到各个特征的特征权重，根据是否与模型有关可以分为1.与模型相关特征权重，使用所有的特征数据训练出来模型，看在模型中各个特征的权重，由于需要训练出模型，模型相关的权重与此次学习所用的模型比较相关。不同的模型有不同的模型权重衡量方法。例如线性模型中，特征的权重系数等。2.与模型无关特征权重。主要分析特征与label的相关性，这样的分析是与这次学习所使用的模型无关的。与模型无关特征权重分析方法包括(1)交叉熵，(2)Information Gain，(3)Odds ratio，(4)互信息，(5)KL散度等</p><h2 id="七、特征监控"><a href="#七、特征监控" class="headerlink" title="七、特征监控"></a>七、特征监控</h2><p>在机器学习任务中，特征非常重要。</p><ul><li>个人经验，80%的效果由特征带来。下图是随着特征数的增加，最终模型预测值与实际值的相关系数变化。</li></ul><p><img src="http://omu7tit09.bkt.clouddn.com/15049337889760.png" alt=""></p><ul><li>对于重要的特征进行监控与有效性分析，了解模型所用的特征是否存在问题，当某个特别重要的特征出问题时，需要做好备案，防止灾难性结果。需要建立特征有效性的长效监控机制</li></ul><p>我们对关键特征进行了监控，下面特征监控界面的一个截图。通过监控我们发现有一个特征的覆盖率每天都在下降，与特征数据提供方联系之后，发现特征数据提供方的数据源存在着问题，在修复问题之后，该特征恢复正常并且覆盖率有了较大提升。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15049338172365.png" alt=""></p><p>在发现特征出现异常时，我们会及时采取措施，对服务进行降级处理，并联系特征数据的提供方尽快修复。对于特征数据生成过程中缺乏监控的情况也会督促做好监控，在源头解决问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h2&gt;&lt;p&gt;随着美团交易规模的逐步增大，积累下来的业务数据和交易数据越来越多，这些数据是美团做为一个团购平台最宝贵的财富。通过对这些数据的分析和挖掘，不仅能给美团业务发展方向提供决策支持，也为业务的迭代指明了方向。目前在美团的团购系统中大量地应用到了机器学习和数据挖掘技术，例如个性化推荐、筛选排序、搜索排序、用户建模等等，为公司创造了巨大的价值。&lt;br&gt;本文主要介绍在美团的推荐与个性化团队实践中的数据清洗与特征挖掘方法。主要内容已经在内部公开课”机器学习InAction系列”讲过，本博客的内容主要是讲座内容的提炼和总结。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="特征处理" scheme="http://yoursite.com/tags/%E7%89%B9%E5%BE%81%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>机器学习算法系列（39）：实例详解机器学习如何解决问题</title>
    <link href="http://yoursite.com/2017/09/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%8839%EF%BC%89%EF%BC%9A%E5%AE%9E%E4%BE%8B%E8%AF%A6%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/09/07/机器学习算法系列（39）：实例详解机器学习如何解决问题/</id>
    <published>2017-09-07T15:14:45.000Z</published>
    <updated>2017-12-26T08:04:45.604Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>随着大数据时代的到来，机器学习成为解决问题的一种重要且关键的工具。不管是工业界还是学术界，机器学习都是一个炙手可热的方向，但是学术界和工业界对机器学习的研究各有侧重，学术界侧重于对机器学习理论的研究，工业界侧重于如何用机器学习来解决实际问题。我们结合美团在机器学习上的实践，进行一个实战（InAction）系列的介绍（带“机器学习InAction系列”标签的文章），介绍机器学习在解决工业界问题的实战中所需的基本技术、经验和技巧。本文主要结合实际问题，概要地介绍机器学习解决实际问题的整个流程，包括对问题建模、准备训练数据、抽取特征、训练模型和优化模型等关键环节；另外几篇则会对这些关键环节进行更深入地介绍。</p><a id="more"></a><p>下文分为</p><ul><li>1）机器学习的概述，</li><li>2）对问题建模，</li><li>3）准备训练数据，</li><li>4）抽取特征，</li><li>5）训练模型，</li><li>6）优化模型，</li><li>7）总结 </li></ul><p>共7个章节进行介绍。</p><h2 id="二、机器学习的概述："><a href="#二、机器学习的概述：" class="headerlink" title="二、机器学习的概述："></a>二、机器学习的概述：</h2><h3 id="2-1-什么是机器学习？"><a href="#2-1-什么是机器学习？" class="headerlink" title="2.1 什么是机器学习？"></a>2.1 什么是机器学习？</h3><p>随着机器学习在实际工业领域中不断获得应用，这个词已经被赋予了各种不同含义。在本文中的“机器学习”含义与wikipedia上的解释比较契合，如下：<br>Machine learning is a scientific discipline that deals with the construction and study of algorithms that can learn from data.</p><p>机器学习可以分为无监督学习（unsupervised learning）和有监督学习（supervised learning），在工业界中，有监督学习是更常见和更有价值的方式，下文中主要以这种方式展开介绍。如下图中所示，有监督的机器学习在解决实际问题时，有两个流程，一个是离线训练流程（蓝色箭头），包含数据筛选和清洗、特征抽取、模型训练和优化模型等环节；另一个流程则是应用流程（绿色箭头），对需要预估的数据，抽取特征，应用离线训练得到的模型进行预估，获得预估值作用在实际产品中。在这两个流程中，离线训练是最有技术挑战的工作（在线预估流程很多工作可以复用离线训练流程的工作），所以下文主要介绍离线训练流程。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15049318784960.png" alt=""></p><h3 id="2-2-什么是模型？"><a href="#2-2-什么是模型？" class="headerlink" title="2.2 什么是模型？"></a>2.2 什么是模型？</h3><p>模型，是机器学习中的一个重要概念，简单的讲，指特征空间到输出空间的映射；一般由模型的假设函数和参数w组成（下面公式就是Logistic Regression模型的一种表达，在训练模型的章节做稍详细的解释）；一个模型的假设空间（hypothesis space），指给定模型所有可能w对应的输出空间组成的集合。工业界常用的模型有Logistic Regression（简称LR）、Gradient Boosting Decision Tree（简称GBDT）、Support Vector Machine（简称SVM）、Deep Neural Network（简称DNN）等。<br><img src="http://omu7tit09.bkt.clouddn.com/15049319158292.jpg" alt=""></p><p>模型训练就是基于训练数据，获得一组参数w，使得特定目标最优，即获得了特征空间到输出空间的最优映射，具体怎么实现，见训练模型章节。</p><h3 id="2-3-为什么要用机器学习解决问题？"><a href="#2-3-为什么要用机器学习解决问题？" class="headerlink" title="2.3 为什么要用机器学习解决问题？"></a>2.3 为什么要用机器学习解决问题？</h3><ul><li>目前处于大数据时代，到处都有成T成P的数据，简单规则处理难以发挥这些数据的价值；</li><li>廉价的高性能计算，使得基于大规模数据的学习时间和代价降低；</li><li>廉价的大规模存储，使得能够更快地和代价更小地处理大规模数据；</li><li>存在大量高价值的问题，使得花大量精力用机器学习解决问题后，能获得丰厚收益。</li></ul><h3 id="2-4-机器学习应该用于解决什么问题？"><a href="#2-4-机器学习应该用于解决什么问题？" class="headerlink" title="2.4 机器学习应该用于解决什么问题？"></a>2.4 机器学习应该用于解决什么问题？</h3><ul><li>目标问题需要价值巨大，因为机器学习解决问题有一定的代价；</li><li>目标问题有大量数据可用，有大量数据才能使机器学习比较好地解决问题（相对于简单规则或人工）；</li><li>目标问题由多种因素（特征）决定，机器学习解决问题的优势才能体现（相对于简单规则或人工）；</li><li>目标问题需要持续优化，因为机器学习可以基于数据自我学习和迭代，持续地发挥价值。</li></ul><h2 id="三、对问题建模"><a href="#三、对问题建模" class="headerlink" title="三、对问题建模"></a>三、对问题建模</h2><p>本文以DEAL（团购单）交易额预估问题为例（就是预估一个给定DEAL一段时间内卖了多少钱），介绍使用机器学习如何解决问题。首先需要：</p><ul><li>收集问题的资料，理解问题，成为这个问题的专家；</li><li>拆解问题，简化问题，将问题转化机器可预估的问题。</li></ul><p>深入理解和分析DEAL交易额后，可以将它分解为如下图的几个问题：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15049320386400.png" alt=""></p><h3 id="3-1-单个模型？多个模型？如何来选择？"><a href="#3-1-单个模型？多个模型？如何来选择？" class="headerlink" title="3.1 单个模型？多个模型？如何来选择？"></a>3.1 单个模型？多个模型？如何来选择？</h3><p>按照上图进行拆解后，预估DEAL交易额就有2种可能模式，一种是直接预估交易额；另一种是预估各子问题，如建立一个用户数模型和建立一个访购率模型（访问这个DEAL的用户会购买的单子数），再基于这些子问题的预估值计算交易额。</p><p>不同方式有不同优缺点，具体如下：<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-09-09 下午12.41.37.png" alt="屏幕快照 2017-09-09 下午12.41.37"></p><p>选择哪种模式？</p><ul><li>1）问题可预估的难度，难度大，则考虑用多模型；</li><li>2）问题本身的重要性，问题很重要，则考虑用多模型；</li><li>3）多个模型的关系是否明确，关系明确，则可以用多模型。</li></ul><p>如果采用多模型，如何融合？</p><ul><li>可以根据问题的特点和要求进行线性融合，或进行复杂的融合。以本文问题为例，至少可以有如下两种：</li></ul><p><img src="http://omu7tit09.bkt.clouddn.com/15049321442593.png" alt=""></p><h3 id="3-2-模型选择"><a href="#3-2-模型选择" class="headerlink" title="3.2 模型选择"></a>3.2 模型选择</h3><p>对于DEAL交易额这个问题，我们认为直接预估难度很大，希望拆成子问题进行预估，即多模型模式。那样就需要建立用户数模型和访购率模型，因为机器学习解决问题的方式类似，下文只以访购率模型为例。要解决访购率问题，首先要选择模型，我们有如下的一些考虑：</p><blockquote><p>主要考虑</p></blockquote><ul><li>1）选择与业务目标一致的模型；</li><li>2）选择与训练数据和特征相符的模型。</li></ul><p>训练数据少，High Level特征多，则使用“复杂”的非线性模型（流行的GBDT、Random Forest等）；</p><p>训练数据很大量，Low Level特征多，则使用“简单”的线性模型（流行的LR、Linear-SVM等）。</p><blockquote><p>补充考虑</p></blockquote><p>1）当前模型是否被工业界广泛使用；<br>2）当前模型是否有比较成熟的开源工具包（公司内或公司外）；<br>3）当前工具包能够的处理数据量能否满足要求；<br>4）自己对当前模型理论是否了解，是否之前用过该模型解决问题。</p><p>为实际问题选择模型，需要转化问题的业务目标为模型评价目标，转化模型评价目标为模型优化目标；根据业务的不同目标，选择合适的模型，具体关系如下：<br><img src="http://omu7tit09.bkt.clouddn.com/15049322585629.png" alt=""></p><p>通常来讲，预估真实数值（回归）、大小顺序（排序）、目标所在的正确区间（分类）的难度从大到小，根据应用所需，尽可能选择难度小的目标进行。对于访购率预估的应用目标来说，我们至少需要知道大小顺序或真实数值，所以我们可以选择Area Under Curve（AUC）或Mean Absolute Error（MAE）作为评估目标，以Maximum likelihood为模型损失函数（即优化目标）。综上所述，我们选择spark版本 GBDT或LR，主要基于如下考虑：</p><p>1）可以解决排序或回归问题；<br>2）我们自己实现了算法，经常使用，效果很好；<br>3）支持海量数据；<br>4）工业界广泛使用。</p><h2 id="四、准备训练数据"><a href="#四、准备训练数据" class="headerlink" title="四、准备训练数据"></a>四、准备训练数据</h2><p>深入理解问题，针对问题选择了相应的模型后，接下来则需要准备数据；数据是机器学习解决问题的根本，数据选择不对，则问题不可能被解决，所以准备训练数据需要格外的小心和注意：</p><h3 id="4-1-注意点："><a href="#4-1-注意点：" class="headerlink" title="4.1 注意点："></a>4.1 注意点：</h3><p>待解决问题的数据本身的分布尽量一致；<br>训练集/测试集分布与线上预测环境的数据分布尽可能一致，这里的分布是指（x,y）的分布，不仅仅是y的分布；<br>y数据噪音尽可能小，尽量剔除y有噪音的数据；<br>非必要不做采样，采样常常可能使实际数据分布发生变化，但是如果数据太大无法训练或者正负比例严重失调（如超过100:1）,则需要采样解决。</p><h3 id="4-2-常见问题及解决办法"><a href="#4-2-常见问题及解决办法" class="headerlink" title="4.2 常见问题及解决办法"></a>4.2 常见问题及解决办法</h3><p>待解决问题的数据分布不一致：<br>1）访购率问题中DEAL数据可能差异很大，如美食DEAL和酒店DEAL的影响因素或表现很不一致，需要做特别处理；要么对数据提前归一化，要么将分布不一致因素作为特征，要么对各类别DEAL单独训练模型。<br>数据分布变化了：<br>1）用半年前的数据训练模型，用来预测当前数据，因为数据分布随着时间可能变化了，效果可能很差。尽量用近期的数据训练，来预测当前数据，历史的数据可以做降权用到模型，或做transfer learning。<br>y数据有噪音：<br>1）在建立CTR模型时，将用户没有看到的Item作为负例，这些Item是因为用户没有看到才没有被点击，不一定是用户不喜欢而没有被点击，所以这些Item是有噪音的。可以采用一些简单规则，剔除这些噪音负例，如采用skip-above思想，即用户点过的Item之上，没有点过的Item作为负例（假设用户是从上往下浏览Item）。<br>采样方法有偏，没有覆盖整个集合：<br>1）访购率问题中，如果只取只有一个门店的DEAL进行预估，则对于多门店的DEAL无法很好预估。应该保证一个门店的和多个门店的DEAL数据都有；<br>2）无客观数据的二分类问题，用规则来获得正/负例，规则对正/负例的覆盖不全面。应该随机抽样数据，进行人工标注，以确保抽样数据和实际数据分布一致。</p><h3 id="4-3-访购率问题的训练数据"><a href="#4-3-访购率问题的训练数据" class="headerlink" title="4.3 访购率问题的训练数据"></a>4.3 访购率问题的训练数据</h3><p>收集N个月的DEAL数据（x）及相应访购率（y）；<br>收集最近N个月，剔除节假日等非常规时间 （保持分布一致）；<br>只收集在线时长&gt;T 且 访问用户数 &gt; U的DEAL （减少y的噪音）；<br>考虑DEAL销量生命周期 （保持分布一致）；<br>考虑不同城市、不同商圈、不同品类的差别 （保持分布一致）。</p><h2 id="五、抽取特征"><a href="#五、抽取特征" class="headerlink" title="五、抽取特征"></a>五、抽取特征</h2><p>完成数据筛选和清洗后，就需要对数据抽取特征，就是完成输入空间到特征空间的转换（见下图）。针对线性模型或非线性模型需要进行不同特征抽取，线性模型需要更多特征抽取工作和技巧，而非线性模型对特征抽取要求相对较低。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15049324768552.png" alt=""></p><p>通常，特征可以分为High Level与Low Level，High Level指含义比较泛的特征，Low Level指含义比较特定的特征，举例来说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">DEAL A1属于POIA，人均50以下，访购率高；</div><div class="line">DEAL A2属于POIA，人均50以上，访购率高；</div><div class="line">DEAL B1属于POIB，人均50以下，访购率高；</div><div class="line">DEAL B2属于POIB，人均50以上，访购率底；</div></pre></td></tr></table></figure><p>基于上面的数据，可以抽到两种特征，POI（门店）或人均消费；POI特征则是Low Level特征，人均消费则是High Level特征；假设模型通过学习，获得如下预估：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">如果DEALx 属于POIA（Low Level feature），访购率高；</div><div class="line">如果DEALx 人均50以下（High Level feature），访购率高。</div></pre></td></tr></table></figure><p>所以，总体上，Low Level 比较有针对性，单个特征覆盖面小（含有这个特征的数据不多），特征数量（维度）很大。High Level比较泛化，单个特征覆盖面大（含有这个特征的数据很多），特征数量（维度）不大。长尾样本的预测值主要受High Level特征影响。高频样本的预测值主要受Low Level特征影响。</p><p>对于访购率问题，有大量的High Level或Low Level的特征，其中一些展示在下图：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15049325864156.png" alt=""></p><p>非线性模型的特征</p><ul><li>1）可以主要使用High Level特征，因为计算复杂度大，所以特征维度不宜太高；</li><li>2）通过High Level非线性映射可以比较好地拟合目标。</li></ul><p>线性模型的特征</p><ul><li>1）特征体系要尽可能全面，High Level和Low Level都要有；</li><li>2）可以将High Level转换Low Level，以提升模型的拟合能力。</li></ul><h3 id="5-1-特征归一化"><a href="#5-1-特征归一化" class="headerlink" title="5.1 特征归一化"></a>5.1 特征归一化</h3><p>特征抽取后，如果不同特征的取值范围相差很大，最好对特征进行归一化，以取得更好的效果，常见的归一化方式如下：</p><ul><li><p>Rescaling：<br>归一化到[0,1] 或 [-1，1]，用类似方式：<br><img src="http://omu7tit09.bkt.clouddn.com/15049326747797.jpg" alt=""></p></li><li><p>Standardization：<br>设为x分布的均值，为x分布的标准差；<br><img src="http://omu7tit09.bkt.clouddn.com/15049327022087.jpg" alt=""></p></li><li><p>Scaling to unit length：<br>归一化到单位长度向量<br><img src="http://omu7tit09.bkt.clouddn.com/15049327222282.jpg" alt=""></p></li></ul><h3 id="5-2-特征选择"><a href="#5-2-特征选择" class="headerlink" title="5.2 特征选择"></a>5.2 特征选择</h3><p>特征抽取和归一化之后，如果发现特征太多，导致模型无法训练，或很容易导致模型过拟合，则需要对特征进行选择，挑选有价值的特征。</p><ul><li><p>Filter：<br>假设特征子集对模型预估的影响互相独立，选择一个特征子集，分析该子集和数据Label的关系，如果存在某种正相关，则认为该特征子集有效。衡量特征子集和数据Label关系的算法有很多，如Chi-square，Information Gain。</p></li><li><p>Wrapper：<br>选择一个特征子集加入原有特征集合，用模型进行训练，比较子集加入前后的效果，如果效果变好，则认为该特征子集有效，否则认为无效。</p></li><li><p>Embedded：<br>将特征选择和模型训练结合起来，如在损失函数中加入L1 Norm ，L2 Norm。</p></li></ul><h2 id="六、训练模型"><a href="#六、训练模型" class="headerlink" title="六、训练模型"></a>六、训练模型</h2><p>完成特征抽取和处理后，就可以开始模型训练了，下文以简单且常用的Logistic Regression模型（下称LR模型）为例，进行简单介绍。</p><p>设有m个（x,y）训练数据，其中x为特征向量，y为label，；w为模型中参数向量，即模型训练中需要学习的对象。<br>所谓训练模型，就是选定假说函数和损失函数，基于已有训练数据（x,y），不断调整w，使得损失函数最优，相应的w就是最终学习结果，也就得到相应的模型。</p><h3 id="6-1-模型函数"><a href="#6-1-模型函数" class="headerlink" title="6.1 模型函数"></a>6.1 模型函数</h3><p>假说函数，即假设x和y存在一种函数关系：<br><img src="http://omu7tit09.bkt.clouddn.com/15049328059857.jpg" alt=""></p><p>损失函数，基于上述假设函数，构建模型损失函数（优化目标），在LR中通常以（x,y）的最大似然估计为目标：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15049328618956.jpg" alt=""></p><h3 id="6-2-优化算法"><a href="#6-2-优化算法" class="headerlink" title="6.2 优化算法"></a>6.2 优化算法</h3><ul><li>梯度下降（Gradient Descent）<br>即w沿着损失函数的负梯度方向进行调整，示意图见下图，的梯度即一阶导数（见下式），梯度下降有多种类型，如随机梯度下降或批量梯度下降。<br><img src="http://omu7tit09.bkt.clouddn.com/15049328995925.jpg" alt=""><br>随机梯度下降（Stochastic Gradient Descent），每一步随机选择一个样本，计算相应的梯度，并完成w的更新，如下式，<br><img src="http://omu7tit09.bkt.clouddn.com/15049329100270.jpg" alt=""></li></ul><p>批量梯度下降（Batch Gradient Descent）,每一步都计算训练数据中的所有样本对应的梯度，w沿着这个梯度方向迭代，即<br><img src="http://omu7tit09.bkt.clouddn.com/15049329245601.jpg" alt=""></p><p><img src="http://omu7tit09.bkt.clouddn.com/15049329425541.png" alt=""></p><ul><li>牛顿法（Newton’s Method）</li></ul><p>牛顿法的基本思想是在极小点附近通过对目标函数做二阶Taylor展开，进而找到L(w)的极小点的估计值。形象地讲，在wk处做切线，该切线与L(w)=0的交点即为下一个迭代点wk+1（示意图如下）。w的更新公式如下，其中目标函数的二阶偏导数，即为大名鼎鼎的Hessian矩阵。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15049329695345.jpg" alt=""></p><p>拟牛顿法（Quasi-Newton Methods）：计算目标函数的二阶偏导数，难度较大，更为复杂的是目标函数的Hessian矩阵无法保持正定；不用二阶偏导数而构造出可以近似Hessian矩阵的逆的正定对称阵，从而在”拟牛顿”的条件下优化目标函数。</p><p>BFGS： 使用BFGS公式对H(w)进行近似，内存中需要放H(w),内存需要O(m2)级别；</p><p>L-BFGS：存储有限次数（如k次）的更新矩阵，用这些更新矩阵生成新的H(w),内存降至O(m)级别；</p><p>OWLQN: 如果在目标函数中引入L1正则化，需要引入虚梯度来解决目标函数不可导问题，OWLQN就是用来解决这个问题。<br><img src="http://omu7tit09.bkt.clouddn.com/15049330065987.png" alt=""></p><ul><li>Coordinate Descent<br>对于w，每次迭代，固定其他维度不变，只对其一个维度进行搜索，确定最优下降方向（示意图如下），公式表达如下：</li></ul><p><img src="http://omu7tit09.bkt.clouddn.com/15049330264923.jpg" alt=""><br><img src="http://omu7tit09.bkt.clouddn.com/15049330405131.jpg" alt=""></p><h2 id="七、优化模型"><a href="#七、优化模型" class="headerlink" title="七、优化模型"></a>七、优化模型</h2><p>经过上文提到的数据筛选和清洗、特征设计和选择、模型训练，就得到了一个模型，但是如果发现效果不好？怎么办？</p><p>【首先】<br>反思目标是否可预估，数据和特征是否存在bug。</p><p>【然后】<br>分析一下模型是Overfitting还是Underfitting，从数据、特征和模型等环节做针对性优化。</p><h3 id="7-1-Underfitting-amp-Overfitting"><a href="#7-1-Underfitting-amp-Overfitting" class="headerlink" title="7.1 Underfitting &amp; Overfitting"></a>7.1 Underfitting &amp; Overfitting</h3><p>所谓Underfitting，即模型没有学到数据内在关系，如下图左一所示，产生分类面不能很好的区分X和O两类数据；产生的深层原因，就是模型假设空间太小或者模型假设空间偏离。<br>所谓Overfitting，即模型过渡拟合了训练数据的内在关系，如下图右一所示，产生分类面过好地区分X和O两类数据，而真实分类面可能并不是这样，以至于在非训练数据上表现不好；产生的深层原因，是巨大的模型假设空间与稀疏的数据之间的矛盾。<br><img src="http://omu7tit09.bkt.clouddn.com/15049330908787.png" alt=""></p><p>在实战中，可以基于模型在训练集和测试集上的表现来确定当前模型到底是Underfitting还是Overfitting，判断方式如下表：<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-09-09 下午12.58.26.png" alt="屏幕快照 2017-09-09 下午12.58.26"></p><h3 id="7-2-怎么解决Underfitting和Overfitting问题？"><a href="#7-2-怎么解决Underfitting和Overfitting问题？" class="headerlink" title="7.2 怎么解决Underfitting和Overfitting问题？"></a>7.2 怎么解决Underfitting和Overfitting问题？</h3><p><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-09-09 下午12.59.02.png" alt="屏幕快照 2017-09-09 下午12.59.02"></p><h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>综上所述，机器学习解决问题涉及到问题建模、准备训练数据、抽取特征、训练模型和优化模型等关键环节，有如下要点：</p><ul><li><p>理解业务，分解业务目标，规划模型可预估的路线图。</p></li><li><p>数据：y数据尽可能真实客观；训练集/测试集分布与线上应用环境的数据分布尽可能一致。</p></li><li><p>特征：利用Domain Knowledge进行特征抽取和选择；针对不同类型的模型设计不同的特征。</p></li><li><p>模型：针对不同业务目标、不同数据和特征，选择不同的模型；如果模型不符合预期，一定检查一下数据、特征、模型等处理环节是否有bug；考虑模型Underfitting和Qverfitting，针对性地优化。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;随着大数据时代的到来，机器学习成为解决问题的一种重要且关键的工具。不管是工业界还是学术界，机器学习都是一个炙手可热的方向，但是学术界和工业界对机器学习的研究各有侧重，学术界侧重于对机器学习理论的研究，工业界侧重于如何用机器学习来解决实际问题。我们结合美团在机器学习上的实践，进行一个实战（InAction）系列的介绍（带“机器学习InAction系列”标签的文章），介绍机器学习在解决工业界问题的实战中所需的基本技术、经验和技巧。本文主要结合实际问题，概要地介绍机器学习解决实际问题的整个流程，包括对问题建模、准备训练数据、抽取特征、训练模型和优化模型等关键环节；另外几篇则会对这些关键环节进行更深入地介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习算法系列（38）：外卖订单量预测异常报警模型实践</title>
    <link href="http://yoursite.com/2017/09/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%8838%EF%BC%89%EF%BC%9A%E5%A4%96%E5%8D%96%E8%AE%A2%E5%8D%95%E9%87%8F%E9%A2%84%E6%B5%8B%E5%BC%82%E5%B8%B8%E6%8A%A5%E8%AD%A6%E6%A8%A1%E5%9E%8B%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2017/09/06/机器学习算法系列（38）：外卖订单量预测异常报警模型实践/</id>
    <published>2017-09-06T15:14:45.000Z</published>
    <updated>2017-12-26T08:04:42.828Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>外卖业务的快速发展对系统稳定性提出了更高的要求，每一次订单量大盘的异常波动，都需要做出及时的应对，以保证系统的整体稳定性。如何做出较为准确的波动预警，显得尤为重要。</p><a id="more"></a><p>从时间上看，外卖订单量时间序列有两个明显的特征（如下图所示）：</p><p>周期性。每天订单量的变化趋势都大致相同，午高峰和晚高峰订单量集中。<br>实时性。当天的订单量可能会受天气等因素影响，呈现整体的上涨或下降。<br>订单量波动预警，初期外卖订单中心使用的是当前时刻和前一时刻订单量比较，超过一定阈值就报警的方式，误报率和漏报率都比较大。后期将业务数据上传到美团点评的服务治理平台，使用该平台下的基线报警模型进行监控报警。基线数据模型考虑到了订单量时间序列的周期性特征，但是忽略了实时性特征，在实际使用中误报率依然很高，大量的误报漏报导致RD对于报警已经麻木，出现问题时不能及时响应，因此，急需一种新的异常检测模型，提高报警的准确率。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15049303473058.png" alt=""></p><h2 id="二、异常检测的定义"><a href="#二、异常检测的定义" class="headerlink" title="二、异常检测的定义"></a>二、异常检测的定义</h2><p>异常，意为“异于正常”。异常检测，就是从一组数据中寻找那些和期望数据不同的数据。监控数据都是和时间相关的，每一个监控指标只有和时间组合一起才有其具体的含义。按照时间顺序，将监控指标组成一个序列，我们就得到了监控指标的时间序列。</p><p>基于预测的异常检测模型如下图所示，xt是真实数据，通过预测器得到预测数据，然后xt和pt分别作为比较器的输入，最终得到输出yt。yt是一个二元值，可以用+1（+1表示输入数据正常），-1（-1表示输入数据异常）表示。<br><img src="http://omu7tit09.bkt.clouddn.com/15049303904786.png" alt=""></p><p>异常检测主要有两种策略：</p><ul><li>异常驱动的异常检测（敏感性）：宁愿误报，也不能错过任何一个异常，这适用于非常重要的检测。简单概括，就是“宁可错杀一千，不能放过一个”。</li><li>预算驱动的异常检测（准确性）：这种策略的异常检测，从字面理解就是只有定量的一些预算去处理这些报警，那么只能当一定是某种问题时，才能将报警发送出来。</li></ul><p>这两种策略不可兼容的。对于检测模型的改善，可以从两个方面入手，一是预测器的优化，二是比较器的优化。我们从这两个方面描述模型的改善。</p><h2 id="三、预测器设计"><a href="#三、预测器设计" class="headerlink" title="三、预测器设计"></a>三、预测器设计</h2><p>预测器，就是用一批历史数据预测当前的数据。使用的历史数据集大小，以及使用的预测算法都会影响最终的预测效果。</p><p>外卖订单量具有明显的周期性，同时相邻时刻的订单量数据也有很强的相关性，我们的目标，就是使用上面说的相关数据预测出当前的订单量。下面，我们分析几种常用的预测器实现。</p><h3 id="3-1-同比环比预测器"><a href="#3-1-同比环比预测器" class="headerlink" title="3.1 同比环比预测器"></a>3.1 同比环比预测器</h3><p>同比环比是比较常用的异常检测方式，它是将当前时刻数据和前一时刻数据（环比）或者前一天同一时刻数据（同比）比较，超过一定阈值即认为该点异常。如果用图2.1模型来表示，那么预测器就可以表示为用当前时刻前一时刻或者前一天同一时刻数据作为当前时刻的预测数据。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15049304701237.png" alt=""></p><p>假如需要预测图中黄色数据，那么环比使用图中的蓝色数据作为预测黄点的源数据，同比使用图中红色数据作为预测黄点的源数据。</p><h3 id="3-2-基线预测器"><a href="#3-2-基线预测器" class="headerlink" title="3.2 基线预测器"></a>3.2 基线预测器</h3><p>同比环比使用历史上的单点数据来预测当前数据，误差比较大。t时刻的监控数据，与<br>$t-1,t-2,…$时刻的监控数据存在相关性。同时，与$t-k,t-2k,…$时刻的数据也存在相关性（k为周期），如果能利用上这些相关数据对t时刻进行预测，预测结果的误差将会更小。</p><p>比较常用的方式是对历史数据求平均，然后过滤噪声，可以得到一个平滑的曲线（基线），使用基线数据来预测当前时刻的数据。该方法预测t时刻数据（图中黄色数据）使用到的历史数据如下图所示（图中红色数据）：<br><img src="http://omu7tit09.bkt.clouddn.com/15049305406119.png" alt=""></p><p>基线数据预测器广泛应用在业务大盘监控中，预测效果如图3.3所示。从图中可以看出，基线比较平滑，在低峰期预测效果比较好，但是在外卖的午高峰和晚高峰预测误差比较大。<br><img src="http://omu7tit09.bkt.clouddn.com/15049305780074.png" alt=""></p><h3 id="3-3-Holt-Winters预测器"><a href="#3-3-Holt-Winters预测器" class="headerlink" title="3.3 Holt-Winters预测器"></a>3.3 Holt-Winters预测器</h3><p>同比环比预测到基线数据预测，使用的相关数据变多，预测的效果也较好。但是基线数据预测器只使用了周期相关的历史数据，没有使用上同周期相邻时刻的历史数据，相邻时刻的历史数据对于当前时刻的预测影响是比较大的。如外卖订单量，某天天气不好，很多用户不愿意出门，那么当天的外卖的订单量就会呈现整体的上涨，这种整体上涨趋势只能从同一周期相邻时刻的历史数据中预测出来。如图3.4所示，预测图中黄色数据，如果使用上图中所有的红色数据，那么预测效果会更好。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15049306111501.png" alt=""></p><p>本文使用了Holt-Winters来实现这一目标。</p><p>Holt-Winters是三次指数滑动平均算法，它将时间序列数据分为三部分：残差数据a(t)，趋势性数据b(t)，季节性数据s(t)。使用Holt-Winters预测t时刻数据，需要t时刻前包含多个周期的历史数据。相关链接：Exponential smoothing、Holt-Winters seasonal method。</p><p>各部分的迭代计算公式（周期为k）：<br><img src="http://omu7tit09.bkt.clouddn.com/15049307018880.png" alt=""></p><p>如图所示，(a)显示了某一段时间内外卖订单的原始提单监控数据（分钟统计量，周期为1天），图(b)显示了其Holt-Winters的分解图（四幅图分别对应原始数据、残差数据分量、趋势数据分量、周期数据分量）。将订单量时间序列分解为残差数据a(t)，趋势数据b(t)，周期数据s(t)后，就可以使用下面的公式预测未来不同时刻时刻的订单量，其中h表示未来时刻距离当前时刻的跨度。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15049307371760.png" alt=""></p><p>外卖订单量，是按分钟统计的离散时间序列，所以如果需要预测下一分钟的订单量，令h=1。<br><img src="http://omu7tit09.bkt.clouddn.com/15049307830931.png" alt=""><br><img src="http://omu7tit09.bkt.clouddn.com/15049307692132.png" alt=""></p><h3 id="3-4-外卖报警模型中的预测器"><a href="#3-4-外卖报警模型中的预测器" class="headerlink" title="3.4 外卖报警模型中的预测器"></a>3.4 外卖报警模型中的预测器</h3><p>在外卖订单量异常检测中，使用Holt-Winters预测器实时预测下一分钟订单量，每次需要至少5天以上的订单量数据才能有较好的预测效果，数据量要求比较大。</p><p>在实际的异常检测模型中，我们对Holt-Winters预测器进行了简化。预测器的趋势数据表示的是时间序列的总体变化趋势，如果以天为周期看待外卖的订单量时间序列，是没有明显的趋势性的，图3.5(b)的分解图也证明了这一点。因此，我们可以去掉其中的趋势数据部分。</p><p>各部分的迭代公式简化为(3-1)：<br><img src="http://omu7tit09.bkt.clouddn.com/15049308308252.png" alt=""></p><p>预测值：<br><img src="http://omu7tit09.bkt.clouddn.com/15049308423699.png" alt=""></p><p>h越大，预测值Yhat[t+h] 的误差也就越大。实时的订单流监控，令h=1，每当有新的监控数据时，更新输入序列，然后预测下一分钟数据。<br><img src="http://omu7tit09.bkt.clouddn.com/15049308574294.png" alt=""></p><p>Holt-Winters每一次预测都需要大量的输入数据序列。从上面模型的简化公式可以看出，对残差数据a(t)的预测是对序列(a(t-m),a(t-m+1),…a(t-2),a(t-1))的一次指数滑动平均，对周期数据s(t)的预测是对序列（s(t-mk) ,s(t-(m-1)k),…s(t-k)）的一次滑动平均，大量的输入数据是用于周期数据s(t)的计算。</p><p>a(t)和s(t)是互相关联的迭代计算过程，如果从周期性角度看公式(3-1)，可以发现：计算当前周期内的a(t)时，使用的是上一周期计算出来的s(t-k)，当前周期计算出的s(t)是用于下一周期a(t+k)的计算。为了将算法应用到线上的实时预测，我们可以将Holt-Winters算法拆分为两个独立的计算过程：</p><ul><li>定时任务计算序列的周期数s(t)。</li><li>对残差序列做实时预测。</li></ul><p>下面就分别从这两个步骤介绍外卖报警模型中的预测器实现。</p><h4 id="3-4-1-计算序列的周期性数据"><a href="#3-4-1-计算序列的周期性数据" class="headerlink" title="3.4.1 计算序列的周期性数据"></a>3.4.1 计算序列的周期性数据</h4><p>时间序列的周期性数据不需要实时计算，按周期性更新即可，如外卖订单大盘监控，s(t)只需要每天更新一次即可。对于s(t)的计算，可以有多种方法，可以使用上面提到的Holt-Winters按公式(3-1)计算出时间序列的周期性数据（如图3.5b所示），或直接使用前一天的监控数据作为当天的周期数据（这两种方式都需要对输入序列进行预处理，保证算法的输入序列不含有异常数据）。也可以用上面3.2节提到的，将历史数据做平均求出基线作为序列的周期性数据。</p><p>目前外卖订单中心报警模型采用的是Holt-Winters计算周期数据的方式。在将该模型推广到外卖其他业务线监控时，使用了计算基线数据作为周期数据的方式，这里简单对比一下两种方式的优劣。</p><blockquote><p>使用Holt-Winters算法计算周期数据</p></blockquote><p>优点：如果序列中含有周期性的陡增陡降点，Holt-Winters计算出的周期数据中会保留这些陡增陡降趋势，因此可以准确的预测出这些趋势，不会产生误报。比如外卖订单的提单数据，在每天的某个时刻都有一个定期陡降，使用该方式可以正确的预测出下降的趋势。如图3.6所示，蓝色线是真实数据，棕色线是预测数据，在该时刻，棕色线准确的预测出了下降点。</p><p>缺点：需要对输入数据进行预处理，去除异常数据。如果输入序列中含有异常数据，使用Holt-Winters时可能会把这些异常数据计算到周期数据中，影响下一周期的预测从而产生误报（Holt-Winters理论上也只是滑动平均的过程，因此如果输入数据中含有比较大的异常数据时，存在这种可能性，实际应用中订单的报警模型也出现过这种误报）。<br><img src="http://omu7tit09.bkt.clouddn.com/15049309740692.png" alt=""></p><blockquote><p>历史数据平均求基线</p></blockquote><p>优点：计算出的周期数据比较平滑，不需要对输入序列进行预处理，计算过程中可以自动屏蔽掉异常数据的影响，计算过程简单，如图3.3所示的基线数据。<br>缺点：周期数据比较平滑，不会出现陡增陡降点，因此对于周期性出现的陡增陡降不能很好的预测，出现误报。比如外卖活动的大盘（如图3.7所示，红线是真实数据，黑线是预测数据），提前下单优惠在每天某个时刻会出现周期性陡降，使用该方式会出现误报。<br><img src="http://omu7tit09.bkt.clouddn.com/15049309933978.png" alt=""></p><p>两种求周期数据的方式各有优劣，可以根据各自的监控数据特点选择合适的计算方式。如果监控数据中含有大量的周期性的陡增陡降点，那么推荐使用方式1，可以避免在这些时间点的误报。如果监控数据比较平滑，陡增陡降点很少，那么推荐方式2，计算简单的同时，也能避免因输入数据预处理不好而造成的意料之外的误报。</p><h4 id="3-4-2-残差数据实时预测"><a href="#3-4-2-残差数据实时预测" class="headerlink" title="3.4.2 残差数据实时预测"></a>3.4.2 残差数据实时预测</h4><p>计算出周期数据后，下一个目标就是对残差数据的预测。使用下面的公式，实际监控数据与周期数据相减得到残差数据，对残差数据做一次滑动平均，预测出下一刻的残差，将该时刻的残差、周期数据相加即可得到该时刻的预测数据。残差序列的长度设为60，即可以得到比较准确的预测效果。<br><img src="http://omu7tit09.bkt.clouddn.com/15049310383778.png" alt=""></p><p>对于实时预测，使用的是当天的周期数据和前60分钟数据。最终的预测结果如图3.8(a)(b)所示，其中蓝色线是真实数据，红色线是预测数据。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15049310554367.png" alt=""><br><img src="http://omu7tit09.bkt.clouddn.com/15049310659176.png" alt=""></p><h2 id="四、比较器设计"><a href="#四、比较器设计" class="headerlink" title="四、比较器设计"></a>四、比较器设计</h2><p>预测器预测出当前时刻订单量的预测值后，还需要与真实值比较来判断当前时刻订单量是否异常。一般的比较器都是通过阈值法，比如实际值超过预测值的一定比例就认为该点出现异常，进行报警。这种方式错误率比较大。在订单模型的报警检测中没有使用这种方式，而是使用了两个串联的Filter（如图4.1所示），只有当两个Fliter都认为该点异常时，才进行报警，下面简单介绍一下两个Filter的实现。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15049310861803.png" alt=""></p><p>离散度Filter：根据预测误差曲线离散程度过滤出可能的异常点。一个序列的方差表示该序列离散的程度，方差越大，表明该序列波动越大。如果一个预测误差序列方差比较大，那么我们认为预测误差的报警阈值相对大一些才比较合理。离散度Filter利用了这一特性，取连续15分钟的预测误差序列，分为首尾两个序列（e1,e2），如果两个序列的均值差大于e1序列方差的某个倍数，我们就认为该点可能是异常点。</p><p>阈值Filter：根据误差绝对值是否超过某个阈值过滤出可能的异常点。利用离散度Filter进行过滤时，报警阈值随着误差序列波动程度变大而变大，但是在输入数据比较小时，误差序列方差比较小，报警阈值也很小，容易出现误报。所以设计了根据误差绝对值进行过滤的阈值Filter。阈值Filter设计了一个分段阈值函数y=f(x)，对于实际值x和预测值p，只有当|x-p|&gt;f(x)时报警。实际使用中，可以寻找一个对数函数替换分段阈值函数，更易于参数调优。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15049311196340.png" alt=""></p><h2 id="五、报警模型最终效果"><a href="#五、报警模型最终效果" class="headerlink" title="五、报警模型最终效果"></a>五、报警模型最终效果</h2><p>最终的外卖订单异常报警模型结构图如图5.1所示，每天会有定时Job从ETL中统计出最近10天的历史订单量，经过预处理模块，去除异常数据，经过周期数据计算模块得到周期性数据。对当前时刻预测时，取60分钟的真实数据和周期性数据，经过实时预测模块，预测出当前订单量。将连续15分钟的预测值和真实值通过比较器，判断当前时刻是否异常。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15049311452338.png" alt=""></p><p>新的报警模型上线后，外卖订单量的异常检测的漏报率和误报率都有显著的提升，上线半年以来，对于每一次的异常都能准确的检测出来，漏报率近乎为0。误报率在通常情况下限制在了每周0~3次误报。</p><p>报警模型目前应用在外卖订单量的异常检测中，同时推广到了外卖业务的其他各种大盘监控中，取得了不错的效果。在报警模型上线后，我们发现并解决了一些系统隐患点，如：</p><ul><li>点评侧外卖提单量在每天定时有一个下降尖刺，经过排查是因为客户端冷启动短时间内大量的请求，导致SLB性能达到瓶颈，从而导致接口成功率下降。</li><li>点评侧外卖订单取消量经常会有尖刺，经过排查发现是由于在支付时，需要进行跨机房的账号转换，专线网络抖动时造成接口超时。</li><li>外卖订单量在每天某些时刻都有陡降趋势，经过排查，是因为这些点大量商家开始休息导致的。</li></ul><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>将机器学习中的预测算法运用到外卖订单的异常检测中，极大的提高了异常检测的准确性和敏感性，提升了系统稳定运维的效率。该报警模型也有很广泛的应用场景，美团点评的各个业务线的监控数据，绝大多数都是含有明显周期性的时间序列，本文提出的模型都能运用到这些监控数据的异常检测中。</p><p>当然，模型还有进一步完善的空间，如：</p><ul><li>历史数据的预处理优化。在进行周期数据计算时，对于输入序列的预处理，如果能够排除绝大部分的异常数据，那么最终检测的误报率将会进一步的降低。</li><li>在不会产生持续误报的情况下替换有异常的实时数据。对于当前数据的预测，利用的都是前60分钟的真实数据，但是这些数据可能本身就存在异常数据，那么就存在一种情况，当出现异常时，真实数据开始下跌，预测数据紧接着也会下跌（如图3.8b所示）。这种情况有时候可能满足需求（比如只在异常开始的时候进行报警，异常持续时间内不再报警，防止报警太多造成的信息轰炸），有时候可能不满足需求（比如要求预测数据不跟随异常变化而变化，这种情况可以应用在故障期间的损失统计中）。如果需要预测值不随异常变化而变化，一种可能的方法是，当检测到当前数据是异常数据时，将预测数据替换当前的真实数据，作为下一时刻预测器的输入，这样可以防止异常数据对于下一时刻预测值的影响。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;外卖业务的快速发展对系统稳定性提出了更高的要求，每一次订单量大盘的异常波动，都需要做出及时的应对，以保证系统的整体稳定性。如何做出较为准确的波动预警，显得尤为重要。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="异常检测" scheme="http://yoursite.com/tags/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>机器学习算法系列（37）：外卖O2O的用户画像实践</title>
    <link href="http://yoursite.com/2017/09/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%8837%EF%BC%89%EF%BC%9A%E5%A4%96%E5%8D%96O2O%E7%9A%84%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2017/09/05/机器学习算法系列（37）：外卖O2O的用户画像实践/</id>
    <published>2017-09-05T15:14:45.000Z</published>
    <updated>2017-12-26T08:04:39.633Z</updated>
    
    <content type="html"><![CDATA[<p>美团外卖经过3年的飞速发展，品类已经从单一的外卖扩展到了美食、夜宵、鲜花、商超等多个品类。用户群体也从早期的学生为主扩展到学生、白领、社区以及商旅，甚至包括在KTV等娱乐场所消费的人群。随着供给和消费人群的多样化，如何在供给和用户之间做一个对接，就是用户画像的一个基础工作。所谓千人千面，画像需要刻画不同人群的消费习惯和消费偏好。</p><a id="more"></a><p>外卖O2O和传统的电商存在一些差异。可以简单总结为如下几点：</p><p>1）新事物，快速发展：这意味很多用户对外卖的认知较少，对平台上的新品类缺乏了解，对自身的需求也没有充分意识。平台需要去发现用户的消费意愿，以便对用户的消费进行引导。</p><p>2）高频：外卖是个典型的高频O2O应用。一方面消费频次高，用户生命周期相对好判定；另一方面消费单价较低，用户决策时间短、随意性大。</p><p>3）场景驱动：场景是特定的时间、地点和人物的组合下的特定的消费意图。不同的时间、地点，不同类型的用户的消费意图会有差异。例如白领在写字楼中午的订单一般是工作餐，通常在营养、品质上有一定的要求，且单价不能太高；而到了周末晚上的订单大多是夜宵，追求口味且价格弹性较大。场景辨识越细致，越能了解用户的消费意图，运营效果就越好。</p><p>4）用户消费的地理位置相对固定，结合地理位置判断用户的消费意图是外卖的一个特点。</p><h2 id="一、外卖产品运营对画像技术的要求"><a href="#一、外卖产品运营对画像技术的要求" class="headerlink" title="一、外卖产品运营对画像技术的要求"></a>一、外卖产品运营对画像技术的要求</h2><p>如下图所示，我们大致可以把一个产品的运营分为用户获取和用户拓展两个阶段。在用户获取阶段，用户因为自然原因或一些营销事件（例如广告、社交媒体传播）产生对外卖的注意，进而产生了兴趣，并在合适的时机下完成首购，从而成为外卖新客。在这一阶段，运营的重点是提高效率，通过一些个性化的营销和广告手段，吸引到真正有潜在需求的用户，并刺激其转化。在用户完成转化后，接下来的运营重点是拓展用户价值。这里有两个问题：第一是提升用户价值，具体而言就是提升用户的单均价和消费频次，从而提升用户的LTV（life-time value)。基本手段包括交叉销售（新品类的推荐）、向上销售（优质高价供给的推荐）以及重复购买（优惠、红包刺激重复下单以及优质供给的推荐带来下单频次的提升）；第二个问题是用户的留存，通过提升用户总体体验以及在用户有流失倾向时通过促销和优惠将用户留在外卖平台。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15049176529900.png" alt=""></p><p>所以用户所处的体验阶段不同，运营的侧重点也需要有所不同。而用户画像作为运营的支撑技术，需要提供相应的用户刻画以满足运营需求。根据上图的营销链条，从支撑运营的角度，除去提供常规的用户基础属性（例如年龄、性别、职业、婚育状况等）以及用户偏好之外，还需要考虑这么几个问题：1）什么样的用户会成为外卖平台的顾客（新客识别）；2）用户所处生命周期的判断，用户是否可能从平台流失（流失预警）；3）用户处于什么样的消费场景（场景识别）。后面“外卖O2O的用户画像实践”一节中，我们会介绍针对这三个问题的一些实践。</p><h2 id="二、外卖画像系统架构"><a href="#二、外卖画像系统架构" class="headerlink" title="二、外卖画像系统架构"></a>二、外卖画像系统架构</h2><p>下图是我们画像服务的架构：数据源包括基础日志、商家数据和订单数据。数据完成处理后存放在一系列主题表中，再导入kv存储，给下游业务端提供在线服务。同时我们会对整个业务流程实施监控。主要分为两部分，第一部分是对数据处理流程的监控，利用用内部自研的数据治理平台，监控每天各主题表产生的时间、数据量以及数据分布是否有异常。第二部分是对服务的监控。目前画像系统支持的下游服务包括：广告、排序、运营等系统。<br><img src="http://omu7tit09.bkt.clouddn.com/15049176981394.png" alt=""></p><h2 id="三、外卖O2O的用户画像实践"><a href="#三、外卖O2O的用户画像实践" class="headerlink" title="三、外卖O2O的用户画像实践"></a>三、外卖O2O的用户画像实践</h2><h3 id="3-1-新客运营"><a href="#3-1-新客运营" class="headerlink" title="3.1 新客运营"></a>3.1 新客运营</h3><p>新客运营主要需要回答下列三个问题：</p><p>1）新客在哪里？</p><p>2）新客的偏好如何？</p><p>3）新客的消费力如何？</p><p>回答这三个问题是比较困难的，因为相对于老客而言，新客的行为记录非常少或者几乎没有。这就需要我们通过一些技术手段作出推断。例如：新客的潜在转化概率，受到新客的人口属性（职业、年龄等）、所处地域（需求的因素）、周围人群（同样反映需求）以及是否有充足供给等因素的影响；而对于新客的偏好和消费力，从新客在到店场景下的消费行为可以做出推测。另外用户的工作和居住地点也能反映他的消费能力。<br>对新客的预测大量依赖他在到店场景下的行为，而用户的到店行为对于外卖是比较稀疏的，大多数的用户是在少数几个类别上有过一些消费行为。这就意味着我们需要考虑选择什么样的统计量描述：是消费单价，总消费价格，消费品类等等。然后通过大量的试验来验证特征的显著性。另外由于数据比较稀疏，需要考虑合适的平滑处理。</p><p>我们在做高潜新客挖掘时，融入了多方特征，通过特征的组合最终作出一个效果比较好的预测模型。我们能够找到一些高转化率的用户，其转化率比普通用户高若干倍。通过对高潜用户有针对性的营销，可以极大提高营销效率。</p><h3 id="3-2-流失预测"><a href="#3-2-流失预测" class="headerlink" title="3.2 流失预测"></a>3.2 流失预测</h3><p>新客来了之后，接下来需要把他留在这个平台上，尽量延长生命周期。营销领域关于用户留存的两个基本观点是（引自菲利普.科特勒 《营销管理》）：</p><p>获取一个新顾客的成本是维系现有顾客成本的5倍！</p><p>如果将顾客流失率降低5%，公司利润将增加25%~85%</p><p>用户流失的原因通常包括：竞对的吸引；体验问题；需求变化。我们借助机器学习的方法，构建用户的描述特征，并借助这些特征来预测用户未来流失的概率。这里有两种做法: 第一种是预测用户未来若干天是否会下单这一事件发生的概率。这是典型的概率回归问题，可以选择逻辑回归、决策树等算法拟合给定观测下事件发生的概率；第二种是借助于生存模型，例如COX-PH模型，做流失的风险预测。下图左边是概率回归的模型，用户未来T天内是否有下单做为类别标记y，然后估计在观察到特征X的情况下y的后验概率P(y|X)。右边是用COX模型的例子，我们会根据用户在未来T天是否下单给样本一个类别，即观测时长记为T。假设用户的下单的距今时长t&lt;T，将t作为生存时长t’；否则将生存时长t’记为T。这样一个样本由三部分构成：样本的类别(flag)，生存时长(t’)以及特征列表。通过生存模型虽然无法显式得到P(t’|X)的概率，但其协变量部分实际反映了用户流失的风险大小。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15049177296058.png" alt=""></p><p>生存模型中，βTx反映了用户流失的风险，同时也和用户下次订单的时间间隔成正相关。下面的箱线图中，横轴为βTx，纵轴为用户下单时间的间隔。<br><img src="http://omu7tit09.bkt.clouddn.com/15049177439027.png" alt=""></p><p>我们做了COX模型和概率回归模型的对比。在预测用户XX天内是否会下单上面，两者有相近的性能。</p><p>美团外卖通过使用了用户流失预警模型，显著降低了用户留存的运营成本。</p><h3 id="3-3-场景运营"><a href="#3-3-场景运营" class="headerlink" title="3.3 场景运营"></a>3.3 场景运营</h3><p>拓展用户的体验，最重要的一点是要理解用户下单的场景。了解用户的订餐场景有助于基于场景的用户运营。对于场景运营而言，通常需要经过如下三个步骤：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15049177875464.png" alt=""><br>场景可以从时间、地点、订单三个维度描述。比如说工作日的下午茶，周末的家庭聚餐，夜里在家点夜宵等等。其中重要的一点是用户订单地址的分析。通过区分用户的订单地址是写字楼、学校或是社区，再结合订单时间、订单内容，可以对用户的下单场景做到大致的了解。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15049178093195.png" alt=""></p><p>上图是我们订单地址分析的流程。根据订单系统中的用户订单地址文本，基于自然语言处理技术对地址文本分析，可以得到地址的主干名称（指去掉了楼宇、门牌号的地址主干部分）和地址的类型（写字楼、住宅小区等）。在此基础上通过一些地图数据辅助从而判断出最终的地址类型。<br>另外我们还做了合并订单的识别，即识别一个订单是一个人下单还是拼单。把拼单信息、地址分析以及时间结合在一起，我们可以预测用户的消费场景，进而基于场景做交叉销售和向上销售。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>外卖的营销特征，跟其他行业的主要区别在于：</p><p>外卖是一个高频的业务。由于用户的消费频次高，用户生命周期的特征体现较显著。运营可以基于用户所处生命周期的阶段制定营销目标，例如用户完成首购后的频次提升、成熟用户的价值提升、衰退用户的挽留以及流失用户的召回等。因此用户的生命周期是一个基础画像，配合用户基本属性、偏好、消费能力、流失预测等其他画像，通过精准的产品推荐或者价格策略实现运营目标。</p><p>用户的消费受到时间、地点等场景因素驱动。因此需要对用户在不同的时间、地点下消费行为的差异做深入了解，归纳不同场景下用户需求的差异，针对场景制定相应的营销策略，提升用户活跃度。</p><p>另外由于外卖是一个新鲜的事物，在用户对一些新品类和新产品缺乏认知的情况下，需要通过技术手段识别用户的潜在需求，进行精准营销。例如哪些用户可能会对小龙虾、鲜花、蛋糕这样的相对低频、高价值的产品产生购买。可以采用的技术手段包括用户分群、对已产生消费的用户做look-alike扩展、迁移学习等。</p><p>同时我们在制作外卖的用户画像时还面临如下挑战：</p><p>1）数据多样性，存在大量非结构化数据例如用户地址、菜品名称等。需要用到自然语言处理技术，同时结合其他数据进行分析。</p><p>2）相对于综合电商而言，外卖是个相对单一的品类，用户在外卖上的行为不足以全方位地描述用户的基本属性。因此需要和用户在其他场合的消费行为做融合。</p><p>3）外卖单价相对较低，用户消费的决策时间短、随意性强。不像传统电商用户在决策前有大量的浏览行为可以用于捕捉用户单次的需求。因此更需要结合用户画像分析用户的历史兴趣、以及用户的消费场景，在消费前对用户做适当的引导、推荐。</p><p>面临这些挑战，需要用户画像团队更细致的数据处理、融合多方数据源，同时发展出新的方法论，才能更好地支持外卖业务发展的需要。而外卖的上述挑战，又分别和一些垂直领域电商类似，经验上存在可以相互借鉴之处。因此，外卖的用户画像的实践和经验累积，必将对整个电商领域的大数据应用作出新的贡献！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;美团外卖经过3年的飞速发展，品类已经从单一的外卖扩展到了美食、夜宵、鲜花、商超等多个品类。用户群体也从早期的学生为主扩展到学生、白领、社区以及商旅，甚至包括在KTV等娱乐场所消费的人群。随着供给和消费人群的多样化，如何在供给和用户之间做一个对接，就是用户画像的一个基础工作。所谓千人千面，画像需要刻画不同人群的消费习惯和消费偏好。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="用户画像" scheme="http://yoursite.com/tags/%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F/"/>
    
  </entry>
  
  <entry>
    <title>机器学习算法系列（36）：GBDT算法原理深入解析</title>
    <link href="http://yoursite.com/2017/09/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%8836%EF%BC%89%EF%BC%9AGBDT%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2017/09/04/机器学习算法系列（36）：GBDT算法原理深入解析/</id>
    <published>2017-09-04T15:14:45.000Z</published>
    <updated>2017-12-26T08:04:36.698Z</updated>
    
    <content type="html"><![CDATA[<p>梯度提升（Gradient boosting）是一种用于回归、分类和排序任务的机器学习技术[1]，属于Boosting算法族的一部分。Boosting是一族可将弱学习器提升为强学习器的算法，属于集成学习（ensemble learning）的范畴。Boosting方法基于这样一种思想：对于一个复杂任务来说，将多个专家的判断进行适当的综合所得出的判断，要比其中任何一个专家单独的判断要好。通俗地说，就是“三个臭皮匠顶个诸葛亮”的道理。梯度提升同其他boosting方法一样，通过集成（ensemble）多个弱学习器，通常是决策树，来构建最终的预测模型。</p><a id="more"></a><p>Boosting、bagging和stacking是集成学习的三种主要方法。不同于bagging方法，boosting方法通过分步迭代（stage-wise）的方式来构建模型，在迭代的每一步构建的弱学习器都是为了弥补已有模型的不足。Boosting族算法的著名代表是AdaBoost，AdaBoost算法通过给已有模型预测错误的样本更高的权重，使得先前的学习器做错的训练样本在后续受到更多的关注的方式来弥补已有模型的不足。与AdaBoost算法不同，梯度提升方法在迭代的每一步构建一个能够沿着梯度最陡的方向降低损失（steepest-descent）的学习器来弥补已有模型的不足。经典的AdaBoost算法只能处理采用指数损失函数的二分类学习任务[2]，而梯度提升方法通过设置不同的可微损失函数可以处理各类学习任务（多分类、回归、Ranking等），应用范围大大扩展。另一方面，AdaBoost算法对异常点（outlier）比较敏感，而梯度提升算法通过引入bagging思想、加入正则项等方法能够有效地抵御训练数据中的噪音，具有更好的健壮性。这也是为什么梯度提升算法（尤其是采用决策树作为弱学习器的GBDT算法）如此流行的原因，有种观点认为GBDT是性能最好的机器学习算法，这当然有点过于激进又固步自封的味道，但通常各类机器学习算法比赛的赢家们都非常青睐GBDT算法，由此可见该算法的实力不可小觑。</p><p>基于梯度提升算法的学习器叫做GBM(Gradient Boosting Machine)。理论上，GBM可以选择各种不同的学习算法作为基学习器。现实中，用得最多的基学习器是决策树。为什么梯度提升方法倾向于选择决策树（通常是CART树）作为基学习器呢？这与决策树算法自身的优点有很大的关系。决策树可以认为是if-then规则的集合，易于理解，可解释性强，预测速度快。同时，决策树算法相比于其他的算法需要更少的特征工程，比如可以不用做特征标准化，可以很好的处理字段缺失的数据，也可以不用关心特征间是否相互依赖等。决策树能够自动组合多个特征，它可以毫无压力地处理特征间的交互关系并且是非参数化的，因此你不必担心异常值或者数据是否线性可分（举个例子，决策树能轻松处理好类别A在某个特征维度x的末端，类别B在中间，然后类别A又出现在特征维度x前端的情况）不过，单独使用决策树算法时，有容易过拟合缺点。所幸的是，通过各种方法，抑制决策树的复杂性，降低单颗决策树的拟合能力，再通过梯度提升的方法集成多个决策树，最终能够很好的解决过拟合的问题。由此可见，梯度提升方法和决策树学习算法可以互相取长补短，是一对完美的搭档。至于抑制单颗决策树的复杂度的方法有很多，比如限制树的最大深度、限制叶子节点的最少样本数量、限制节点分裂时的最少样本数量、吸收bagging的思想对训练样本采样（subsample），在学习单颗决策树时只使用一部分训练样本、借鉴随机森林的思路在学习单颗决策树时只采样一部分特征、在目标函数中添加正则项惩罚复杂的树结构等。现在主流的GBDT算法实现中这些方法基本上都有实现，因此GBDT算法的超参数还是比较多的，应用过程中需要精心调参，并用交叉验证的方法选择最佳参数。</p><p>本文对GBDT算法原理进行介绍，从机器学习的关键元素出发，一步一步推导出GBDT算法背后的理论基础，读者可以从这个过程中了解到GBDT算法的来龙去脉。对于该算法的工程实现，本文也有较好的指导意义，实际上对机器学习关键概念元素的区分对应了软件工程中的“开放封闭原则”的思想，基于此思想的实现将会具有很好的模块独立性和扩展性。</p><h2 id="一、机器学习的关键元素"><a href="#一、机器学习的关键元素" class="headerlink" title="一、机器学习的关键元素"></a>一、机器学习的关键元素</h2><p>先复习下监督学习的关键概念：模型（model）、参数（parameters）、目标函数（objective function）</p><p>模型就是所要学习的条件概率分布或者决策函数，它决定了在给定特征向量x时如何预测出目标y。定义$x_i\in R^d$为训练集中的第$i$个训练样本，则线性模型（linear model）可以表示为：$\hat{y}=\sum_jw_jx_{ij }$。模型预测的分数$\hat{y_i}$在不同的任务中有不同的解释。例如在逻辑回归任务中，$1/(1+exp(-\hat{y}_i))$表示模型预测为正例的概率；而在排序学习任务中，$\hat{y_i}$表示排序分。</p><p>参数就是我们要从数据中学习得到的内容。模型通常是由一个参数向量决定的函数。例如，线性模型的参数可以表示为：$\Theta=\{w_j|j=1,\cdots,d\}$</p><p>目标函数通常定义为如下形式：</p><script type="math/tex; mode=display">Obj(\Theta)=L(\Theta)+\Omega(\Theta)</script><p>其中，$L(\Theta)$是损失函数，用来衡量模型拟合训练数据的好坏程度；$\Omega(\Theta)$称之为正则项，用来衡量学习到的模型的复杂度。训练集上的损失（Loss）定义为：$L=\sum_{i=1}^n l(y_i, \hat{y}_i)$。常用的损失函数有平方损失（square loss）：$l(y_i, \hat{y}_i)=(y_i - \hat{y}_i)^2$；Logistic损失： $l(y_i, \hat{y}_i)=y_i ln(1+e^{y_i}) + (1-y_i)ln(1+e^{\hat{y}_i})$。常用的正则项有L1范数$\Omega(w)=\lambda \Vert w \Vert_1$和L2范数$\Omega(w)=\lambda \Vert w \Vert_2$。Ridge regression就是指使用平方损失和L2范数正则项的线性回归模型；Lasso regression就是指使用平方损失和L1范数正则项的线性回归模型；逻辑回归（Logistic regression）指使用logistic损失和L2范数或L1范数正则项的线性模型。</p><p>目标函数之所以定义为损失函数和正则项两部分，是为了尽可能平衡模型的偏差和方差（Bias Variance Trade-off）。最小化目标函数意味着同时最小化损失函数和正则项，损失函数最小化表明模型能够较好的拟合训练数据，一般也预示着模型能够较好地拟合真实数据（groud true）；另一方面，对正则项的优化鼓励算法学习到较简单的模型，简单模型一般在测试样本上的预测结果比较稳定、方差较小（奥坎姆剃刀原则）。也就是说，优化损失函数尽量使模型走出欠拟合的状态，优化正则项尽量使模型避免过拟合。</p><p>从概念上区分模型、参数和目标函数给学习算法的工程实现带来了益处，使得机器学习的各个组成部分之间耦合尽量松散。</p><h2 id="二、加法模型"><a href="#二、加法模型" class="headerlink" title="二、加法模型"></a>二、加法模型</h2><p>GBDT算法可以看成是由K棵树组成的加法模型：</p><script type="math/tex; mode=display">\hat{y}_i=\sum_{k=1}^K f_k(x_i), f_k \in F \tag 0</script><p>其中$F$为所有树组成的函数空间，以回归任务为例，回归树可以看作为一个把特征向量映射为某个score的函数。该模型的参数为：$\Theta=\{f_1,f_2, \cdots, f_K \}$。于一般的机器学习算法不同的是，加法模型不是学习d维空间中的权重，而是直接学习函数（决策树）集合。</p><p>上述加法模型的目标函数定义为：$Obj=\sum_{i=1}^n l(y_i, \hat{y}_i) + \sum_{k=1}^K \Omega(f_k)$，其中表示决策树的复杂度，那么该如何定义树的复杂度呢？比如，可以考虑树的节点数量、树的深度或者叶子节点所对应的分数的L2范数等等。</p><p>如何来学习加法模型呢？</p><p>解这一优化问题，可以用前向分布算法（forward stagewise algorithm）。因为学习的是加法模型，如果能够从前往后，每一步只学习一个基函数及其系数（结构），逐步逼近优化目标函数，那么就可以简化复杂度。这一学习过程称之为Boosting。具体地，我们从一个常量预测开始，每次学习一个新的函数，过程如下： </p><script type="math/tex; mode=display">\begin{split}\hat{y}_i^0 &= 0 \\\hat{y}_i^1 &= f_1(x_i) = \hat{y}_i^0 + f_1(x_i) \\\hat{y}_i^2 &= f_1(x_i) + f_2(x_i) = \hat{y}_i^1 + f_2(x_i) \\& \cdots \\\hat{y}_i^t &= \sum_{k=1}^t f_k(x_i) = \hat{y}_i^{t-1} + f_t(x_i) \\\end{split}</script><p>那么，在每一步如何决定哪一个函数$f$被加入呢？指导原则还是最小化目标函数。<br>在第$t$步，模型对$x_i$的预测为：$\hat{y}_i^t= \hat{y}_i^{t-1} + f_t(x_i)$，其中$f_t(x_i)$为这一轮我们要学习的函数（决策树）。这个时候目标函数可以写为：</p><script type="math/tex; mode=display">\begin{split}Obj^{(t)} &= \sum_{i=1}^nl(y_i, \hat{y}_i^t) + \sum_{i=i}^t \Omega(f_i) \\&=  \sum_{i=1}^n l\left(y_i, \hat{y}_i^{t-1} + f_t(x_i) \right) + \Omega(f_t) + constant\end{split}\tag{1}</script><p>举例说明，假设损失函数为平方损失（square loss），则目标函数为：</p><script type="math/tex; mode=display">\begin{split}Obj^{(t)} &= \sum_{i=1}^n \left(y_i - (\hat{y}_i^{t-1} + f_t(x_i)) \right)^2 + \Omega(f_t) + constant \\&= \sum_{i=1}^n \left[2(\hat{y}_i^{t-1} - y_i)f_t(x_i) + f_t(x_i)^2 \right] + \Omega(f_t) + constant\end{split}\tag{2}</script><p>其中$(\hat{y}_i^{t-1} - y_i)$，称之为残差（residual）。因此，使用平方损失函数时，GBDT算法的每一步在生成决策树时只需要拟合前面的模型的残差。</p><blockquote><p>泰勒公式：设$n$是一个正整数，如果定义在一个包含$a$的区间上的函数$f$在$a$点处$n+1$次可导，那么对于这个区间上的任意$x$都有：</p><script type="math/tex; mode=display">\displaystyle f(x)=\sum _{n=0}^{N}\frac{f^{(n)}(a)}{n!}(x-a)^ n+R_ n(x)</script><p>，其中的多项式称为函数在$a$处的泰勒展开式，$R_n(x)$是泰勒公式的余项且是$(x-a)^n$的高阶无穷小。——维基百科</p></blockquote><p>根据泰勒公式把函数$f(x+\Delta x)$在点处二阶展开，可得到如下等式： </p><script type="math/tex; mode=display">f(x+\Delta x) \approx f(x) + f'(x)\Delta x + \frac12 f''(x)\Delta x^2 \tag 3</script><p>由等式(1)可知，目标函数是关于变量$\hat{y}_i^{t-1} + f_t(x_i)$若把变量$\hat{y}_i^{t-1}$看成是等式(3)中的$x$，把变量$f_t(x_i)$看成是等式(3)中的$\Delta x$，则等式(1)可转化为： </p><script type="math/tex; mode=display">Obj^{(t)} = \sum_{i=1}^n \left[ l(y_i, \hat{y}_i^{t-1}) + g_if_t(x_i) + \frac12h_if_t^2(x_i) \right]  + \Omega(f_t) + constant \tag 4</script><p>其中，$g_i$定义为损失函数的一阶导数，即$g_i=\partial_{\hat{y}^{t-1}}l(y_i,\hat{y}^{t-1})$；$h_i$定义为损失函数的二阶导数，即$h_i=\partial_{\hat{y}^{t-1}}^2l(y_i,\hat{y}^{t-1})$。 假设损失函数为平方损失函数，则$g_i=\partial_{\hat{y}^{t-1}}(\hat{y}^{t-1} - y_i)^2 = 2(\hat{y}^{t-1} - y_i)$，$h_i=\partial_{\hat{y}^{t-1}}^2(\hat{y}^{t-1} - y_i)^2 = 2$，把$g_i$和$h_i$代入等式(4)即得等式(2)。由于函数中的常量在函数最小化的过程中不起作用，因此我们可以从等式(4)中移除掉常量项，得： </p><script type="math/tex; mode=display">Obj^{(t)} \approx \sum_{i=1}^n \left[ g_if_t(x_i) + \frac12h_if_t^2(x_i) \right]  + \Omega(f_t) \tag 5</script><p>由于要学习的函数仅仅依赖于目标函数，从等式(5)可以看出只需为学习任务定义好损失函数，并为每个训练样本计算出损失函数的一阶导数和二阶导数，通过在训练样本集上最小化等式(5)即可求得每步要学习的函数$f(x)$，从而根据加法模型等式(0)可得最终要学习的模型。</p><h2 id="二、GBDT算法"><a href="#二、GBDT算法" class="headerlink" title="二、GBDT算法"></a>二、GBDT算法</h2><p>一颗生成好的决策树，假设其叶子节点个数为$T$，该决策树是由所有叶子节点对应的值组成的向量$w \in R^T$，以及一个把特征向量映射到叶子节点索引（Index）的函数$q:R^d \to \{1,2,\cdots,T\}$组成的。因此，决策树可以定义为$f_t(x)=w_{q(x)}$。</p><p>决策树的复杂度可以由正则项$\Omega(f_t)=\gamma T + \frac12 \lambda \sum_{j=1}^T w_j^2$来定义，即决策树模型的复杂度由生成的树的叶子节点数量和叶子节点对应的值向量的L2范数决定。</p><p>定义集合$I_j=\{ i \vert q(x_i)=j \}$为所有被划分到叶子节点的训练样本的集合。等式(5)可以根据树的叶子节点重新组织为T个独立的二次函数的和： </p><script type="math/tex; mode=display">\begin{split}Obj^{(t)} &\approx \sum_{i=1}^n \left[ g_if_t(x_i) + \frac12h_if_t^2(x_i) \right]  + \Omega(f_t) \\&= \sum_{i=1}^n \left[ g_iw_{q(x_i)} + \frac12h_iw_{q(x_i)}^2 \right] + \gamma T + \frac12 \lambda \sum_{j=1}^T w_j^2 \\&= \sum_{j=1}^T \left[(\sum_{i \in I_j}g_i)w_j + \frac12(\sum_{i \in I_j}h_i + \lambda)w_j^2 \right] + \gamma T\end{split}\tag 6</script><p>定义$G_j=\sum_{i \in I_j}g_i$，$H_j=\sum_{i \in I_j}h_i$，则等式(6)可写为：</p><script type="math/tex; mode=display">Obj^{(t)} = \sum_{j=1}^T \left[G_iw_j + \frac12(H_i + \lambda)w_j^2 \right] + \gamma T</script><p>假设树的结构是固定的，即函数$q(x)$确定，令函数$Obj^{(t)}$的一阶导数等于0，即可求得叶子节点对应的值为：$w_j^*=-\frac{G_j}{H_j+\lambda} \tag 7$此时，目标函数的值为</p><script type="math/tex; mode=display">Obj = -\frac12 \sum_{j=1}^T \frac{G_j^2}{H_j+\lambda} + \gamma T \tag 8</script><p>综上，为了便于理解，单颗决策树的学习过程可以大致描述为： </p><ol><li>枚举所有可能的树结构$q$ </li><li>用等式(8)为每个$q$计算其对应的分数$Obj$，分数越小说明对应的树结构越好。</li><li>根据上一步的结果，找到最佳的树结构，用等式(7)为树的每个叶子节点计算预测值</li></ol><p>然而，可能的树结构数量是无穷的，所以实际上我们不可能枚举所有可能的树结构。通常情况下，我们采用贪心策略来生成决策树的每个节点。 </p><ol><li>从深度为0的树开始，对每个叶节点枚举所有的可用特征 </li><li>针对每个特征，把属于该节点的训练样本根据该特征值升序排列，通过线性扫描的方式来决定该特征的最佳分裂点，并记录该特征的最大收益（采用最佳分裂点时的收益） </li><li>选择收益最大的特征作为分裂特征，用该特征的最佳分裂点作为分裂位置，把该节点生长出左右两个新的叶节点，并为每个新节点关联对应的样本集 </li><li>回到第1步，递归执行到满足特定条件为止</li></ol><p>在上述算法的第二步，样本排序的时间复杂度为$O(nlogn)$，假设共用K个特征，那么生成一颗深度为K的树的时间复杂度为$O(dKnlogn)$。具体实现可以进一步优化计算复杂度，比如可以缓存每个特征的排序结果等。</p><p>如何计算每次分裂的收益呢？假设当前节点记为,分裂之后左孩子节点记为，右孩子节点记为，则该分裂获得的收益定义为当前节点的目标函数值减去左右两个孩子节点的目标函数值之和：$Gain=Obj_C-Obj_L-Obj_R$，具体地，根据等式(8)可得：</p><script type="math/tex; mode=display">Gain=\frac12 \left[ \frac{G_L^2}{H_L+\lambda} + \frac{G_R^2}{H_R+\lambda} - \frac{(G_L+G_R)^2}{H_L+H_R+\lambda}\right] - \gamma \tag 9</script><p>其中，$-\gamma$项表示因为增加了树的复杂性（该分裂增加了一个叶子节点）带来的惩罚。等式(9)还可以用来计算输入特征的相对重要程度，具体见下一节</p><p>最后，总结一下GBDT的学习算法： </p><ol><li>算法每次迭代生成一颗新的决策树 </li><li>在每次迭代开始之前，计算损失函数在每个训练样本点的一阶导数$g_i$和二阶导数$h_i$</li><li>通过贪心策略生成新的决策树，通过等式(7)计算每个叶节点对应的预测值 </li><li>把新生成的决策树$f_t(x)$添加到模型中：$\hat{y}_i^t = \hat{y}_i^{t-1} + f_t(x_i)$</li></ol><p>通常在第四步，我们把模型更新公式替换为：$\hat{y}_i^t = \hat{y}_i^{t-1} + \epsilon f_t(x_i)$，其中$\epsilon$称之为步长或者学习率。增加因子的目的是为了避免模型过拟合。</p><h2 id="三、特征重要度"><a href="#三、特征重要度" class="headerlink" title="三、特征重要度"></a>三、特征重要度</h2><p>集成学习因具有预测精度高的优势而受到广泛关注，尤其是使用决策树作为基学习器的集成学习算法。树的集成算法的著名代码有随机森林和GBDT。随机森林具有很好的抵抗过拟合的特性，并且参数（决策树的个数）对预测性能的影响较小，调参比较容易，一般设置一个比较大的数。GBDT具有很优美的理论基础，一般而言性能更有优势。</p><p>基于树的集成算法还有一个很好的特性，就是模型训练结束后可以输出模型所使用的特征的相对重要度，便于我们选择特征，理解哪些因素是对预测有关键影响，这在某些领域（如生物信息学、神经系统科学等）特别重要。本文主要介绍基于树的集成算法如何计算各特征的相对重要度。</p><h3 id="3-1-优势"><a href="#3-1-优势" class="headerlink" title="3.1 优势"></a>3.1 优势</h3><ul><li>使用不同类型的数据时，不需要做特征标准化/归一化</li><li>可以很容易平衡运行时效率和精度；比如，使用boosted tree作为在线预测的模型可以在机器资源紧张的时候截断参与预测的树的数量从而提高预测效率</li><li>学习模型可以输出特征的相对重要程度，可以作为一种特征选择的方法</li><li>模型可解释性好</li><li>对数据字段缺失不敏感</li><li>能够自动做多组特征间的interaction，具有很好的非性线性</li></ul><h3 id="3-2-特征重要度的计算"><a href="#3-2-特征重要度的计算" class="headerlink" title="3.2 特征重要度的计算"></a>3.2 特征重要度的计算</h3><p>Friedman在GBM的论文中提出的方法：</p><p>特征$j$的全局重要度通过特征$j$在单颗树中的重要度的平均值来衡量：</p><script type="math/tex; mode=display">\hat{J_{j}^2}=\frac1M \sum_{m=1}^M\hat{J_{j}^2}(T_m)</script><p>其中，M是树的数量。特征$j$在单颗树中的重要度的如下：</p><script type="math/tex; mode=display">\hat{J_{j}^2}(T)=\sum\limits_{t=1}^{L-1} \hat{i_{t}^2} 1(v_{t}=j)</script><p>其中，$L$为树的叶子节点数量，$L-1$即为树的非叶子节点数量（构建的树都是具有左右孩子的二叉树），是和节点$t$相关联的特征，$\hat{i_t^2}$是节点分裂之后平方损失的减少值。</p><h3 id="3-3-实现代码"><a href="#3-3-实现代码" class="headerlink" title="3.3 实现代码"></a>3.3 实现代码</h3><p>为了更好的理解特征重要度的计算方法，下面给出scikit-learn工具包中的实现，代码移除了一些不相关的部分。</p><p>下面的代码来自于GradientBoostingClassifier对象的feature_importances属性的计算方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">feature_importances_</span><span class="params">(self)</span>:</span></div><div class="line">    total_sum = np.zeros((self.n_features, ), dtype=np.float64)</div><div class="line">    <span class="keyword">for</span> tree <span class="keyword">in</span> self.estimators_:</div><div class="line">        total_sum += tree.feature_importances_ </div><div class="line">    importances = total_sum / len(self.estimators_)</div><div class="line">    <span class="keyword">return</span> importances</div></pre></td></tr></table></figure><p>其中，self.estimators_是算法构建出的决策树的数量，tree.feature_importances_ 是单棵树的特征重要度向量，其计算方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">cpdef compute_feature_importances(self, normalize=True):</div><div class="line">    &quot;&quot;&quot;Computes the importance of each feature (aka variable).&quot;&quot;&quot;</div><div class="line">    while node != end_node:</div><div class="line">        if node.left_child != _TREE_LEAF:</div><div class="line">            # ... and node.right_child != _TREE_LEAF:</div><div class="line">            left = &amp;nodes[node.left_child]</div><div class="line">            right = &amp;nodes[node.right_child]</div><div class="line">            importance_data[node.feature] += (</div><div class="line">                node.weighted_n_node_samples * node.impurity -</div><div class="line">                left.weighted_n_node_samples * left.impurity -</div><div class="line">                right.weighted_n_node_samples * right.impurity)</div><div class="line">        node += 1</div><div class="line">    importances /= nodes[0].weighted_n_node_samples</div><div class="line">    return importances</div></pre></td></tr></table></figure><p>上面的代码关键点是两个：</p><p>第一点：weighted_n_node_samples : array of int, shape [node_count]<br>        weighted_n_node_samples[i] holds the weighted number of training samples reaching node i.</p><p>第二点：impurity : array of double, shape [node_count]<br>        impurity[i] holds the impurity (i.e., the value of the splitting criterion) at node i.</p><p>当然上面的代码经过了简化，保留了核心思想。计算所有的非叶子节点在分裂时加权不纯度的减少，减少得越多说明特征越重要</p><p>不纯度的减少实际上就是该节点此次分裂的收益，因此我们也可以这样理解，节点分裂时收益越大，该节点对应的特征的重要度越高。关于收益的定义就是上一节中等式(9)的定义。</p><p>参考资料<br>[1] <a href="https://www.wikiwand.com/en/Gradient_boosting" target="_blank" rel="noopener">Gradient Boosting</a> 的更多内容<br>[2] <a href="http://xgboost.readthedocs.io/en/latest/" target="_blank" rel="noopener">XGBoost</a>是一个优秀的GBDT开源软件库，有多种语言接口<br>[3] <a href="https://github.com/cheng-li/pyramid" target="_blank" rel="noopener">Pyramid</a>是一个基于Java语言的机器学习库，里面也有GBDT算法的介绍和实现<br>[4] Friedman的论文<a href="http://www-stat.stanford.edu/~jhf/ftp/trebst.pdf" target="_blank" rel="noopener">《Greedy function approximation: a gradient boosting machine》</a>是比较早的GBDT算法文献，但是比较晦涩难懂，不适合初学者，高阶选手可以进一步学习<br>[5] <a href="http://www-stat.stanford.edu/~jhf/ftp/trebst.pdf" target="_blank" rel="noopener">“A Gentle Introduction to Gradient Boosting”</a>是关于Gradient Boosting的一个通俗易懂的解释，比较适合初学者或者是已经对GBDT算法原理印象不深的从业者<br>[6] 关于GBDT算法调参的经验和技巧可以参考这两篇博文：<a href="https://www.analyticsvidhya.com/blog/2016/02/complete-guide-parameter-tuning-gradient-boosting-gbm-python/" target="_blank" rel="noopener">《GBM调参指南》</a>、<br><a href="https://www.analyticsvidhya.com/blog/2016/03/complete-guide-parameter-tuning-xgboost-with-codes-python/" target="_blank" rel="noopener">《XGBoost调参指南》</a>，作者使用的算法实现工具来自于著名的Python机器学习工具scikit-learn<br>[7] GBDT算法在搜索引擎排序中的应用可以查看这篇论文<a href="http://proceedings.mlr.press/v14/mohan11a/mohan11a.pdf" target="_blank" rel="noopener">《Web-Search Ranking with Initialized Gradient Boosted Regression Trees 》</a>，这篇论文提出了一个非常有意思的方法，用一个已经训练好的随机森林模型作为GBDT算法的初始化，再用GBDT算法优化最终的模型，取得了很好的效果</p><p>[1] <a href="https://pdfs.semanticscholar.org/156e/3c979e7bc25381fdd0614d1bab60b7aa5dfd.pdf" target="_blank" rel="noopener">Feature Selection for Ranking using Boosted Trees </a><br>[2] <a href="http://alicezheng.org/papers/gbfs.pdf" target="_blank" rel="noopener">Gradient Boosted Feature Selection</a><br>[3] <a href="http://www.jmlr.org/papers/volume10/tuv09a/tuv09a.pdf" target="_blank" rel="noopener">Feature Selection with Ensembles, Artificial Variables, and Redundancy Elimination</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;梯度提升（Gradient boosting）是一种用于回归、分类和排序任务的机器学习技术[1]，属于Boosting算法族的一部分。Boosting是一族可将弱学习器提升为强学习器的算法，属于集成学习（ensemble learning）的范畴。Boosting方法基于这样一种思想：对于一个复杂任务来说，将多个专家的判断进行适当的综合所得出的判断，要比其中任何一个专家单独的判断要好。通俗地说，就是“三个臭皮匠顶个诸葛亮”的道理。梯度提升同其他boosting方法一样，通过集成（ensemble）多个弱学习器，通常是决策树，来构建最终的预测模型。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="GBDT" scheme="http://yoursite.com/tags/GBDT/"/>
    
  </entry>
  
  <entry>
    <title>机器学习算法系列（35）：使用Sklearn进行集成学习（实践）</title>
    <link href="http://yoursite.com/2017/09/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%8835%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8Sklearn%E8%BF%9B%E8%A1%8C%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%AE%9E%E8%B7%B5%EF%BC%89/"/>
    <id>http://yoursite.com/2017/09/03/机器学习算法系列（35）：使用Sklearn进行集成学习（实践）/</id>
    <published>2017-09-03T15:14:45.000Z</published>
    <updated>2017-12-26T08:04:31.583Z</updated>
    
    <content type="html"><![CDATA[<p>jjj<br><a id="more"></a><br>hhh</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;jjj&lt;br&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="集成学习" scheme="http://yoursite.com/tags/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习算法系列（34）：使用Sklearn进行集成学习（理论）</title>
    <link href="http://yoursite.com/2017/09/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%8834%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8Sklearn%E8%BF%9B%E8%A1%8C%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0%EF%BC%88%E7%90%86%E8%AE%BA%EF%BC%89/"/>
    <id>http://yoursite.com/2017/09/02/机器学习算法系列（34）：使用Sklearn进行集成学习（理论）/</id>
    <published>2017-09-02T15:14:45.000Z</published>
    <updated>2017-12-26T08:04:27.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>很多人在竞赛（Kaggle，天池等）或工程实践中使用了集成学习（例如，RF、GTB等），确实也取得了不错的效果，在保证准确度的同时也提升了模型防止过拟合的能力。但是，我们真的用对了集成学习吗？</p><a id="more"></a><p>sklearn提供了sklearn.ensemble库，支持众多集成学习算法和模型。恐怕大多数人使用这些工具时，要么使用默认参数，要么根据模型在测试集上的性能试探性地进行调参（当然，完全不懂的参数还是不动算了），要么将调参的工作丢给调参算法（网格搜索等）。这样并不能真正地称为“会”用sklearn进行集成学习。</p><p>我认为，学会调参是进行集成学习工作的前提。然而，第一次遇到这些算法和模型时，肯定会被其丰富的参数所吓到，要知道，教材上教的伪代码可没这么多参数啊！！！没关系，暂时，我们只要记住一句话：参数可分为两种，一种是影响模型在训练集上的准确度或影响防止过拟合能力的参数；另一种不影响这两者的其他参数。模型在样本总体上的准确度（后简称准确度）由其在训练集上的准确度及其防止过拟合的能力所共同决定，所以在调参时，我们主要对第一种参数进行调整，最终达到的效果是：模型在训练集上的准确度和防止过拟合能力的大和谐！</p><p>本篇博文将详细阐述模型参数背后的理论知识，在下篇博文中，我们将对最热门的两个模型Random Forrest和Gradient Tree Boosting（含分类和回归，所以共4个模型）进行具体的参数讲解。如果你实在无法静下心来学习理论，你也可以在下篇博文中找到最直接的调参指导，虽然我不赞同这么做。</p><h2 id="二、集成学习是什么？"><a href="#二、集成学习是什么？" class="headerlink" title="二、集成学习是什么？"></a>二、集成学习是什么？</h2><p>我们还是花一点时间来说明一下集成学习是什么，如果对此有一定基础的同学可以跳过本节。简单来说，集成学习是一种技术框架，其按照不同的思路来组合基础模型，从而达到其利断金的目的。</p><p>目前，有三种常见的集成学习框架：bagging，boosting和stacking。国内，南京大学的周志华教授对集成学习有很深入的研究，其在09年发表的一篇概述性论文《Ensemble Learning》对这三种集成学习框架有了明确的定义，概括如下：</p><ul><li>bagging：从训练集从进行子抽样组成每个基模型所需要的子训练集，对所有基模型预测的结果进行综合产生最终的预测结果：</li></ul><p><img src="http://omu7tit09.bkt.clouddn.com/15043255665954.jpg" alt=""></p><ul><li>boosting：训练过程为阶梯状，基模型按次序一一进行训练（实现上可以做到并行），基模型的训练集按照某种策略每次都进行一定的转化。对所有基模型预测的结果进行线性综合产生最终的预测结果：</li></ul><p><img src="http://omu7tit09.bkt.clouddn.com/15043256075450.jpg" alt=""></p><ul><li>stacking：将训练好的所有基模型对训练基进行预测，第j个基模型对第i个训练样本的预测值将作为新的训练集中第i个样本的第j个特征值，最后基于新的训练集进行训练。同理，预测的过程也要先经过所有基模型的预测形成新的测试集，最后再对测试集进行预测：</li></ul><p><img src="http://omu7tit09.bkt.clouddn.com/15043256303505.jpg" alt=""><br>有了这些基本概念之后，直觉将告诉我们，由于不再是单一的模型进行预测，所以模型有了“集思广益”的能力，也就不容易产生过拟合现象。但是，直觉是不可靠的，接下来我们将从模型的偏差和方差入手，彻底搞清楚这一问题。</p><h2 id="三、偏差和方差"><a href="#三、偏差和方差" class="headerlink" title="三、偏差和方差"></a>三、偏差和方差</h2><p>广义的偏差（bias）描述的是预测值和真实值之间的差异，方差（variance）描述距的是预测值作为随机变量的离散程度。《Understanding the Bias-Variance Tradeoff》当中有一副图形象地向我们展示了偏差和方差的关系：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15043259439732.png" alt=""></p><h3 id="3-1-模型的偏差和方差"><a href="#3-1-模型的偏差和方差" class="headerlink" title="3.1 模型的偏差和方差"></a>3.1 模型的偏差和方差</h3><p>模型的偏差是一个相对来说简单的概念：训练出来的模型在训练集上的准确度。</p><p>定义随机变量的值的差异是计算方差的前提条件，通常来说，我们遇到的都是数值型的随机变量，数值之间的差异再明显不过（减法运算）。但是，模型的差异性呢？我们可以理解模型的差异性为模型的结构差异，例如：线性模型中权值向量的差异，树模型中树的结构差异等。在研究模型方差的问题上，我们并不需要对方差进行定量计算，只需要知道其概念即可。</p><p>研究模型的方差有什么现实的意义呢？我们认为方差越大的模型越容易过拟合：假设有两个训练集A和B，经过A训练的模型Fa与经过B训练的模型Fb差异很大，这意味着Fa在类A的样本集合上有更好的性能，而Fb反之，这便是我们所说的过拟合现象。</p><p>我们常说集成学习框架中的基模型是弱模型，通常来说弱模型是偏差高（在训练集上准确度低）方差小（防止过拟合能力强）的模型。但是，并不是所有集成学习框架中的基模型都是弱模型。bagging和stacking中的基模型为强模型（偏差低方差高），boosting中的基模型为弱模型。</p><p>在bagging和boosting框架中，通过计算基模型的期望和方差，我们可以得到模型整体的期望和方差。为了简化模型，我们假设基模型的权重、方差及两两间的相关系数相等。由于bagging和boosting的基模型都是线性组成的，那么有：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15043259867980.png" alt=""></p><h3 id="3-2-bagging的偏差和方差"><a href="#3-2-bagging的偏差和方差" class="headerlink" title="3.2 bagging的偏差和方差"></a>3.2 bagging的偏差和方差</h3><p>对于bagging来说，每个基模型的权重等于1/m且期望近似相等（子训练集都是从原训练集中进行子抽样），故我们可以进一步化简得到：<br><img src="http://omu7tit09.bkt.clouddn.com/15043260804255.png" alt=""></p><p>根据上式我们可以看到，整体模型的期望近似于基模型的期望，这也就意味着整体模型的偏差和基模型的偏差近似。同时，整体模型的方差小于等于基模型的方差（当相关性为1时取等号），随着基模型数（m）的增多，整体模型的方差减少，从而防止过拟合的能力增强，模型的准确度得到提高。但是，模型的准确度一定会无限逼近于1吗？并不一定，当基模型数增加到一定程度时，方差公式第二项的改变对整体方差的作用很小，防止过拟合的能力达到极限，这便是准确度的极限了。另外，在此我们还知道了为什么bagging中的基模型一定要为强模型，否则就会导致整体模型的偏差度低，即准确度低。</p><p>Random Forest是典型的基于bagging框架的模型，其在bagging的基础上，进一步降低了模型的方差。Random Fores中基模型是树模型，在树的内部节点分裂过程中，不再是将所有特征，而是随机抽样一部分特征纳入分裂的候选项。这样一来，基模型之间的相关性降低，从而在方差公式中，第一项显著减少，第二项稍微增加，整体方差仍是减少。</p><h3 id="3-3-boosting的偏差和方差"><a href="#3-3-boosting的偏差和方差" class="headerlink" title="3.3 boosting的偏差和方差"></a>3.3 boosting的偏差和方差</h3><p>对于boosting来说，基模型的训练集抽样是强相关的，那么模型的相关系数近似等于1，故我们也可以针对boosting化简公式为：<br><img src="http://omu7tit09.bkt.clouddn.com/15043263221887.png" alt=""></p><p>通过观察整体方差的表达式，我们容易发现，若基模型不是弱模型，其方差相对较大，这将导致整体模型的方差很大，即无法达到防止过拟合的效果。因此，boosting框架中的基模型必须为弱模型。</p><p>因为基模型为弱模型，导致了每个基模型的准确度都不是很高（因为其在训练集上的准确度不高）。随着基模型数的增多，整体模型的期望值增加，更接近真实值，因此，整体模型的准确度提高。但是准确度一定会无限逼近于1吗？仍然并不一定，因为训练过程中准确度的提高的主要功臣是整体模型在训练集上的准确度提高，而随着训练的进行，整体模型的方差变大，导致防止过拟合的能力变弱，最终导致了准确度反而有所下降。</p><p>基于boosting框架的Gradient Tree Boosting模型中基模型也为树模型，同Random Forrest，我们也可以对特征进行随机抽样来使基模型间的相关性降低，从而达到减少方差的效果。</p><h3 id="3-4-模型的独立性"><a href="#3-4-模型的独立性" class="headerlink" title="3.4 模型的独立性"></a>3.4 模型的独立性</h3><p>聪明的读者这时肯定要问了，如何衡量基模型的独立性？我们说过，抽样的随机性决定了模型的随机性，如果两个模型的训练集抽样过程不独立，则两个模型则不独立。这时便有一个天大的陷阱在等着我们：bagging中基模型的训练样本都是独立的随机抽样，但是基模型却不独立呢？</p><p>我们讨论模型的随机性时，抽样是针对于样本的整体。而bagging中的抽样是针对于训练集（整体的子集），所以并不能称其为对整体的独立随机抽样。那么到底bagging中基模型的相关性体现在哪呢？在知乎问答《为什么说bagging是减少variance，而boosting是减少bias?》中请教用户“过拟合”后，我总结bagging的抽样为两个过程：</p><ul><li>样本抽样：整体模型F(X1, X2, …, Xn)中各输入随机变量（X1, X2, …, Xn）对样本的抽样</li><li>子抽样：从整体模型F(X1, X2, …, Xn)中随机抽取若干输入随机变量成为基模型的输入随机变量</li></ul><p>假若在子抽样的过程中，两个基模型抽取的输入随机变量有一定的重合，那么这两个基模型对整体样本的抽样将不再独立，这时基模型之间便具有了相关性。</p><h3 id="3-5-小结"><a href="#3-5-小结" class="headerlink" title="3.5 小结"></a>3.5 小结</h3><p>还记得调参的目标吗：模型在训练集上的准确度和防止过拟合能力的大和谐！为此，我们目前做了一些什么工作呢？</p><ul><li>使用模型的偏差和方差来描述其在训练集上的准确度和防止过拟合的能力</li><li>对于bagging来说，整体模型的偏差和基模型近似，随着训练的进行，整体模型的方差降低</li><li>对于boosting来说，整体模型的初始偏差较高，方差较低，随着训练的进行，整体模型的偏差降低（虽然也不幸地伴随着方差增高），当训练过度时，因方差增高，整体模型的准确度反而降低</li><li>整体模型的偏差和方差与基模型的偏差和方差息息相关</li></ul><p>这下总算有点开朗了，那些让我们抓狂的参数，现在可以粗略地分为两类了：控制整体训练过程的参数和基模型的参数，这两类参数都在影响着模型在训练集上的准确度以及防止过拟合的能力。</p><h2 id="四、Gradient-Boosting"><a href="#四、Gradient-Boosting" class="headerlink" title="四、Gradient Boosting"></a>四、Gradient Boosting</h2><p>对基于Gradient Boosting框架的模型的进行调试时，我们会遇到一个重要的概念：损失函数。在本节中，我们将把损失函数的“今生来世”讲个清楚！</p><p>基于boosting框架的整体模型可以用线性组成式来描述，其中$h<a href="x">i</a>$为基模型与其权值的乘积：<img src="http://omu7tit09.bkt.clouddn.com/15049164023539.png" alt=""></p><p>根据上式，整体模型的训练目标是使预测值F(x)逼近真实值y，也就是说要让每一个基模型的预测值逼近各自要预测的部分真实值。由于要同时考虑所有基模型，导致了整体模型的训练变成了一个非常复杂的问题。所以，研究者们想到了一个贪心的解决手段：每次只训练一个基模型。那么，现在改写整体模型为迭代式：<img src="http://omu7tit09.bkt.clouddn.com/15049164187673.png" alt=""></p><p>这样一来，每一轮迭代中，只要集中解决一个基模型的训练问题：使$F<a href="x">i</a>$逼近真实值y。</p><h3 id="4-1-拟合残差"><a href="#4-1-拟合残差" class="headerlink" title="4.1 拟合残差"></a>4.1 拟合残差</h3><p>使F<a href="x">i</a>逼近真实值，其实就是使h<a href="x">i</a>逼近真实值和上一轮迭代的预测值F<a href="x">i-1</a>之差，即残差（y-F<a href="x">i-1</a>）。最直接的做法是构建基模型来拟合残差，在博文《GBDT（MART） 迭代决策树入门教程 | 简介》中，作者举了一个生动的例子来说明通过基模型拟合残差，最终达到整体模型F(x)逼近真实值。</p><p>研究者发现，残差其实是最小均方损失函数的关于预测值的反向梯度：<br><img src="http://omu7tit09.bkt.clouddn.com/15049165747607.png" alt=""></p><p>也就是说，若$F<a href="x">i-1</a>$加上拟合了反向梯度的$h<a href="x">i</a>$得到$F<a href="x">i</a>$，该值可能将导致平方差损失函数降低，预测的准确度提高！这显然不是巧合，但是研究者们野心更大，希望能够创造出一种对任意损失函数都可行的训练方法，那么仅仅拟合残差是不恰当的了。</p><h3 id="4-2-拟合反向梯度"><a href="#4-2-拟合反向梯度" class="headerlink" title="4.2 拟合反向梯度"></a>4.2 拟合反向梯度</h3><h4 id="4-2-1-契机：引入任意损失函数"><a href="#4-2-1-契机：引入任意损失函数" class="headerlink" title="4.2.1 契机：引入任意损失函数"></a>4.2.1 契机：引入任意损失函数</h4><p>引入任意损失函数后，我们可以定义整体模型的迭代式如下：<br><img src="http://omu7tit09.bkt.clouddn.com/15049166219029.png" alt=""></p><p>在这里，损失函数被定义为泛函。</p><h4 id="4-2-2-难题一：任意损失函数的最优化"><a href="#4-2-2-难题一：任意损失函数的最优化" class="headerlink" title="4.2.2 难题一：任意损失函数的最优化"></a>4.2.2 难题一：任意损失函数的最优化</h4><p>对任意损失函数（且是泛函）的最优化是困难的。我们需要打破思维的枷锁，将整体损失函数L’定义为n元普通函数（n为样本容量），损失函数L定义为2元普通函数（记住！！！这里的损失函数不再是泛函！！！）：<br><img src="http://omu7tit09.bkt.clouddn.com/15049167322659.png" alt=""></p><p>我们不妨使用梯度最速下降法来解决整体损失函数L’最小化的问题，先求整体损失函数的反向梯度：<br><img src="http://omu7tit09.bkt.clouddn.com/15049167506559.png" alt=""></p><p>假设已知样本x的当前预测值为$F<a href="x">i-1</a>$，下一步将预测值按照反向梯度，依照步长为$r[i]$，进行更新：<br><img src="http://omu7tit09.bkt.clouddn.com/15049167761742.png" alt=""></p><p>步长r[i]不是固定值，而是设计为：<br><img src="http://omu7tit09.bkt.clouddn.com/15049167933072.png" alt=""></p><h4 id="4-2-3-难题二：无法对测试样本计算反向梯度"><a href="#4-2-3-难题二：无法对测试样本计算反向梯度" class="headerlink" title="4.2.3 难题二：无法对测试样本计算反向梯度"></a>4.2.3 难题二：无法对测试样本计算反向梯度</h4><p>问题又来了，由于测试样本中y是未知的，所以无法求反向梯度。这正是Gradient Boosting框架中的基模型闪亮登场的时刻！在第i轮迭代中，我们创建训练集如下：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15049168107346.png" alt=""></p><p>也就是说，让基模型拟合反向梯度函数，这样我们就可以做到只输入x这一个参数，就可求出其对应的反向梯度了（当然，通过基模型预测出来的反向梯度并不是准确的，这也提供了泛化整体模型的机会）。</p><p>综上，假设第i轮迭代中，根据新训练集训练出来的基模型为$f<a href="x">i</a>$，那么最终的迭代公式为：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15049168358384.png" alt=""></p><h3 id="4-3-常见的损失函数"><a href="#4-3-常见的损失函数" class="headerlink" title="4.3 常见的损失函数"></a>4.3 常见的损失函数</h3><p>ls：最小均方回归中用到的损失函数。在之前我们已经谈到，从拟合残差的角度来说，残差即是该损失函数的反向梯度值（所以又称反向梯度为伪残差）。不同的是，从拟合残差的角度来说，步长是无意义的。该损失函数是sklearn中Gradient Tree Boosting回归模型默认的损失函数。</p><p>deviance：逻辑回归中用到的损失函数。熟悉逻辑回归的读者肯定还记得，逻辑回归本质是求极大似然解，其认为样本服从几何分布，样本属于某类别的概率可以logistic函数表达。所以，如果该损失函数可用在多类别的分类问题上，故其是sklearn中Gradient Tree Boosting分类模型默认的损失函数。</p><p>exponential：指数损失函数，表达式为：<br><img src="http://omu7tit09.bkt.clouddn.com/15049169121290.png" alt=""></p><p>对该损失函数求反向梯度得：<br><img src="http://omu7tit09.bkt.clouddn.com/15049169232006.png" alt=""></p><p>这时，在第i轮迭代中，新训练集如下：<br><img src="http://omu7tit09.bkt.clouddn.com/15049169392577.png" alt=""><br>脑袋里有什么东西浮出水面了吧？让我们看看Adaboost算法中，第i轮迭代中第j个样本权值的更新公式：<br><img src="http://omu7tit09.bkt.clouddn.com/15049169515007.png" alt=""><br>样本的权值什么时候会用到呢？计算第i轮损失函数的时候会用到：<br><img src="http://omu7tit09.bkt.clouddn.com/15049169634827.png" alt=""><br>让我们再回过头来，看看使用指数损失函数的Gradient Boosting计算第i轮损失函数：<br><img src="http://omu7tit09.bkt.clouddn.com/15049169776362.png" alt=""></p><p>天呐，两个公式就差了一个对权值的归一项。这并不是巧合，当损失函数是指数损失时，Gradient Boosting相当于二分类的Adaboost算法。是的，指数损失仅能用于二分类的情况。</p><h3 id="4-4-步子太大容易扯着蛋：缩减"><a href="#4-4-步子太大容易扯着蛋：缩减" class="headerlink" title="4.4 步子太大容易扯着蛋：缩减"></a>4.4 步子太大容易扯着蛋：缩减</h3><p>缩减也是一个相对显见的概念，也就是说使用Gradient Boosting时，每次学习的步长缩减一点。这有什么好处呢？缩减思想认为每次走一小步，多走几次，更容易逼近真实值。如果步子迈大了，使用最速下降法时，容易迈过最优点。将缩减代入迭代公式：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15049170105760.png" alt=""></p><p>缩减需要配合基模型数一起使用，当缩减率v降低时，基模型数要配合增大，这样才能提高模型的准确度。</p><h3 id="4-5-初始模型"><a href="#4-5-初始模型" class="headerlink" title="4.5 初始模型"></a>4.5 初始模型</h3><p>还有一个不那么起眼的问题，初始模型$F<a href="x">0</a>$是什么呢？如果没有定义初始模型，整体模型的迭代式一刻都无法进行！所以，我们定义初始模型为：<br><img src="http://omu7tit09.bkt.clouddn.com/15049170394638.png" alt=""></p><p>根据上式可知，对于不同的损失函数来说，初始模型也是不一样的。对所有的样本来说，根据初始模型预测出来的值都一样。</p><h3 id="4-5-Gradient-Tree-Boosting"><a href="#4-5-Gradient-Tree-Boosting" class="headerlink" title="4.5 Gradient Tree Boosting"></a>4.5 Gradient Tree Boosting</h3><p>终于到了备受欢迎的Gradient Tree Boosting模型了！但是，可讲的却已经不多了。我们已经知道了该模型的基模型是树模型，并且可以通过对特征的随机抽样进一步减少整体模型的方差。我们可以在维基百科的Gradient Boosting词条中找到其伪代码实现。</p><h3 id="4-6-小结"><a href="#4-6-小结" class="headerlink" title="4.6 小结"></a>4.6 小结</h3><p>到此，读者应当很清楚Gradient Boosting中的损失函数有什么意义了。要说偏差描述了模型在训练集准确度，则损失函数则是描述该准确度的间接量纲。也就是说，模型采用不同的损失函数，其训练过程会朝着不同的方向进行！</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>　　磨刀不误砍柴功，我们花了这么多时间来学习必要的理论，我强调一次：必要的理论！集成学习模型的调参工作的核心就是找到合适的参数，能够使整体模型在训练集上的准确度和防止过拟合的能力达到协调，从而达到在样本总体上的最佳准确度。有了本文的理论知识铺垫，在下篇中，我们将对Random Forest和Gradient Tree Boosting中的每个参数进行详细阐述，同时也有一些小试验证明我们的结论。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;很多人在竞赛（Kaggle，天池等）或工程实践中使用了集成学习（例如，RF、GTB等），确实也取得了不错的效果，在保证准确度的同时也提升了模型防止过拟合的能力。但是，我们真的用对了集成学习吗？&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Scikit-Learn" scheme="http://yoursite.com/tags/Scikit-Learn/"/>
    
      <category term="集成学习" scheme="http://yoursite.com/tags/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习算法系列（33）：特征处理（Feature Processing）</title>
    <link href="http://yoursite.com/2017/08/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%8833%EF%BC%89%EF%BC%9A%E7%89%B9%E5%BE%81%E5%A4%84%E7%90%86%EF%BC%88Feature%20Processing%EF%BC%89/"/>
    <id>http://yoursite.com/2017/08/31/机器学习算法系列（33）：特征处理（Feature Processing）/</id>
    <published>2017-08-31T15:14:45.000Z</published>
    <updated>2017-12-26T08:04:24.376Z</updated>
    
    <content type="html"><![CDATA[<p>特征工程（Feature Engineering）经常被说为机器学习中的black art，这里面包含了很多不可言说的方面。怎么处理好特征，最重要的当然还是对要解决问题的了解。但是，它其实也有很多科学的地方。这篇文章我之所以命名为特征处理（Feature Processing），是因为这里面要介绍的东西只是特征工程中的一小部分。这部分比较基础，比较容易说，所以由此开始。</p><a id="more"></a><p>单个原始特征（或称为变量）通常属于以下几类之一：</p><ul><li>连续（continuous）特征；</li><li>无序类别（categorical）特征；</li><li>有序类别（ordinal）特征。</li></ul><p>本文中我主要介绍针对单个特征的处理方法，虽然也会附带介绍基础的特征组合方法。同时处理多个特征，以及更复杂的特征处理方法介绍，以后我再另外细说。下面我由浅入深地逐渐说明针对这三类特征的常用处理方法。</p><h2 id="一、初级篇"><a href="#一、初级篇" class="headerlink" title="一、初级篇"></a>一、初级篇</h2><p>这节要讲的处理技术，应该刚接触机器学习不久的同学都会知道。</p><h3 id="1-1-连续特征"><a href="#1-1-连续特征" class="headerlink" title="1.1 连续特征"></a>1.1 连续特征</h3><h3 id="1-2-无序特征"><a href="#1-2-无序特征" class="headerlink" title="1.2 无序特征"></a>1.2 无序特征</h3><p>可以使用One-hot（也叫One-of-k）的方法把每个无序特征转化为一个数值向量。比如一个无序特征color有三种取值：red，green，blue。那么可以用一个长度为3的向量来表示它，向量中的各个值分别对应于red，green，blue。如：</p><div class="table-container"><table><thead><tr><th>color取值</th><th>向量表示</th></tr></thead><tbody><tr><td>red</td><td>(1, 0, 0)</td><td></td></tr><tr><td>green</td><td>(0, 1, 0)</td></tr><tr><td>blue</td><td>(0, 0, 1)</td></tr></tbody></table></div><p>这种方法在NLP里用的很多，就是所谓的词向量模型。变换后的向量长度对于词典长度，每个词对应于向量中的一个元素。</p><p>机器学习书籍里在讲这个的时候介绍的处理方法可能跟我上面说的有点差别。上面说的表达方式里有一个维度是可以省略的。</p><p>既然我们知道color一定是取3个值中的一个，那么我们知道向量的前两个元素值，就能推断第3个值是多少。所以，其实用下面的方式就可以表达到底是哪种颜色：</p><div class="table-container"><table><thead><tr><th>color取值</th><th>向量表示</th></tr></thead><tbody><tr><td>red</td><td>(1, 0)</td><td></td></tr><tr><td>green</td><td>(0, 1)</td></tr><tr><td>blue</td><td>(0, 0)</td></tr></tbody></table></div><p>这样表达的好处是少用了一个维度，降低了转化后特征之间的相关性。但在实际问题中特征基本都或多或少会有些缺失。使用第一种表达方式就可以用全0的向量来表示值缺失，而第二种表达方式是没法表达缺失的。</p><h3 id="1-3-有序特征"><a href="#1-3-有序特征" class="headerlink" title="1.3 有序特征"></a>1.3 有序特征</h3><p>有些特征虽然也像无序特征那样只取限定的几个值，但是这些值之间有顺序的含义。例如一个人的状态status有三种取值：bad, normal, good，显然bad &lt; normal &lt; good。</p><p>当然，对有序特征最简单的处理方式是忽略其中的顺序关系，把它看成无序的，这样我们就可以使用处理无序特征的方式来处理它。在实际问题中，这种处理方式其实用的很多。</p><p>当然有些问题里有序可能会很重要，这时候就不应该把其中的顺序关系丢掉。一般的表达方式如下：</p><div class="table-container"><table><thead><tr><th>status取值</th><th>向量表示</th></tr></thead><tbody><tr><td>bad</td><td>(1, 0, 0)</td><td></td></tr><tr><td>normal</td><td>(1, 1, 0)</td></tr><tr><td>good</td><td>(1, 1, 1)</td></tr></tbody></table></div><p>上面这种表达方式很巧妙地利用递进表达了值之间的顺序关系。</p><h2 id="二、中级篇"><a href="#二、中级篇" class="headerlink" title="二、中级篇"></a>二、中级篇</h2><p>最容易让人掉以轻心的，往往就是大家觉得最简单的事。在特征处理中，最容易让刚入门同学忽略的，是对连续特征的处理方式。</p><p>以线性分类器Linear Regression (LinearReg)为例，它是通过特征的线性加权来预测因变量y：</p><script type="math/tex; mode=display">y=w^Tx</script><p>但大部分实际情况下，yy与xx都不会是这么简单的线性关系，甚至连单调关系都不会有。举个只有一个特征的例子，如果yy与xx的实际关系如下图：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15041455130654.png" alt=""></p><p>那么直接把xx扔进LinearReg模型是怎么也得不到好结果的。很多人会想着既然线性分类器搞不定，那就直接找个非线性的好了，比如高斯核的SVM。我们确实可以通过这种简单换算法的方式解决这个简单的问题。但对于很多实际问题（如广告点击率预测），往往特征非常多，这时候时间约束通常不允许我们使用很复杂的非线性分类器。这也是为什么算法发展这么多年，广告点击率预测最常用的方法还是Logistic Regression (LogisticReg)。</p><p>对于上面这个问题，有没有什么办法使得LinearReg也能处理得不错？当然是有，就是对原始特征x做转化，把原来的非线性关系转化为线性关系。</p><h3 id="2-1-方法一：离散化"><a href="#2-1-方法一：离散化" class="headerlink" title="2.1 方法一：离散化"></a>2.1 方法一：离散化</h3><p>最常用的转化方式是对xx做离散化(discretization)，也就是把原来的值分段，转化成一个取值为0或1的向量。原始值落在某个段里，向量中此段对应的元素就为1，否则为0。</p><p>离散化的目标是y与转化后向量里的每个元素都保持比较好的线性关系。</p><p>比如取离散点{0.5,1.5,2.5}，通过判断xx属于(−∞,0.5)，[0.5,1.5)，[1.5,2.5)，[2.5,+∞)中哪段来把它离散化为4维的向量。下面是一些例子的离散结果：</p><div class="table-container"><table><thead><tr><th>原始值xx</th><th>离散化后的值</th></tr></thead><tbody><tr><td>0.1</td><td>(1, 0, 0, 0)</td></tr><tr><td>1.3</td><td>(0, 1, 0, 0)</td></tr><tr><td>3.2</td><td>(0, 0, 0, 1)</td></tr><tr><td>5.8</td><td>(0, 0, 0, 1)</td></tr></tbody></table></div><p>离散化方法的关键是怎么确定分段中的离散点。下面是常用的选取离散点的方法：</p><blockquote><p>等距离离散：</p></blockquote><p>顾名思义，就是离散点选取等距点。我们上面对xx取离散点{0.5,1.5,2.5}就是一种等距离散，见下图。图中垂直的灰线代表离散点。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15041459283636.png" alt=""></p><blockquote><p>等样本点离散</p></blockquote><p>选取的离散点保证落在每段里的样本点数量大致相同，见下图。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15041459715963.png" alt=""></p><blockquote><p>画图观察趋势</p></blockquote><p>以xx为横坐标，yy为纵坐标，画图，看曲线的趋势和拐点。通过观察下面的图我们发现可以利用3条直线（红色直线）来逐段近似原来的曲线。把离散点设为两条直线相交的各个点，我们就可以把xx离散化为长度为3的向量。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15041460055828.png" alt=""></p><p>上面介绍的这种离散化为0/1向量的方法有个问题，它在离散时不会考虑到具体的xx到离散边界的距离。比如等距离散中取离散点为{0.5,1.5,2.5}{0.5,1.5,2.5}，那么1.499，1.501和2.49分别会离散为(0, 1, 0, 0)，(0, 0, 1, 0)和(0, 0, 1, 0)。1.499和1.501很接近，可是就因为这种强制分段的离散导致它们离散的结果差距很大。</p><p>针对上面这种硬离散的一种改进就是使用软离散，也就是在离散时考虑到xx与附近离散点的距离，离散出来的向量元素值可以是0/1之外的其他值。有兴趣的同学可以去ESL1这本书中找点感觉。</p><h3 id="2-2-函数变换"><a href="#2-2-函数变换" class="headerlink" title="2.2 函数变换"></a>2.2 函数变换</h3><p>函数变换直接把原来的特征通过非线性函数做变换，然后把原来的特征，以及变换后的特征一起加入模型进行训练。常用的变换函数见下表，不过其实你可以尝试任何函数。</p><div class="table-container"><table><thead><tr><th>常用非线性函数f(x)</th><th>x的取值范围</th></tr></thead><tbody><tr><td>$x^α; α∈(−∞,+∞)$</td><td>$(−∞,+∞)$</td></tr><tr><td>$log(x)$</td><td>$(0,+∞)$</td></tr><tr><td>$log(\frac{x}{1−x})$</td><td>$(0,1)$</td></tr></tbody></table></div><p>这个方法操作起来很简单，但记得对新加入的特征做归一化。</p><p>对于我们前面的问题，只要把$x^2$，$x^3$也作为特征加入即可，因为实际上y就是x的一个三次多项式。</p><h2 id="三、高级篇"><a href="#三、高级篇" class="headerlink" title="三、高级篇"></a>三、高级篇</h2><h3 id="3-1-笛卡尔乘积"><a href="#3-1-笛卡尔乘积" class="headerlink" title="3.1 笛卡尔乘积"></a>3.1 笛卡尔乘积</h3><p>我们可以使用笛卡尔乘积的方式来组合2个或更多个特征。比如有两个类别特征color和light，它们分别可以取值为red，green，blue和on, off。这两个特征各自可以离散化为3维和2维的向量。对它们做笛卡尔乘积转化，就可以组合出长度为6的特征，它们分别对应着原始值对(red, on)，(red, off)，(green, on)，(green, off)，(blue, on)，(blue, off)。下面的矩阵表达方式更清楚地说明了这种组合。</p><div class="table-container"><table><thead><tr><th>X</th><th>on</th><th>off</th></tr></thead><tbody><tr><td>red</td><td></td></tr><tr><td>green</td><td></td></tr><tr><td>blue</td></tr></tbody></table></div><p>对于3个特征的笛卡尔乘积组合，可以表达为立方的形式。更多特征的组合依次类推。这个方法也可以直接用于连续特征与类别特征之间的组合，只要把连续特征看成是1维的类别特征就好了，这时候组合后特征对应的值就不是0/1了，而是连续特征的取值。</p><h3 id="3-2-离散化续篇"><a href="#3-2-离散化续篇" class="headerlink" title="3.2 离散化续篇"></a>3.2 离散化续篇</h3><p>在上节中我已经介绍了一些常用的离散化单个连续特征的方法，其中一个是画图观察趋势。画图观察趋势的好处是直观、可解释性强，坏处是很麻烦。当要离散化的特征很多时，这种方法可操作性较差。</p><p>机器学习中有个很好解释，速度也不错的模型——决策树模型。大白话说决策树模型就是一大堆的if else。它天生就可以对连续特征分段，所以把它用于离散化连续特征合情合理。我称这种方法为决策树离散化方法。例如Gmail在对信件做重要性排序时就使用了决策树离散化方法</p><p>决策树离散化方法通常也是每次离散化一个连续特征，做法如下：</p><p>单独用此特征和目标值yy训练一个决策树模型，然后把训练获得的模型内的特征分割点作为离散化的离散点。</p><p>这种方法当然也可以同时离散化多个连续特征，但是操作起来就更复杂了，实际用的不多。</p><h3 id="3-3-核方法"><a href="#3-3-核方法" class="headerlink" title="3.3 核方法"></a>3.3 核方法</h3><p>核方法经常作为线性模型的一种推广出现。以线性回归模型为例，它对应的核方法如下：</p><script type="math/tex; mode=display">f_\theta (x)=\sum_{i=1}^n\theta _iK(x,x_i)</script><p>其中$\{x_i\}^n_{i=1}$为训练样本点，$K(x_i，x_j)$为核函数，比如常用的高斯核函数为：</p><script type="math/tex; mode=display">K(x_i，x_j)=exp(-\frac{||x_i-x_j||_2^2}{2h^2})</script><p>如果我们把上面模型里的${K(x,x_i)}^n_{i=1}$看成特征，而$θ$看成模型参数的话，上面的模型仍旧是个线性模型。所以可以认为核方法只是特征函数变换的一种方式。</p><p>当然，如果把核函数$K(x_i,x_j)$看成一种相似度的话，那上面的模型就是kNN模型了，或者叫做加权平均模型也可以。</p><p>因为核方法在预测时也要用到训练样本点，耗内存且计算量大，所以在数据量较大的实际问题中用的并不多。</p><p>到此，我已经介绍了不少针对单个特征的处理方法。这些处理方法很难说哪个好哪个不好。有些问题这个好，有些问题那个好，也没什么绝招能直接判断出哪种方法能适合哪些问题。唯一的招就是：Experiment a lot!</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>Trevor Hastie et al. The Elements of Statistical Learning, 2001. ↩</li><li>Douglas Aberdeen et al. The Learning Behind Gmail Priority Inbox, 2010. ↩</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;特征工程（Feature Engineering）经常被说为机器学习中的black art，这里面包含了很多不可言说的方面。怎么处理好特征，最重要的当然还是对要解决问题的了解。但是，它其实也有很多科学的地方。这篇文章我之所以命名为特征处理（Feature Processing），是因为这里面要介绍的东西只是特征工程中的一小部分。这部分比较基础，比较容易说，所以由此开始。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="特征工程" scheme="http://yoursite.com/tags/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记（12）：单例模式</title>
    <link href="http://yoursite.com/2017/08/30/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8812%EF%BC%89%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/08/30/Java学习笔记（12）：单例模式/</id>
    <published>2017-08-30T14:20:45.000Z</published>
    <updated>2017-09-22T14:21:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、设计模式"><a href="#一、设计模式" class="headerlink" title="一、设计模式"></a>一、设计模式</h2><p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。</p><a id="more"></a><p>面向对象最基本的设计原则有5条，分别是：单一职责原则、开放封闭原则、依赖倒置原则、接口隔离原则和Liskov替换原则。</p><p>设计模式就是实现了这些原则，从而达到了代码复用、增加可维护性的目的。</p><p>设计模式分为三种类型，共23类。</p><ul><li>创建型模式：</li></ul><p>是处理对象创建的设计模式，试图根据实际情况使用合适的方式创建对象。基本的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式通过以某种方式控制对象的创建来解决问题。</p><p>创建型模式由两个主导思想构成。一是将系统使用的具体类封装起来，二是隐藏这些具体类的实例创建和结合的方式。</p><p>创建型模式包括：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。</p><ul><li>结构型模式：</li></ul><p>适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。</p><ul><li>行为型模式：</li></ul><p>模板方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式。</p><h2 id="二、单例模式"><a href="#二、单例模式" class="headerlink" title="二、单例模式"></a>二、单例模式</h2><p>单例模式是较为常用的模式之一，且经常作为考题进行考察。<br>单例模式的意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p>单例模式的结构图：<br><img src="http://omu7tit09.bkt.clouddn.com/15047784910835.jpg" alt=""></p><p>使用单例的优点：</p><ul><li>单例类只有一个实例</li><li>共享资源，全局使用</li><li>节省创建时间，提高性能</li></ul><p>单例模式有多种写法各有利弊，现在我们来看看各种模式写法。</p><h3 id="2-1-饿汉式"><a href="#2-1-饿汉式" class="headerlink" title="2.1 饿汉式"></a>2.1 饿汉式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;  </div><div class="line">     private static Singleton instance = new Singleton();  </div><div class="line">     private Singleton ()&#123;</div><div class="line">     &#125;</div><div class="line">     public static Singleton getInstance() &#123;  </div><div class="line">     return instance;  </div><div class="line">     &#125;  </div><div class="line"> &#125;</div></pre></td></tr></table></figure><p>这种方式和名字很贴切，饥不择食，在类装载的时候就创建，不管你用不用，先创建了再说，如果一直没有被使用，便浪费了空间，典型的空间换时间，每次调用的时候，就不需要再判断，节省了运行时间。</p><p>Java Runtime就是使用这种方式，它的源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runtime</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Runtime currentRuntime = <span class="keyword">new</span> Runtime();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns the runtime object associated with the current Java application.</div><div class="line">     * Most of the methods of class &lt;code&gt;Runtime&lt;/code&gt; are instance</div><div class="line">     * methods and must be invoked with respect to the current runtime object.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span>  the &lt;code&gt;Runtime&lt;/code&gt; object associated with the current</div><div class="line">     *          Java application.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title">getRuntime</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> currentRuntime;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/** Don't let anyone else instantiate this class */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Runtime</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"><span class="comment">//以下代码省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>总结：「饿汉式」是最简单的实现方式，这种实现方式适合那些在初始化时就要用到单例的情况，这种方式简单粗暴，如果单例对象初始化非常快，而且占用内存非常小的时候这种方式是比较合适的，可以直接在应用启动时加载并初始化。</p><p>但是，如果单例初始化的操作耗时比较长而应用对于启动速度又有要求，或者单例的占用内存比较大，再或者单例只是在某个特定场景的情况下才会被使用，而一般情况下是不会使用时，使用「饿汉式」的单例模式就是不合适的，这时候就需要用到「懒汉式」的方式去按需延迟加载单例。</p><h3 id="2-2-懒汉式（非线程安全）"><a href="#2-2-懒汉式（非线程安全）" class="headerlink" title="2.2 懒汉式（非线程安全）"></a>2.2 懒汉式（非线程安全）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;  </div><div class="line">      private static Singleton instance;  </div><div class="line">      private Singleton ()&#123;</div><div class="line">      &#125;   </div><div class="line">      public static Singleton getInstance() &#123;  </div><div class="line">      if (instance == null) &#123;  </div><div class="line">          instance = new Singleton();  </div><div class="line">      &#125;  </div><div class="line">      return instance;  </div><div class="line">      &#125;  </div><div class="line"> &#125;</div></pre></td></tr></table></figure><p>懒汉模式申明了一个静态对象，在用户第一次调用时初始化，虽然节约了资源，但第一次加载时需要实例化，反映稍慢一些，而且在多线程不能正常工作。在多线程访问的时候，很可能会造成多次实例化，就不再是单例了。</p><p>「懒汉式」与「饿汉式」的最大区别就是将单例的初始化操作，延迟到需要的时候才进行，这样做在某些场合中有很大用处。比如某个单例用的次数不是很多，但是这个单例提供的功能又非常复杂，而且加载和初始化要消耗大量的资源，这个时候使用「懒汉式」就是非常不错的选择。</p><h3 id="2-3-懒汉式（线程安全）"><a href="#2-3-懒汉式（线程安全）" class="headerlink" title="2.3 懒汉式（线程安全）"></a>2.3 懒汉式（线程安全）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;  </div><div class="line">      private static Singleton instance;  </div><div class="line">      private Singleton ()&#123;</div><div class="line">      &#125;</div><div class="line">      public static synchronized Singleton getInstance() &#123;  </div><div class="line">      if (instance == null) &#123;  </div><div class="line">          instance = new Singleton();  </div><div class="line">      &#125;  </div><div class="line">      return instance;  </div><div class="line">      &#125;  </div><div class="line"> &#125;</div></pre></td></tr></table></figure><p>这两种「懒汉式」单例，名字起的也很贴切，一直等到对象实例化的时候才会创建，确实够懒，不用鞭子抽就不知道走了，典型的时间换空间，每次获取实例的时候才会判断，看是否需要创建，浪费判断时间，如果一直没有被使用，就不会被创建，节省空间。</p><p>因为这种方式在getInstance()方法上加了同步锁，所以在多线程情况下会造成线程阻塞，把大量的线程锁在外面，只有一个线程执行完毕才会执行下一个线程。</p><p>Android中的 InputMethodManager 使用了这种方式，我们看看它的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public final class InputMethodManager &#123;</div><div class="line">    static InputMethodManager sInstance;</div><div class="line">    </div><div class="line">     /**</div><div class="line">     * Retrieve the global InputMethodManager instance, creating it if it</div><div class="line">     * doesn&apos;t already exist.</div><div class="line">     * @hide</div><div class="line">     */</div><div class="line">    public static InputMethodManager getInstance() &#123;</div><div class="line">        synchronized (InputMethodManager.class) &#123;</div><div class="line">            if (sInstance == null) &#123;</div><div class="line">                IBinder b = ServiceManager.getService(Context.INPUT_METHOD_SERVICE);</div><div class="line">                IInputMethodManager service = IInputMethodManager.Stub.asInterface(b);</div><div class="line">                sInstance = new InputMethodManager(service, Looper.getMainLooper());</div><div class="line">            &#125;</div><div class="line">            return sInstance;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-4-双重校验锁（DCL）"><a href="#2-4-双重校验锁（DCL）" class="headerlink" title="2.4 双重校验锁（DCL）"></a>2.4 双重校验锁（DCL）</h3><p>上面的方法「懒汉式（线程安全）」毫无疑问存在性能的问题 — 如果存在很多次getInstance()的调用，那性能问题就不得不考虑了！</p><p>让我们来分析一下，究竟是整个方法都必须加锁，还是仅仅其中某一句加锁就足够了？我们为什么要加锁呢？分析一下出现lazy loaded的那种情形的原因。原因就是检测null的操作和创建对象的操作分离了。如果这两个操作能够原子地进行，那么单例就已经保证了。于是，我们开始修改代码，就成了下面的双重校验锁（Double Check Lock）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;</div><div class="line">/**</div><div class="line">     * 注意此处使用的关键字 volatile，</div><div class="line">     * 被volatile修饰的变量的值，将不会被本地线程缓存，</div><div class="line">     * 所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的处理该变量。</div><div class="line">     */</div><div class="line">    private volatile static Singleton singleton;</div><div class="line">    private Singleton() &#123;</div><div class="line">    &#125;</div><div class="line">    public static Singleton getInstance() &#123;</div><div class="line">        if (instance == null) &#123;</div><div class="line">            synchronized(Singleton.class) &#123;</div><div class="line">                if (instance == null) &#123;</div><div class="line">                    instance = new Singleton();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return singleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这种写法在getSingleton()方法中对singleton进行了两次判空，第一次是为了不必要的同步，第二次是在singleton等于null的情况下才创建实例。在这里用到了volatile关键字，不了解volatile关键字的可以查看 Java多线程（三）volatile域 和 java中volatile关键字的含义 两篇文章，可以看到双重检查模式是正确使用volatile关键字的场景之一。</p><p>「双重校验锁」：既可以达到线程安全，也可以使性能不受很大的影响，换句话说在保证线程安全的前提下，既节省空间也节省了时间，集合了「饿汉式」和两种「懒汉式」的优点，取其精华，去其槽粕。</p><p>对于volatile关键字，还是存在很多争议的。由于volatile关键字可能会屏蔽掉虚拟机中一些必要的代码优化，所以运行效率并不是很高。也就是说，虽然可以使用“双重检查加锁”机制来实现线程安全的单例，但并不建议大量采用，可以根据情况来选用。</p><p>还有就是在java1.4及以前版本中，很多JVM对于volatile关键字的实现的问题，会导致“双重检查加锁”的失败，因此“双重检查加锁”机制只只能用在java1.5及以上的版本。</p><h3 id="2-5-静态内部类"><a href="#2-5-静态内部类" class="headerlink" title="2.5 静态内部类"></a>2.5 静态内部类</h3><p>另外，在很多情况下JVM已经为我们提供了同步控制，比如：</p><ul><li>在static {…}区块中初始化的数据</li><li>访问final字段时</li></ul><p>因为在JVM进行类加载的时候他会保证数据是同步的，我们可以这样实现：采用内部类，在这个内部类里面去创建对象实例。这样的话，只要应用中不使用内部类 JVM 就不会去加载这个单例类，也就不会创建单例对象，从而实现「懒汉式」的延迟加载和线程安全。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123; </div><div class="line">    private Singleton()&#123;</div><div class="line">    &#125;</div><div class="line">      public static Singleton getInstance()&#123;  </div><div class="line">        return SingletonHolder.sInstance;  </div><div class="line">    &#125;  </div><div class="line">    private static class SingletonHolder &#123;  </div><div class="line">        private static final Singleton sInstance = new Singleton();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>第一次加载Singleton类时并不会初始化sInstance，只有第一次调用getInstance方法时虚拟机加载SingletonHolder 并初始化sInstance ，这样不仅能确保线程安全也能保证Singleton类的唯一性，所以推荐使用静态内部类单例模式。</p><p>然而这还不是最简单的方式，《Effective Java》中作者推荐了一种更简洁方便的使用方式，就是使用「枚举」。</p><h3 id="2-6-枚举"><a href="#2-6-枚举" class="headerlink" title="2.6 枚举"></a>2.6 枚举</h3><p>《Java与模式》中，作者这样写道，使用枚举来实现单实例控制会更加简洁，而且无偿地提供了序列化机制，并由JVM从根本上提供保障，绝对防止多次实例化，是更简洁、高效、安全的实现单例的方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public enum Singleton &#123;</div><div class="line"> //定义一个枚举的元素，它就是 Singleton 的一个实例</div><div class="line">     INSTANCE;  </div><div class="line">     </div><div class="line">     public void doSomeThing() &#123;  </div><div class="line">     // do something...</div><div class="line">     &#125;  </div><div class="line"> &#125;</div></pre></td></tr></table></figure><p>使用方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public static void main(String args[]) &#123;</div><div class="line">Singleton singleton = Singleton.instance;</div><div class="line">singleton.doSomeThing();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>枚举单例的优点就是简单，但是大部分应用开发很少用枚举，可读性并不是很高，不建议用。</p><h3 id="2-7-使用容器"><a href="#2-7-使用容器" class="headerlink" title="2.7 使用容器"></a>2.7 使用容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class SingletonManager &#123; </div><div class="line">　　private static Map&lt;String, Object&gt; objMap = new HashMap&lt;String,Object&gt;();</div><div class="line">　　private Singleton() &#123; </div><div class="line">　　&#125;</div><div class="line">　　public static void registerService(String key, Objectinstance) &#123;</div><div class="line">　　　　if (!objMap.containsKey(key) ) &#123;</div><div class="line">　　　　　　objMap.put(key, instance) ;</div><div class="line">　　　　&#125;</div><div class="line">　　&#125;</div><div class="line">　　public static ObjectgetService(String key) &#123;</div><div class="line">　　　　return objMap.get(key) ;</div><div class="line">　　&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这种是用SingletonManager 将多种单例类统一管理，在使用时根据key获取对象对应类型的对象。这种方式使得我们可以管理多种类型的单例，并且在使用时可以通过统一的接口进行获取操作，降低了用户的使用成本，也对用户隐藏了具体实现，降低了耦合度。</p><ul><li>总结</li></ul><p>对于以上七种单例，分别是「饿汉式」、「懒汉式(非线程安全)」、「懒汉式(线程安全)」、「双重校验锁」、「静态内部类」、「枚举」和「容器类管理」。很多时候取决人个人的喜好，虽然双重检查有一定的弊端和问题，但我就是钟爱双重检查，觉得这种方式可读性高、安全、优雅（个人观点）。所以代码里常常默写这样的单例，写的时候感觉自己是个伟大的建筑师。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、设计模式&quot;&gt;&lt;a href=&quot;#一、设计模式&quot; class=&quot;headerlink&quot; title=&quot;一、设计模式&quot;&gt;&lt;/a&gt;一、设计模式&lt;/h2&gt;&lt;p&gt;设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="单例模式" scheme="http://yoursite.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记（11）：进程与线程</title>
    <link href="http://yoursite.com/2017/08/30/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/08/30/Java学习笔记（11）：进程与线程/</id>
    <published>2017-08-30T13:20:45.000Z</published>
    <updated>2017-09-22T14:21:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>操作系统可以同时运行多个任务。打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有3个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。</p><a id="more"></a><p>操作系统轮流让各个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒……这样反复执行下去。表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。</p><p>对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。</p><p>有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。</p><p>由于每个进程至少要干一件事，所以，一个进程至少有一个线程。当然，像Word这种复杂的进程可以有多个线程，多个线程可以同时执行，多线程的执行方式和多进程是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。当然，真正地同时执行多线程需要多核CPU才可能实现。</p><h2 id="一、进程"><a href="#一、进程" class="headerlink" title="一、进程"></a>一、进程</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p>狭义定义：进程是计算机中正在运行的程序的实例（an instance of a computer program that is being executed）。</p><p>程序本身只是指令的集合，进程才是程序（那些指令）的真正运行。用户下达运行程序的命令后，就会产生进程。同一程序可产生多个进程（一对多关系），以允许同时有多位用户运行同一程序，却不会相互冲突。进程需要一些资源才能完成工作，比如CPU使用时间、存储器、文件以及I/O设备，且为依序逐一进行，也就是任何时间内仅能运行一项进程。</p><h3 id="1-2-基本状态"><a href="#1-2-基本状态" class="headerlink" title="1.2 基本状态"></a>1.2 基本状态</h3><p>通常进程有如下5种状态，其中前三种是进程的基本状态。</p><ul><li>1）运行状态（执行窗台）：进程正在处理器上运行。在单处理器环境下，每一时刻最多只有一个进程处于运行状态。</li><li>2）就绪状态：进程已处于准备运行的状态，即进程获得了除处理器之外的一切所需资源，一旦得到处理器即可运行。</li><li>3）阻塞状态：又称为等待状态，进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理器）或等待输入/输出完成。即使处理器空闲，该进程也不能运行。</li><li>4）创建状态：进程正在被创建，尚未转到就绪状态。</li><li>5）结束状态：进程正从系统中消失。可能是进程正常结束或其他原因中断退出运行。</li></ul><p><img src="http://omu7tit09.bkt.clouddn.com/15047697988876.jpg" alt=""><br>进程的三个基本状态之间只可以相互转换的，如图所示。具体的说：</p><ul><li>当一个就绪状态获得处理机时，其状态由就绪变为执行；</li><li>当一个运行进程被剥夺处理机时，如用完系统分给它的时间片、出现更高优先级别的其他进程，其状态由运行变为就绪；</li><li>当一个运行进程因某事件受阻时，如所申请资源被占用、启动I/O传输未完成，其状态由执行变为阻塞；</li><li>当所等待事件发生时，如得到申请资源、I/O传输完成，其状态由阻塞变为就绪</li></ul><h3 id="1-3-进程与程序的区别"><a href="#1-3-进程与程序的区别" class="headerlink" title="1.3 进程与程序的区别"></a>1.3 进程与程序的区别</h3><ul><li>进程是程序及其数据在计算机上的一次运行活动，是一个动态的概念。进程的运行实体是程序、离开程序的进程没有存在的意义。从静态角度看，进程是由程序、数据和进程控制块（PCB）三部分组成的。而程序时一组有序的指令集合，是一种静态的概念。</li><li>进程是程序的一次执行过程，它是动态地创建和消亡的，具有一定的生命期，是暂时存在的；而程序则是一组代码的集合，它是永久存在的，可长期保存。</li><li>一个进程可以执行一个或几个程序，一个程序也可以构成多个进程。进程可创建进程，而程序不可能形成新的程序。</li></ul><h2 id="二、线程"><a href="#二、线程" class="headerlink" title="二、线程"></a>二、线程</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p>线程，有时被称为轻量级进程（Lightweight Process，LWP），是程序执行流的最小单元。一个标准的线程由线程ID、当前指令指针（PC）、寄存器集合和堆栈（stack）组成。另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的资源。</p><p>线程共享的进程环境包括：进程代码段、进程的共有数据（如全局变量，利用这些共享的数据，线程很容易的实现相互之间的通信）、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。</p><p>线程拥有这许多共性的同时，还拥有自己的个性。有了这些个性，线程才能够实现并发性。这些个性包括：</p><ul><li>线程ID：每个线程都有自己的线程ID，这个ID在本进程中是唯一的。进程用此来标识线程；</li><li>寄存器的值：由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线程切换到另一个线程上时，必须将原有线程的寄存器集合的状态进行保存，以便将来该线程在被重新切换时能得以恢复。</li><li>线程的堆栈（Stack）：堆栈是保证线程独立运行所必须的。线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程必须拥有自己的函数堆栈，使得函数调用可以正常执行，不受其他线程的影响。在一个进程的线程共享堆区（heap）。</li><li>错误返回码</li><li>线程的信号屏蔽码</li><li>线程的优先级</li></ul><p>一个线程可以创建和撤销另一个线程，同一进程的多个线程之间可以并发执行。由于县城之间的相互制约，致使线程在运行中呈现间断性。</p><p>线程也有就绪、阻塞和运行三种基本状态。每一个程序都至少有一个线程，若程序只有一个线程，那就是程序本身。</p><p>线程是程序中一个单一的顺序控制流程。在单个程序中同时运行多个线程完成不同的工作，称为多线程。</p><p>引入线程后，进程的内涵发生了变化，进程只作为除CPU以外系统资源的分配单元，线程则作为处理器的分配单元。在同一进程中，线程的切换不会引起进程的切换，但从一个进程中的线程切换到另一个进程中的线程时，将会引起进程的切换。</p><h3 id="1-2-进程与线程的区别"><a href="#1-2-进程与线程的区别" class="headerlink" title="1.2 进程与线程的区别"></a>1.2 进程与线程的区别</h3><ul><li>调度：在传统操作系统中，拥有资源和独立调度的基本单位都是进程。引入线程后，线程是独立调度的基本单位，进程是拥有资源的基本单位。在同一进程中，线程的切换不会引起进程切换。在不同进程中进行的线程切换，则会引起进程切换。</li><li>拥有资源：不论是传统的还是引入线程的操作系统，进程都是拥有资源的基本单位，线程不拥有资源（也有一点必不可少的资源），但线程可以共享其隶属进程的系统资源。</li><li>并发性：在引入线程的操作系统中，不仅进程可以并发执行，而且同一进程内的多个线程也可以并发执行，从而使操作系统具有具有更好的并发性，大大提高了系统的吞吐量。</li><li>系统开销：创建和撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等等，因此操作系统所付出的开销远大于创建或撤销线程的开销。类似地，在进程切换时，涉及当前执行进程CPU环境的保存以及新调度的进程CPU环境的设置；而线程切换时只需保存和设置少量寄存器内容，因此开销很小。另外，由于同一进程内的多个线程共享进程的地址空间，因此这些线程之间的同步与通信比较容易实现，甚至无需操作系统的干预。</li><li>地址空间和其他资源（如打开的文件）：进程的地址空间之间相互独立，同一进程的各线程间共享进程的资源，某进程内的线程对于其他进程不可见。</li><li>通信方面：进程间通信需要借助操作系统，而线程间可以直接读、写进程数据段（如全局变量）来进行通信。</li></ul><h2 id="三、进程通信与进程同步"><a href="#三、进程通信与进程同步" class="headerlink" title="三、进程通信与进程同步"></a>三、进程通信与进程同步</h2><p>多个进程可以共享系统中的各种资源，但其中许多资源一次为能为一个进程使用，我们把一次仅允许一个进程使用的资源成为临界资源。许多物理设备都属于临界资源，如打印机等。</p><p>对临界资源的访问，必须互斥的进行，在每个进程中，访问临界资源的那段代码成为临界区（Critical Section）。</p><p>进程通信与同步有如下一些目的。</p><ul><li>数据传输</li><li>共享数据</li><li>通知数据</li><li>资源共享</li><li>进程控制</li></ul><p>Linux进程间通信的几种主要手段简介：</p><ul><li>管道（Pipe）及有名管道（named Pipe）</li><li>信号（Signal）</li><li>Message（消息队列）</li><li>共享内存（Shared Memory）</li><li>信号量</li><li>套接口</li></ul><p>Linux线程间通信：互斥体（互斥量）、信号量、条件变量<br>Windows进程间通信：管道、共享内存、消息队列、信号量、socket<br>windows线程间通信：临界区（Critical Section）、互斥量（Mutex）、信号量（信号灯）（Semaphore）、事件（Event）。</p><h2 id="四、调度算法"><a href="#四、调度算法" class="headerlink" title="四、调度算法"></a>四、调度算法</h2><p>调度的基本准则包括CPU利用率、系统吞吐量、周转时间、等待时间、响应时间等。</p><ul><li>系统吞吐量：表示单位时间内CPU完成作业的数量</li><li>周转时间：作业完成时刻减去作业到达的时刻</li><li>等待时间：进程处于等处理器状态的时间之和，等待时间越长，用户满意度越低。</li><li>响应时间：从用户提交请求到系统首次产生响应所用的时间。</li></ul><p>典型的调度算法包括：</p><p>实时系统中：FIFO(First Input First Output，先进先出算法)，SJF(Shortest Job First，最短作业优先算法)，SRTF(Shortest Remaining Time First，最短剩余时间优先算法）。</p><p>交互式系统中：RR(Round Robin，时间片轮转算法)，HPF(Highest Priority First，最高优先级算法)，多级队列，最短进程优先，保证调度，彩票调度，公平分享调度。</p><p>多级反馈队列调度算法。其中SJF的平均等待时间、平均周转时间最少。</p><h2 id="五、死锁"><a href="#五、死锁" class="headerlink" title="五、死锁"></a>五、死锁</h2><p>所谓死锁是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。现实生活中简单的例子：交通阻塞，两股相向而行的车流都想通过已被对方占用的道路，结果双方都不能前进。</p><p>死锁产生的原因：系统资源的竞争、进程推进顺序非法</p><p>死锁产生的必要条件：产生死锁必须同时满足以下四个条件，只要其中任一条件不满足，死锁就不会发生。</p><ul><li>互斥条件：进程要求对所分配的资源进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待；</li><li>不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他资源强行夺走，即只能由获得该资源的进程自己来释放。</li><li>请求和保持条件：又称为部分分配条件。进程每次申请它所需要的一部分资源，在等待新资源的同时，进程继续占有已分配到的资源。</li><li>循环等待条件：存在一种进程资源的循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。即存在一个处于等待状态的进程集合$\{P_1,P_2,….P_n\}$其中$P_i$等待的资源被$P_{i+1}(i=0,1,2,…n-1)$占有，$P_n$等待资源被$P_0$占有。</li></ul><p>死锁处理策略</p><ul><li>预防死锁：设置某些限制条件，破坏产生死锁的四个必要条件中的一个或几个</li><li>避免死锁：在资源的动态分配过程中，用某种方法防止系统进入不安全状态。银行家算法是著名的死锁避免算法。</li><li>死锁的检测及解除：无需采取任何限制性措施，允许进程在运行过程中发生死锁，通过系统的检测机制及时地检测出死锁的发生，然后采取某种措施解除死锁。死锁可利用资源分配图来描述。死锁的解除主要方法：资源剥夺法、撤销进程法、进程回退法</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;操作系统可以同时运行多个任务。打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有3个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="操作系统基础" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记（10）：QA</title>
    <link href="http://yoursite.com/2017/08/30/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8810%EF%BC%89%EF%BC%9AQA/"/>
    <id>http://yoursite.com/2017/08/30/Java学习笔记（10）：QA/</id>
    <published>2017-08-30T12:20:45.000Z</published>
    <updated>2017-09-22T14:21:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？"><a href="#一、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？" class="headerlink" title="一、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？"></a>一、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？</h2><p>Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。</p><a id="more"></a><h2 id="二、JDK和JRE的区别是什么？"><a href="#二、JDK和JRE的区别是什么？" class="headerlink" title="二、JDK和JRE的区别是什么？"></a>二、JDK和JRE的区别是什么？</h2><p>Java运行时环境(JRE)是将要执行Java程序的Java虚拟机。它同时也包含了执行applet需要的浏览器插件。Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序。</p><h2 id="三、static关键字是什么意思？Java中是否可以覆盖-override-一个private或者是static的方法？"><a href="#三、static关键字是什么意思？Java中是否可以覆盖-override-一个private或者是static的方法？" class="headerlink" title="三、static关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？"></a>三、static关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？</h2><p>第一小问：<br>static 修饰符能够与变量、方法一起使用，表示是“静态”的。静态变量和静态方法能够通过类名来访问，不需要创建一个类的对象来访问该类的静态成员，所以static修饰的成员又称作类变量和类方法。静态变量与实例变量不同，实例变量总是通过对象来访问，因为它们的值在对象和对象之间有所不同。</p><p>静态变量属于类，不属于任何独立的对象，所以无需创建类的实例就可以访问静态变量。之所以会产生这样的结果，是因为编译器只为整个类创建了一个静态变量的副本，也就是只分配一个内存空间，虽然有多个实例，但这些实例共享该内存。实例变量则不同，每创建一个对象，都会分配一次内存空间，不同变量的内存相互独立，互不影响，改变 a 对象的实例变量不会影响 b 对象。</p><p>static 的变量是在类装载的时候就会被初始化。也就是说，只要类被装载，不管你是否使用了这个static 变量，它都会被初始化。</p><p>小结：类变量(class variables)用关键字 static 修饰，在类加载的时候，分配类变量的内存，以后再生成类的实例对象时，将共享这块内存（类变量），任何一个对象对类变量的修改，都会影响其它对象。外部有两种访问方式：通过对象来访问或通过类名来访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Demo obj1 = <span class="keyword">new</span> Demo();</div><div class="line">        obj1.i = <span class="number">10</span>;</div><div class="line">        obj1.j = <span class="number">20</span>;</div><div class="line">       </div><div class="line">        Demo obj2 = <span class="keyword">new</span> Demo();</div><div class="line">       </div><div class="line">        System.out.println(<span class="string">"obj1.i="</span> + obj1.i + <span class="string">", obj1.j="</span> + obj1.j);</div><div class="line">        System.out.println(<span class="string">"obj2.i="</span> + obj2.i + <span class="string">", obj2.j="</span> + obj2.j);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obj1.i=10, obj1.j=20</div><div class="line">obj2.i=10, obj2.j=0</div></pre></td></tr></table></figure><p>第二小问：<br>被覆盖的方法不能为static。如果父类中的方法为静态的，而子类中的方法不是静态的，但是两个方法除了这一点外其他都满足覆盖条件，那么会发生编译错误；反之亦然。即使父类和子类中的方法都是静态的，并且满足覆盖条件，但是仍然不会发生覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。</p><h2 id="四、是否可以在static环境中访问非static变量？"><a href="#四、是否可以在static环境中访问非static变量？" class="headerlink" title="四、是否可以在static环境中访问非static变量？"></a>四、是否可以在static环境中访问非static变量？</h2><p>非静态的既可以访问静态的，也可以访问非静态的，而静态的只能访问静态的。</p><p>不可以在静态环境中访问非静态。因为静态的成员属于类，随着类的加载而加载到静态方法区内存，当类加载时，此时不一定有实例创建，没有实例，就不可以访问非静态的成员。类的加载先于实例的创建，因此静态环境中，不可以访问非静态！</p><p>static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。</p><h2 id="五、Java支持的数据类型有哪些？什么是自动拆装箱？"><a href="#五、Java支持的数据类型有哪些？什么是自动拆装箱？" class="headerlink" title="五、Java支持的数据类型有哪些？什么是自动拆装箱？"></a>五、Java支持的数据类型有哪些？什么是自动拆装箱？</h2><div class="table-container"><table><thead><tr><th>基本数据类型</th><th>对应的包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table></div><p>虽然 Java 语言是典型的面向对象编程语言，但其中的八种基本数据类型并不支持面向对象编程，基本类型的数据不具备“对象”的特性——不携带属性、没有方法可调用。 沿用它们只是为了迎合人类根深蒂固的习惯，并的确能简单、有效地进行常规数据处理。这种借助于非面向对象技术的做法有时也会带来不便，比如引用类型数据均继承了 Object 类的特性，要转换为 String 类型（经常有这种需要）时只要简单调用 Object 类中定义的toString()即可，而基本数据类型转换为 String 类型则要麻烦得多。为解决此类问题 ，Java为每种基本数据类型分别设计了对应的类，称之为包装类(Wrapper Classes)，也有教材称为外覆类或数据类型类。</p><p>每个包装类的对象可以封装一个相应的基本类型的数据，并提供了其它一些有用的方法。包装类对象一经创建，其内容（所封装的基本类型数据值）不可改变。</p><p>基本类型和对应的包装类可以相互装换：</p><ul><li>由基本类型向对应的包装类转换称为装箱，例如把 int 包装成 Integer 类的对象；</li><li>包装类向对应的基本类型转换称为拆箱，例如把 Integer 类的对象重新简化为 int。</li></ul><p>八个包装类的使用比较相似，下面是常见的应用场景。</p><ul><li>1）实现 int 和 Integer 的相互转换</li></ul><p>可以通过 Integer 类的构造方法将 int 装箱，通过 Integer 类的 intValue 方法将 Integer 拆箱。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Demo &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        int m = 500;</div><div class="line">        Integer obj = new Integer(m);  // 手动装箱</div><div class="line">        int n = obj.intValue();  // 手动拆箱</div><div class="line">        System.out.println(&quot;n = &quot; + n);</div><div class="line">       </div><div class="line">        Integer obj1 = new Integer(500);</div><div class="line">        System.out.println(&quot;obj 等价于 obj1？&quot; + obj.equals(obj1));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">n = 500</div><div class="line">obj 等价于 obj1？true</div></pre></td></tr></table></figure><ul><li>2）将字符串转换为整数</li></ul><p>Integer 类有一个静态的 paseInt() 方法，可以将字符串转换为整数，语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">parseInt(String s, int radix);</div></pre></td></tr></table></figure><p>s 为要转换的字符串，radix 为进制，可选，默认为十进制。</p><p>下面的代码将会告诉你什么样的字符串可以转换为整数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Demo &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        String str[] = &#123;&quot;123&quot;, &quot;123abc&quot;, &quot;abc123&quot;, &quot;abcxyz&quot;&#125;;</div><div class="line">       </div><div class="line">        for(String str1 : str)&#123;</div><div class="line">            try&#123;</div><div class="line">                int m = Integer.parseInt(str1, 10);</div><div class="line">                System.out.println(str1 + &quot; 可以转换为整数 &quot; + m);</div><div class="line">            &#125;catch(Exception e)&#123;</div><div class="line">                System.out.println(str1 + &quot; 无法转换为整数&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">123 可以转换为整数 123</div><div class="line">123abc 无法转换为整数</div><div class="line">abc123 无法转换为整数</div><div class="line">abcxyz 无法转换为整数</div></pre></td></tr></table></figure><ul><li>3）将整数转换为字符串</li></ul><p>Integer 类有一个静态的 toString() 方法，可以将整数转换为字符串。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Demo &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        int m = 500;</div><div class="line">        String s = Integer.toString(m);</div><div class="line">        System.out.println(&quot;s = &quot; + s);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s = 500</div></pre></td></tr></table></figure><p>上面的例子都需要手动实例化一个包装类，称为手动拆箱装箱。Java 1.5(5.0) 之前必须手动拆箱装箱。</p><p>Java 1.5 之后可以自动拆箱装箱，也就是在进行基本数据类型和对应的包装类转换时，系统将自动进行，这将大大方便程序员的代码书写。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> m = <span class="number">500</span>;</div><div class="line">        Integer obj = m;  <span class="comment">// 自动装箱</span></div><div class="line">        <span class="keyword">int</span> n = obj;  <span class="comment">// 自动拆箱</span></div><div class="line">        System.out.println(<span class="string">"n = "</span> + n);</div><div class="line">      </div><div class="line">        Integer obj1 = <span class="number">500</span>;</div><div class="line">        System.out.println(<span class="string">"obj 等价于 obj1？"</span> + obj.equals(obj1));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">n = 500</div><div class="line">obj 等价于 obj1？true</div></pre></td></tr></table></figure><p>自动拆箱装箱是常用的一个功能，需要重点掌握。</p><h2 id="六、Java中的方法覆盖-Overriding-和方法重载-Overloading-是什么意思？"><a href="#六、Java中的方法覆盖-Overriding-和方法重载-Overloading-是什么意思？" class="headerlink" title="六、Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？"></a>六、Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？</h2><p>1、方法覆盖（Overriding）：</p><p>在类继承中，子类可以修改从父类继承来的方法，也就是说子类能创建一个与父类方法有不同功能的方法，但具有相同的名称、返回值类型、参数列表。如果在新类中定义一个方法，其名称、返回值类型和参数列表正好与父类中的相同，那么，新方法被称做覆盖旧方法。参数列表又叫参数签名，包括参数的类型、参数的个数和参数的顺序，只要有一个不同就叫做参数列表不同。被覆盖的方法在子类中只能通过super调用。</p><p>注意：覆盖不会删除父类中的方法，而是对子类的实例隐藏，暂时不使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Dog myDog = <span class="keyword">new</span> Dog(<span class="string">"花花"</span>);</div><div class="line">        myDog.say();  <span class="comment">// 子类的实例调用子类中的方法</span></div><div class="line">       </div><div class="line">        Animal myAnmial = <span class="keyword">new</span> Animal(<span class="string">"贝贝"</span>);</div><div class="line">        myAnmial.say();  <span class="comment">// 父类的实例调用父类中的方法</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</div><div class="line">    String name;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"我是一只小动物，我的名字叫"</span> + name + <span class="string">"，我会发出叫声"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</div><div class="line">    <span class="comment">// 构造方法不能被继承，通过super()调用</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name)</span></span>&#123;</div><div class="line">        <span class="keyword">super</span>(name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 覆盖say() 方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"我是一只小狗，我的名字叫"</span> + name + <span class="string">"，我会发出汪汪的叫声"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">我是一只小狗，我的名字叫花花，我会发出汪汪的叫声</div><div class="line">我是一只小动物，我的名字叫贝贝，我会发出叫声</div></pre></td></tr></table></figure><p>方法覆盖的原则：</p><ul><li>覆盖方法的返回类型、方法名称、参数列表必须与原方法的相同。</li><li>覆盖方法不能比原方法访问性差（即访问权限不允许缩小）。</li><li>覆盖方法不能比原方法抛出更多的异常。</li><li>被覆盖的方法不能是final类型，因为final修饰的方法是无法覆盖的。</li><li>被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。</li><li>被覆盖的方法不能为static。如果父类中的方法为静态的，而子类中的方法不是静态的，但是两个方法除了这一点外其他都满足覆盖条件，那么会发生编译错误；反之亦然。即使父类和子类中的方法都是静态的，并且满足覆盖条件，但是仍然不会发生覆盖，因为静态方法是在编译的时候把静态方法和类的引用类型进行匹配。</li></ul><p>2、方法重载(Overloading)<br>在Java中，同一个类中的多个方法可以有相同的名字，只要它们的参数列表不同就可以，这被称为方法重载(method overloading)。参数列表又叫参数签名，包括参数的类型、参数的个数和参数的顺序，只要有一个不同就叫做参数列表不同。</p><p>重载是面向对象的一个基本特性。</p><p>下面看一个详细的实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class Demo&#123;</div><div class="line">    // 一个普通的方法，不带参数</div><div class="line">    void test()&#123;</div><div class="line">        System.out.println(&quot;No parameters&quot;);</div><div class="line">    &#125;</div><div class="line">    // 重载上面的方法，并且带了一个整型参数</div><div class="line">    void test(int a)&#123;</div><div class="line">        System.out.println(&quot;a: &quot; + a);</div><div class="line">    &#125;</div><div class="line">    // 重载上面的方法，并且带了两个参数</div><div class="line">    void test(int a,int b)&#123;</div><div class="line">        System.out.println(&quot;a and b: &quot; + a + &quot; &quot; + b);</div><div class="line">    &#125;</div><div class="line">    // 重载上面的方法，并且带了一个双精度参数</div><div class="line">    double test(double a)&#123;</div><div class="line">        System.out.println(&quot;double a: &quot; + a);</div><div class="line">        return a*a;</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    public static void main(String args[])&#123;</div><div class="line">        Demo obj= new Demo();</div><div class="line">        obj.test();</div><div class="line">        obj.test(2);</div><div class="line">        obj.test(2,3);</div><div class="line">        obj.test(2.0);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">No parameters</div><div class="line">a: 2</div><div class="line">a and b: 2 3</div><div class="line">double a: 2.0</div></pre></td></tr></table></figure><p>通过上面的实例，读者可以看出，重载就是在一个类中，有相同的函数名称，但形参不同的函数。重载的结果，可以让一个程序段尽量减少代码和方法的种类。<br>说明：</p><ul><li>参数列表不同包括：个数不同、类型不同和顺序不同。</li><li>仅仅参数变量名称不同是不可以的。</li><li>跟成员方法一样，构造方法也可以重载。</li><li>声明为final的方法不能被重载。</li><li>声明为static的方法不能被重载，但是能够被再次声明。</li></ul><p>方法的重载的规则：</p><ul><li>方法名称必须相同。</li><li>参数列表必须不同（个数不同、或类型不同、参数排列顺序不同等）。</li><li>方法的返回类型可以相同也可以不相同。</li><li>仅仅返回类型不同不足以成为方法的重载。</li></ul><p>方法重载的实现：</p><ul><li>方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法，如果匹配失败，则编译器报错，这叫做重载分辨。</li></ul><p>3、覆盖和重载的不同：</p><ul><li>方法覆盖要求参数列表必须一致，而方法重载要求参数列表必须不一致。</li><li>方法覆盖要求返回类型必须一致，方法重载对此没有要求。</li><li>方法覆盖只能用于子类覆盖父类的方法，方法重载用于同一个类中的所有方法（包括从父类中继承而来的方法）。</li><li>方法覆盖对方法的访问权限和抛出的异常有特殊的要求，而方法重载在这方面没有任何限制。</li><li>父类的一个方法只能被子类覆盖一次，而一个方法可以在所有的类中可以被重载多次</li></ul><h2 id="七、Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？"><a href="#七、Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？" class="headerlink" title="七、Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？"></a>七、Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？</h2><p>1、Java中，什么是构造方法？</p><p>在类实例化的过程中自动执行的方法叫做构造方法，它不需要你手动调用。构造方法可以在类实例化的过程中做一些初始化的工作。</p><p>构造方法的名称必须与类的名称相同，并且没有返回值。</p><p>每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认的构造方法。</p><p>下面是一个构造方法示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</div><div class="line">    String name;</div><div class="line">    <span class="keyword">int</span> age;</div><div class="line">   </div><div class="line">    <span class="comment">// 构造方法，没有返回值</span></div><div class="line">    Dog(String name1, <span class="keyword">int</span> age1)&#123;</div><div class="line">        name = name1;</div><div class="line">        age = age1;</div><div class="line">        System.out.println(<span class="string">"感谢主人领养了我"</span>);</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    <span class="comment">// 普通方法，必须有返回值</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"汪汪，不要过来"</span>);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hungry</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"主人，我饿了"</span>);</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String arg[])</span></span>&#123;</div><div class="line">        <span class="comment">// 创建对象时传递的参数要与构造方法参数列表对应</span></div><div class="line">        Dog myDog = <span class="keyword">new</span> Dog(<span class="string">"花花"</span>, <span class="number">3</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">感谢主人领养了我</div></pre></td></tr></table></figure><p>说明：</p><ul><li>构造方法不能被显示调用。</li><li>构造方法不能有返回值，因为没有变量来接收返回值。</li></ul><p>2、什么是构造方法重载？</p><p>跟成员方法一样，构造方法也可以重载。Java中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己唯一的参数列表。</p><p>3、什么是复制构造方法？<br>Java不支持像C++中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，Java不会创建默认的复制构造函数.</p><h2 id="八、Java支持多继承么？"><a href="#八、Java支持多继承么？" class="headerlink" title="八、Java支持多继承么？"></a>八、Java支持多继承么？</h2><p>单继承性：Java 允许一个类仅能继承一个其它类，即一个类只能有一个父类，这个限制被称做单继承性。</p><p>但是java中的接口支持多继承，，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。</p><h2 id="九、接口和抽象类的区别是什么？"><a href="#九、接口和抽象类的区别是什么？" class="headerlink" title="九、接口和抽象类的区别是什么？"></a>九、接口和抽象类的区别是什么？</h2><p>Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：</p><ul><li>接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。</li><li>类可以实现很多个接口，但是只能继承一个抽象类</li><li>类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。</li><li>抽象类可以在不提供接口方法实现的情况下实现接口。</li><li>Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。</li><li>Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。</li><li>接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。</li><li>也可以参考JDK8中抽象类和接口的区别</li></ul><h2 id="十、什么是值传递和引用传递"><a href="#十、什么是值传递和引用传递" class="headerlink" title="十、什么是值传递和引用传递?"></a>十、什么是值传递和引用传递?</h2><p>值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量.</p><p>引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。 所以对引用对象进行操作会同时改变原对象.</p><p>一般认为,java内的传递都是值传递.</p><h2 id="十一、进程与线程的区别"><a href="#十一、进程与线程的区别" class="headerlink" title="十一、进程与线程的区别"></a>十一、进程与线程的区别</h2><p>概述:</p><p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.</p><p>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.</p><p>一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.</p><p>相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。</p><p>在串行程序基础上引入线程和进程是为了提高程序的并发度，从而提高程序运行效率和响应时间。</p><p>区别:<br>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p><p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是操作系统进行资源分配和调度的一个独立单位；线程是进程的一个实体，是CPU调度和分派的基本单位，是比进程更小的能独立运行的基本单位。线程的划分尺度小于进程，这使得多线程程序的并发性高；进程在执行时通常拥有独立的内存单元，而线程之间可以共享内存。使用多线程的编程通常能够带来更好的性能和用户体验，但是多线程的程序对于其他程序是不友好的，因为它可能占用了更多的CPU资源。当然，也不是线程越多，程序的性能就越好，因为线程之间的调度和切换也会浪费CPU时间。时下很时髦的Node.js就采用了单线程异步I/O的工作模式。</p><ul><li>简而言之,一个程序至少有一个进程,一个进程至少有一个线程.</li><li>线程的划分尺度小于进程，使得多线程程序的并发性高。</li><li>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</li><li>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li><li>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</li></ul><p>优缺点:</p><p>线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。</p><h2 id="十二、为什么集合类没有实现Cloneable和Serializable接口？"><a href="#十二、为什么集合类没有实现Cloneable和Serializable接口？" class="headerlink" title="十二、为什么集合类没有实现Cloneable和Serializable接口？"></a>十二、为什么集合类没有实现Cloneable和Serializable接口？</h2><p>克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化</p><p>实现Serializable序列化的作用：将对象的状态保存在存储媒体中以便可以在以后重写创建出完全相同的副本；按值将对象从一个从一个应用程序域发向另一个应用程序域。</p><p>实现Serializable接口的作用就是可以把对象存到字节流，然后可以恢复。所以你想如果你的对象没有序列化，怎么才能进行网络传输呢？要网络传输就得转为字节流，所以在分布式应用中，你就得实现序列化。如果你不需要分布式应用，那就没必要实现实现序列化。</p><h2 id="十三、什么是迭代器-Iterator-？"><a href="#十三、什么是迭代器-Iterator-？" class="headerlink" title="十三、什么是迭代器(Iterator)？"></a>十三、什么是迭代器(Iterator)？</h2><p>Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的<br>迭代方法。迭代器可以在迭代的过程中删除底层集合的元素,但是不可以直接调用集合的<br>remove(Object Obj)删除，可以通过迭代器的remove()方法删除。</p><h2 id="十四、-Iterator和ListIterator的区别是什么？"><a href="#十四、-Iterator和ListIterator的区别是什么？" class="headerlink" title="十四、 Iterator和ListIterator的区别是什么？"></a>十四、 Iterator和ListIterator的区别是什么？</h2><p>Iterator是遍历集合的迭代器（不能遍历Map，只用来遍历Collection），Collection的实现类都实现了iterator()函数，它返回一个Iterator对象，用来遍历集合，ListIterator则专门用来遍历List。</p><p>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。</p><p>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</p><h2 id="十五、快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？"><a href="#十五、快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？" class="headerlink" title="十五、快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？"></a>十五、快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？</h2><p>Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。</p><h2 id="十六、final的作用"><a href="#十六、final的作用" class="headerlink" title="十六、final的作用"></a>十六、final的作用</h2><p>在 Java 中，声明类、变量和方法时，可使用关键字 final 来修饰。final 所修饰的数据具有“终态”的特征，表示“最终的”意思。具体规定如下：</p><ul><li>final 修饰的类不能被继承。</li><li>final 修饰的方法不能被子类重写。</li><li>final 修饰的变量（成员变量或局部变量）即成为常量，只能赋值一次。</li><li>final 修饰的成员变量必须在声明的同时赋值，如果在声明的时候没有赋值，那么只有 一次赋值的机会，而且只能在构造方法中显式赋值，然后才能使用。</li><li>final 修饰的局部变量可以只声明不赋值，然后再进行一次性的赋值。</li></ul><p>final 一般用于修饰那些通用性的功能、实现方式或取值不能随意被改变的数据，以避免被误用，例如实现数学三角方法、幂运算等功能的方法，以及数学常量π=3.141593、e=2.71828 等。</p><p>事实上，为确保终态性，提供了上述方法和常量的 java.lang.Math 类也已被定义为final 的。</p><p>需要注意的是，如果将引用类型（任何类的类型）的变量标记为 final，那么该变量不能指向任何其它对象。但可以改变对象的内容，因为只有引用本身是 final 的。</p><p>如果变量被标记为 final，其结果是使它成为常数。想改变 final 变量的值会导致一个编译错误。下面是一个正确定义 final 变量的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public final int MAX_ARRAY_SIZE = 25;  // 常量名一般大写</div></pre></td></tr></table></figure><p>常量因为有 final 修饰，所以不能被继承。<br>请看下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public final class Demo&#123;</div><div class="line">    public static final int TOTAL_NUMBER = 5;</div><div class="line">    public int id;</div><div class="line">    public Demo() &#123;</div><div class="line">        // 非法，对final变量TOTAL_NUMBER进行二次赋值了</div><div class="line">        // 因为++TOTAL_NUMBER相当于 TOTAL_NUMBER=TOTAL_NUMBER+1</div><div class="line">        id = ++TOTAL_NUMBER;</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        final Demo t = new Demo();</div><div class="line">        final int i = 10;</div><div class="line">        final int j;</div><div class="line">        j = 20;</div><div class="line">        j = 30;  // 非法，对final变量进行二次赋值</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>final 也可以用来修饰类（放在 class 关键字前面），阻止该类再派生出子类，例如 Java.lang.String 就是一个 final 类。这样做是出于安全原因，因为要保证一旦有字符串的引用，就必须是类 String 的字符串，而不是某个其它类的字符串（String 类可能被恶意继承并篡改）。</p><p>方法也可以被 final 修饰，被 final 修饰的方法不能被覆盖；变量也可以被 final 修饰，被 final 修饰的变量在创建对象以后就不允许改变它们的值了。一旦将一个类声明为 final，那么该类包含的方法也将被隐式地声明为 final，但是变量不是。</p><p>被 final 修饰的方法为静态绑定，不会产生多态（动态绑定），程序在运行时不需要再检索方法表，能够提高代码的执行效率。在Java中，被 static 或 private 修饰的方法会被隐式的声明为 final，因为动态绑定没有意义。</p><p>由于动态绑定会消耗资源并且很多时候没有必要，所以有一些程序员认为：除非有足够的理由使用多态性，否则应该将所有的方法都用 final 修饰。</p><p>这样的认识未免有些偏激，因为 JVM 中的即时编译器能够实时监控程序的运行信息，可以准确的知道类之间的继承关系。如果一个方法没有被覆盖并且很短，编译器就能够对它进行优化处理，这个过程为称为内联(inlining)。例如，内联调用 e.getName() 将被替换为访问 e.name 变量。这是一项很有意义的改进，这是由于CPU在处理调用方法的指令时，使用的分支转移会扰乱预取指令的策略，所以，这被视为不受欢迎的。然而，如果 getName() 在另外一个类中被覆盖，那么编译器就无法知道覆盖的代码将会做什么操作，因此也就不能对它进行内联处理了。</p><h2 id="十七、String-与StringBuffer的区别，有什么好处？"><a href="#十七、String-与StringBuffer的区别，有什么好处？" class="headerlink" title="十七、String 与StringBuffer的区别，有什么好处？"></a>十七、String 与StringBuffer的区别，有什么好处？</h2><p>String 的值是不可变的，每次对String的操作都会生成新的String对象，不仅效率低，而且耗费大量内存空间。</p><p>StringBuffer类和String类一样，也用来表示字符串，但是StringBuffer的内部实现方式和String不同，在进行字符串处理时，不生成新的对象，在内存使用上要优于String。</p><p>StringBuffer 默认分配16字节长度的缓冲区，当字符串超过该大小时，会自动增加缓冲区长度，而不是生成新的对象。</p><p>StringBuffer不像String，只能通过 new 来创建对象，不支持简写方式，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">StringBuffer str1 = new StringBuffer();  // 分配16个字节长度的缓冲区</div><div class="line">StringBuffer str2 = =new StringBuffer(512);  // 分配512个字节长度的缓冲区</div><div class="line">// 在缓冲区中存放了字符串，并在后面预留了16个字节长度的空缓冲区</div><div class="line">StringBuffer str3 = new StringBuffer(&quot;www.baidu.com&quot;);</div></pre></td></tr></table></figure><h3 id="17-1-StringBuffer类的主要方法"><a href="#17-1-StringBuffer类的主要方法" class="headerlink" title="17.1 StringBuffer类的主要方法"></a>17.1 StringBuffer类的主要方法</h3><p>StringBuffer类中的方法主要偏重于对于字符串的操作，例如追加、插入和删除等，这个也是StringBuffer类和String类的主要区别。实际开发中，如果需要对一个字符串进行频繁的修改，建议使用 StringBuffer。</p><ul><li>1) append() 方法</li></ul><p>append() 方法用于向当前字符串的末尾追加内容，类似于字符串的连接。调用该方法以后，StringBuffer对象的内容也发生改变，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">StringBuffer str = new StringBuffer(“biancheng100”);</div><div class="line">str.append(true);</div></pre></td></tr></table></figure><p>则对象str的值将变成”biancheng100true”。注意是str指向的内容变了，不是str的指向变了。</p><p>字符串的”+“操作实际上也是先创建一个StringBuffer对象，然后调用append()方法将字符串片段拼接起来，最后调用toString()方法转换为字符串。</p><p>这样看来，String的连接操作就比StringBuffer多出了一些附加操作，效率上必然会打折扣。</p><p>但是，对于长度较小的字符串，”+“操作更加直观，更具可读性，有些时候可以稍微牺牲一下效率。</p><ul><li>2) deleteCharAt()</li></ul><p>deleteCharAt() 方法用来删除指定位置的字符，并将剩余的字符形成新的字符串。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">StringBuffer str = new StringBuffer(&quot;abcdef&quot;);</div><div class="line">str. deleteCharAt(3);</div></pre></td></tr></table></figure><p>该代码将会删除索引值为3的字符，即”d“字符。</p><p>你也可以通过delete()方法一次性删除多个字符，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">StingBuffer str = new StringBuffer(&quot;abcdef&quot;);</div><div class="line">str.delete(1, 4);</div></pre></td></tr></table></figure><p>该代码会删除索引值为1~4之间的字符，包括索引值1，但不包括4。</p><ul><li>3) insert()方法</li></ul><p>insert() 用来在指定位置插入字符串，可以认为是append()的升级版。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">StringBuffer str = new StringBuffer(&quot;abcdef&quot;);</div><div class="line">str.insert(3, &quot;xyz&quot;);</div></pre></td></tr></table></figure><p>最后str所指向的字符串为 abcdxyzef。</p><ul><li>4) setCharAt() 方法</li></ul><p>setCharAt() 方法用来修改指定位置的字符。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">StringBuffer str = new StringBuffer(&quot;abcdef&quot;);</div><div class="line">str.setCharAt(3, &apos;z&apos;);</div></pre></td></tr></table></figure><p>该代码将把索引值为3的字符修改为 z，最后str所指向的字符串为 abczef。</p><p>以上仅仅是部分常用方法的简单说明，更多方法和解释请查阅API文档。</p><h3 id="17-2-String和StringBuffer的效率对比"><a href="#17-2-String和StringBuffer的效率对比" class="headerlink" title="17.2 String和StringBuffer的效率对比"></a>17.2 String和StringBuffer的效率对比</h3><p>为了更加明显地看出它们的执行效率，下面的代码，将26个英文字母加了10000次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        String fragment = <span class="string">"abcdefghijklmnopqrstuvwxyz"</span>;</div><div class="line">        <span class="keyword">int</span> times = <span class="number">10000</span>;</div><div class="line">       </div><div class="line">        <span class="comment">// 通过String对象</span></div><div class="line">        <span class="keyword">long</span> timeStart1 = System.currentTimeMillis();</div><div class="line">        String str1 = <span class="string">""</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;times; i++) &#123;</div><div class="line">            str1 += fragment;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> timeEnd1 = System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"String: "</span> + (timeEnd1 - timeStart1) + <span class="string">"ms"</span>);</div><div class="line">       </div><div class="line">        <span class="comment">// 通过StringBuffer</span></div><div class="line">        <span class="keyword">long</span> timeStart2 = System.currentTimeMillis();</div><div class="line">        StringBuffer str2 = <span class="keyword">new</span> StringBuffer();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;times; i++) &#123;</div><div class="line">            str2.append(fragment);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> timeEnd2 = System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"StringBuffer: "</span> + (timeEnd2 - timeStart2) + <span class="string">"ms"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String: 5287ms</div><div class="line">StringBuffer: 3ms</div></pre></td></tr></table></figure><p>结论很明显，StringBuffer的执行效率比String快上千倍，这个差异随着叠加次数的增加越来越明显，当叠加次数达到30000次的时候，运行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String: 35923ms</div><div class="line">StringBuffer: 8ms</div></pre></td></tr></table></figure><p>所以，强烈建议在涉及大量字符串操作时使用StringBuffer。</p><h3 id="17-3-StringBuilder类"><a href="#17-3-StringBuilder类" class="headerlink" title="17.3 StringBuilder类"></a>17.3 StringBuilder类</h3><p>StringBuilder类和StringBuffer类功能基本相似，方法也差不多，主要区别在于StringBuffer类的方法是多线程安全的，而StringBuilder不是线程安全的，相比而言，StringBuilder类会略微快一点。</p><p>StringBuffer、StringBuilder、String中都实现了CharSequence接口。CharSequence是一个定义字符串操作的接口，它只包括length()、charAt(int index)、subSequence(int start, int end) 这几个API。</p><p>StringBuffer、StringBuilder、String对CharSequence接口的实现过程不一样，如下图所示：<br><img src="http://omu7tit09.bkt.clouddn.com/15024502085934.png" alt=""></p><p>可见，String直接实现了CharSequence接口；StringBuilder 和 StringBuffer都是可变的字符序列，它们都继承于AbstractStringBuilder，实现了CharSequence接口。</p><p>总结一下：</p><ul><li>线程安全：<ul><li>StringBuffer：线程安全</li><li>StringBuilder：线程不安全</li></ul></li><li><p>速度：</p><ul><li>一般情况下，速度从快到慢为 StringBuilder &gt; StringBuffer &gt; String，当然这是相对的，不是绝对的。</li></ul></li><li><p>使用环境：</p><ul><li>操作少量的数据使用 String；</li><li>单线程操作大量数据使用 StringBuilder；</li><li>多线程操作大量数据使用 StringBuffer。</li></ul></li></ul><h2 id="十九、异常处理机制，，try和finally里面都有return的时候，会不会执行finally的return。"><a href="#十九、异常处理机制，，try和finally里面都有return的时候，会不会执行finally的return。" class="headerlink" title="十九、异常处理机制，，try和finally里面都有return的时候，会不会执行finally的return。"></a>十九、异常处理机制，，try和finally里面都有return的时候，会不会执行finally的return。</h2><h2 id="二十、-synchronized和lock的区别"><a href="#二十、-synchronized和lock的区别" class="headerlink" title="二十、 synchronized和lock的区别"></a>二十、 synchronized和lock的区别</h2><ul><li><p>动态绑定与静态绑定：</p></li><li><p>volatile是什么，threadlocal是什么</p></li><li><p>volatile和synchronized的区别</p></li></ul><p>垃圾回收机制</p><p>1.进程与线程的区别，线程的同步问题，两个线程访问一个临界资源该怎么做？线程什么时候终止？（还问到一个daemon函数，我当时完全不知道这是什么）</p><p>1.什么是面向对象？JAVA与C相比有什么区别？JAVA的对象与c的结构体有什么区别？</p><p>2.JAVA的IO有哪些类？接口？关系是啥？（谁继承谁之类的）</p><p>3.你用过哪些JAVA的库？（java.io, java.util, 等等）你什么时候开始用JAVA的？（这个问题是最开始问的，我说14年开始的。。后面又问了一遍。。）</p><p>然后问了高并发问题，讲讲CurrentHashMap原理，可是我并不了解，就大概说了下自己想法</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？&quot;&gt;&lt;a href=&quot;#一、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？&quot; class=&quot;headerlink&quot; title=&quot;一、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？&quot;&gt;&lt;/a&gt;一、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？&lt;/h2&gt;&lt;p&gt;Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="QA" scheme="http://yoursite.com/tags/QA/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记（9）：内部类、抽象类、接口</title>
    <link href="http://yoursite.com/2017/08/28/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%889%EF%BC%89%EF%BC%9A%E5%86%85%E9%83%A8%E7%B1%BB%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2017/08/28/Java学习笔记（9）：内部类、抽象类、接口/</id>
    <published>2017-08-28T14:20:45.000Z</published>
    <updated>2017-09-01T06:51:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Java内部类及其实例化"><a href="#一、Java内部类及其实例化" class="headerlink" title="一、Java内部类及其实例化"></a>一、Java内部类及其实例化</h1><p>在 Java 中，允许在一个类（或方法、语句块）的内部定义另一个类，称为内部类(Inner Class)，有时也称为嵌套类(Nested Class)。</p><a id="more"></a><p>内部类和外层封装它的类之间存在逻辑上的所属关系，一般只用在定义它的类或语句块之内，实现一些没有通用意义的功能逻辑，在外部引用它时必须给出完整的名称。</p><p>使用内部类的主要原因有：</p><ul><li>内部类可以访问外部类中的数据，包括私有的数据。</li><li>内部类可以对同一个包中的其他类隐藏起来。</li><li>当想要定义一个回调函数且不想编写大量代码时，使用匿名(anonymous)内部类比较便捷。</li><li>减少类的命名冲突。</li></ul><p>请看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> counter = <span class="number">10</span>;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doStuff</span><span class="params">()</span> </span>&#123;</div><div class="line">            size++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">        Demo outer = <span class="keyword">new</span> Demo();</div><div class="line">        Inner inner = outer.new Inner();</div><div class="line">        inner.doStuff();</div><div class="line">        System.out.println(outer.size);</div><div class="line">        System.out.println(inner.counter);</div><div class="line">        <span class="comment">// 编译错误，外部类不能访问内部类的变量</span></div><div class="line"><span class="comment">//        System.out.println(counter);</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这段代码定义了一个外部类 Outer，它包含了一个内部类 Inner。将错误语句注释掉，编译，会生成两个 .class 文件：Outer.class 和 Outer<script type="math/tex">`Inner.class。也就是说，内部类会被编译成独立的字节码文件。内部类是一种编译器现象，与虚拟机无关。编译器将会把内部类翻译成用`</script> 符号分隔外部类名与内部类名的常规类文件，而虚拟机则对此一无所知。<br>注意：必须先有外部类的对象才能生成内部类的对象，因为内部类需要访问外部类中的成员变量，成员变量必须实例化才有意义。</p><p>内部类是 Java 1.1 的新增特性，有些程序员认为这是一个值得称赞的进步，但是内部类的语法很复杂，严重破坏了良好的代码结构， 违背了Java要比C++更加简单的设计理念。</p><p>内部类看似增加了—些优美有趣，实属没必要的特性，这是不是也让Java开始走上了许多语言饱受折磨的毁灭性道路呢？本教程并不打算就这个问题给予一个肯定的答案。</p><h1 id="二、内部类的分类"><a href="#二、内部类的分类" class="headerlink" title="二、内部类的分类"></a>二、内部类的分类</h1><p>内部类可以是静态(static)的，可以使用 public、protected 和 private 访问控制符，而外部类只能使用 public，或者默认。</p><h2 id="2-1-成员式内部类"><a href="#2-1-成员式内部类" class="headerlink" title="2.1 成员式内部类"></a>2.1 成员式内部类</h2><p>在外部类内部直接定义（不在方法内部或代码块内部）的类就是成员式内部类，它可以直接使用外部类的所有变量和方法，即使是 private 的。外部类要想访问内部类的成员变量和方法，则需要通过内部类的对象来获取。</p><p>请看下面的代码：</p><h1 id="三、抽象类的概念和使用"><a href="#三、抽象类的概念和使用" class="headerlink" title="三、抽象类的概念和使用"></a>三、抽象类的概念和使用</h1><p>在自上而下的继承层次结构中，位于上层的类更具有通用性，甚至可能更加抽象。从某种角度看，祖先类更加通用，它只包含一些最基本的成员，人们只将它作为派生其他类的基类，而不会用来创建对象。甚至，你可以只给出方法的定义而不实现，由子类根据具体需求来具体实现。</p><p>这种只给出方法定义而不具体实现的方法被称为抽象方法，抽象方法是没有方法体的，在代码的表达上就是没有“{}”。包含一个或多个抽象方法的类也必须被声明为抽象类。</p><p>使用 abstract 修饰符来表示抽象方法和抽象类。</p><p>抽象类除了包含抽象方法外，还可以包含具体的变量和具体的方法。类即使不包含抽象方法，也可以被声明为抽象类，防止被实例化。</p><p>抽象类不能被实例化，抽象方法必须在子类中被实现。请看下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">import static java.lang.System.*;</div><div class="line"></div><div class="line">public  class Demo&#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Teacher t = new Teacher();</div><div class="line">        t.setName(&quot;王明&quot;);</div><div class="line">        t.work();</div><div class="line">       </div><div class="line">        Driver d = new Driver();</div><div class="line">        d.setName(&quot;小陈&quot;);</div><div class="line">        d.work();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 定义一个抽象类</div><div class="line">abstract class People&#123;</div><div class="line">    private String name;  // 实例变量</div><div class="line">   </div><div class="line">    // 共有的 setter 和 getter 方法</div><div class="line">    public void setName(String name)&#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">    public String getName()&#123;</div><div class="line">        return this.name;</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    // 抽象方法</div><div class="line">    public abstract void work();</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Teacher extends People&#123;</div><div class="line">    // 必须实现该方法</div><div class="line">    public void work()&#123;</div><div class="line">        out.println(&quot;我的名字叫&quot; + this.getName() + &quot;，我正在讲课，请大家不要东张西望...&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Driver extends People&#123;</div><div class="line">    // 必须实现该方法</div><div class="line">    public void work()&#123;</div><div class="line">        out.println(&quot;我的名字叫&quot; + this.getName() + &quot;，我正在开车，不能接听电话...&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：<br>我的名字叫王明，我正在讲课，请大家不要东张西望…<br>我的名字叫小陈，我正在开车，不能接听电话…</p><p>关于抽象类的几点说明：</p><ul><li>抽象类不能直接使用，必须用子类去实现抽象类，然后使用其子类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例，也就是可以使用抽象类来充当形参，实际实现类作为实参，也就是多态的应用。</li><li>不能有抽象构造方法或抽象静态方法。</li></ul><p>在下列情况下，一个类将成为抽象类：</p><ul><li>当一个类的一个或多个方法是抽象方法时；</li><li>当类是一个抽象类的子类，并且不能为任何抽象方法提供任何实现细节或方法主体时；</li><li>当一个类实现一个接口，并且不能为任何抽象方法提供实现细节或方法主体时；注意：</li></ul><p>这里说的是这些情况下一个类将成为抽象类，没有说抽象类一定会有这些情况。一个典型的错误：抽象类一定包含抽象方法。 但是反过来说“包含抽象方法的类一定是抽象类”就是正确的。事实上，抽象类可以是一个完全正常实现的类</p><h1 id="四、接口的概念和使用"><a href="#四、接口的概念和使用" class="headerlink" title="四、接口的概念和使用"></a>四、接口的概念和使用</h1><h2 id="4-1-接口的概念"><a href="#4-1-接口的概念" class="headerlink" title="4.1 接口的概念"></a>4.1 接口的概念</h2><p>在抽象类中，可以包含一个或多个抽象方法；但在接口(interface)中，所有的方法必须都是抽象的，不能有方法体，它比抽象类更加“抽象”。</p><p>接口使用 interface 关键字来声明，可以看做是一种特殊的抽象类，可以指定一个类必须做什么，而不是规定它如何去做。</p><p>现实中也有很多接口的实例，比如说串口电脑硬盘，Serial ATA委员会指定了Serial ATA 2.0规范，这种规范就是接口。Serial ATA委员会不负责生产硬盘，只是指定通用的规范。</p><p>希捷、日立、三星等生产厂家会按照规范生产符合接口的硬盘，这些硬盘就可以实现通用化，如果正在用一块160G日立的串口硬盘，现在要升级了，可以购买一块320G的希捷串口硬盘，安装上去就可以继续使用了。</p><p>下面的代码可以模拟Serial ATA委员会定义以下串口硬盘接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public interface Demo&#123;</div><div class="line">    //连接线的数量</div><div class="line">    public static final int CONNECT_LINE=4;</div><div class="line">    //写数据</div><div class="line">    public void writeData(String data);</div><div class="line">    //读数据</div><div class="line">    public String readData();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>注意：接口中声明的成员变量默认都是 public static final 的，必须显式地初始化。因而在常量声明时可以省略这些修饰符。</p><p>接口是若干常量和抽象方法的集合，目前看来和抽象类差不多。确实如此，接口本就是从抽象类中演化而来的，因而除特别规定，接口享有和类同样的“待遇”。比如，源程序中可以定义多个类或接口，但最多只能有一个public 的类或接口，如果有则源文件必须取和public的类和接口相同的名字。和类的继承格式一样，接口之间也可以继承，子接口可以继承父接口中的常量和抽象方法并添加新的抽象方法等。</p><p>但接口有其自身的一些特性，归纳如下。</p><ul><li>1) 接口中只能定义抽象方法，这些方法默认为 public abstract 的，因而在声明方法时可以省略这些修饰符。试图在接口中定义实例变量、非抽象的实例方法及静态方法，都是非法的。例如：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public interface SataHdd&#123;</div><div class="line">    //连接线的数量</div><div class="line">    public int connectLine; //编译出错，connectLine被看做静态常量，必须显式初始化</div><div class="line">    //写数据</div><div class="line">    protected void writeData(String data); //编译出错，必须是public类型</div><div class="line">    //读数据</div><div class="line">    public static String readData()&#123; //编译出错，接口中不能包含静态方法</div><div class="line">        return &quot;数据&quot;; //编译出错，接口中只能包含抽象方法，</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>2) 接口中没有构造方法，不能被实例化。</p></li><li><p>3) 一个接口不实现另一个接口，但可以继承多个其他接口。接口的多继承特点弥补了类的单继承。例如：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//串行硬盘接口</div><div class="line">public interface SataHdd extends A,B&#123;</div><div class="line">    // 连接线的数量</div><div class="line">    public static final int CONNECT_LINE = 4;</div><div class="line">    // 写数据</div><div class="line">    public void writeData(String data);</div><div class="line">    // 读数据</div><div class="line">    public String readData();</div><div class="line">&#125;</div><div class="line">interface A&#123;</div><div class="line">    public void a();</div><div class="line">&#125;</div><div class="line">interface B&#123;</div><div class="line">    public void b();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="4-2-为什么使用接口"><a href="#4-2-为什么使用接口" class="headerlink" title="4.2 为什么使用接口"></a>4.2 为什么使用接口</h2><p>大型项目开发中，可能需要从继承链的中间插入一个类，让它的子类具备某些功能而不影响它们的父类。例如 A -&gt; B -&gt; C -&gt; D -&gt; E，A 是祖先类，如果需要为C、D、E类添加某些通用的功能，最简单的方法是让C类再继承另外一个类。但是问题来了，Java 是一种单继承的语言，不能再让C继承另外一个父类了，只到移动到继承链的最顶端，让A再继承一个父类。这样一来，对C、D、E类的修改，影响到了整个继承链，不具备可插入性的设计。</p><p>接口是可插入性的保证。在一个继承链中的任何一个类都可以实现一个接口，这个接口会影响到此类的所有子类，但不会影响到此类的任何父类。此类将不得不实现这个接口所规定的方法，而子类可以从此类自动继承这些方法，这时候，这些子类具有了可插入性。</p><p>我们关心的不是哪一个具体的类，而是这个类是否实现了我们需要的接口。</p><p>接口提供了关联以及方法调用上的可插入性，软件系统的规模越大，生命周期越长，接口使得软件系统的灵活性和可扩展性，可插入性方面得到保证。</p><p>接口在面向对象的 Java 程序设计中占有举足轻重的地位。事实上在设计阶段最重要的任务之一就是设计出各部分的接口，然后通过接口的组合，形成程序的基本框架结构。</p><h2 id="4-3-接口的使用"><a href="#4-3-接口的使用" class="headerlink" title="4.3 接口的使用"></a>4.3 接口的使用</h2><p>接口的使用与类的使用有些不同。在需要使用类的地方，会直接使用new关键字来构建一个类的实例，但接口不可以这样使用，因为接口不能直接使用 new 关键字来构建实例。</p><p>接口必须通过类来实现(implements)它的抽象方法，然后再实例化类。类实现接口的关键字为implements。</p><p>如果一个类不能实现该接口的所有抽象方法，那么这个类必须被定义为抽象方法。</p><p>不允许创建接口的实例，但允许定义接口类型的引用变量，该变量指向了实现接口的类的实例。</p><p>一个类只能继承一个父类，但却可以实现多个接口。</p><p>实现接口的格式如下：<br>修饰符 class 类名 extends 父类 implements 多个接口 {<br>实现方法<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">import static java.lang.System.*;</div><div class="line"></div><div class="line">public class Demo&#123;</div><div class="line">  public static void main(String[] args) &#123;</div><div class="line">      SataHdd sh1=new SeagateHdd(); //初始化希捷硬盘</div><div class="line">      SataHdd sh2=new SamsungHdd(); //初始化三星硬盘</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//串行硬盘接口</div><div class="line">interface SataHdd&#123;</div><div class="line">    //连接线的数量</div><div class="line">    public static final int CONNECT_LINE=4;</div><div class="line">    //写数据</div><div class="line">    public void writeData(String data);</div><div class="line">    //读数据</div><div class="line">    public String readData();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 维修硬盘接口</div><div class="line">interface fixHdd&#123;</div><div class="line">    // 维修地址</div><div class="line">    String address = &quot;北京市海淀区&quot;;</div><div class="line">    // 开始维修</div><div class="line">    boolean doFix();</div><div class="line">&#125;</div><div class="line"></div><div class="line">//捷硬盘</div><div class="line">class SeagateHdd implements SataHdd, fixHdd&#123;</div><div class="line">    //希捷硬盘读取数据</div><div class="line">    public String readData()&#123;</div><div class="line">        return &quot;数据&quot;;</div><div class="line">    &#125;</div><div class="line">    //希捷硬盘写入数据</div><div class="line">    public void writeData(String data) &#123;</div><div class="line">        out.println(&quot;写入成功&quot;);</div><div class="line">    &#125;</div><div class="line">    // 维修希捷硬盘</div><div class="line">    public boolean doFix()&#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//三星硬盘</div><div class="line">class SamsungHdd implements SataHdd&#123;</div><div class="line">    //三星硬盘读取数据</div><div class="line">    public String readData()&#123;</div><div class="line">        return &quot;数据&quot;;</div><div class="line">    &#125;</div><div class="line">    //三星硬盘写入数据</div><div class="line">    public void writeData(String data)&#123;</div><div class="line">        out.println(&quot;写入成功&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//某劣质硬盘，不能写数据</div><div class="line">abstract class XXHdd implements SataHdd&#123;</div><div class="line">    //硬盘读取数据</div><div class="line">    public String readData() &#123;</div><div class="line">        return &quot;数据&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="4-4-接口作为类型使用"><a href="#4-4-接口作为类型使用" class="headerlink" title="4.4 接口作为类型使用"></a>4.4 接口作为类型使用</h2><p>接口作为引用类型来使用，任何实现该接口的类的实例都可以存储在该接口类型的变量中，通过这些变量可以访问类中所实现的接口中的方法，Java 运行时系统会动态地确定应该使用哪个类中的方法，实际上是调用相应的实现类的方法。</p><p>示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(A a)</span> </span>&#123;</div><div class="line">        a.doSth();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Demo d = <span class="keyword">new</span> Demo();</div><div class="line">        A a = <span class="keyword">new</span> B();</div><div class="line">        d.test1(a);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doSth</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doSth</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"now in B"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">123</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：<br>now in B</p><p>大家看到接口可以作为一个类型来使用，把接口作为方法的参数和返回类型。</p><h1 id="五、接口和抽象类的区别"><a href="#五、接口和抽象类的区别" class="headerlink" title="五、接口和抽象类的区别"></a>五、接口和抽象类的区别</h1><p>类是对象的模板，抽象类和接口可以看做是具体的类的模板。</p><p>由于从某种角度讲，接口是一种特殊的抽象类，它们的渊源颇深，有很大的相似之处，所以在选择使用谁的问题上很容易迷糊。我们首先分析它们具有的相同点。</p><ul><li>都代表类树形结构的抽象层。在使用引用变量时，尽量使用类结构的抽象层，使方法的定义和实现分离，这样做对于代码有松散耦合的好处。</li><li>都不能被实例化。</li><li>都能包含抽象方法。抽象方法用来描述系统提供哪些功能，而不必关心具体的实现。</li></ul><p>下面说一下抽象类和接口的主要区别。</p><ul><li>1) 抽象类可以为部分方法提供实现，避免了在子类中重复实现这些方法，提高了代码的可重用性，这是抽象类的优势；而接口中只能包含抽象方法，不能包含任何实现。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public abstract class A&#123;</div><div class="line">    public abstract void method1();</div><div class="line">    public void method2()&#123;</div><div class="line">        //A method2</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public class B extends A&#123;</div><div class="line">    public void method1()&#123;</div><div class="line">        //B method1</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public class C extends A&#123;</div><div class="line">    public void method1()&#123;</div><div class="line">        //C method1</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>抽象类A有两个子类B、C，由于A中有方法method2的实现，子类B、C中不需要重写method2方法，我们就说A为子类提供了公共的功能，或A约束了子类的行为。method2就是代码可重用的例子。A 并没有定义 method1的实现，也就是说B、C 可以根据自己的特点实现method1方法，这又体现了松散耦合的特性。</p><p>再换成接口看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public interface A&#123;</div><div class="line">    public void method1();</div><div class="line">    public void method2();</div><div class="line">&#125;</div><div class="line">public class B implements A&#123;</div><div class="line">    public void method1()&#123;</div><div class="line">        //B method1</div><div class="line">    &#125;</div><div class="line">    public void method2()&#123;</div><div class="line">        //B method2</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public class C implements A&#123;</div><div class="line">    public void method1()&#123;</div><div class="line">        //C method1</div><div class="line">    &#125;</div><div class="line">    public void method2()&#123;</div><div class="line">        //C method2</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>接口A无法为实现类B、C提供公共的功能，也就是说A无法约束B、C的行为。B、C可以自由地发挥自己的特点现实 method1和 method2方法，接口A毫无掌控能力。</p><ul><li>2) 一个类只能继承一个直接的父类（可能是抽象类），但一个类可以实现多个接口，这个就是接口的优势。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">interface A&#123;</div><div class="line">    public void method2();</div><div class="line">&#125;</div><div class="line">interface B&#123;</div><div class="line">    public void method1();</div><div class="line">&#125;</div><div class="line">class C implements A,B&#123;</div><div class="line">    public void method1()&#123;</div><div class="line">        //C method1</div><div class="line">    &#125;</div><div class="line">    public void method2()&#123;</div><div class="line">        //C method2</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//可以如此灵活的使用C，并且C还有机会进行扩展，实现其他接口</div><div class="line">A a=new C();</div><div class="line">B b=new C();</div><div class="line">abstract class A&#123;</div><div class="line">    public abstract void method1();</div><div class="line">&#125;</div><div class="line">abstract class B extends A&#123;</div><div class="line">    public abstract void method2();</div><div class="line">&#125;</div><div class="line">class C extends B&#123;</div><div class="line">    public void method1()&#123;</div><div class="line">        //C method1</div><div class="line">    &#125;</div><div class="line">    public void method2() &#123;</div><div class="line">        //C method2</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>对于C类，将没有机会继承其他父类了。</p><p>综上所述，接口和抽象类各有优缺点，在接口和抽象类的选择上，必须遵守这样一个原则：</p><ul><li>行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量少用抽象类。</li><li>选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用的功能。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、Java内部类及其实例化&quot;&gt;&lt;a href=&quot;#一、Java内部类及其实例化&quot; class=&quot;headerlink&quot; title=&quot;一、Java内部类及其实例化&quot;&gt;&lt;/a&gt;一、Java内部类及其实例化&lt;/h1&gt;&lt;p&gt;在 Java 中，允许在一个类（或方法、语句块）的内部定义另一个类，称为内部类(Inner Class)，有时也称为嵌套类(Nested Class)。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="内部类" scheme="http://yoursite.com/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
      <category term="抽象类" scheme="http://yoursite.com/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    
      <category term="接口" scheme="http://yoursite.com/tags/%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记（8）：常用库类、向量与哈希</title>
    <link href="http://yoursite.com/2017/08/27/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%888%EF%BC%89%EF%BC%9A%E5%B8%B8%E7%94%A8%E5%BA%93%E7%B1%BB%E3%80%81%E5%90%91%E9%87%8F%E4%B8%8E%E5%93%88%E5%B8%8C/"/>
    <id>http://yoursite.com/2017/08/27/Java学习笔记（8）：常用库类、向量与哈希/</id>
    <published>2017-08-27T14:20:45.000Z</published>
    <updated>2017-09-01T06:50:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Java基础类库"><a href="#一、Java基础类库" class="headerlink" title="一、Java基础类库"></a>一、Java基础类库</h1><p>Java 的类库是 Java 语言提供的已经实现的标准类的集合，是 Java 编程的 API（Application Program Interface），它可以帮助开发者方便、快捷地开发 Java 程序。这些类根据实现的功能不同，可以划分为不同的集合，每个集合组成一个包，称为类库。Java 类库中大部分都是由Sun 公司提供的，这些类库称为基础类库。</p><a id="more"></a><p>Java 语言中提供了大量的类库共程序开发者来使用，了解类库的结构可以帮助开发者节省大量的编程时间，而且能够使编写的程序更简单更实用。Java 中丰富的类库资源也是 Java 语言的一大特色，是 Java 程序设计的基础。</p><p>Java 常用包的简单介绍如下：</p><ul><li>java.lang 包：主要含有与语言相关的类。java.lang 包由解释程序自动加载，不需要显示说明。</li><li>java.io 包：主要含有与输入/输出相关的类，这些类提供了对不同的输入和输出设备读写数据的支持，这些输入和输出设备包括键盘、显示器、打印机、磁盘文件等。</li><li>java.util 包：包括许多具有特定功能的类，有日期、向量、哈希表、堆栈等，其中 Date类支持与时间有关的操作。</li><li>java.swing 包和 java.awt 包：提供了创建图形用户界面元素的类。通过这些元素，编程者可以控制所写的 Applet 或 Application 的外观界面。包中包含了窗口、对话框、菜单等类。</li><li>java.net 包：含有与网络操作相关的类，如 TCP Scokets、URL 等工具。</li><li>java.applet 包：含有控制 HTML 文档格式、应用程序中的声音等资源的类，其中 Applet类是用来创建包含于 HTML 的 Applet 必不可少的类。</li><li>java.beans 包：定义了应用程序编程接口（API），Java Beans 是 Java 应用程序环境的中性平台组件结构。</li></ul><h1 id="二、Java语言包-java-lang-简介"><a href="#二、Java语言包-java-lang-简介" class="headerlink" title="二、Java语言包(java.lang)简介"></a>二、Java语言包(java.lang)简介</h1><p>Java语言包（java.lang）定义了Java中的大多数基本类，由Java语言自动调用，不需要显示声明。该包中包含了Object类，Object类是整个类层次结构的根结点，同时还定义了基本数据类型的类，如：String、Boolean、Byter、Short等。这些类支持数字类型的转换和字符串的操作等，下面将进行简单介绍。</p><p>Math类提供了常用的数学运算方法以及Math.PI和Math.E两个数学常量。该类是final的，不能被继承，类中的方法和属性全部是静态，不允许在类的外部创建Math类的对象。因此，只能使用Math类的方法而不能对其作任何更改。表8-1列出了Math类的主要方法。</p><h2 id="2-1-Math类"><a href="#2-1-Math类" class="headerlink" title="2.1 Math类"></a>2.1 Math类</h2><blockquote><p>Math类的主要方法</p></blockquote><div class="table-container"><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>int abs(int i)</td><td>求整数的绝对值（另有针对long、float、double的方法）</td></tr><tr><td>double ceil(double d)</td><td>不小于d的最小整数（返回值为double型）</td></tr><tr><td>double floor(double d)</td><td>不大于d的最大整数（返回值为double型）</td></tr><tr><td>int max(int i1,int i2)</td><td>求两个整数中最大数（另有针对long、float、double的方法）</td></tr><tr><td>int min(int i1,int i2)</td><td>求两个整数中最小数（另有针对long、float、double的方法）</td></tr><tr><td>double random()</td><td>产生0~1之间的随机数</td></tr><tr><td>int round(float f)</td><td>求最靠近f的整数</td></tr><tr><td>long round(double d)</td><td>求最靠近d的长整数</td></tr><tr><td>double sqrt(double a)</td><td>求平方根</td></tr><tr><td>double sin(double d)</td><td>求d的sin值（另有求其他三角函数的方法如cos，tan，atan）</td></tr><tr><td>double log(double x)</td><td>求自然对数</td></tr><tr><td>double exp(double x)</td><td>求e的x次幂（ex）</td></tr><tr><td>double pow(double a, double b)</td><td>求a的b次幂</td></tr></tbody></table></div><p>例如：产生10个10~100之间的随机整数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//********** ep8_2.java **********</div><div class="line">class Demo&#123;</div><div class="line">    public static void main(String args[])&#123;</div><div class="line">        int a;</div><div class="line">        System.out.print(&quot;随机数为：&quot;);</div><div class="line">        for(int i=1;i&lt;=10;i++)&#123;</div><div class="line">            a=(int)((100-10+1)*Math.random()+10);</div><div class="line">            System.out.print(&quot; &quot;+a);</div><div class="line">        &#125;</div><div class="line">        System.out.println();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="2-2-字符串类"><a href="#2-2-字符串类" class="headerlink" title="2.2 字符串类"></a>2.2 字符串类</h2><p>字符串是字符的序列。在 Java 中，字符串无论是常量还是变量都是用类的对象来实现的。java.lang 提供了两种字符串类：String 类和 StringBuffer 类。</p><blockquote><p>1.String 类</p></blockquote><p>按照 Java 语言的规定，String 类是 immutable 的 Unicode 字符序列，其作用是实现一种不能改变的静态字符串。例如，把两个字符串连接起来的结果是生成一个新的字符串，而不会使原来的字符串改变。实际上，所有改变字符串的结果都是生成新的字符串，而不是改变原来字符串。</p><p>字符串与数组的实现很相似，也是通过 index 编号来指出字符在字符串中的位置的，编号从0 开始，第 2 个字符的编号为 1，以此类推。如果要访问的编号不在合法的范围内，系统会产生 StringIndexOutOfBoundsExecption 异常。如果 index 的值不是整数，则会产生编译错误。</p><p>String 类提供了如下表所示的几种字符串创建方法。</p><div class="table-container"><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>String s=”Hello!”</td><td>用字符串常量自动创建 String 实例。</td></tr><tr><td>String s=new String(String s)</td><td>通过 String 对象或字符串常量传递给构造方法。</td></tr><tr><td>public String(char value[])</td><td>将整个字符数组赋给 String 构造方法。</td></tr><tr><td>public String(char value[], int offset, int count)</td><td>将字符数组的一部分赋给 String 构造方法，offset 为起始下标，count为子数组长度。</td></tr></tbody></table></div><blockquote><p>2.StringBuffer 类</p></blockquote><p>String 类不能改变字符串对象中的内容，只能通过建立一个新串来实现字符串的变化。如果字符串需要动态改变，就需要用 StringBuffer 类。StringBuffer 类主要用来实现字符串内容的添加、修改、删除，也就是说该类对象实体的内存空间可以自动改变大小，以便于存放一个可变的字符序列。</p><p>StringBuffer 类提供的三种构造方法：</p><div class="table-container"><table><thead><tr><th>构造方法</th><th>说明</th></tr></thead><tbody><tr><td>StringBuffer()</td><td>使用该无参数的构造方法创建的 StringBuffer 对象，初始容量为 16 个字符，当对象存放的字符序列大于 16 个字符时，对象的容量自动增加。该对象可以通过 length()方法获取实体中存放的字符序列的长度，通过 capacity()方法获取当前对象的实际容量。</td></tr><tr><td>StringBuffer(int length)</td><td>使用该构造方法创建的 StringBuffer 对象，其初始容量为参数 length 指定的字符个数，当对象存放的字符序列的长度大于 length 时，对象的容量自动增加，以便存放所增加的字符。</td></tr><tr><td>StringBuffer(Strin str)</td><td>使用该构造方法创建的 StringBuffer 对象，其初始容量为参数字符串 str 的长度再加上 16 个字符。</td></tr></tbody></table></div><blockquote><p>几种 StringBuffer 类常用的方法</p></blockquote><div class="table-container"><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>append()</td><td>使用 append() 方法可以将其他 Java 类型数据转化为字符串后再追加到 StringBuffer 的对象中。</td></tr><tr><td>insert(int index, String str)</td><td>insert() 方法将一个字符串插入对象的字符序列中的某个位置。</td></tr><tr><td>setCharAt(int n, char ch)</td><td>将当前 StringBuffer 对象中的字符序列 n 处的字符用参数 ch 指定的字符替换，n 的值必须是非负的，并且小于当前对象中字符串序列的长度。</td></tr><tr><td>reverse()</td><td>使用 reverse()方法可以将对象中的字符序列翻转。</td></tr><tr><td>delete(int n, int m)</td><td>从当前 StringBuffer 对象中的字符序列删除一个子字符序列。这里的 n 指定了需要删除的第一个字符的下标，m 指定了需要删除的最后一个字符的下一个字符的下标，因此删除的子字符串从 n~m-1。</td></tr><tr><td>replace(int n, int m, String str)</td><td>用 str 替换对象中的字符序列，被替换的子字符序列由下标 n 和 m 指定。</td></tr></tbody></table></div><h1 id="三、日期和时间类"><a href="#三、日期和时间类" class="headerlink" title="三、日期和时间类"></a>三、日期和时间类</h1><p>Java 的日期和时间类位于 java.util 包中。利用日期时间类提供的方法，可以获取当前的日期和时间，创建日期和时间参数，计算和比较时间。</p><h2 id="3-1-Date-类"><a href="#3-1-Date-类" class="headerlink" title="3.1 Date 类"></a>3.1 Date 类</h2><p>Date 类是 Java 中的日期时间类，其构造方法比较多，下面是常用的两个：</p><ul><li>Date()：使用当前的日期和时间初始化一个对象。</li><li>Date(long millisec)：从1970年01月01日00时（格林威治时间）开始以毫秒计算时间，计算 millisec 毫秒。如果运行 Java 程序的本地时区是北京时区（与格林威治时间相差 8 小时），Date dt1=new Date(1000);，那么对象 dt1 就是1970年01月01日08时00分01秒。</li></ul><p>请看一个显示日期时间的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import java.util.Date;</div><div class="line">public class Demo&#123;</div><div class="line">    public static void main(String args[])&#123;</div><div class="line">        Date da=new Date();  //创建时间对象</div><div class="line">        System.out.println(da); //显示时间和日期</div><div class="line">        long msec=da.getTime();</div><div class="line">        System.out.println(&quot;从1970年1月1日0时到现在共有：&quot; + msec + &quot;毫秒&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Mon Feb 05 22:50:05 CST 2007</div><div class="line">从1970年1月1日0时到现在共有：1170687005390 毫秒</div></pre></td></tr></table></figure><p>一些比较常用的 Date 类方法：</p><div class="table-container"><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>boolean after(Date date)</td><td>若调用 Date 对象所包含的日期比 date 指定的对象所包含的日期晚，返回 true，否则返回 false。</td></tr><tr><td>boolean before(Date date)</td><td>若调用 Date 对象所包含的日期比 date 指定的对象所包含的日期早，返回 true，否则返回 false。</td></tr><tr><td>Object clone()</td><td>复制调用 Date 对象。</td></tr><tr><td>int compareTo(Date date)</td><td>比较调用对象所包含的日期和指定的对象包含的日期，若相等返回 0；若前者比后者早，返回负值；否则返回正值。</td></tr><tr><td>long getTime()</td><td>以毫秒数返回从 1970 年 01 月 01 日 00 时到目前的时间。</td></tr><tr><td>int hashCode()</td><td>返回调用对象的散列值。</td></tr><tr><td>void setTime(long time)</td><td>根据 time 的值，设置时间和日期。time 值从 1970 年 01 月 01 日 00 时开始计算。</td></tr><tr><td>String toString()</td><td>把调用的 Date 对象转换成字符串并返回结果。</td></tr><tr><td>public Static String valueOf(type variable)</td><td>把 variable 转换为字符串。</td></tr></tbody></table></div><p>Date 对象表示时间的默认顺序是星期、月、日、小时、分、秒、年。若需要修改时间显示的格式可以使用“SimpleDateFormat(String pattern)”方法。</p><p>例如，用不同的格式输出时间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">import java.util.Date;</div><div class="line">import java.text.SimpleDateFormat;</div><div class="line">public class Demo&#123;</div><div class="line">    public static void main(String args[])&#123;</div><div class="line">        Date da=new Date();</div><div class="line">        System.out.println(da);</div><div class="line">        SimpleDateFormat ma1=new SimpleDateFormat(&quot;yyyy 年 MM 月 dd 日 E 北京时间&quot;);</div><div class="line">        System.out.println(ma1.format(da));</div><div class="line">        SimpleDateFormat ma2=new SimpleDateFormat(&quot;北京时间：yyyy 年 MM 月 dd 日 HH 时 mm 分 ss 秒&quot;);</div><div class="line">        System.out.println(ma2.format(-1000));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Sun Jan 04 17:31:36 CST 2015</div><div class="line">2015 年 01 月 04 日 星期日 北京时间</div><div class="line">北京时间：1970 年 01 月 01 日 07 时 59 分 59 秒</div></pre></td></tr></table></figure><h2 id="3-2-Calendar-类"><a href="#3-2-Calendar-类" class="headerlink" title="3.2 Calendar 类"></a>3.2 Calendar 类</h2><p>抽象类 Calendar 提供了一组方法，允许把以毫秒为单位的时间转换成一些有用的时间组成部分。Calendar 不能直接创建对象，但可以使用静态方法 getInstance() 获得代表当前日期的日历对象，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Calendar calendar=Calendar.getInstance();</div></pre></td></tr></table></figure><p>该对象可以调用下面的方法将日历翻到指定的一个时间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void set(int year,int month,int date);</div><div class="line">void set(int year,int month,int date,int hour,int minute);</div><div class="line">void set(int year,int month,int date,int hour,int minute,int second);</div></pre></td></tr></table></figure><p>若要调用有关年份、月份、小时、星期等信息，可以通过调用下面的方法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int get(int field);</div></pre></td></tr></table></figure><p>其中，参数 field 的值由 Calendar 类的静态常量决定。其中：YEAR 代表年，MONTH 代表月，HOUR 代表小时，MINUTE 代表分，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">calendar.get(Calendar.MONTH);</div></pre></td></tr></table></figure><p>如果返回值为 0 代表当前日历是一月份，如果返回 1 代表二月份，依此类推。</p><p>由 Calendar 定义的一些常用方法如下表所示：</p><div class="table-container"><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>abstract void add(int which,int val)</td><td>将 val 加到 which 所指定的时间或者日期中，如果需要实现减的功能，可以加一个负数。which 必须是 Calendar 类定义的字段之一，如 Calendar.HOUR</td></tr><tr><td>boolean after(Object calendarObj)</td><td>如果调用 Calendar 对象所包含的日期比 calendarObj 指定的对象所包含的日期晚，返回 true，否则返回 false</td></tr><tr><td>boolean before(Object calendarObj)</td><td>如果调用 Calendar 对象所包含的日期比 calendarObj 指定的对象所包含的日期早，返回 true，否则返回 false</td></tr><tr><td>final void clear()</td><td>对调用对象包含的所有时间组成部分清零</td></tr><tr><td>final void clear(int which)</td><td>对调用对象包含的 which 所指定的时间组成部分清零</td></tr><tr><td>boolean equals(Object calendarObj)</td><td>如果调用 Calendar 对象所包含的日期和 calendarObj 指定的对象所包含的日期相等，返回 true，否则返回 false</td></tr><tr><td>int get(int calendarField)</td><td>返回调用 Calendar 对象的一个时间组成部分的值，这个组成部分由 calendarField指定，可以被返回的组成部分如：Calendar.YEAR，Calendar.MONTH 等</td></tr><tr><td>static Calendar getInstance()</td><td>返回使用默认地域和时区的一个 Calendar 对象</td></tr><tr><td>final Date getTime()</td><td>返回一个和调用对象时间相等的 Date 对象</td></tr><tr><td>final boolean isSet(int which)</td><td>如果调用对象所包含的 which 指定的时间部分被设置了，返回 true，否则返回 false</td></tr><tr><td>final void set(int year,int month)</td><td>设置调用对象的各种日期和时间部分</td></tr><tr><td>final void setTime(Date d)</td><td>从 Date 对象 d 中获得日期和时间部分</td></tr><tr><td>void setTimeZone(TimeZone t)</td><td>设置调用对象的时区为 t 指定的那个时区</td></tr></tbody></table></div><h2 id="3-3-GregorianCalendar-类"><a href="#3-3-GregorianCalendar-类" class="headerlink" title="3.3 GregorianCalendar 类"></a>3.3 GregorianCalendar 类</h2><p>GregorianCalendar 是一个具体实现 Calendar 类的类，该类实现了公历日历。Calendar 类的 getInstance() 方法返回一个 GregorianCalendar，它被初始化为默认的地域和时区下的当前日期和时间。</p><p>GregorianCalendar 类定义了两个字段：AD 和 BC，分别代表公元前和公元后。其默认的构造方法 GregorianCalendar() 以默认的地域和时区的当前日期和时间初始化对象，另外也可以指定地域和时区来建立一个 GregorianCalendar 对象，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">GregorianCalendar(Locale locale);</div><div class="line">GregorianCalendar(TimeZone timeZone);</div><div class="line">GregorianCalendar(TimeZone timeZone,Locale locale);</div></pre></td></tr></table></figure><p>GregorianCalendar 类提供了 Calendar 类中所有的抽象方法的实现，同时还提供了一些附加的方法，其中用来判断闰年的方法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Boolean isLeapYear(int year);</div></pre></td></tr></table></figure><p>如果 year 是闰年，该方法返回 true，否则返回 false。</p><h1 id="四、哈希表及其应用"><a href="#四、哈希表及其应用" class="headerlink" title="四、哈希表及其应用"></a>四、哈希表及其应用</h1><p>哈希表也称为散列表，是用来存储群体对象的集合类结构。</p><h2 id="4-1-什么是哈希表"><a href="#4-1-什么是哈希表" class="headerlink" title="4.1 什么是哈希表"></a>4.1 什么是哈希表</h2><p>数组和向量都可以存储对象，但对象的存储位置是随机的，也就是说对象本身与其存储位置之间没有必然的联系。当要查找一个对象时，只能以某种顺序（如顺序查找或二分查找）与各个元素进行比较，当数组或向量中的元素数量很多时，查找的效率会明显的降低。</p><p>一种有效的存储方式，是不与其他元素进行比较，一次存取便能得到所需要的记录。这就需要在对象的存储位置和对象的关键属性（设为 k）之间建立一个特定的对应关系（设为 f），使每个对象与一个唯一的存储位置相对应。在查找时，只要根据待查对象的关键属性 k 计算f(k)的值即可。如果此对象在集合中，则必定在存储位置 f(k)上，因此不需要与集合中的其他元素进行比较。称这种对应关系 f 为哈希（hash）方法，按照这种思想建立的表为哈希表。</p><p>Java 使用哈希表类（Hashtable）来实现哈希表，以下是与哈希表相关的一些概念：</p><ul><li>容量（Capacity）：Hashtable 的容量不是固定的，随对象的加入其容量也可以自动增长。</li><li>关键字（Key）：每个存储的对象都需要有一个关键字，key 可以是对象本身，也可以是对象的一部分（如某个属性）。要求在一个 Hashtable 中的所有关键字都是唯一的。</li><li>哈希码（Hash Code）：若要将对象存储到 Hashtable 上，就需要将其关键字 key 映射到一个整型数据，成为 key 的哈希码。</li><li>项（Item）：Hashtable 中的每一项都有两个域，分别是关键字域 key 和值域 value（存储的对象）。Key 和 value 都可以是任意的 Object 类型的对象，但不能为空。</li><li>装填因子（Load Factor）：装填因子表示为哈希表的装满程度，其值等于元素数比上哈希表的长度。</li></ul><h2 id="4-2-哈希表的使用"><a href="#4-2-哈希表的使用" class="headerlink" title="4.2 哈希表的使用"></a>4.2 哈希表的使用</h2><p>哈希表类主要有三种形式的构造方法：</p><ul><li>Hashtable(); //默认构造函数，初始容量为 101，最大填充因子 0.75</li><li>Hashtable(int capacity);</li><li>Hashtable(int capacity,float loadFactor)</li></ul><p>哈希表类的主要方法如下表所示。</p><div class="table-container"><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>void clear()</td><td>重新设置并清空哈希表</td></tr><tr><td>boolean contains(Object value)</td><td>确定哈希表内是否包含了给定的对象，若有返回 true，否则返回 false</td></tr><tr><td>boolean containsKey(Object key)</td><td>确定哈希表内是否包含了给定的关键字，若有返回 true，否则返回 false</td></tr><tr><td>boolean isEmpty()</td><td>确认哈希表是否为空，若是返回 true，否则返回 false</td></tr><tr><td>Object get(Object key)</td><td>获取对应关键字的对象，若不存在返回 null</td></tr><tr><td>void rehash()</td><td>再哈希，扩充哈希表使之可以保存更多的元素，当哈希表达到饱和时，系统自动调用此方法</td></tr><tr><td>Object put(Object key,Object value)</td><td>用给定的关键字把对象保存到哈希表中，此处的关键字和元素均不可为空</td></tr><tr><td>Object remove(Object key)</td><td>从哈希表中删除与给定关键字相对应的对象，若该对象不存在返回 null</td></tr><tr><td>int size()</td><td>返回哈希表的大小</td></tr><tr><td>String toString()</td><td>将哈希表内容转换为字符串</td></tr></tbody></table></div><p>哈希表的创建也可以通过 new 操作符实现。其语句为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HashTable has=new HashTable();</div></pre></td></tr></table></figure><p>哈希表的遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//*** ep8_12.java **********</div><div class="line">import java.util.*;</div><div class="line">class Demo&#123;</div><div class="line">    public static void main(String args[])&#123;</div><div class="line">        Hashtable has=new Hashtable();</div><div class="line">        has.put(&quot;one&quot;,new Integer(1));</div><div class="line">        has.put(&quot;two&quot;,new Integer(2));</div><div class="line">        has.put(&quot;three&quot;,new Integer(3));</div><div class="line">        has.put(&quot;four&quot;,new Double(12.3));</div><div class="line">        Set s=has.keySet();</div><div class="line">        for(Iterator&lt;String&gt; i=s.iterator();i.hasNext();)&#123;</div><div class="line">            System.out.println(has.get(i.next()));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、Java基础类库&quot;&gt;&lt;a href=&quot;#一、Java基础类库&quot; class=&quot;headerlink&quot; title=&quot;一、Java基础类库&quot;&gt;&lt;/a&gt;一、Java基础类库&lt;/h1&gt;&lt;p&gt;Java 的类库是 Java 语言提供的已经实现的标准类的集合，是 Java 编程的 API（Application Program Interface），它可以帮助开发者方便、快捷地开发 Java 程序。这些类根据实现的功能不同，可以划分为不同的集合，每个集合组成一个包，称为类库。Java 类库中大部分都是由Sun 公司提供的，这些类库称为基础类库。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="常用库类" scheme="http://yoursite.com/tags/%E5%B8%B8%E7%94%A8%E5%BA%93%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记（7）：深入理解java异常处理机制</title>
    <link href="http://yoursite.com/2017/08/26/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%887%EF%BC%89%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2017/08/26/Java学习笔记（7）：深入理解java异常处理机制/</id>
    <published>2017-08-26T14:20:45.000Z</published>
    <updated>2017-09-01T06:50:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、java异常"><a href="#一、java异常" class="headerlink" title="一、java异常"></a>一、java异常</h2><p>异常指不期而至的各种状况，如：文件找不到、网络连接失败、非法参数等。异常是一个事件，它发生在程序运行期间，干扰了正常的指令流程。Java通 过API中Throwable类的众多子类描述各种不同的异常。因而，Java异常都是对象，是Throwable子类的实例，描述了出现在一段编码中的 错误条件。当条件生成时，错误将引发异常。</p><a id="more"></a><p>Java异常类层次结构图：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15032841166891.jpg" alt=""></p><p> 在 Java 中，所有的异常都有一个共同的祖先 Throwable（可抛出）。Throwable 指定代码中可用异常传播机制通过 Java 应用程序传输的任何问题的共性。</p><h3 id="1-1-Exception（异常）和-Error（错误）"><a href="#1-1-Exception（异常）和-Error（错误）" class="headerlink" title="1.1 Exception（异常）和 Error（错误）"></a>1.1 Exception（异常）和 Error（错误）</h3><ul><li>Throwable： 有两个重要的子类：Exception（异常）和 Error（错误），二者都是 Java 异常处理的重要子类，各自都包含大量子类。<ul><li>Error（错误）:是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述。</li><li>Exception（异常）:是程序本身可以处理的异常。Exception 类有一个重要的子类 RuntimeException。RuntimeException 类及其子类表示“JVM 常用操作”引发的错误。例如，若试图使用空值对象引用、除数为零或数组越界，则分别引发运行时异常（NullPointerException、ArithmeticException）和 ArrayIndexOutOfBoundException。</li></ul></li></ul><p>注意：异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。</p><h3 id="1-2-可查异常（checked-exceptions）和不可查异常（unchecked-exceptions）"><a href="#1-2-可查异常（checked-exceptions）和不可查异常（unchecked-exceptions）" class="headerlink" title="1.2 可查异常（checked exceptions）和不可查异常（unchecked exceptions）"></a>1.2 可查异常（checked exceptions）和不可查异常（unchecked exceptions）</h3><p>Java的异常(包括Exception和Error)分为可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）。</p><blockquote><p>可查异常（编译器要求必须处置的异常）：</p></blockquote><p>正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。 除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</p><blockquote><p>不可查异常(编译器不要求强制处置的异常):</p></blockquote><p>包括运行时异常（RuntimeException与其子类）和错误（Error）。</p><h3 id="1-3-运行时异常和非运行时异常"><a href="#1-3-运行时异常和非运行时异常" class="headerlink" title="1.3 运行时异常和非运行时异常"></a>1.3 运行时异常和非运行时异常</h3><p>Exception 这种异常分两大类运行时异常和非运行时异常(编译异常)。程序中应当尽可能去处理这些异常。</p><blockquote><p>运行时异常：</p></blockquote><p>都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。</p><blockquote><p>非运行时异常 （编译异常）：</p></blockquote><p>是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p><h2 id="二、处理异常机制"><a href="#二、处理异常机制" class="headerlink" title="二、处理异常机制"></a>二、处理异常机制</h2><p>在Java应用程序中，异常处理机制为：抛出异常，捕捉异常。</p><blockquote><p>抛出异常：</p></blockquote><p>当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。运行时系统负责寻找处置异常的代码并执行。</p><blockquote><p>捕获异常：</p></blockquote><p>在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exception handler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适 的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适 的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。</p><p>对于运行时异常、错误或可查异常，Java技术所要求的异常处理方式有所不同。</p><p>由于运行时异常的不可查性，为了更合理、更容易地实现应用程序，Java规定，运行时异常将由Java运行时系统自动抛出，允许应用程序忽略运行时异常。</p><p>对于方法运行中可能出现的Error，当运行方法不欲捕捉时，Java允许该方法不做任何抛出声明。因为，大多数Error异常属于永远不能被允许发生的状况，也属于合理的应用程序不该捕捉的异常。</p><p>对于所有的可查异常，Java规定：一个方法必须捕捉，或者声明抛出方法之外。也就是说，当一个方法选择不捕捉可查异常时，它必须声明将抛出异常。</p><p>能够捕捉异常的方法，需要提供相符类型的异常处理器。所捕捉的异常，可能是由于自身语句所引发并抛出的异常，也可能是由某个调用的方法或者Java运行时 系统等抛出的异常。也就是说，一个方法所能捕捉的异常，一定是Java代码在某处所抛出的异常。简单地说，异常总是先被抛出，后被捕捉的。</p><p>任何Java代码都可以抛出异常，如：自己编写的代码、来自Java开发环境包中代码，或者Java运行时系统。无论是谁，都可以通过Java的throw语句抛出异常。</p><p>从方法中抛出的任何异常都必须使用throws子句。</p><p>捕捉异常通过try-catch语句或者try-catch-finally语句实现。</p><p>总体来说，Java规定，对于可查异常必须捕捉、或者声明抛出。允许忽略不可查的RuntimeException和Error。</p><h3 id="2-1-捕获异常：try、catch和finally"><a href="#2-1-捕获异常：try、catch和finally" class="headerlink" title="2.1 捕获异常：try、catch和finally"></a>2.1 捕获异常：try、catch和finally</h3><h4 id="2-1-1-try-catch语句"><a href="#2-1-1-try-catch语句" class="headerlink" title="2.1.1 try-catch语句"></a>2.1.1 try-catch语句</h4><p>在Java中，异常通过try-catch语句捕获。其一般语法形式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">try &#123;  </div><div class="line">    // 可能会发生异常的程序代码  </div><div class="line">&#125; catch (Type1 id1)&#123;  </div><div class="line">    // 捕获并处置try抛出的异常类型Type1  </div><div class="line">&#125;  </div><div class="line">catch (Type2 id2)&#123;  </div><div class="line">     //捕获并处置try抛出的异常类型Type2  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>关键词try后的一对大括号将一块可能发生异常的代码包起来，称为监控区域。Java方法在运行过程中出现异常，则创建异常对象。将异常抛出监控区域之 外，由Java运行时系统试图寻找匹配的catch子句以捕获异常。若有匹配的catch子句，则运行其异常处理代码，try-catch语句结束。</p><p>匹配的原则是：如果抛出的异常对象属于catch子句的异常类，或者属于该异常类的子类，则认为生成的异常对象与catch块捕获的异常类型相匹配。</p><blockquote><p>例1  捕捉throw语句抛出的“除数为0”异常。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class TestException &#123;  </div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">        int a = 6;  </div><div class="line">        int b = 0;  </div><div class="line">        try &#123; // try监控区域  </div><div class="line">              </div><div class="line">            if (b == 0) throw new ArithmeticException(); // 通过throw语句抛出异常  </div><div class="line">            System.out.println(&quot;a/b的值是：&quot; + a / b);  </div><div class="line">        &#125;  </div><div class="line">        catch (ArithmeticException e) &#123; // catch捕捉异常  </div><div class="line">            System.out.println(&quot;程序出现异常，变量b不能为0。&quot;);  </div><div class="line">        &#125;  </div><div class="line">        System.out.println(&quot;程序正常结束。&quot;);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">程序出现异常，变量b不能为0。</div><div class="line">程序正常结束。</div></pre></td></tr></table></figure><p>在try监控区域通过if语句进行判断，当“除数为0”的错误条件成立时引发ArithmeticException异常，创建 ArithmeticException异常对象，并由throw语句将异常抛给Java运行时系统，由系统寻找匹配的异常处理器catch并运行相应异 常处理代码，打印输出“程序出现异常，变量b不能为0。”try-catch语句结束，继续程序流程。</p><p>事实上，“除数为0”等ArithmeticException，是RuntimException的子类。而运行时异常将由运行时系统自动抛出，不需要使用throw语句。</p><blockquote><p>例2  捕捉运行时系统自动抛出“除数为0”引发的ArithmeticException异常。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;  </div><div class="line">        int a = 6;  </div><div class="line">        int b = 0;  </div><div class="line">        try &#123;  </div><div class="line">            System.out.println(&quot;a/b的值是：&quot; + a / b);  </div><div class="line">        &#125; catch (ArithmeticException e) &#123;  </div><div class="line">            System.out.println(&quot;程序出现异常，变量b不能为0。&quot;);  </div><div class="line">        &#125;  </div><div class="line">        System.out.println(&quot;程序正常结束。&quot;);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">程序出现异常，变量b不能为0。</div><div class="line">                  程序正常结束。</div></pre></td></tr></table></figure><p>例2中的语句System.out.println(“a/b的值是：” + a/b);在运行中出现“除数为0”错误，引发ArithmeticException异常。运行时系统创建异常对象并抛出监控区域，转而匹配合适的异常处理器catch，并执行相应的异常处理代码。由于检查运行时异常的代价远大于捕捉异常所带来的益处，运行时异常不可查。Java编译器允许忽略运行时异常，一个方法可以既不捕捉，也不声明抛出运行时异常。</p><blockquote><p>例3  不捕捉、也不声明抛出运行时异常。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class TestException &#123;  </div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">        int a, b;  </div><div class="line">        a = 6;  </div><div class="line">        b = 0; // 除数b 的值为0  </div><div class="line">        System.out.println(a / b);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero</div><div class="line">at Test.TestException.main(TestException.java:8)</div></pre></td></tr></table></figure><blockquote><p>例4  程序可能存在除数为0异常和数组下标越界异常。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class TestException &#123;  </div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">        int[] intArray = new int[3];  </div><div class="line">        try &#123;  </div><div class="line">            for (int i = 0; i &lt;= intArray.length; i++) &#123;  </div><div class="line">                intArray[i] = i;  </div><div class="line">                System.out.println(&quot;intArray[&quot; + i + &quot;] = &quot; + intArray[i]);  </div><div class="line">                System.out.println(&quot;intArray[&quot; + i + &quot;]模 &quot; + (i - 2) + &quot;的值:  &quot;  </div><div class="line">                        + intArray[i] % (i - 2));  </div><div class="line">            &#125;  </div><div class="line">        &#125; catch (ArrayIndexOutOfBoundsException e) &#123;  </div><div class="line">            System.out.println(&quot;intArray数组下标越界异常。&quot;);  </div><div class="line">        &#125; catch (ArithmeticException e) &#123;  </div><div class="line">            System.out.println(&quot;除数为0异常。&quot;);  </div><div class="line">        &#125;  </div><div class="line">        System.out.println(&quot;程序正常结束。&quot;);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">intArray[0] = 0</div><div class="line">intArray[0]模 -2的值:  0</div><div class="line">intArray[1] = 1</div><div class="line">intArray[1]模 -1的值:  0</div><div class="line">intArray[2] = 2</div><div class="line">除数为0异常。</div><div class="line">程序正常结束。</div></pre></td></tr></table></figure><p>例4中程序可能会出现除数为0异常，还可能会出现数组下标越界异常。程序运行过程中ArithmeticException异常类型是先行匹配的，因此执行相匹配的catch语句：</p><figure class="highlight plain"><figcaption><span>(ArithmeticException e)&#123;  </span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">     System.out.println(&quot;除数为0异常。&quot;);  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p> 需要注意的是，一旦某个catch捕获到匹配的异常类型，将进入异常处理代码。一经处理结束，就意味着整个try-catch语句结束。其他的catch子句不再有匹配和捕获异常类型的机会。</p><p>Java通过异常类描述异常类型，异常类的层次结构如图1所示。对于有多个catch子句的异常程序而言，应该尽量将捕获底层异常类的catch子 句放在前面，同时尽量将捕获相对高层的异常类的catch子句放在后面。否则，捕获底层异常类的catch子句将可能会被屏蔽。</p><p>RuntimeException异常类包括运行时各种常见的异常，ArithmeticException类和ArrayIndexOutOfBoundsException类都是它的子类。因此，RuntimeException异常类的catch子句应该放在 最后面，否则可能会屏蔽其后的特定异常处理或引起编译错误。</p><h4 id="2-1-2-try-catch-finally语句"><a href="#2-1-2-try-catch-finally语句" class="headerlink" title="2.1.2 try-catch-finally语句"></a>2.1.2 try-catch-finally语句</h4><p> try-catch语句还可以包括第三部分，就是finally子句。它表示无论是否出现异常，都应当执行的内容。try-catch-finally语句的一般语法形式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">try &#123;  </div><div class="line">    // 可能会发生异常的程序代码  </div><div class="line">&#125; catch (Type1 id1) &#123;  </div><div class="line">    // 捕获并处理try抛出的异常类型Type1  </div><div class="line">&#125; catch (Type2 id2) &#123;  </div><div class="line">    // 捕获并处理try抛出的异常类型Type2  </div><div class="line">&#125; finally &#123;  </div><div class="line">    // 无论是否发生异常，都将执行的语句块  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>例5  带finally子句的异常处理程序。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class TestException &#123;  </div><div class="line">    public static void main(String args[]) &#123;  </div><div class="line">        int i = 0;  </div><div class="line">        String greetings[] = &#123; &quot; Hello world !&quot;, &quot; Hello World !! &quot;,  </div><div class="line">                &quot; HELLO WORLD !!!&quot; &#125;;  </div><div class="line">        while (i &lt; 4) &#123;  </div><div class="line">            try &#123;  </div><div class="line">                // 特别注意循环控制变量i的设计，避免造成无限循环  </div><div class="line">                System.out.println(greetings[i++]);  </div><div class="line">            &#125; catch (ArrayIndexOutOfBoundsException e) &#123;  </div><div class="line">                System.out.println(&quot;数组下标越界异常&quot;);  </div><div class="line">            &#125; finally &#123;  </div><div class="line">                System.out.println(&quot;--------------------------&quot;);  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Hello world !</div><div class="line">--------------------------</div><div class="line">Hello World !!</div><div class="line">--------------------------</div><div class="line">HELLO WORLD !!!</div><div class="line">--------------------------</div><div class="line">数组下标越界异常</div><div class="line">--------------------------</div></pre></td></tr></table></figure></p><pre><code> 在例5中，请特别注意try子句中语句块的设计，如果设计为如下，将会出现死循环。如果设计为：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">try &#123;  </div><div class="line">      System.out.println (greetings[i]); i++;  </div><div class="line">&#125; </div><div class="line">``` </div><div class="line"></div><div class="line">小结：</div><div class="line"></div><div class="line">try 块：用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。</div><div class="line">catch 块：用于处理try捕获到的异常。</div><div class="line">finally 块：无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return语句时，finally语句块将</div><div class="line">在方法返回之前被执行。在以下4种特殊情况下，finally块不会被执行：</div><div class="line"></div><div class="line">1. 在finally语句块中发生了异常。</div><div class="line">2. 在前面的代码中用了System.exit()退出程序。</div><div class="line">3. 程序所在的线程死亡。</div><div class="line">4. 关闭CPU。</div><div class="line"></div><div class="line">#### 2.1.3 try-catch-finally 规则</div><div class="line"></div><div class="line">1. 必须在 try 之后添加 catch 或 finally 块。try 块后可同时接 catch 和 finally 块，但至少有一个块。</div><div class="line">2. 必须遵循块顺序：若代码同时使用 catch 和 finally 块，则必须将 catch 块放在 try 块之后。</div><div class="line">3. catch 块与相应的异常类的类型相关。</div><div class="line">4. 一个 try 块可能有多个 catch 块。若如此，则执行第一个匹配块。即Java虚拟机会把实际抛出的异常对象依次和各个catch代码块声明的异常类型匹配，如果异常对象为某个异常类型或其子类的实例，就执行这个catch代码块，不会再执行其他的 catch代码块</div><div class="line">5. 可嵌套 try-catch-finally 结构。</div><div class="line">6. 在 try-catch-finally 结构中，可重新抛出异常。</div><div class="line">7. 除了下列情况，总将执行 finally 做为结束：JVM 过早终止（调用 System.exit(int)）；在 finally 块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。</div><div class="line"></div><div class="line">#### 2.1.4 try、catch、finally语句块的执行顺序</div><div class="line"></div><div class="line"></div><div class="line">1. 当try没有捕获到异常时：try语句块中的语句逐一被执行，程序将跳过catch语句块，执行finally语句块和其后的语句；</div><div class="line"></div><div class="line">2. 当try捕获到异常，catch语句块里没有处理此异常的情况：当try语句块里的某条语句出现异常时，而没有处理此异常的catch语句块时，此异常将会抛给JVM处理，finally语句块里的语句还是会被执行，但finally语句块后的语句不会被执行；</div><div class="line"></div><div class="line">3. 当try捕获到异常，catch语句块里有处理此异常的情况：在try语句块中是按照顺序来执行的，当执行到某一条语句出现异常时，程序将跳到catch语句块，并与catch语句块逐一匹配，找到与之对应的处理程序，其他的catch语句块将不会被执行，而try语句块中，出现异常之后的语句也不会被执行，catch语句块执行完后，执行finally语句块里的语句，最后执行finally语句块后的语句；</div><div class="line"></div><div class="line">如下图所示：</div><div class="line"></div><div class="line">![](http://omu7tit09.bkt.clouddn.com/15032852537063.jpg)</div><div class="line"></div><div class="line"></div><div class="line">### 2.2 抛出异常</div><div class="line">任何Java代码都可以抛出异常，如：自己编写的代码、来自Java开发环境包中代码，或者Java运行时系统。无论是谁，都可以通过Java的throw语句抛出异常。从方法中抛出的任何异常都必须使用throws子句。</div><div class="line"></div><div class="line">#### 2.2.1 throws抛出异常</div><div class="line"></div><div class="line">如果一个方法可能会出现异常，但没有能力处理这种异常，可以在方法声明处用throws子句来声明抛出异常。例如汽车在运行时可能会出现故障，汽车本身没办法处理这个故障，那就让开车的人来处理。</div><div class="line"></div><div class="line">throws语句用在方法定义时声明该方法要抛出的异常类型，如果抛出的是Exception异常类型，则该方法被声明为抛出所有的异常。多个异常可使用逗号分割。throws语句的语法格式为：</div></pre></td></tr></table></figure><p>methodname throws Exception1,Exception2,..,ExceptionN<br>                    {<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">方法名后的throws Exception1,Exception2,...,ExceptionN 为声明要抛出的异常列表。当方法抛出异常列表的异常时，方法将不对这些类型及其子类类型的异常作处理，而抛向调用该方法的方法，由他去处理。例如：</div></pre></td></tr></table></figure></p><p>import java.lang.Exception;<br>public class TestException {<br>    static void pop() throws NegativeArraySizeException {<br>        // 定义方法并抛出NegativeArraySizeException异常<br>        int[] arr = new int[-3]; // 创建数组<br>    }  </p><pre><code>public static void main(String[] args) { // 主方法      try { // try语句处理异常信息          pop(); // 调用pop()方法      } catch (NegativeArraySizeException e) {          System.out.println(&quot;pop()方法抛出的异常&quot;);// 输出异常信息      }  }  </code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">使用throws关键字将异常抛给调用者后，如果调用者不想处理该异常，可以继续向上抛出，但最终要有能够处理该异常的调用者。 pop方法没有处理异常NegativeArraySizeException，而是由main函数来处理。</div><div class="line"></div><div class="line"> Throws抛出异常的规则：</div><div class="line"></div><div class="line">1. 如果是不可查异常（unchecked exception），即Error、RuntimeException或它们的子类，那么可以不使用throws关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。</div><div class="line">2. 必须声明方法可抛出的任何可查异常（checked exception）。即如果一个方法可能出现受可查异常，要么用try-catch语句捕获，要么用throws子句声明将它抛出，否则会导致编译错误</div><div class="line">3. 仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣。</div><div class="line">4. 调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。</div><div class="line"></div><div class="line">例如：</div></pre></td></tr></table></figure></p><p>void method1() throws IOException{}  //合法    </p><p>//编译错误，必须捕获或声明抛出IOException<br>void method2(){<br>  method1();<br>}    </p><p>//合法，声明抛出IOException<br>void method3()throws IOException {<br>  method1();<br>}    </p><p>//合法，声明抛出Exception，IOException是Exception的子类<br>void method4()throws Exception {<br>  method1();<br>}    </p><p>//合法，捕获IOException<br>void method5(){<br> try{<br>    method1();<br> }catch(IOException e){…}<br>}    </p><p>//编译错误，必须捕获或声明抛出Exception<br>void method6(){<br>  try{<br>    method1();<br>  }catch(IOException e){throw new Exception();}<br>}    </p><p>//合法，声明抛出Exception<br>void method7()throws Exception{<br> try{<br>  method1();<br> }catch(IOException e){throw new Exception();}<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">判断一个方法可能会出现异常的依据如下：</div><div class="line"></div><div class="line">1. 方法中有throw语句。例如，以上method7()方法的catch代码块有throw语句。</div><div class="line">2. 调用了其他方法，其他方法用throws子句声明抛出某种异常。例如，method3()方法调用了method1()方法，method1()方法声明抛出IOException，因此，在method3()方法中可能会出现IOException。</div><div class="line"></div><div class="line"></div><div class="line">#### 2.2.2 throw抛出异常</div><div class="line"></div><div class="line">throw总是出现在函数体中，用来抛出一个Throwable类型的异常。程序会在throw语句后立即终止，它后面的语句执行不到，然后在包含它的所有try块中（可能在上层调用函数中）从里向外寻找含有与其匹配的catch子句的try块。</div><div class="line"></div><div class="line">我们知道，异常是异常类的实例对象，我们可以创建异常类的实例对象通过throw语句抛出。该语句的语法格式为：</div></pre></td></tr></table></figure></p><p>throw new exceptionname;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">例如抛出一个IOException类的异常对象：</div></pre></td></tr></table></figure></p><p> throw new IOException;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">要注意的是，throw 抛出的只能够是可抛出类Throwable 或者其子类的实例对象。下面的操作是错误的：</div></pre></td></tr></table></figure></p><p>throw new String(“exception”);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">这是因为String 不是Throwable 类的子类。</div><div class="line"></div><div class="line">如果抛出了检查异常，则还应该在方法头部声明方法可能抛出的异常类型。该方法的调用者也必须检查处理抛出的异常。</div><div class="line"></div><div class="line">如果所有方法都层层上抛获取的异常，最终JVM会进行处理，处理也很简单，就是打印异常消息和堆栈信息。如果抛出的是Error或RuntimeException，则该方法的调用者可选择处理该异常。</div></pre></td></tr></table></figure></p><p>package Test;<br>import java.lang.Exception;<br>public class TestException {<br>    static int quotient(int x, int y) throws MyException { // 定义方法抛出异常<br>        if (y &lt; 0) { // 判断参数是否小于0<br>            throw new MyException(“除数不能是负数”); // 异常信息<br>        }<br>        return x/y; // 返回值<br>    }<br>    public static void main(String args[]) { // 主方法<br>        int  a =3;<br>        int  b =0;<br>        try { // try语句包含可能发生异常的语句<br>            int result = quotient(a, b); // 调用方法quotient()<br>        } catch (MyException e) { // 处理自定义异常<br>            System.out.println(e.getMessage()); // 输出异常信息<br>        } catch (ArithmeticException e) { // 处理ArithmeticException异常<br>            System.out.println(“除数不能为0”); // 输出提示信息<br>        } catch (Exception e) { // 处理其他异常<br>            System.out.println(“程序发生了其他的异常”); // 输出提示信息<br>        }<br>    }  </p><p>}<br>class MyException extends Exception { // 创建自定义异常类<br>    String message; // 定义String类型变量<br>    public MyException(String ErrorMessagr) { // 父类方法<br>        message = ErrorMessagr;<br>    }  </p><pre><code>public String getMessage() { // 覆盖getMessage()方法      return message;  }  </code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 2.3 异常链</div><div class="line">&gt; 如果调用quotient(3,-1)</div><div class="line"></div><div class="line">将发生MyException异常，程序调转到catch (MyException e)代码块中执行；</div><div class="line">&gt; 如果调用quotient(5,0)</div><div class="line"></div><div class="line">将会因“除数为0”错误引发ArithmeticException异常，属于运行时异常类，由Java运行时系统自动抛出。quotient（）方法没有捕捉ArithmeticException异常，Java运行时系统将沿方法调用栈查到main方法，将抛出的异常上传至quotient（）方法的调用者：</div></pre></td></tr></table></figure></p><p>int result = quotient(a, b); // 调用方法quotient()由于该语句在try监控区域内，因此传回的“除数为0”的ArithmeticException异常<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">由Java运行时系统抛出，并匹配catch子句：</div></pre></td></tr></table></figure></p><p>catch (ArithmeticException e) { // 处理ArithmeticException异常<br>System.out.println(“除数不能为0”); // 输出提示信息<br>}<br>```</p><p>处理结果是输出“除数不能为0”。Java这种向上传递异常信息的处理机制，形成异常链。</p><p>Java方法抛出的可查异常将依据调用栈、沿着方法调用的层次结构一直传递到具备处理能力的调用方法，最高层次到main方法为止。如果异常传递到main方法，而main不具备处理能力，也没有通过throws声明抛出该异常，将可能出现编译错误。</p><blockquote><p>如还有其他异常发生</p></blockquote><p>将使用catch (Exception e)捕捉异常。由于Exception是所有异常类的父类，如果将catch (Exception e)代码块放在其他两个代码块的前面，后面的代码块将永远得不到执行，就没有什么意义了，所以catch语句的顺序不可掉换。</p><h3 id="2-4-Throwable类中的常用方法"><a href="#2-4-Throwable类中的常用方法" class="headerlink" title="2.4 Throwable类中的常用方法"></a>2.4 Throwable类中的常用方法</h3><p>注意：catch关键字后面括号中的Exception类型的参数e。Exception就是try代码块传递给catch代码块的变量类型，e就是变量名。catch代码块中语句”e.getMessage();”用于输出错误性质。通常异常处理常用3个函数来获取异常的有关信息:</p><ul><li>getCause()：返回抛出异常的原因。如果 cause 不存在或未知，则返回 null。</li><li>getMeage()：返回异常的消息信息。</li><li>printStackTrace()：对象的堆栈跟踪输出至错误输出流，作为字段 System.err 的值。</li></ul><p>有时为了简单会忽略掉catch语句后的代码，这样try-catch语句就成了一种摆设，一旦程序在运行过程中出现了异常，就会忽略处理异常，而错误发生的原因很难查找。</p><h2 id="三、Java常见异常"><a href="#三、Java常见异常" class="headerlink" title="三、Java常见异常"></a>三、Java常见异常</h2><p>  在Java中提供了一些异常用来描述经常发生的错误，对于这些异常，有的需要程序员进行捕获处理或声明抛出，有的是由Java虚拟机自动进行捕获处理。Java中常见的异常类:</p><h3 id="3-1-runtimeException子类"><a href="#3-1-runtimeException子类" class="headerlink" title="3.1 runtimeException子类:"></a>3.1 runtimeException子类:</h3><ul><li>java.lang.ArrayIndexOutOfBoundsException：数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。</li><li>java.lang.ArithmeticException：算术条件异常。譬如：整数除零等。</li><li>java.lang.NullPointerException：空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等</li><li>java.lang.ClassNotFoundException：找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。</li><li>java.lang.NegativeArraySizeException：数组长度为负异常</li><li>java.lang.ArrayStoreException：数组中包含不兼容的值抛出的异常</li><li>java.lang.SecurityException：安全性异常</li><li>java.lang.IllegalArgumentException：非法参数异常</li></ul><h3 id="3-2-IOException"><a href="#3-2-IOException" class="headerlink" title="3.2 IOException"></a>3.2 IOException</h3><ul><li>IOException：操作输入流和输出流时可能出现的异常。</li><li>EOFException：文件已结束异常</li><li>FileNotFoundException ：文件未找到异常<h3 id="3-3-其他"><a href="#3-3-其他" class="headerlink" title="3.3 其他"></a>3.3 其他</h3></li><li>ClassCastException：类型转换异常类</li><li>ArrayStoreException：数组中包含不兼容的值抛出的异常</li><li>SQLException：操作数据库异常类</li><li>NoSuchFieldException：字段未找到异常</li><li>NoSuchMethodException：方法未找到抛出的异常</li><li>NumberFormatException：字符串转换为数字抛出的异常</li><li>StringIndexOutOfBoundsException：字符串索引超出范围抛出的异常</li><li>IllegalAccessException：不允许访问某类异常</li><li>InstantiationException：当应用程序试图使用Class类中的newInstance()方法创建一个类的实例，而指定的类对象无法被实例化时，抛出该异常</li></ul><h2 id="四、自定义异常"><a href="#四、自定义异常" class="headerlink" title="四、自定义异常"></a>四、自定义异常</h2><p>使用Java内置的异常类可以描述在编程时出现的大部分异常情况。除此之外，用户还可以自定义异常。用户自定义异常类，只需继承Exception类即可。</p><p>在程序中使用自定义异常类，大体可分为以下几个步骤。</p><ol><li>创建自定义异常类。</li><li>在方法中通过throw关键字抛出异常对象。</li><li>如果在当前抛出异常的方法中处理异常，可以使用try-catch语句捕获并处理；否则在方法的声明处通过throws关键字指明要抛出给方法调用者的异常，继续进行下一步操作。</li><li>在出现异常方法的调用者中捕获并处理异常。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、java异常&quot;&gt;&lt;a href=&quot;#一、java异常&quot; class=&quot;headerlink&quot; title=&quot;一、java异常&quot;&gt;&lt;/a&gt;一、java异常&lt;/h2&gt;&lt;p&gt;异常指不期而至的各种状况，如：文件找不到、网络连接失败、非法参数等。异常是一个事件，它发生在程序运行期间，干扰了正常的指令流程。Java通 过API中Throwable类的众多子类描述各种不同的异常。因而，Java异常都是对象，是Throwable子类的实例，描述了出现在一段编码中的 错误条件。当条件生成时，错误将引发异常。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="异常处理" scheme="http://yoursite.com/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记（6）：异常处理</title>
    <link href="http://yoursite.com/2017/08/25/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89%EF%BC%9A%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2017/08/25/Java学习笔记（6）：异常处理/</id>
    <published>2017-08-25T14:20:45.000Z</published>
    <updated>2017-09-01T06:50:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、异常处理基础"><a href="#一、异常处理基础" class="headerlink" title="一、异常处理基础"></a>一、异常处理基础</h1><p>Java异常是一个描述在代码段中发生的异常（也就是出错）情况的对象。当异常情况发生，一个代表该异常的对象被创建并且在导致该错误的方法中被抛出（throw）。该方法可以选择自己处理异常或传递该异常。两种情况下，该异常被捕获（catch）并处理。异常可能是由Java运行时系统产生，或者是由你的手工代码产生。被Java抛出的异常与违反语言规范或超出Java执行环境限制的基本错误有关。手工编码产生的异常基本上用于报告方法调用程序的出错状况。</p><a id="more"></a><p>Java异常处理通过5个关键字控制：try、catch、throw、throws和 finally。下面讲述它们如何工作的。程序声明了你想要的异常监控包含在一个try块中。如果在try块中发生异常，它被抛出。你的代码可以捕捉这个异常（用catch）并且用某种合理的方法处理该异常。系统产生的异常被Java运行时系统自动抛出。手动抛出一个异常，用关键字throw。任何被抛出方法的异常都必须通过throws子句定义。任何在方法返回前绝对被执行的代码被放置在finally块中。</p><p>下面是一个异常处理块的通常形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">try&#123;</div><div class="line">    // block of code to monitor for errors</div><div class="line">&#125;</div><div class="line">catch (ExceptionType1 exOb) &#123;</div><div class="line">    // exception handler for ExceptionType1</div><div class="line">&#125;</div><div class="line">catch (ExceptionType2 exOb) &#123;</div><div class="line">    // exception handler for ExceptionType2</div><div class="line">&#125;</div><div class="line">// ...</div><div class="line">finally &#123;</div><div class="line">    // block of code to be executed before try block ends</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里，ExceptionType 是发生异常的类型。下面将介绍怎样应用这个框架。</p><h1 id="二、异常类型"><a href="#二、异常类型" class="headerlink" title="二、异常类型"></a>二、异常类型</h1><p>所有异常类型都是内置类Throwable的子类。因此，Throwable在异常类层次结构的顶层。紧接着Throwable下面的是两个把异常分成两个不同分支的子类。一个分支是Exception。该类用于用户程序可能捕捉的异常情况。它也是你可以用来创建你自己用户异常类型子类的类。在Exception分支中有一个重要子类RuntimeException。该类型的异常自动为你所编写的程序定义并且包括被零除和非法数组索引这样的错误。</p><p>另一类分支由Error作为顶层，Error定义了在通常环境下不希望被程序捕获的异常。Error类型的异常用于Java运行时系统来显示与运行时系统本身有关的错误。堆栈溢出是这种错误的一例。本章将不讨论关于Error类型的异常处理，因为它们通常是灾难性的致命错误，不是你的程序可以控制的。</p><h1 id="三、未被捕获的异常"><a href="#三、未被捕获的异常" class="headerlink" title="三、未被捕获的异常"></a>三、未被捕获的异常</h1><p>在你学习在程序中处理异常之前，看一看如果你不处理它们会有什么情况发生是很有好处的。下面的小程序包括一个故意导致被零除错误的表达式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Exc0 &#123;</div><div class="line">    public static void main(String args[]) &#123;</div><div class="line">        int d = 0;</div><div class="line">        int a = 42 / d;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当Java运行时系统检查到被零除的情况，它构造一个新的异常对象然后抛出该异常。这导致Exc0的执行停止，因为一旦一个异常被抛出，它必须被一个异常处理程序捕获并且被立即处理。该例中，我们没有提供任何我们自己的异常处理程序，所以异常被Java运行时系统的默认处理程序捕获。任何不是被你程序捕获的异常最终都会被该默认处理程序处理。默认处理程序显示一个描述异常的字符串，打印异常发生处的堆栈轨迹并且终止程序。</p><p>下面是由标准javaJDK运行时解释器执行该程序所产生的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">java.lang.ArithmeticException: / by zero</div><div class="line">at Exc0.main(Exc0.java:4)</div></pre></td></tr></table></figure><p>注意，类名Exc0，方法名main，文件名Exc0.java和行数4是怎样被包括在一个简单的堆栈使用轨迹中的。还有，注意抛出的异常类型是Exception的一个名为ArithmeticException的子类，该子类更明确的描述了何种类型的错误方法。本章后面部分将讨论，Java提供多个内置的与可能产生的不同种类运行时错误相匹配的异常类型。</p><p>堆栈轨迹将显示导致错误产生的方法调用序列。例如，下面是前面程序的另一个版本，它介绍了相同的错误，但是错误是在main( )方法之外的另一个方法中产生的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Demo &#123;</div><div class="line">    static void subroutine() &#123;</div><div class="line">        int d = 0;</div><div class="line">        int a = 10 / d;</div><div class="line">    &#125;</div><div class="line">    public static void main(String args[]) &#123;</div><div class="line">        Exc1.subroutine();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>默认异常处理器的堆栈轨迹结果表明了整个调用栈是怎样显示的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">java.lang.ArithmeticException: / by zero</div><div class="line">at Exc1.subroutine(Exc1.java:4)</div><div class="line">at Exc1.main(Exc1.java:7)</div></pre></td></tr></table></figure><p>如你所见，栈底是main的第7行，该行调用了subroutine( )方法。该方法在第4行导致了异常。调用堆栈对于调试来说是很重要的，因为它查明了导致错误的精确的步骤。</p><h1 id="四、try和catch的使用"><a href="#四、try和catch的使用" class="headerlink" title="四、try和catch的使用"></a>四、try和catch的使用</h1><p>尽管由Java运行时系统提供的默认异常处理程序对于调试是很有用的，但通常你希望自己处理异常。这样做有两个好处。第一，它允许你修正错误。第二，它防止程序自动终止。大多数用户对于在程序终止运行和在无论何时错误发生都会打印堆栈轨迹感到很烦恼（至少可以这么说）。幸运的是，这很容易避免。为防止和处理一个运行时错误，只需要把你所要监控的代码放进一个try块就可以了。紧跟着try块的，包括一个说明你希望捕获的错误类型的catch子句。完成这个任务很简单，下面的程序包含一个处理因为被零除而产生的ArithmeticException 异常的try块和一个catch子句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Demo &#123;</div><div class="line">    public static void main(String args[]) &#123;</div><div class="line">        int d, a;</div><div class="line">        try &#123; // monitor a block of code.</div><div class="line">            d = 0;</div><div class="line">            a = 42 / d;</div><div class="line">            System.out.println(&quot;This will not be printed.&quot;);</div><div class="line">        &#125; catch (ArithmeticException e) &#123; // catch divide-by-zero error</div><div class="line">            System.out.println(&quot;Division by zero.&quot;);</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;After catch statement.&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>该程序输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Division by zero.</div><div class="line">After catch statement.</div></pre></td></tr></table></figure><p>注意在try块中的对println( )的调用是永远不会执行的。一旦异常被引发，程序控制由try块转到catch块。执行永远不会从catch块“返回”到try块。因此，“This will not be printed。”将不会被显示。一旦执行了catch语句，程序控制从整个try/catch机制的下面一行继续。</p><p>一个try和它的catch语句形成了一个单元。catch子句的范围限制于try语句前面所定义的语句。一个catch语句不能捕获另一个try声明所引发的异常（除非是嵌套的try语句情况）。</p><p>被try保护的语句声明必须在一个大括号之内（也就是说，它们必须在一个块中）。你不能单独使用try。</p><p>构造catch子句的目的是解决异常情况并且像错误没有发生一样继续运行。例如，下面的程序中，每一个for循环的反复得到两个随机整数。这两个整数分别被对方除，结果用来除12345。最后的结果存在a中。如果一个除法操作导致被零除错误，它将被捕获，a的值设为零，程序继续运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//Handle an exception and move on.</div><div class="line">import java.util.Random;</div><div class="line"></div><div class="line">class Demo &#123;</div><div class="line">    public static void main(String args[]) &#123;</div><div class="line">        int a=0, b=0, c=0;</div><div class="line">        Random r = new Random();</div><div class="line"></div><div class="line">        for(int i=0; i&lt;30; i++) &#123;</div><div class="line">            try &#123;</div><div class="line">                b = r.nextInt();</div><div class="line">                c = r.nextInt();</div><div class="line">                a = 12345 / (b/c);</div><div class="line">            &#125; catch (ArithmeticException e) &#123;</div><div class="line">                System.out.println(&quot;Division by zero.&quot;);</div><div class="line">                a = 0; // set a to zero and continue</div><div class="line">            &#125;</div><div class="line">            System.out.println(&quot;a: &quot; + a);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Throwable重载toString( )方法（由Object定义），所以它返回一个包含异常描述的字符串。你可以通过在println( )中传给异常一个参数来显示该异常的描述。例如，前面程序的catch块可以被重写成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//Handle an exception and move on.</div><div class="line">import java.util.Random;</div><div class="line"></div><div class="line">class Demo &#123;</div><div class="line">    public static void main(String args[]) &#123;</div><div class="line">        int a=0, b=0, c=0;</div><div class="line">        Random r = new Random();</div><div class="line"></div><div class="line">        for(int i=0; i&lt;30; i++) &#123;</div><div class="line">            try &#123;</div><div class="line">                b = r.nextInt();</div><div class="line">                c = r.nextInt();</div><div class="line">                a = 12345 / (b/c);</div><div class="line">            &#125; catch (ArithmeticException e) &#123;</div><div class="line">            System.out.println(&quot;Exception: &quot; + e);</div><div class="line">            a = 0; // set a to zero and continue</div><div class="line">            &#125;</div><div class="line">            System.out.println(&quot;a: &quot; + a);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当这个版本代替原程序中的版本，程序在标准javaJDK解释器下运行，每一个被零除错误显示下面的消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Exception: java.lang.ArithmeticException: / by zero</div></pre></td></tr></table></figure><p>尽管在上下文中没有特殊的值，显示一个异常描述的能力在其他情况下是很有价值的——特别是当你对异常进行实验和调试时。</p><h1 id="五、多重catch语句的使用"><a href="#五、多重catch语句的使用" class="headerlink" title="五、多重catch语句的使用"></a>五、多重catch语句的使用</h1><p>某些情况，由单个代码段可能引起多个异常。处理这种情况，你可以定义两个或更多的catch子句，每个子句捕获一种类型的异常。当异常被引发时，每一个catch子句被依次检查，第一个匹配异常类型的子句执行。当一个catch语句执行以后，其他的子句被旁路，执行从try/catch块以后的代码开始继续。下面的例子设计了两种不同的异常类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//Demonstrate multiple catch statements.</div><div class="line">class Demo &#123;</div><div class="line">    public static void main(String args[]) &#123;</div><div class="line">        try &#123;</div><div class="line">            int a = args.length;</div><div class="line">            System.out.println(&quot;a = &quot; + a);</div><div class="line">            int b = 42 / a;</div><div class="line">            int c[] = &#123; 1 &#125;;</div><div class="line">            c[42] = 99;</div><div class="line">        &#125; catch(ArithmeticException e) &#123;</div><div class="line">            System.out.println(&quot;Divide by 0: &quot; + e);</div><div class="line">        &#125; catch(ArrayIndexOutOfBoundsException e) &#123;</div><div class="line">            System.out.println(&quot;Array index oob: &quot; + e);</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;After try/catch blocks.&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>该程序在没有命令行参数的起始条件下运行导致被零除异常，因为a为0。如果你提供一个命令行参数，它将幸免于难，把a设成大于零的数值。但是它将导致ArrayIndexOutOf BoundsException异常，因为整型数组c的长度为1，而程序试图给c[42]赋值。下面是运行在两种不同情况下程序的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">C:\&gt;java MultiCatch</div><div class="line">a = 0</div><div class="line">Divide by 0: java.lang.ArithmeticException: / by zero After try/catch blocks.</div><div class="line">C:\&gt;java MultiCatch TestArg</div><div class="line">a = 1</div><div class="line">Array index oob: java.lang.ArrayIndexOutOfBoundsException After try/catch blocks.</div></pre></td></tr></table></figure><p>当你用多catch语句时，记住异常子类必须在它们任何父类之前使用是很重要的。这是因为运用父类的catch语句将捕获该类型及其所有子类类型的异常。这样，如果子类在父类后面，子类将永远不会到达。而且，Java中不能到达的代码是一个错误。例如，考虑下面的程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//This program contains an error.</div><div class="line">//A subclass must come before its superclass in a series of catch statements. If not,unreachable code will be created and acompile-time error will result.</div><div class="line">//*/</div><div class="line">class Demo &#123;</div><div class="line">    public static void main(String args[]) &#123;</div><div class="line">        try &#123;</div><div class="line">            int a = 0;</div><div class="line">            int b = 42 / a;</div><div class="line">        &#125; catch(Exception e) &#123;</div><div class="line">            System.out.println(&quot;Generic Exception catch.&quot;);</div><div class="line">        &#125;</div><div class="line">        /* This catch is never reached because</div><div class="line">        ArithmeticException is a subclass of Exception. */</div><div class="line">        catch(ArithmeticException e) &#123; // ERROR - unreachable</div><div class="line">            System.out.println(&quot;This is never reached.&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果你试着编译该程序，你会收到一个错误消息，该错误消息说明第二个catch语句不会到达，因为该异常已经被捕获。因为ArithmeticException 是Exception的子类，第一个catch语句将处理所有的面向Exception的错误，包括ArithmeticException。这意味着第二个catch语句永远不会执行。为修改程序，颠倒两个catch语句的次序。</p><h1 id="六、try语句的嵌套"><a href="#六、try语句的嵌套" class="headerlink" title="六、try语句的嵌套"></a>六、try语句的嵌套</h1><p>Try语句可以被嵌套。也就是说，一个try语句可以在另一个try块内部。每次进入try语句，异常的前后关系都会被推入堆栈。如果一个内部的try语句不含特殊异常的catch处理程序，堆栈将弹出，下一个try语句的catch处理程序将检查是否与之匹配。这个过程将继续直到一个catch语句匹配成功，或者是直到所有的嵌套try语句被检查耗尽。如果没有catch语句匹配，Java的运行时系统将处理这个异常。下面是运用嵌套try语句的一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">//An example of nested try statements.</div><div class="line">class Demo &#123;</div><div class="line">    public static void main(String args[]) &#123;</div><div class="line">        try &#123;</div><div class="line">            int a = args.length;</div><div class="line">            /* If no command-line args are present,the following statement will generate a divide-by-zero exception. */</div><div class="line">            int b = 42 / a;</div><div class="line">            System.out.println(&quot;a = &quot; + a);</div><div class="line">            try &#123; // nested try block</div><div class="line">                /* If one command-line arg is used,then a divide-by-zero exception will be generated by the following code. */</div><div class="line">                if(a==1) a = a/(a-a); // division by zero</div><div class="line">                /* If two command-line args are used,then generate an out-of-bounds exception. */</div><div class="line">                if(a==2) &#123;</div><div class="line">                    int c[] = &#123; 1 &#125;;</div><div class="line">                    c[42] = 99; // generate an out-of-bounds exception</div><div class="line">                &#125;</div><div class="line">            &#125; catch(ArrayIndexOutOfBoundsException e) &#123;</div><div class="line">                System.out.println(&quot;Array index out-of-bounds: &quot; + e);</div><div class="line">            &#125;</div><div class="line">        &#125; catch(ArithmeticException e) &#123;</div><div class="line">            System.out.println(&quot;Divide by 0: &quot; + e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如你所见，该程序在一个try块中嵌套了另一个try块。程序工作如下：当你在没有命令行参数的情况下执行该程序，外面的try块将产生一个被零除的异常。程序在有一个命令行参数条件下执行，由嵌套的try块产生一个被零除的错误。因为内部的块不匹配这个异常，它将把异常传给外部的try块，在那里异常被处理。如果你在具有两个命令行参数的条件下执行该程序，由内部try块产生一个数组边界异常。下面的结果阐述了每一种情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">C:\&gt;java NestTry</div><div class="line">Divide by 0: java.lang.ArithmeticException: / by zero</div><div class="line">C:\&gt;java NestTry One</div><div class="line">a = 1</div><div class="line">Divide by 0: java.lang.ArithmeticException: / by zero</div><div class="line">C:\&gt;java NestTry One Two</div><div class="line">a = 2</div><div class="line">Array index out-of-bounds: java.lang.ArrayIndexOutOfBoundsException</div></pre></td></tr></table></figure><p>当有方法调用时，try语句的嵌套可以很隐蔽的发生。例如，你可以把对方法的调用放在一个try块中。在该方法内部，有另一个try语句。这种情况下，方法内部的try仍然是嵌套在外部调用该方法的try块中的。下面是前面例子的修改，嵌套的try块移到了方法nesttry( )的内部：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">//Try statements can be implicitly nested via calls to methods. */</div><div class="line">class Demo &#123;</div><div class="line">    static void nesttry(int a) &#123;</div><div class="line">        try &#123; // nested try block</div><div class="line">            /* If one command-line arg is used,then a divide-by-zero exception will be generated by the following code. */</div><div class="line">            if(a==1) a = a/(a-a); // division by zero</div><div class="line">            /* If two command-line args are used,then generate an out-of-bounds exception. */</div><div class="line">            if(a==2) &#123;</div><div class="line">                int c[] = &#123; 1 &#125;;</div><div class="line">                c[42] = 99; // generate an out-of-bounds exception</div><div class="line">            &#125;</div><div class="line">        &#125; catch(ArrayIndexOutOfBoundsException e) &#123;</div><div class="line">            System.out.println(&quot;Array index out-of-bounds: &quot; + e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String args[]) &#123;</div><div class="line">        try &#123;</div><div class="line">            int a = args.length;</div><div class="line">           /* If no command-line args are present,the following statement will generate a divide-by-zero exception. */</div><div class="line">           int b = 42 / a;</div><div class="line">           System.out.println(&quot;a = &quot; + a);</div><div class="line">           nesttry(a);</div><div class="line">        &#125; catch(ArithmeticException e) &#123;</div><div class="line">            System.out.println(&quot;Divide by 0: &quot; + e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>该程序的输出与前面的例子相同。</p><h1 id="八、throws子句"><a href="#八、throws子句" class="headerlink" title="八、throws子句"></a>八、throws子句</h1><p>如果一个方法可以导致一个异常但不处理它，它必须指定这种行为以使方法的调用者可以保护它们自己而不发生异常。做到这点你可以在方法声明中包含一个throws子句。一个 throws 子句列举了一个方法可能抛出的所有异常类型。这对于除Error或RuntimeException及它们子类以外类型的所有异常是必要的。一个方法可以抛出的所有其他类型的异常必须在throws子句中声明。如果不这样做，将会导致编译错误。</p><p>下面是包含一个throws子句的方法声明的通用形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">type method-name(parameter-list) throws exception-list&#123;</div><div class="line">    // body of method</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里，exception-list是该方法可以抛出的以有逗号分割的异常列表。</p><p>下面是一个不正确的例子。该例试图抛出一个它不能捕获的异常。因为程序没有指定一个throws子句来声明这一事实，程序将不会编译。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//this program contains an error and will not compile.</div><div class="line">class ThrowsDemo &#123;</div><div class="line">    static void throwOne() &#123;</div><div class="line">        System.out.println(&quot;Inside throwOne.&quot;);</div><div class="line">        throw new IllegalAccessException(&quot;demo&quot;);</div><div class="line">    &#125;</div><div class="line">    public static void main(String args[]) &#123;</div><div class="line">        throwOne();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>为编译该程序，需要改变两个地方。第一，需要声明throwOne( )引发IllegalAccess Exception异常。第二，main( )必须定义一个try/catch 语句来捕获该异常。正确的例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//This is now correct.</div><div class="line">class Demo &#123;</div><div class="line">    static void throwOne() throws IllegalAccessException &#123;</div><div class="line">      System.out.println(&quot;Inside throwOne.&quot;);</div><div class="line">      throw new IllegalAccessException(&quot;demo&quot;);</div><div class="line">   &#125;</div><div class="line">   public static void main(String args[]) &#123;</div><div class="line">      try &#123;</div><div class="line">         throwOne();</div><div class="line">      &#125; catch (IllegalAccessException e) &#123;</div><div class="line">         System.out.println(&quot;Caught &quot; + e);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>下面是例题的输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">inside throwOne</div><div class="line">caught java.lang.IllegalAccessException: demo</div></pre></td></tr></table></figure><h1 id="九、finally块"><a href="#九、finally块" class="headerlink" title="九、finally块"></a>九、finally块</h1><p>当异常被抛出，通常方法的执行将作一个陡峭的非线性的转向。依赖于方法是怎样编码的，异常甚至可以导致方法过早返回。这在一些方法中是一个问题。例如，如果一个方法打开一个文件项并关闭，然后退出，你不希望关闭文件的代码被异常处理机制旁路。finally关键字为处理这种意外而设计。finally创建一个代码块。该代码块在一个try/catch 块完成之后另一个try/catch出现之前执行。finally块无论有没有异常抛出都会执行。如果异常被抛出，finally甚至是在没有与该异常相匹配的catch子句情况下也将执行。一个方法将从一个try/catch块返回到调用程序的任何时候，经过一个未捕获的异常或者是一个明确的返回语句，finally子句在方法返回之前仍将执行。这在关闭文件句柄和释放任何在方法开始时被分配的其他资源是很有用的。finally子句是可选项，可以有也可以无。然而每一个try语句至少需要一个catch或finally子句。</p><p>下面的例子显示了3种不同的退出方法。每一个都执行了finally子句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Demonstrate finally.</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</div><div class="line">    <span class="comment">// Through an exception out of the method.</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">procA</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">           System.out.println(<span class="string">"inside procA"</span>);</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"demo"</span>);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">           System.out.println(<span class="string">"procA's finally"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Return from within a try block.</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">procB</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">           System.out.println(<span class="string">"inside procB"</span>);</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">           System.out.println(<span class="string">"procB's finally"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Execute a try block normally.</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">procC</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">           System.out.println(<span class="string">"inside procC"</span>);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">           System.out.println(<span class="string">"procC's finally"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">          procA();</div><div class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">          System.out.println(<span class="string">"Exception caught"</span>);</div><div class="line">       &#125;</div><div class="line">       procB();</div><div class="line">       procC();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>该例中，procA( )过早地通过抛出一个异常中断了try。Finally子句在退出时执行。procB( )的try语句通过一个return语句退出。在procB( )返回之前finally子句执行。在procC（）中，try语句正常执行，没有错误。然而，finally块仍将执行。</p><p>注意：如果finally块与一个try联合使用，finally块将在try结束之前执行。</p><p>下面是上述程序产生的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">inside procA</div><div class="line">procA’s finally</div><div class="line">Exception caught</div><div class="line">inside procB</div><div class="line">procB’s finally</div><div class="line">inside procC</div><div class="line">procC’s finally</div></pre></td></tr></table></figure><h1 id="十、内置异常"><a href="#十、内置异常" class="headerlink" title="十、内置异常"></a>十、内置异常</h1><p>在标准包java.lang中，Java定义了若干个异常类。前面的例子曾用到其中一些。这些异常一般是标准类RuntimeException的子类。因为java.lang实际上被所有的Java程序引入，多数从RuntimeException派生的异常都自动可用。而且，它们不需要被包含在任何方法的throws列表中。Java语言中，这被叫做未经检查的异常（unchecked exceptions ）。因为编译器不检查它来看一个方法是否处理或抛出了这些异常。 java.lang中定义的未经检查的异常列于表10-1。表10-2列出了由 java.lang定义的必须在方法的throws列表中包括的异常，如果这些方法能产生其中的某个异常但是不能自己处理它。这些叫做受检查的异常（checked exceptions）。Java定义了几种与不同类库相关的其他的异常类型。</p><blockquote><p>Java 的 java.lang 中定义的未检查异常子类</p></blockquote><div class="table-container"><table><thead><tr><th>异常</th><th>说明</th></tr></thead><tbody><tr><td>ArithmeticException</td><td>算术错误，如被0除</td></tr><tr><td>ArrayIndexOutOfBoundsException</td><td>数组下标出界</td></tr><tr><td>ArrayStoreException</td><td>数组元素赋值类型不兼容</td></tr><tr><td>ClassCastException</td><td>非法强制转换类型</td></tr><tr><td>IllegalArgumentException</td><td>调用方法的参数非法</td></tr><tr><td>IllegalMonitorStateException</td><td>非法监控操作，如等待一个未锁定线程</td></tr><tr><td>IllegalStateException</td><td>环境或应用状态不正确</td></tr><tr><td>IllegalThreadStateException</td><td>请求操作与当前线程状态不兼容</td></tr><tr><td>IndexOutOfBoundsException</td><td>某些类型索引越界</td></tr><tr><td>NullPointerException</td><td>非法使用空引用</td></tr><tr><td>NumberFormatException</td><td>字符串到数字格式非法转换</td></tr><tr><td>SecurityException</td><td>试图违反安全性</td></tr><tr><td>StringIndexOutOfBounds</td><td>试图在字符串边界之外索引</td></tr><tr><td>UnsupportedOperationException</td><td>遇到不支持的操作</td></tr></tbody></table></div><blockquote><p> java.lang 中定义的检查异常</p></blockquote><div class="table-container"><table><thead><tr><th>异常</th><th>意义</th></tr></thead><tbody><tr><td>ClassNotFoundException</td><td>找不到类</td></tr><tr><td>CloneNotSupportedException</td><td>试图克隆一个不能实现Cloneable接口的对象</td></tr><tr><td>IllegalAccessException</td><td>对一个类的访问被拒绝</td></tr><tr><td>InstantiationException</td><td>试图创建一个抽象类或者抽象接口的对象</td></tr><tr><td>InterruptedException</td><td>一个线程被另一个线程中断</td></tr><tr><td>NoSuchFieldException</td><td>请求的字段不存在</td></tr><tr><td>NoSuchMethodException</td><td>请求的方法不存在</td></tr></tbody></table></div><h1 id="十一、创建自己的异常子类"><a href="#十一、创建自己的异常子类" class="headerlink" title="十一、创建自己的异常子类"></a>十一、创建自己的异常子类</h1><p>尽管Java的内置异常处理大多数常见错误，你也许希望建立你自己的异常类型来处理你所应用的特殊情况。这是非常简单的：只要定义Exception的一个子类就可以了（Exception当然是Throwable的一个子类）。你的子类不需要实际执行什么——它们在类型系统中的存在允许你把它们当成异常使用。Exception类自己没有定义任何方法。当然，它继承了Throwable提供的一些方法。因此，所有异常，包括你创建的，都可以获得Throwable定义的方法。这些方法显示在表10-3中。你还可以在你创建的异常类中覆盖一个或多个这样的方法。</p><blockquote><p>Throwable 定义的方法</p></blockquote><div class="table-container"><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>Throwable fillInStackTrace( )</td><td>返回一个包含完整堆栈轨迹的Throwable对象，该对象可能被再次引发。</td></tr><tr><td>String getLocalizedMessage( )</td><td>返回一个异常的局部描述</td></tr><tr><td>String getMessage( )</td><td>返回一个异常的描述</td></tr><tr><td>void printStackTrace( )</td><td>显示堆栈轨迹</td></tr><tr><td>void printStackTrace(PrintStreamstream)</td><td>把堆栈轨迹送到指定的流</td></tr><tr><td>void printStackTrace(PrintWriterstream)</td><td>把堆栈轨迹送到指定的流</td></tr><tr><td>String toString( )</td><td>返回一个包含异常描述的String对象。当输出一个Throwable对象时，该方法被println( )调用</td></tr></tbody></table></div><p>下面的例子声明了Exception的一个新子类，然后该子类当作方法中出错情形的信号。它重载了toString( )方法，这样可以用println( )显示异常的描述。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">//This program creates a custom exception type.</div><div class="line">class MyException extends Exception &#123;</div><div class="line">    private int detail;</div><div class="line">    MyException(int a) &#123;</div><div class="line">        detail = a;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String toString() &#123;</div><div class="line">        return &quot;MyException[&quot; + detail + &quot;]&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class ExceptionDemo &#123;</div><div class="line">    static void compute(int a) throws MyException &#123;</div><div class="line">        System.out.println(&quot;Called compute(&quot; + a + &quot;)&quot;);</div><div class="line">       if(a &gt; 10)</div><div class="line">          throw new MyException(a);</div><div class="line">       System.out.println(&quot;Normal exit&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String args[]) &#123;</div><div class="line">       try &#123;</div><div class="line">           compute(1);</div><div class="line">           compute(20);</div><div class="line">        &#125; catch (MyException e) &#123;</div><div class="line">            System.out.println(&quot;Caught &quot; + e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>该例题定义了Exception的一个子类MyException。该子类非常简单：它只含有一个构造函数和一个重载的显示异常值的toString( )方法。ExceptionDemo类定义了一个compute( )方法。该方法抛出一个MyException对象。当compute( )的整型参数比10大时该异常被引发。</p><p>main( )方法为MyException设立了一个异常处理程序，然后用一个合法的值和不合法的值调用compute( )来显示执行经过代码的不同路径。下面是结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Called compute(1)</div><div class="line">Normal exit</div><div class="line">Called compute(20)</div><div class="line">Caught MyException[20]</div></pre></td></tr></table></figure><h1 id="十二、断言"><a href="#十二、断言" class="headerlink" title="十二、断言"></a>十二、断言</h1><p>断言用于证明和测试程序的假设，比如“这里的值大于 5”。<br>断言可以在运行时从代码中完全删除，所以对代码的运行速度没有影响。</p><p>断言有两种方法：</p><ul><li>一种是 assert&lt;&lt;布尔表达式&gt;&gt; ；</li><li>另一种是 assert&lt;&lt;布尔表达式&gt;&gt; ：&lt;&lt;细节描述&gt;&gt;。</li></ul><p>如果布尔表达式的值为false ， 将抛出AssertionError 异常； 细节描述是AssertionError异常的描述文本使用 javac –source 1.4 MyClass.java 的方式进行编译示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> x = <span class="number">10</span>;</div><div class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                x = Integer.parseInt(args[<span class="number">0</span>]);</div><div class="line">            &#125; <span class="keyword">catch</span> (NumberFormatException nfe) &#123;</div><div class="line">                <span class="comment">/* Ignore */</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"Testing assertion that x == 10"</span>);</div><div class="line">        <span class="keyword">assert</span> x == <span class="number">10</span> : <span class="string">"Our assertion failed"</span>;</div><div class="line">        System.out.println(<span class="string">"Test passed"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>由于引入了一个新的关键字，所以在编译的时候就需要增加额外的参数，要编译成功，必须使用 JDK1.4 的 javac 并加上参数’-source 1.4′,例如可以使用以下的命令编译上面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">javac -source 1.4 AssertExample.java</div></pre></td></tr></table></figure><p>以上程序运行使用断言功能也需要使用额外的参数（并且需要一个数字的命令行参数），例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -ea AssertExample 1</div></pre></td></tr></table></figure><p>程序的输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Testing assertion that x == 10</div><div class="line">Exception in thread “main” java.lang.AssertionError:Our assertion failed</div><div class="line">at AssertExample.main(AssertExample.java:20)</div></pre></td></tr></table></figure><p>由于输入的参数不等于 10，因此断言功能使得程序运行时抛出断言错误，注意是错误， 这意味着程序发生严重错误并且将强制退出。断言使用 boolean 值，如果其值不为 true 则 抛出 AssertionError 并终止程序的运行。</p><p>断言推荐使用方法</p><p>用于验证方法中的内部逻辑，包括：</p><ul><li>内在不变式</li><li>控制流程不变式</li><li>后置条件和类不变式</li></ul><p>注意：不推荐用于公有方法内的前置条件的检查。</p><p>运行时要屏蔽断言，可以用如下方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java –disableassertions 或 java –da 类名</div></pre></td></tr></table></figure><p>运行时要允许断言，可以用如下方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java –enableassertions 或 java –ea类名</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、异常处理基础&quot;&gt;&lt;a href=&quot;#一、异常处理基础&quot; class=&quot;headerlink&quot; title=&quot;一、异常处理基础&quot;&gt;&lt;/a&gt;一、异常处理基础&lt;/h1&gt;&lt;p&gt;Java异常是一个描述在代码段中发生的异常（也就是出错）情况的对象。当异常情况发生，一个代表该异常的对象被创建并且在导致该错误的方法中被抛出（throw）。该方法可以选择自己处理异常或传递该异常。两种情况下，该异常被捕获（catch）并处理。异常可能是由Java运行时系统产生，或者是由你的手工代码产生。被Java抛出的异常与违反语言规范或超出Java执行环境限制的基本错误有关。手工编码产生的异常基本上用于报告方法调用程序的出错状况。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="异常处理" scheme="http://yoursite.com/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记（5）：static、final关键字和Object类</title>
    <link href="http://yoursite.com/2017/08/24/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89%EF%BC%9Astatic%E3%80%81final%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8CObject%E7%B1%BB/"/>
    <id>http://yoursite.com/2017/08/24/Java学习笔记（5）：static、final关键字和Object类/</id>
    <published>2017-08-24T14:20:45.000Z</published>
    <updated>2017-09-01T06:50:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、static关键字"><a href="#一、static关键字" class="headerlink" title="一、static关键字"></a>一、static关键字</h1><p>static 修饰符能够与变量、方法一起使用，表示是“静态”的。静态变量和静态方法能够通过类名来访问，不需要创建一个类的对象来访问该类的静态成员，所以static修饰的成员又称作类变量和类方法。静态变量与实例变量不同，实例变量总是通过对象来访问，因为它们的值在对象和对象之间有所不同。请看下面的例子：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Demo &#123;</div><div class="line">    static int i = 10;</div><div class="line">    int j;</div><div class="line"></div><div class="line">    Demo() &#123;</div><div class="line">        this.j = 20;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        System.out.println(&quot;类变量 i=&quot; + Demo.i);</div><div class="line">        Demo obj = new Demo();</div><div class="line">        System.out.println(&quot;实例变量 j=&quot; + obj.j);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">类变量 i=10</div><div class="line">实例变量 j=20</div></pre></td></tr></table></figure><h2 id="1-1-static的内存分配"><a href="#1-1-static的内存分配" class="headerlink" title="1.1 static的内存分配"></a>1.1 static的内存分配</h2><p>静态变量属于类，不属于任何独立的对象，所以无需创建类的实例就可以访问静态变量。之所以会产生这样的结果，是因为编译器只为整个类创建了一个静态变量的副本，也就是只分配一个内存空间，虽然有多个实例，但这些实例共享该内存。实例变量则不同，每创建一个对象，都会分配一次内存空间，不同变量的内存相互独立，互不影响，改变 a 对象的实例变量不会影响 b 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Demo obj1 = <span class="keyword">new</span> Demo();</div><div class="line">        obj1.i = <span class="number">10</span>;</div><div class="line">        obj1.j = <span class="number">20</span>;</div><div class="line">       </div><div class="line">        Demo obj2 = <span class="keyword">new</span> Demo();</div><div class="line">       </div><div class="line">        System.out.println(<span class="string">"obj1.i="</span> + obj1.i + <span class="string">", obj1.j="</span> + obj1.j);</div><div class="line">        System.out.println(<span class="string">"obj2.i="</span> + obj2.i + <span class="string">", obj2.j="</span> + obj2.j);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obj1.i=10, obj1.j=20</div><div class="line">obj2.i=10, obj2.j=0</div></pre></td></tr></table></figure><p>注意：静态变量虽然也可以通过对象来访问，但是不被提倡，编译器也会产生警告。</p><p>上面的代码中，i 是静态变量，通过 obj1 改变 i 的值，会影响到 obj2；j 是实例变量，通过 obj1 改变 j 的值，不会影响到 obj2。这是因为 obj1.i 和 obj2.i 指向同一个内存空间，而 obj1.j 和 obj2.j 指向不同的内存空间，请看下图：<br><img src="http://omu7tit09.bkt.clouddn.com/15025432513037.png" alt=""></p><p>注意：static 的变量是在类装载的时候就会被初始化。也就是说，只要类被装载，不管你是否使用了这个static 变量，它都会被初始化。</p><p>小结：类变量(class variables)用关键字 static 修饰，在类加载的时候，分配类变量的内存，以后再生成类的实例对象时，将共享这块内存（类变量），任何一个对象对类变量的修改，都会影响其它对象。外部有两种访问方式：通过对象来访问或通过类名来访问。</p><h2 id="1-2-静态方法"><a href="#1-2-静态方法" class="headerlink" title="1.2 静态方法"></a>1.2 静态方法</h2><p>静态方法是一种不能向对象实施操作的方法。例如，Math 类的 pow() 方法就是一个静态方法，语法为 Math.pow(x, a)，用来计算 x 的 a 次幂，在使用时无需创建任何 Math 对象。</p><p>因为静态方法不能操作对象，所以不能在静态方法中访问实例变量，只能访问自身类的静态变量。</p><p>以下情形可以使用静态方法：</p><ul><li>一个方法不需要访问对象状态，其所需参数都是通过显式参数提供（例如 Math.pow()）。</li><li>一个方法只需要访问类的静态变量。</li></ul><p>读者肯定注意到，main() 也是一个静态方法，不对任何对象进行操作。实际上，在程序启动时还没有任何对象，main() 方法是程序的入口，将被执行并创建程序所需的对象。</p><p>关于静态变量和静态方法的总结：</p><ul><li>一个类的静态方法只能访问静态变量；</li><li>一个类的静态方法不能够直接调用非静态方法；</li><li>如访问控制权限允许，静态变量和静态方法也可以通过对象来访问，但是不被推荐；</li><li>静态方法中不存在当前对象，因而不能使用 this，当然也不能使用 super；</li><li>静态方法不能被非静态方法覆盖；</li><li>构造方法不允许声明为 static 的；</li><li>局部变量不能使用static修饰。</li></ul><p>静态方法举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Demo &#123;</div><div class="line">    static int sum(int x, int y)&#123;</div><div class="line">        return x + y;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        int sum = Demo.sum(10, 10);</div><div class="line">        System.out.println(&quot;10+10=&quot; + sum);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">10+10=20</div></pre></td></tr></table></figure><p>static 方法不需它所属的类的任何实例就会被调用，因此没有 this 值，不能访问实例变量，否则会引起编译错误。</p><p>注意：实例变量只能通过对象来访问，不能通过类访问。</p><h2 id="1-3-静态初始器（静态块）"><a href="#1-3-静态初始器（静态块）" class="headerlink" title="1.3 静态初始器（静态块）"></a>1.3 静态初始器（静态块）</h2><p>块是由大括号包围的一段代码。静态初始器(Static Initializer)是一个存在于类中、方法外面的静态块。静态初始器仅仅在类装载的时候（第一次使用类的时候）执行一次，往往用来初始化静态变量。</p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class Demo &#123;</div><div class="line">    public static int i;</div><div class="line">    static&#123;</div><div class="line">        i = 10;</div><div class="line">        System.out.println(&quot;Now in static block.&quot;);</div><div class="line">    &#125;</div><div class="line">    public void test() &#123;</div><div class="line">        System.out.println(&quot;test method: i=&quot; + i);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        System.out.println(&quot;Demo.i=&quot; + Demo.i);</div><div class="line">        new Demo().test();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Now in static block.</div><div class="line">Demo.i=10</div><div class="line">test method: i=10</div></pre></td></tr></table></figure><h2 id="1-4-静态导入"><a href="#1-4-静态导入" class="headerlink" title="1.4 静态导入"></a>1.4 静态导入</h2><p>静态导入是 Java 5 的新增特性，用来导入类的静态变量和静态方法。</p><p>一般我们导入类都这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import packageName.className;  // 导入某个特定的类</div></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import packageName.*;  // 导入包中的所有类</div></pre></td></tr></table></figure><p>而静态导入可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import static packageName.className.methonName;  // 导入某个特定的静态方法</div></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import static packageName.className.*;  // 导入类中的所有静态成员</div></pre></td></tr></table></figure><p>导入后，可以在当前类中直接用方法名调用静态方法，不必再用 className.methodName 来访问。</p><p>对于使用频繁的静态变量和静态方法，可以将其静态导入。静态导入的好处是可以简化一些操作，例如输出语句 System.out.println(); 中的 out 就是 System 类的静态变量，可以通过 import static java.lang.System.*; 将其导入，下次直接调用 out.println() 就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import static java.lang.System.*;</div><div class="line">import static java.lang.Math.random;</div><div class="line">public class Demo &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        out.println(&quot;产生的一个随机数：&quot; + random());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">产生的一个随机数：0.05800891549018705</div></pre></td></tr></table></figure><h1 id="二、final关键字"><a href="#二、final关键字" class="headerlink" title="二、final关键字"></a>二、final关键字</h1><p>在 Java 中，声明类、变量和方法时，可使用关键字 final 来修饰。final 所修饰的数据具有“终态”的特征，表示“最终的”意思。具体规定如下：</p><ul><li>final 修饰的类不能被继承。</li><li>final 修饰的方法不能被子类重写。</li><li>final 修饰的变量（成员变量或局部变量）即成为常量，只能赋值一次。</li><li>final 修饰的成员变量必须在声明的同时赋值，如果在声明的时候没有赋值，那么只有 一次赋值的机会，而且只能在构造方法中显式赋值，然后才能使用。</li><li>final 修饰的局部变量可以只声明不赋值，然后再进行一次性的赋值。</li></ul><p>final 一般用于修饰那些通用性的功能、实现方式或取值不能随意被改变的数据，以避免被误用，例如实现数学三角方法、幂运算等功能的方法，以及数学常量π=3.141593、e=2.71828 等。</p><p>事实上，为确保终态性，提供了上述方法和常量的 java.lang.Math 类也已被定义为final 的。</p><p>需要注意的是，如果将引用类型（任何类的类型）的变量标记为 final，那么该变量不能指向任何其它对象。但可以改变对象的内容，因为只有引用本身是 final 的。</p><p>如果变量被标记为 final，其结果是使它成为常数。想改变 final 变量的值会导致一个编译错误。下面是一个正确定义 final 变量的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public final int MAX_ARRAY_SIZE = 25;  // 常量名一般大写</div></pre></td></tr></table></figure><p>常量因为有 final 修饰，所以不能被继承。<br>请看下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public final class Demo&#123;</div><div class="line">    public static final int TOTAL_NUMBER = 5;</div><div class="line">    public int id;</div><div class="line">    public Demo() &#123;</div><div class="line">        // 非法，对final变量TOTAL_NUMBER进行二次赋值了</div><div class="line">        // 因为++TOTAL_NUMBER相当于 TOTAL_NUMBER=TOTAL_NUMBER+1</div><div class="line">        id = ++TOTAL_NUMBER;</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        final Demo t = new Demo();</div><div class="line">        final int i = 10;</div><div class="line">        final int j;</div><div class="line">        j = 20;</div><div class="line">        j = 30;  // 非法，对final变量进行二次赋值</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>final 也可以用来修饰类（放在 class 关键字前面），阻止该类再派生出子类，例如 Java.lang.String 就是一个 final 类。这样做是出于安全原因，因为要保证一旦有字符串的引用，就必须是类 String 的字符串，而不是某个其它类的字符串（String 类可能被恶意继承并篡改）。</p><p>方法也可以被 final 修饰，被 final 修饰的方法不能被覆盖；变量也可以被 final 修饰，被 final 修饰的变量在创建对象以后就不允许改变它们的值了。一旦将一个类声明为 final，那么该类包含的方法也将被隐式地声明为 final，但是变量不是。</p><p>被 final 修饰的方法为静态绑定，不会产生多态（动态绑定），程序在运行时不需要再检索方法表，能够提高代码的执行效率。在Java中，被 static 或 private 修饰的方法会被隐式的声明为 final，因为动态绑定没有意义。</p><p>由于动态绑定会消耗资源并且很多时候没有必要，所以有一些程序员认为：除非有足够的理由使用多态性，否则应该将所有的方法都用 final 修饰。</p><p>这样的认识未免有些偏激，因为 JVM 中的即时编译器能够实时监控程序的运行信息，可以准确的知道类之间的继承关系。如果一个方法没有被覆盖并且很短，编译器就能够对它进行优化处理，这个过程为称为内联(inlining)。例如，内联调用 e.getName() 将被替换为访问 e.name 变量。这是一项很有意义的改进，这是由于CPU在处理调用方法的指令时，使用的分支转移会扰乱预取指令的策略，所以，这被视为不受欢迎的。然而，如果 getName() 在另外一个类中被覆盖，那么编译器就无法知道覆盖的代码将会做什么操作，因此也就不能对它进行内联处理了。</p><h1 id="三、Object类"><a href="#三、Object类" class="headerlink" title="三、Object类"></a>三、Object类</h1><p>Object 类位于 java.lang 包中，是所有 Java 类的祖先，Java 中的每个类都由它扩展而来。定义Java类时如果没有显示的指明父类，那么就默认继承了 Object 类。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public class Demo&#123;</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>实际上是下面代码的简写形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public class Demo extends Object&#123;</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在Java中，只有基本类型不是对象，例如数值、字符和布尔型的值都不是对象，所有的数组类型，不管是对象数组还是基本类型数组都是继承自 Object 类。</p><p>Object 类定义了一些有用的方法，由于是根类，这些方法在其他类中都存在，一般是进行了重载或覆盖，实现了各自的具体功能。</p><h2 id="3-1-equals-方法"><a href="#3-1-equals-方法" class="headerlink" title="3.1 equals() 方法"></a>3.1 equals() 方法</h2><p>Object 类中的 equals() 方法用来检测一个对象是否等价于另外一个对象，语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public boolean equals(Object obj)</div></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj1.equals(obj2);</div></pre></td></tr></table></figure><p>在Java中，数据等价的基本含义是指两个数据的值相等。在通过 equals() 和“==”进行比较的时候，引用类型数据比较的是引用，即内存地址，基本数据类型比较的是值。</p><p>在Java中，数据等价的基本含义是指两个数据的值相等。在通过 equals() 和“==”进行比较的时候，引用类型数据比较的是引用，即内存地址，基本数据类型比较的是值。</p><p>注意：</p><ul><li>equals()方法只能比较引用类型，“==”可以比较引用类型及基本类型。</li><li>当用 equals() 方法进行比较时，对类 File、String、Date 及包装类来说，是比较类型及内容而不考虑引用的是否是同一个实例。</li><li>用“==”进行比较时，符号两边的数据类型必须一致（可自动转换的数据类型除外），否则编译出错，而用 equals 方法比较的两个数据只要都是引用类型即可。</li></ul><h2 id="3-2-hashCode-方法"><a href="#3-2-hashCode-方法" class="headerlink" title="3.2 hashCode()方法"></a>3.2 hashCode()方法</h2><p>散列码(hashCode)是按照一定的算法由对象得到的一个数值，散列码没有规律。如果 x 和 y 是不同的对象，x.hashCode() 与 y.hashCode() 基本上不会相同。</p><p>hashCode() 方法主要用来在集合中实现快速查找等操作，也可以用于对象的比较。</p><p>在 Java 中，对 hashCode 的规定如下：</p><ul><li>在同一个应用程序执行期间，对同一个对象调用 hashCode()，必须返回相同的整数结果——前提是 equals() 所比较的信息都不曾被改动过。至于同一个应用程序在不同执行期所得的调用结果，无需一致。</li><li>如果两个对象被 equals() 方法视为相等，那么对这两个对象调用 hashCode() 必须获得相同的整数结果。</li><li>如果两个对象被 equals() 方法视为不相等，那么对这两个对象调用 hashCode() 不必产生不同的整数结果。然而程序员应该意识到，对不同对象产生不同的整数结果，有可能提升hashTable的效率。</li><li>简单地说：如果两个对象相同，那么它们的 hashCode 值一定要相同；如果两个对象的 hashCode 值相同，它们并不一定相同。在 Java 规范里面规定，一般是覆盖 equals() 方法应该连带覆盖 hashCode() 方法。</li></ul><h2 id="3-3-toString-方法"><a href="#3-3-toString-方法" class="headerlink" title="3.3 toString()方法"></a>3.3 toString()方法</h2><p>toString() 方法是 Object 类中定义的另一个重要方法，是对象的字符串表现形式，语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public String toString()</div></pre></td></tr></table></figure><p>返回值是 String 类型，用于描述当前对象的有关信息。Object 类中实现的 toString() 方法是返回当前对象的类型和内存地址信息，但在一些子类（如 String、Date 等）中进行了 重写，也可以根据需要在用户自定义类型中重写 toString() 方法，以返回更适用的信息。</p><p>除显式调用对象的 toString() 方法外，在进行 String 与其它类型数据的连接操作时，会自动调用 toString() 方法。</p><p>以上几种方法，在Java中是经常用到的，这里仅作简单介绍，让大家对Object类和其他类有所了解，详细说明请参考 Java API 文档。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、static关键字&quot;&gt;&lt;a href=&quot;#一、static关键字&quot; class=&quot;headerlink&quot; title=&quot;一、static关键字&quot;&gt;&lt;/a&gt;一、static关键字&lt;/h1&gt;&lt;p&gt;static 修饰符能够与变量、方法一起使用，表示是“静态”的。静态变量和静态方法能够通过类名来访问，不需要创建一个类的对象来访问该类的静态成员，所以static修饰的成员又称作类变量和类方法。静态变量与实例变量不同，实例变量总是通过对象来访问，因为它们的值在对象和对象之间有所不同。请看下面的例子：&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="static" scheme="http://yoursite.com/tags/static/"/>
    
      <category term="final" scheme="http://yoursite.com/tags/final/"/>
    
      <category term="Object" scheme="http://yoursite.com/tags/Object/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记（4）：多态</title>
    <link href="http://yoursite.com/2017/08/23/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89%EF%BC%9A%E5%A4%9A%E6%80%81/"/>
    <id>http://yoursite.com/2017/08/23/Java学习笔记（4）：多态/</id>
    <published>2017-08-23T14:20:45.000Z</published>
    <updated>2017-09-01T07:15:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、多态"><a href="#一、多态" class="headerlink" title="一、多态"></a>一、多态</h1><p>在Java中，父类的变量可以引用父类的实例，也可以引用子类的实例。请读者先看一段代码：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public class Demo &#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        Animal obj = new Animal();</div><div class="line">        obj.cry();</div><div class="line"></div><div class="line">        obj = new Cat();</div><div class="line">        obj.cry();</div><div class="line"></div><div class="line">        obj = new Dog();</div><div class="line">        obj.cry();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Animal&#123;</div><div class="line">    // 动物的叫声</div><div class="line">    public void cry()&#123;</div><div class="line">        System.out.println(&quot;不知道怎么叫&quot;);</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">&#125;</div><div class="line"></div><div class="line">class Cat extends Animal&#123;</div><div class="line">    // 猫的叫声</div><div class="line">    public void cry()&#123;</div><div class="line">        System.out.println(&quot;喵喵~&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Dog extends Animal&#123;</div><div class="line">    // 狗的叫声</div><div class="line">    public void cry()&#123;</div><div class="line">        System.out.println(&quot;汪汪~&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">不知道怎么叫</div><div class="line">喵喵~</div><div class="line">汪汪~</div></pre></td></tr></table></figure><p>上面的代码，定义了三个类，分别是 Animal、Cat 和 Dog，Cat 和 Dog 类都继承自 Animal 类。obj 变量的类型为 Animal，它既可以指向 Animal 类的实例，也可以指向 Cat 和 Dog 类的实例，这是正确的。也就是说，父类的变量可以引用父类的实例，也可以引用子类的实例。注意反过来是错误的，因为所有的猫都是动物，但不是所有的动物都是猫。</p><p>可以看出，obj 既可以是人类，也可以是猫、狗，它有不同的表现形式，这就被称为多态。多态是指一个事物有不同的表现形式或形态。</p><p>再比如“人类”，也有很多不同的表达或实现，TA 可以是司机、教师、医生等，你憎恨自己的时候会说“下辈子重新做人”，那么你下辈子成为司机、教师、医生都可以，我们就说“人类”具备了多态性。</p><p>多态存在的三个必要条件：要有继承、要有重写、父类变量引用子类对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public class Demo &#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        Animal obj = new Animal();</div><div class="line">        obj.cry();</div><div class="line"></div><div class="line">        obj = new Cat();</div><div class="line">        obj.bark();</div><div class="line"></div><div class="line">        obj = new Dog();</div><div class="line">        obj.cry();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Animal&#123;</div><div class="line">    // 动物的叫声</div><div class="line">    public void cry()&#123;</div><div class="line">        System.out.println(&quot;不知道怎么叫&quot;);</div><div class="line">    &#125;</div><div class="line">    public void bark() &#123;</div><div class="line">    System.out.println(&quot;哈哈！！&quot;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">   </div><div class="line">&#125;</div><div class="line"></div><div class="line">class Cat extends Animal&#123;</div><div class="line">    // 猫的叫声</div><div class="line">    public void cry()&#123;</div><div class="line">        System.out.println(&quot;喵喵~&quot;);</div><div class="line">    &#125;</div><div class="line">    public void bark()&#123;</div><div class="line">    System.out.println(&quot;丫丫！！&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Dog extends Animal&#123;</div><div class="line">    // 狗的叫声</div><div class="line">    public void cry()&#123;</div><div class="line">        System.out.println(&quot;汪汪~&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>从上面的例子可以看出，多态的一个好处是：当子类比较多时，也不需要定义多个变量，可以只定义一个父类类型的变量来引用不同子类的实例。请再看下面的一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">public class Demo &#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        // 借助多态，主人可以给很多动物喂食</div><div class="line">        Master ma = new Master();</div><div class="line">        ma.feed(new Animal(), new Food());</div><div class="line">        ma.feed(new Cat(), new Fish());</div><div class="line">        ma.feed(new Dog(), new Bone());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Animal类及其子类</div><div class="line">class Animal&#123;</div><div class="line">    public void eat(Food f)&#123;</div><div class="line">        System.out.println(&quot;我是一个小动物，正在吃&quot; + f.getFood());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Cat extends Animal&#123;</div><div class="line">    public void eat(Food f)&#123;</div><div class="line">        System.out.println(&quot;我是一只小猫咪，正在吃&quot; + f.getFood());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Dog extends Animal&#123;</div><div class="line">    public void eat(Food f)&#123;</div><div class="line">        System.out.println(&quot;我是一只狗狗，正在吃&quot; + f.getFood());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Food及其子类</div><div class="line">class Food&#123;</div><div class="line">    public String getFood()&#123;</div><div class="line">        return &quot;食物&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Fish extends Food&#123;</div><div class="line">    public String getFood()&#123;</div><div class="line">        return &quot;鱼&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Bone extends Food&#123;</div><div class="line">    public String getFood()&#123;</div><div class="line">        return &quot;骨头&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Master类</div><div class="line">class Master&#123;</div><div class="line">    public void feed(Animal an, Food f)&#123;</div><div class="line">        an.eat(f);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">我是一个小动物，正在吃事物</div><div class="line">我是一只小猫咪，正在吃鱼</div><div class="line">我是一只狗狗，正在吃骨头</div></pre></td></tr></table></figure><p>Master 类的 feed 方法有两个参数，分别是 Animal 类型和 Food 类型，因为是父类，所以可以将子类的实例传递给它，这样 Master 类就不需要多个方法来给不同的动物喂食。</p><h1 id="二、动态绑定"><a href="#二、动态绑定" class="headerlink" title="二、动态绑定"></a>二、动态绑定</h1><p>为了理解多态的本质，下面讲一下Java调用方法的详细流程。</p><ul><li>1) 编译器查看对象的声明类型和方法名。</li></ul><p>假设调用 obj.func(param)，obj 为 Cat 类的对象。需要注意的是，有可能存在多个名字为func但参数签名不一样的方法。例如，可能存在方法 func(int) 和 func(String)。编译器将会一一列举所有 Cat 类中名为func的方法和其父类 Animal 中访问属性为 public 且名为func的方法。</p><p>这样，编译器就获得了所有可能被调用的候选方法列表。</p><ul><li>2) 接下来，编泽器将检查调用方法时提供的参数签名。</li></ul><p>如果在所有名为func的方法中存在一个与提供的参数签名完全匹配的方法，那么就选择这个方法。这个过程被称为重载解析(overloading resolution)。例如，如果调用 func(“hello”)，编译器会选择 func(String)，而不是 func(int)。由于自动类型转换的存在，例如 int 可以转换为 double，如果没有找到与调用方法参数签名相同的方法，就进行类型转换后再继续查找，如果最终没有匹配的类型或者有多个方法与之匹配，那么编译错误。</p><p>这样，编译器就获得了需要调用的方法名字和参数签名。</p><ul><li>3) 如果方法的修饰符是private、static、final（static和final将在后续讲解），或者是构造方法，那么编译器将可以准确地知道应该调用哪个方法，我们将这种调用方式 称为静态绑定(static binding)。</li></ul><p>与此对应的是，调用的方法依赖于对象的实际类型， 并在运行时实现动态绑。例如调用 func(“hello”)，编泽器将采用动态绑定的方式生成一条调用 func(String) 的指令。</p><ul><li>4)当程序运行，并且釆用动态绑定调用方法时，JVM一定会调用与 obj 所引用对象的实际类型最合适的那个类的方法。我们已经假设 obj 的实际类型是 Cat，它是 Animal 的子类，如果 Cat 中定义了 func(String)，就调用它，否则将在 Animal 类及其父类中寻找。</li></ul><p>每次调用方法都要进行搜索，时间开销相当大，因此，JVM预先为每个类创建了一个方法表(method lable)，其中列出了所有方法的名称、参数签名和所属的类。这样一来，在真正调用方法的时候，虚拟机仅查找这个表就行了。在上面的例子中，JVM 搜索 Cat 类的方法表，以便寻找与调用 func(“hello”) 相匹配的方法。这个方法既有可能是 Cat.func(String)，也有可能是 Animal.func(String)。注意，如果调用super.func(“hello”)，编译器将对父类的方法表迸行搜索。</p><p>假设 Animal 类包含cry()、getName()、getAge() 三个方法，那么它的方法表如下：</p><ul><li>cry() -&gt; Animal.cry()</li><li>getName() -&gt; Animal.getName()</li><li>getAge() -&gt; Animal.getAge()</li></ul><p>实际上，Animal 也有默认的父类 Object（后续会讲解），会继承 Object 的方法，所以上面列举的方法并不完整。</p><p>假设 Cat 类覆盖了 Animal 类中的 cry() 方法，并且新增了一个方法 climbTree()，那么它的参数列表为：</p><ul><li>cry() -&gt; Cat.cry()</li><li>getName() -&gt; Animal.getName()</li><li>getAge() -&gt; Animal.getAge()</li><li>climbTree() -&gt; Cat.climbTree()</li></ul><p>在运行的时候，调用 obj.cry() 方法的过程如下：</p><ul><li>JVM 首先访问 obj 的实际类型的方法表，可能是 Animal 类的方法表，也可能是 Cat 类及其子类的方法表。</li><li>JVM 在方法表中搜索与 cry() 匹配的方法，找到后，就知道它属于哪个类了。</li><li>JVM 调用该方法。</li></ul><h1 id="三、instanceof运算符"><a href="#三、instanceof运算符" class="headerlink" title="三、instanceof运算符"></a>三、instanceof运算符</h1><p>多态性带来了一个问题，就是如何判断一个变量所实际引用的对象的类型 。 C++使用runtime-type information(RTTI)，Java 使用 instanceof 操作符。instanceof 运算符用来判断一个变量所引用的对象的实际类型，注意是它引用的对象的类型，不是变量的类型。请看下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public final class Demo&#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        // 引用 People 类的实例</div><div class="line">        People obj = new People();</div><div class="line">        if(obj instanceof Object)&#123;</div><div class="line">            System.out.println(&quot;我是一个对象&quot;);</div><div class="line">        &#125;</div><div class="line">        if(obj instanceof People)&#123;</div><div class="line">            System.out.println(&quot;我是人类&quot;);</div><div class="line">        &#125;</div><div class="line">        if(obj instanceof Teacher)&#123;</div><div class="line">            System.out.println(&quot;我是一名教师&quot;);</div><div class="line">        &#125;</div><div class="line">        if(obj instanceof President)&#123;</div><div class="line">            System.out.println(&quot;我是校长&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        System.out.println(&quot;-----------&quot;);  // 分界线</div><div class="line">       </div><div class="line">        // 引用 Teacher 类的实例</div><div class="line">        obj = new Teacher();</div><div class="line">        if(obj instanceof Object)&#123;</div><div class="line">            System.out.println(&quot;我是一个对象&quot;);</div><div class="line">        &#125;</div><div class="line">        if(obj instanceof People)&#123;</div><div class="line">            System.out.println(&quot;我是人类&quot;);</div><div class="line">        &#125;</div><div class="line">        if(obj instanceof Teacher)&#123;</div><div class="line">            System.out.println(&quot;我是一名教师&quot;);</div><div class="line">        &#125;</div><div class="line">        if(obj instanceof President)&#123;</div><div class="line">            System.out.println(&quot;我是校长&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class People&#123; &#125;</div><div class="line">class Teacher extends People&#123; &#125;</div><div class="line">class President extends Teacher&#123; &#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">我是一个对象</div><div class="line">我是人类</div><div class="line">———–</div><div class="line">我是一个对象</div><div class="line">我是人类</div><div class="line">我是一名教师</div></pre></td></tr></table></figure><p>可以看出，如果变量引用的是当前类或它的子类的实例，instanceof 返回 true，否则返回 false。</p><h1 id="四、多态对象的类型转换"><a href="#四、多态对象的类型转换" class="headerlink" title="四、多态对象的类型转换"></a>四、多态对象的类型转换</h1><p>这里所说的对象类型转换，是指存在继承关系的对象，不是任意类型的对象。当对不存在继承关系的对象进行强制类型转换时，java 运行时将抛出 java.lang.ClassCastException 异常。在继承链中，我们将子类向父类转换称为“向上转型”，将父类向子类转换称为“向下转型”。很多时候，我们会将变量定义为父类的类型，却引用子类的对象，这个过程就是向上转型。程序运行时通过动态绑定来实现对子类方法的调用，也就是多态性。</p><p>然而有些时候为了完成某些父类没有的功能，我们需要将向上转型后的子类对象再转成子类，调用子类的方法，这就是向下转型。</p><p>注意：不能直接将父类的对象强制转换为子类类型，只能将向上转型后的子类对象再次转换为子类类型。也就是说，子类对象必须向上转型后，才能再向下转型。请看下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class Demo &#123;</div><div class="line">    public static void main(String args[]) &#123;</div><div class="line">        SuperClass superObj = new SuperClass();</div><div class="line">        SonClass sonObj = new SonClass();</div><div class="line"></div><div class="line">        // 下面的代码运行时会抛出异常，不能将父类对象直接转换为子类类型</div><div class="line">        // SonClass sonObj2 = (SonClass)superObj;</div><div class="line"></div><div class="line">        // 先向上转型，再向下转型</div><div class="line">        superObj = sonObj;</div><div class="line">        SonClass sonObj1 = (SonClass)superObj;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class SuperClass&#123; &#125;</div><div class="line">class SonClass extends SuperClass&#123; &#125;</div></pre></td></tr></table></figure><p>将第7行的注释去掉，运行时会抛出异常，但是编译可以通过。</p><p>因为向下转型存在风险，所以在接收到父类的一个引用时，请务必使用 instanceof 运算符来判断该对象是否是你所要的子类，请看下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class Demo &#123;</div><div class="line">    public static void main(String args[]) &#123;</div><div class="line">        SuperClass superObj = new SuperClass();</div><div class="line">        SonClass sonObj = new SonClass();</div><div class="line"></div><div class="line">        // superObj 不是 SonClass 类的实例</div><div class="line">        if(superObj instanceof SonClass)&#123;</div><div class="line">            SonClass sonObj1 = (SonClass)superObj;</div><div class="line">        &#125;else&#123;</div><div class="line">            System.out.println(&quot;①不能转换&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        superObj = sonObj;</div><div class="line">        // superObj 是 SonClass 类的实例</div><div class="line">        if(superObj instanceof SonClass)&#123;</div><div class="line">            SonClass sonObj2 = (SonClass)superObj;</div><div class="line">        &#125;else&#123;</div><div class="line">            System.out.println(&quot;②不能转换&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class SuperClass&#123; &#125;</div><div class="line">class SonClass extends SuperClass&#123; &#125;</div></pre></td></tr></table></figure><p>运行结果：<br>①不能转换</p><p>总结：对象的类型转换在程序运行时检查，向上转型会自动进行，向下转型的对象必须是当前引用类型的子类。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、多态&quot;&gt;&lt;a href=&quot;#一、多态&quot; class=&quot;headerlink&quot; title=&quot;一、多态&quot;&gt;&lt;/a&gt;一、多态&lt;/h1&gt;&lt;p&gt;在Java中，父类的变量可以引用父类的实例，也可以引用子类的实例。请读者先看一段代码：&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="多态" scheme="http://yoursite.com/tags/%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记（3）：继承、覆盖、重载</title>
    <link href="http://yoursite.com/2017/08/22/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%EF%BC%9A%E7%BB%A7%E6%89%BF/"/>
    <id>http://yoursite.com/2017/08/22/Java学习笔记（3）：继承/</id>
    <published>2017-08-22T14:20:45.000Z</published>
    <updated>2017-09-01T07:00:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、继承的概念与实现"><a href="#一、继承的概念与实现" class="headerlink" title="一、继承的概念与实现"></a>一、继承的概念与实现</h1><p>继承是类与类之间的关系，是一个很简单很直观的概念，与现实世界中的继承（例如儿子继承父亲财产）类似。继承可以理解为一个类从另一个类获取方法和属性的过程。如果类B继承于类A，那么B就拥有A的方法和属性。</p><a id="more"></a><p>继承使用 extends 关键字。<br>例如我们已经定义了一个类 People：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class People&#123;</div><div class="line">    String name;</div><div class="line">    int age;</div><div class="line">    int height;</div><div class="line">   </div><div class="line">    void say()&#123;</div><div class="line">        System.out.println(&quot;我的名字是 &quot; + name + &quot;，年龄是 &quot; + age + &quot;，身高是 &quot; + height);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果现在需要定义一个类 Teacher，它也有 name、age、height 属性和 say() 方法，另外还需要增加 school、seniority、subject 属性和 lecturing() 方法，怎么办呢？我们要重新定义一个类吗？</p><p>完全没必要，可以先继承 People 类的成员，再增加自己的成员即可，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Teacher extends People&#123;</div><div class="line">    String school;  // 所在学校</div><div class="line">    String subject;  // 学科</div><div class="line">    int seniority;  // 教龄</div><div class="line">   </div><div class="line">    // 覆盖 People 类中的 say() 方法</div><div class="line">    void say()&#123;</div><div class="line">        System.out.println(&quot;我叫&quot; + name + &quot;，在&quot; + school + &quot;教&quot; + subject + &quot;，有&quot; + seniority + &quot;年教龄&quot;);</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    void lecturing()&#123;</div><div class="line">        System.out.println(&quot;我已经&quot; + age + &quot;岁了，依然站在讲台上讲课&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>对程序的说明</p><ul><li>name 和 age 变量虽然没有在 Teacher 中定义，但是已在 People 中定义，可以直接拿来用。</li><li>Teacher 是 People 的子类，People 是Teacher 类的父类。</li><li>子类可以覆盖父类的方法。</li><li>子类可以继承父类除private以为的所有的成员。</li><li>构造方法不能被继承。</li></ul><p>继承是在维护和可靠性方面的一个伟大进步。如果在 People 类中进行修改，那么 Teacher 类就会自动修改，而不需要程序员做任何工作，除了对它进行编译。</p><p>单继承性：Java 允许一个类仅能继承一个其它类，即一个类只能有一个父类，这个限制被称做单继承性。后面将会学到接口(interface)的概念，接口允许多继承。</p><p>最后对上面的代码进行整理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public class Demo &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Teacher t = new Teacher();</div><div class="line">        t.name = &quot;小布&quot;;</div><div class="line">        t.age = 70;</div><div class="line">        t.school = &quot;清华大学&quot;;</div><div class="line">        t.subject = &quot;Java&quot;;</div><div class="line">        t.seniority = 12;</div><div class="line">        t.say();</div><div class="line">        t.lecturing();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class People&#123;</div><div class="line">    String name;</div><div class="line">    int age;</div><div class="line">    int height;</div><div class="line">   </div><div class="line">    void say()&#123;</div><div class="line">        System.out.println(&quot;我的名字是 &quot; + name + &quot;，年龄是 &quot; + age + &quot;，身高是 &quot; + height);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Teacher extends People&#123;</div><div class="line">    String school;  // 所在学校</div><div class="line">    String subject;  // 学科</div><div class="line">    int seniority;  // 教龄</div><div class="line">   </div><div class="line">    // 覆盖 People 类中的 say() 方法</div><div class="line">    void say()&#123;</div><div class="line">        System.out.println(&quot;我叫&quot; + name + &quot;，在&quot; + school + &quot;教&quot; + subject + &quot;，有&quot; + seniority + &quot;年教龄&quot;);</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    void lecturing()&#123;</div><div class="line">        System.out.println(&quot;我已经&quot; + age + &quot;岁了，依然站在讲台上讲课&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">我叫小布，在清华大学教Java，有12年教龄</div><div class="line">我已经70岁了，依然站在讲台上讲课</div></pre></td></tr></table></figure><p>注意：构造方法不能被继承，掌握这一点很重要。 一个类能得到构造方法，只有两个办法：编写构造方法，或者根本没有构造方法，类有一个默认的构造方法。</p><h1 id="二、super关键字"><a href="#二、super关键字" class="headerlink" title="二、super关键字"></a>二、super关键字</h1><p>super 关键字与 this 类似，this 用来表示当前类的实例，super 用来表示父类。super 可以用在子类中，通过点号(.)来获取父类的成员变量和方法。super 也可以用在子类的子类中，Java 能自动向上层类追溯。父类行为被调用，就好象该行为是本类的行为一样，而且调用行为不必发生在父类中，它能自动向上层类追溯。</p><p>super 关键字的功能：</p><ul><li>调用父类中声明为 private 的变量。</li><li>点取已经覆盖了的方法。</li><li>作为方法名表示父类构造方法。</li></ul><h2 id="2-1-调用隐藏变量和被覆盖的方法"><a href="#2-1-调用隐藏变量和被覆盖的方法" class="headerlink" title="2.1 调用隐藏变量和被覆盖的方法"></a>2.1 调用隐藏变量和被覆盖的方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class Demo&#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Dog obj = new Dog();</div><div class="line">        obj.move();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class Animal&#123;</div><div class="line">    private String desc = &quot;Animals are human&apos;s good friends&quot;;</div><div class="line">    // 必须要声明一个 getter 方法</div><div class="line">    public String getDesc() &#123; return desc; &#125;</div><div class="line"></div><div class="line">    public void move()&#123;</div><div class="line">        System.out.println(&quot;Animals can move&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class Dog extends Animal&#123;</div><div class="line">    public void move()&#123;</div><div class="line">        super.move();  // 调用父类的方法</div><div class="line">        System.out.println(&quot;Dogs can walk and run&quot;);</div><div class="line">        // 通过 getter 方法调用父类隐藏变量</div><div class="line">        System.out.println(&quot;Please remember: &quot; + super.getDesc());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Animals can move</div><div class="line">Dogs can walk and run</div><div class="line">Please remember: Animals are human’s good friends</div></pre></td></tr></table></figure><p>move() 方法也可以定义在某些祖先类中，比如父类的父类，Java 具有追溯性，会一直向上找，直到找到该方法为止。</p><p>通过 super 调用父类的隐藏变量，必须要在父类中声明 getter 方法，因为声明为 private 的数据成员对子类是不可见的。</p><h2 id="2-2-调用父类的构造方法"><a href="#2-2-调用父类的构造方法" class="headerlink" title="2.2 调用父类的构造方法"></a>2.2 调用父类的构造方法</h2><p>在许多情况下，使用默认构造方法来对父类对象进行初始化。当然也可以使用 super 来显示调用父类的构造方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class Demo&#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Dog obj = new Dog(&quot;花花&quot;, 3);</div><div class="line">        obj.say();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class Animal&#123;</div><div class="line">    String name;</div><div class="line">    public Animal(String name)&#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class Dog extends Animal&#123;</div><div class="line">    int age;</div><div class="line">    public Dog(String name, int age)&#123;</div><div class="line">        super(name);</div><div class="line">        this.age = age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void say()&#123;</div><div class="line">        System.out.println(&quot;我是一只可爱的小狗，我的名字叫&quot; + name + &quot;，我&quot; + age + &quot;岁了&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">我是一只可爱的小狗，我的名字叫花花，我3岁了</div></pre></td></tr></table></figure><p>注意：无论是 super() 还是 this()，都必须放在构造方法的第一行。</p><p>值得注意的是：</p><ul><li>在构造方法中调用另一个构造方法，调用动作必须置于最起始的位置。</li><li>不能在构造方法以外的任何方法内调用构造方法。</li><li>在一个构造方法内只能调用一个构造方法。</li></ul><p>如果编写一个构造方法，既没有调用 super() 也没有调用 this()，编译器会自动插入一个调用到父类构造方法中，而且不带参数。</p><p>最后注意 super 与 this 的区别：super 不是一个对象的引用，不能将 super 赋值给另一个对象变量，它只是一个指示编译器调用父类方法的特殊关键字。</p><h1 id="三、继承中的方法的覆盖和重载"><a href="#三、继承中的方法的覆盖和重载" class="headerlink" title="三、继承中的方法的覆盖和重载"></a>三、继承中的方法的覆盖和重载</h1><h2 id="3-1-覆盖"><a href="#3-1-覆盖" class="headerlink" title="3.1 覆盖"></a>3.1 覆盖</h2><p>在类继承中，子类可以修改从父类继承来的方法，也就是说子类能创建一个与父类方法有不同功能的方法，但具有相同的名称、返回值类型、参数列表。如果在新类中定义一个方法，其名称、返回值类型和参数列表正好与父类中的相同，那么，新方法被称做覆盖旧方法。参数列表又叫参数签名，包括参数的类型、参数的个数和参数的顺序，只要有一个不同就叫做参数列表不同。被覆盖的方法在子类中只能通过super调用。</p><p>注意：覆盖不会删除父类中的方法，而是对子类的实例隐藏，暂时不使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Dog myDog = <span class="keyword">new</span> Dog(<span class="string">"花花"</span>);</div><div class="line">        myDog.say();  <span class="comment">// 子类的实例调用子类中的方法</span></div><div class="line">       </div><div class="line">        Animal myAnmial = <span class="keyword">new</span> Animal(<span class="string">"贝贝"</span>);</div><div class="line">        myAnmial.say();  <span class="comment">// 父类的实例调用父类中的方法</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</div><div class="line">    String name;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"我是一只小动物，我的名字叫"</span> + name + <span class="string">"，我会发出叫声"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</div><div class="line">    <span class="comment">// 构造方法不能被继承，通过super()调用</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name)</span></span>&#123;</div><div class="line">        <span class="keyword">super</span>(name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 覆盖say() 方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"我是一只小狗，我的名字叫"</span> + name + <span class="string">"，我会发出汪汪的叫声"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">我是一只小狗，我的名字叫花花，我会发出汪汪的叫声</div><div class="line">我是一只小动物，我的名字叫贝贝，我会发出叫声</div></pre></td></tr></table></figure><p>方法覆盖的原则：</p><ul><li>覆盖方法的返回类型、方法名称、参数列表必须与原方法的相同。</li><li>覆盖方法不能比原方法访问性差（即访问权限不允许缩小）。</li><li>覆盖方法不能比原方法抛出更多的异常。</li><li>被覆盖的方法不能是final类型，因为final修饰的方法是无法覆盖的。</li><li>被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。</li><li>被覆盖的方法不能为static。如果父类中的方法为静态的，而子类中的方法不是静态的，但是两个方法除了这一点外其他都满足覆盖条件，那么会发生编译错误；反之亦然。即使父类和子类中的方法都是静态的，并且满足覆盖条件，但是仍然不会发生覆盖，因为静态方法是在编译的时候把静态方法和类的引用类型进行匹配。</li></ul><h2 id="3-2-重载"><a href="#3-2-重载" class="headerlink" title="3.2 重载"></a>3.2 重载</h2><p>前面已经对Java方法重载进行了说明，这里再强调一下，Java父类和子类中的方法都会参与重载，例如，父类中有一个方法是 func(){ … }，子类中有一个方法是 func(int i){ … }，就构成了方法的重载。</p><p>覆盖和重载的不同：</p><ul><li>方法覆盖要求参数列表必须一致，而方法重载要求参数列表必须不一致。</li><li>方法覆盖要求返回类型必须一致，方法重载对此没有要求。</li><li>方法覆盖只能用于子类覆盖父类的方法，方法重载用于同一个类中的所有方法（包括从父类中继承而来的方法）。</li><li>方法覆盖对方法的访问权限和抛出的异常有特殊的要求，而方法重载在这方面没有任何限制。</li><li>父类的一个方法只能被子类覆盖一次，而一个方法可以在所有的类中可以被重载多次</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、继承的概念与实现&quot;&gt;&lt;a href=&quot;#一、继承的概念与实现&quot; class=&quot;headerlink&quot; title=&quot;一、继承的概念与实现&quot;&gt;&lt;/a&gt;一、继承的概念与实现&lt;/h1&gt;&lt;p&gt;继承是类与类之间的关系，是一个很简单很直观的概念，与现实世界中的继承（例如儿子继承父亲财产）类似。继承可以理解为一个类从另一个类获取方法和属性的过程。如果类B继承于类A，那么B就拥有A的方法和属性。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="继承" scheme="http://yoursite.com/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记（2）：类与对象</title>
    <link href="http://yoursite.com/2017/08/21/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%EF%BC%9A%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2017/08/21/Java学习笔记（2）：类与对象/</id>
    <published>2017-08-21T14:20:45.000Z</published>
    <updated>2017-09-01T06:46:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、类的定义及其实例化"><a href="#一、类的定义及其实例化" class="headerlink" title="一、类的定义及其实例化"></a>一、类的定义及其实例化</h1><p>类必须先定义才能使用。类是创建对象的模板，创建对象也叫类的实例化。</p><a id="more"></a><p>下面通过一个简单的例子来理解Java中类的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</div><div class="line">    String name;</div><div class="line">    <span class="keyword">int</span> age;</div><div class="line">   </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span></span>&#123;  <span class="comment">// 汪汪叫</span></div><div class="line">        System.out.println(<span class="string">"汪汪，不要过来"</span>);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hungry</span><span class="params">()</span></span>&#123;  <span class="comment">// 饥饿</span></div><div class="line">        System.out.println(<span class="string">"主人，我饿了"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>对示例的说明：</p><ul><li>public 是类的修饰符，表明该类是公共类，可以被其他类访问。修饰符将在下节讲解。</li><li>class 是定义类的关键字。</li><li>Dog 是类名称。</li><li>name、age是类的成员变量，也叫属性；bark()、hungry() 是类中的函数，也叫方法。</li></ul><p>一个类可以包含以下类型变量：</p><ul><li>局部变量：在方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li><li>成员变量：成员变量是定义在类中、方法体之外的变量。这种变量在创建对象的时候实例化（分配内存）。成员变量可以被类中的方法和特定类的语句访问。</li><li>类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。static 也是修饰符的一种，将在下节讲解。</li></ul><h2 id="1-1-构造方法"><a href="#1-1-构造方法" class="headerlink" title="1.1 构造方法"></a>1.1 构造方法</h2><p>在类实例化的过程中自动执行的方法叫做构造方法，它不需要你手动调用。构造方法可以在类实例化的过程中做一些初始化的工作。</p><p>构造方法的名称必须与类的名称相同，并且没有返回值。</p><p>每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认的构造方法。</p><p>下面是一个构造方法示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</div><div class="line">    String name;</div><div class="line">    <span class="keyword">int</span> age;</div><div class="line">   </div><div class="line">    <span class="comment">// 构造方法，没有返回值</span></div><div class="line">    Dog(String name1, <span class="keyword">int</span> age1)&#123;</div><div class="line">        name = name1;</div><div class="line">        age = age1;</div><div class="line">        System.out.println(<span class="string">"感谢主人领养了我"</span>);</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    <span class="comment">// 普通方法，必须有返回值</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"汪汪，不要过来"</span>);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hungry</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"主人，我饿了"</span>);</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String arg[])</span></span>&#123;</div><div class="line">        <span class="comment">// 创建对象时传递的参数要与构造方法参数列表对应</span></div><div class="line">        Dog myDog = <span class="keyword">new</span> Dog(<span class="string">"花花"</span>, <span class="number">3</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">感谢主人领养了我</div></pre></td></tr></table></figure><p>说明：</p><ul><li>构造方法不能被显示调用。</li><li>构造方法不能有返回值，因为没有变量来接收返回值。<h2 id="1-2-创建对象"><a href="#1-2-创建对象" class="headerlink" title="1.2 创建对象"></a>1.2 创建对象</h2>对象是类的一个实例，创建对象的过程也叫类的实例化。对象是以类为模板来创建的。</li></ul><p>在Java中，使用new关键字来创建对象，一般有以下三个步骤：</p><ul><li>声明：声明一个对象，包括对象名称和对象类型。</li><li>实例化：使用关键字new来创建一个对象。</li><li>初始化：使用new创建对象时，会调用构造方法初始化对象。</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Dog myDog;  // 声明一个对象</div><div class="line">myDog = new Dog(&quot;花花&quot;, 3);  // 实例化</div></pre></td></tr></table></figure><p>也可以在声明的同时进行初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Dog myDog = new Dog(&quot;花花&quot;, 3);</div></pre></td></tr></table></figure><h2 id="1-3-访问成员变量和方法"><a href="#1-3-访问成员变量和方法" class="headerlink" title="1.3 访问成员变量和方法"></a>1.3 访问成员变量和方法</h2><p>通过已创建的对象来访问成员变量和成员方法，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//实例化</div><div class="line">Dog myDog = new Dog(&quot;花花&quot;, 3);</div><div class="line">// 通过点号访问成员变量</div><div class="line">myDog.name;</div><div class="line">// 通过点号访问成员方法</div><div class="line">myDog.bark();</div></pre></td></tr></table></figure><p>下面的例子演示了如何访问成员变量和方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</div><div class="line">    String name;</div><div class="line">    <span class="keyword">int</span> age;</div><div class="line">   </div><div class="line">    Dog(String name1, <span class="keyword">int</span> age1)&#123;</div><div class="line">        name = name1;</div><div class="line">        age = age1;</div><div class="line">        System.out.println(<span class="string">"感谢主人领养了我"</span>);</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"汪汪，不要过来"</span>);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hungry</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"主人，我饿了"</span>);</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String arg[])</span></span>&#123;</div><div class="line">        Dog myDog = <span class="keyword">new</span> Dog(<span class="string">"花花"</span>, <span class="number">3</span>);</div><div class="line">        <span class="comment">// 访问成员变量</span></div><div class="line">        String name = myDog.name;</div><div class="line">        <span class="keyword">int</span> age = myDog.age;</div><div class="line">        System.out.println(<span class="string">"我是一只小狗，我名字叫"</span> + name + <span class="string">"，我"</span> + age + <span class="string">"岁了"</span>);</div><div class="line">        <span class="comment">// 访问方法</span></div><div class="line">        myDog.bark();</div><div class="line">        myDog.hungry();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">感谢主人领养了我</div><div class="line">我是一只小狗，我名字叫花花，我3岁了</div><div class="line">汪汪，不要过来</div><div class="line">主人，我饿了</div></pre></td></tr></table></figure><h1 id="二、Java访问修饰符"><a href="#二、Java访问修饰符" class="headerlink" title="二、Java访问修饰符"></a>二、Java访问修饰符</h1><p>Java 通过修饰符来控制类、属性和方法的访问权限和其他功能，通常放在语句的最前端。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class className &#123;</div><div class="line">    // body of class</div><div class="line">&#125;</div><div class="line">private boolean myFlag;</div><div class="line">static final double weeks = 9.5;</div><div class="line">protected static final int BOXWIDTH = 42;</div><div class="line">public static void main(String[] arguments) &#123;</div><div class="line">    // body of method</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Java 的修饰符很多，分为访问修饰符和非访问修饰符。本节仅介绍访问修饰符，非访问修饰符会在后续介绍。</p><p>访问修饰符也叫访问控制符，是指能够控制类、成员变量、方法的使用权限的关键字。</p><p>在面向对象编程中，访问控制符是一个很重要的概念，可以使用它来保护对类、变量、方法和构造方法的访问。</p><p>Java支持四种不同的访问权限：</p><div class="table-container"><table><thead><tr><th>修饰符</th><th>说明</th></tr></thead><tbody><tr><td>public</td><td>公有的，对所有类可见</td></tr><tr><td>protected</td><td>受保护的，对同一包内的类和所有子类可见</td></tr><tr><td>private</td><td>私有的，在同一类内可见</td></tr><tr><td>默认的</td><td>在同一包内可见。默认不使用任何修饰符</td></tr></tbody></table></div><h2 id="2-1-public：公有的"><a href="#2-1-public：公有的" class="headerlink" title="2.1 public：公有的"></a>2.1 public：公有的</h2><p>被声明为public的类、方法、构造方法和接口能够被任何其他类访问。</p><p>如果几个相互访问的public类分布在不同的包中，则需要导入相应public类所在的包。由于类的继承性，类所有的公有方法和变量都能被其子类继承。</p><p>下面的方法使用了公有访问控制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arguments)</span> </span>&#123;</div><div class="line">    <span class="comment">// body of method</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Java程序的main() 方法必须设置成公有的，否则，Java解释器将不能运行该类。</p><h2 id="2-2-protected：受保护的"><a href="#2-2-protected：受保护的" class="headerlink" title="2.2 protected：受保护的"></a>2.2 protected：受保护的</h2><p>被声明为protected的变量、方法和构造方法不能被同一个包中的任何其他类访问，也不能够被不同包中的子类访问。</p><p>protected访问修饰符不能修饰类和接口，方法和成员变量能够声明为protected，但是接口的成员变量和成员方法不能声明为protected。</p><p>子类能访问protected修饰符声明的方法和变量，这样就能保护不相关的类使用这些方法和变量。</p><p>下面的父类使用了protected访问修饰符，子类重载了父类的bark()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"汪汪，不要过来"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teddy</span> <span class="keyword">extends</span> <span class="title">Dog</span></span>&#123;  <span class="comment">// 泰迪</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"汪汪，我好怕，不要跟着我"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果把bark()方法声明为private，那么除了Dog之外的类将不能访问该方法。如果把bark()声明为public，那么所有的类都能够访问该方法。如果我们只想让该方法对其所在类的子类可见，则将该方法声明为protected。</p><h2 id="2-3-private：私有的"><a href="#2-3-private：私有的" class="headerlink" title="2.3 private：私有的"></a>2.3 private：私有的</h2><p>私有访问修饰符是最严格的访问级别，所以被声明为private的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为private。</p><p>声明为私有访问类型的变量只能通过类中公共的Getter/Setter方法被外部类访问。</p><p>private访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据。</p><p>下面的类使用了私有访问修饰符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class Dog&#123;</div><div class="line">    private String name;</div><div class="line">    private int age;</div><div class="line">    public String getName() &#123;</div><div class="line">        return name;</div><div class="line">    &#125;</div><div class="line">    public void setName(String name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">    public int getAge() &#123;</div><div class="line">        return age;</div><div class="line">    &#125;</div><div class="line">    public void setAge(int age) &#123;</div><div class="line">        this.age = age;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>例子中，Dog类中的name、age变量为私有变量，所以其他类不能直接得到和设置该变量的值。为了使其他类能够操作该变量，定义了两对public方法，getName()/setName() 和 getAge()/setAge()，它们用来获取和设置私有变量的值。</p><p>this 是Java中的一个关键字，接下来会讲到。</p><p>在类中定义访问私有变量的方法，习惯上是这样命名的：在变量名称前面加“get”或“set”，并将变量的首字母大写。例如，获取私有变量 name 的方法为 getName()，设置 name 的方法为 setName()。这些方法经常使用，也有了特定的称呼，称为 Getter 和 Setter 方法。</p><h2 id="2-4-默认的：不使用任何关键字"><a href="#2-4-默认的：不使用任何关键字" class="headerlink" title="2.4 默认的：不使用任何关键字"></a>2.4 默认的：不使用任何关键字</h2><p>不使用任何修饰符声明的属性和方法，对同一个包内的类是可见的。接口里的变量都隐式声明为public static final，而接口里的方法默认情况下访问权限为public。</p><p>如下例所示，类、变量和方法的定义没有使用任何修饰符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Dog&#123;</div><div class="line">    String name;</div><div class="line">    int age;</div><div class="line">  </div><div class="line">    void bark()&#123;  // 汪汪叫</div><div class="line">        System.out.println(&quot;汪汪，不要过来&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void hungry()&#123;  // 饥饿</div><div class="line">        System.out.println(&quot;主人，我饿了&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="2-5-访问控制和继承"><a href="#2-5-访问控制和继承" class="headerlink" title="2.5 访问控制和继承"></a>2.5 访问控制和继承</h2><p>请注意以下方法继承的规则：</p><ul><li>父类中声明为public的方法在子类中也必须为public。</li><li>父类中声明为protected的方法在子类中要么声明为protected，要么声明为public。不能声明为private。</li><li>父类中默认修饰符声明的方法，能够在子类中声明为private。</li><li>父类中声明为private的方法，不能够被继承。</li></ul><h2 id="2-6-如何使用访问控制符"><a href="#2-6-如何使用访问控制符" class="headerlink" title="2.6 如何使用访问控制符"></a>2.6 如何使用访问控制符</h2><p>访问控制符可以让我们很方便的控制代码的权限：</p><ul><li>当需要让自己编写的类被所有的其他类访问时，就可以将类的访问控制符声明为 public。</li><li>当需要让自己的类只能被自己的包中的类访问时，就可以省略访问控制符。</li><li>当需要控制一个类中的成员数据时，可以将这个类中的成员数据访问控制符设置为 public、protected，或者省略。</li></ul><h1 id="三、Java变量的作用域"><a href="#三、Java变量的作用域" class="headerlink" title="三、Java变量的作用域"></a>三、Java变量的作用域</h1><p>在Java中，变量的作用域分为四个级别：类级、对象实例级、方法级、块级。</p><ul><li>类级变量：又称全局级变量或静态变量，需要使用static关键字修饰，你可以与 C/C++ 中的 static 变量对比学习。类级变量在类定义后就已经存在，占用内存空间，可以通过类名来访问，不需要实例化。</li><li>对象实例级变量：就是成员变量，实例化后才会分配内存空间，才能访问。</li><li>方法级变量：就是在方法内部定义的变量，就是局部变量。</li><li>块级变量：就是定义在一个块内部的变量，变量的生存周期就是这个块，出了这个块就消失了，比如 if、for 语句的块。块是指由大括号包围的代码，例如：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">int age = 3;</div><div class="line">    String name = &quot;www.yq1012.com&quot;;</div><div class="line">    // 正确，在块内部可以访问 age 和 name 变量</div><div class="line">    System.out.println( name + &quot;已经&quot; + age + &quot;岁了&quot;);</div><div class="line">&#125;</div><div class="line">// 错误，在块外部无法访问 age 和 name 变量</div><div class="line">System.out.println( name + &quot;已经&quot; + age + &quot;岁了&quot;);</div></pre></td></tr></table></figure><p>说明：</p><ul><li>方法内部除了能访问方法级的变量，还可以访问类级和实例级的变量。</li><li>块内部能够访问类级、实例级变量，如果块被包含在方法内部，它还可以访问方法级的变量。</li><li>方法级和块级的变量必须被显示地初始化，否则不能访问。<br>演示代码：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">lic class Demo&#123;</div><div class="line">    public static String name = &quot;程序员&quot;;  // 类级变量</div><div class="line">    public int i; // 对象实例级变量</div><div class="line"></div><div class="line">    // 属性块，在类初始化属性时候运行</div><div class="line">    &#123;</div><div class="line">        int j = 2;// 块级变量</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void test1() &#123;</div><div class="line">        int j = 3;  // 方法级变量</div><div class="line">        if(j == 3) &#123;</div><div class="line">            int k = 5;  // 块级变量</div><div class="line">        &#125;</div><div class="line">        // 这里不能访问块级变量，块级变量只能在块内部访问</div><div class="line">        System.out.println(&quot;name=&quot; + name + &quot;, i=&quot; + i + &quot;, j=&quot; + j);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        // 不创建对象，直接通过类名访问类级变量</div><div class="line">        System.out.println(Demo.name);</div><div class="line">       </div><div class="line">        // 创建对象并访问它的方法</div><div class="line">        Demo t = new Demo();</div><div class="line">        t.test1();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">程序员</div><div class="line">name=程序员, i=0, j=3</div></pre></td></tr></table></figure><h1 id="四、this关键字"><a href="#四、this关键字" class="headerlink" title="四、this关键字"></a>四、this关键字</h1><p>this 关键字用来表示当前对象本身，或当前类的一个实例，通过 this 可以调用本对象的所有方法和属性。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x = <span class="number">10</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> y = <span class="number">15</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sum</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">// 通过 this 点取成员变量</span></div><div class="line">        <span class="keyword">int</span> z = <span class="keyword">this</span>.x + <span class="keyword">this</span>.y;</div><div class="line">        System.out.println(<span class="string">"x + y = "</span> + z);</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Demo obj = <span class="keyword">new</span> Demo();</div><div class="line">        obj.sum();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x + y = 25</div></pre></td></tr></table></figure><p>上面的程序中，obj 是 Demo 类的一个实例，this 与 obj 等价，执行 int z = this.x + this.y;，就相当于执行 int z = obj.x + obj.y;。</p><p>注意：this 只有在类实例化后才有意义。</p><h2 id="4-1-使用this区分同名变量"><a href="#4-1-使用this区分同名变量" class="headerlink" title="4.1 使用this区分同名变量"></a>4.1 使用this区分同名变量</h2><p>成员变量与方法内部的变量重名时，希望在方法内部调用成员变量，怎么办呢？这时候只能使用this，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</div><div class="line"><span class="keyword">public</span> String name;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</div><div class="line">    <span class="comment">//构造方法</span></div><div class="line">    Demo(String name, <span class="keyword">int</span> age)&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//普通方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"网站的名字是"</span> + name + <span class="string">"，已经成立了"</span> + age + <span class="string">"年"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//main方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Demo obj = <span class="keyword">new</span> Demo(<span class="string">"程序员"</span>, <span class="number">3</span>);</div><div class="line">        obj.say();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">网站的名字是程序员，已经成立了3年</div></pre></td></tr></table></figure><p>形参的作用域是整个方法体，是局部变量。在Demo()中，形参和成员变量重名，如果不使用this，访问到的就是局部变量name和age，而不是成员变量。在 say() 中，我们没有使用 this，因为成员变量的作用域是整个实例，当然也可以加上 this：</p><p>Java 默认将所有成员变量和成员方法与 this 关联在一起，因此使用 this 在某些情况下是多余的。</p><h2 id="4-2-作为方法名来初始化对象"><a href="#4-2-作为方法名来初始化对象" class="headerlink" title="4.2 作为方法名来初始化对象"></a>4.2 作为方法名来初始化对象</h2><p>也就是相当于调用本类的其它构造方法，它必须作为构造方法的第一句。示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class Demo&#123;</div><div class="line">    public String name;</div><div class="line">    public int age;</div><div class="line">   </div><div class="line">    public Demo()&#123;</div><div class="line">        this(&quot;程序员&quot;, 3);</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    public Demo(String name, int age)&#123;</div><div class="line">        this.name = name;</div><div class="line">        this.age = age;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    public void say()&#123;</div><div class="line">        System.out.println(&quot;网站的名字是&quot; + name + &quot;，已经成立了&quot; + age + &quot;年&quot;);</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Demo obj = new Demo();</div><div class="line">        obj.say();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">网站的名字是程序员，已经成立了3年</div></pre></td></tr></table></figure><p>值得注意的是：</p><ul><li>在构造方法中调用另一个构造方法，调用动作必须置于最起始的位置。</li><li>不能在构造方法以外的任何方法内调用构造方法。</li><li>在一个构造方法内只能调用一个构造方法。</li></ul><p>上述代码涉及到方法重载，即Java允许出现多个同名方法，只要参数不同就可以。后续章节会讲解。</p><h2 id="4-3-作为参数传递"><a href="#4-3-作为参数传递" class="headerlink" title="4.3 作为参数传递"></a>4.3 作为参数传递</h2><p>需要在某些完全分离的类中调用一个方法，并将当前对象的一个引用作为参数传递时。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class Demo&#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        B b = new B(new A());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class A&#123;</div><div class="line">    public A()&#123;</div><div class="line">        new B(this).print();  // 匿名对象</div><div class="line">    &#125;</div><div class="line">    public void print()&#123;</div><div class="line">        System.out.println(&quot;Hello from A!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class B&#123;</div><div class="line">    A a;</div><div class="line">    public B(A a)&#123;</div><div class="line">        this.a = a;</div><div class="line">    &#125;</div><div class="line">    public void print() &#123;</div><div class="line">        a.print();</div><div class="line">        System.out.println(&quot;Hello from B!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Hello from A!</div><div class="line">Hello from B!</div></pre></td></tr></table></figure><p>匿名对象就是没有名字的对象。如果对象只使用一次，就可以作为匿名对象，代码中 new B(this).print(); 等价于 ( new B(this) ).print();，先通过 new B(this) 创建一个没有名字的对象，再调用它的方法。</p><h1 id="五、方法重载"><a href="#五、方法重载" class="headerlink" title="五、方法重载"></a>五、方法重载</h1><p>在Java中，同一个类中的多个方法可以有相同的名字，只要它们的参数列表不同就可以，这被称为方法重载(method overloading)。参数列表又叫参数签名，包括参数的类型、参数的个数和参数的顺序，只要有一个不同就叫做参数列表不同。</p><p>重载是面向对象的一个基本特性。</p><p>下面看一个详细的实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class Demo&#123;</div><div class="line">    // 一个普通的方法，不带参数</div><div class="line">    void test()&#123;</div><div class="line">        System.out.println(&quot;No parameters&quot;);</div><div class="line">    &#125;</div><div class="line">    // 重载上面的方法，并且带了一个整型参数</div><div class="line">    void test(int a)&#123;</div><div class="line">        System.out.println(&quot;a: &quot; + a);</div><div class="line">    &#125;</div><div class="line">    // 重载上面的方法，并且带了两个参数</div><div class="line">    void test(int a,int b)&#123;</div><div class="line">        System.out.println(&quot;a and b: &quot; + a + &quot; &quot; + b);</div><div class="line">    &#125;</div><div class="line">    // 重载上面的方法，并且带了一个双精度参数</div><div class="line">    double test(double a)&#123;</div><div class="line">        System.out.println(&quot;double a: &quot; + a);</div><div class="line">        return a*a;</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    public static void main(String args[])&#123;</div><div class="line">        Demo obj= new Demo();</div><div class="line">        obj.test();</div><div class="line">        obj.test(2);</div><div class="line">        obj.test(2,3);</div><div class="line">        obj.test(2.0);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">No parameters</div><div class="line">a: 2</div><div class="line">a and b: 2 3</div><div class="line">double a: 2.0</div></pre></td></tr></table></figure><p>通过上面的实例，读者可以看出，重载就是在一个类中，有相同的函数名称，但形参不同的函数。重载的结果，可以让一个程序段尽量减少代码和方法的种类。<br>说明：</p><ul><li>参数列表不同包括：个数不同、类型不同和顺序不同。</li><li>仅仅参数变量名称不同是不可以的。</li><li>跟成员方法一样，构造方法也可以重载。</li><li>声明为final的方法不能被重载。</li><li>声明为static的方法不能被重载，但是能够被再次声明。</li></ul><p>方法的重载的规则：</p><ul><li>方法名称必须相同。</li><li>参数列表必须不同（个数不同、或类型不同、参数排列顺序不同等）。</li><li>方法的返回类型可以相同也可以不相同。</li><li>仅仅返回类型不同不足以成为方法的重载。</li></ul><p>方法重载的实现：</p><ul><li>方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法，如果匹配失败，则编译器报错，这叫做重载分辨。</li></ul><h1 id="六、基本运行顺序"><a href="#六、基本运行顺序" class="headerlink" title="六、基本运行顺序"></a>六、基本运行顺序</h1><p>我们以下面的类来说明一个基本的 Java 类的运行顺序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">()</span></span>&#123;</div><div class="line">        name = <span class="string">"java学习"</span>;</div><div class="line">        age = <span class="number">3</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        Demo obj = <span class="keyword">new</span> Demo();</div><div class="line">        System.out.println(obj.name + <span class="string">"的年龄是"</span> + obj.age);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>基本运行顺序是：</p><ul><li>先运行到第 9 行，这是程序的入口。</li><li>然后运行到第 10 行，这里要 new 一个Demo，就要调用 Demo 的构造方法。</li><li>就运行到第 5 行，注意：可能很多人觉得接下来就应该运行第 6 行了，错！初始化一个类，必须先初始化它的属性。</li><li>因此运行到第 2 行，然后是第 3 行。</li><li>属性初始化完过后，才回到构造方法，执行里面的代码，也就是第 6 行、第 7 行。</li><li>然后是第8行，表示 new 一个Demo实例完成。</li><li>然后回到 main 方法中执行第 11 行。</li><li>然后是第 12 行，main方法执行完毕。</li></ul><p>作为程序员，应该清楚程序的基本运行过程，否则糊里糊涂的，不利于编写代码，也不利于技术上的发展。</p><h1 id="七、包装类、拆箱和装箱"><a href="#七、包装类、拆箱和装箱" class="headerlink" title="七、包装类、拆箱和装箱"></a>七、包装类、拆箱和装箱</h1><p>虽然 Java 语言是典型的面向对象编程语言，但其中的八种基本数据类型并不支持面向对象编程，基本类型的数据不具备“对象”的特性——不携带属性、没有方法可调用。 沿用它们只是为了迎合人类根深蒂固的习惯，并的确能简单、有效地进行常规数据处理。这种借助于非面向对象技术的做法有时也会带来不便，比如引用类型数据均继承了 Object 类的特性，要转换为 String 类型（经常有这种需要）时只要简单调用 Object 类中定义的toString()即可，而基本数据类型转换为 String 类型则要麻烦得多。为解决此类问题 ，Java为每种基本数据类型分别设计了对应的类，称之为包装类(Wrapper Classes)，也有教材称为外覆类或数据类型类。</p><div class="table-container"><table><thead><tr><th>基本数据类型</th><th>对应的包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table></div><p>每个包装类的对象可以封装一个相应的基本类型的数据，并提供了其它一些有用的方法。包装类对象一经创建，其内容（所封装的基本类型数据值）不可改变。</p><p>基本类型和对应的包装类可以相互装换：</p><ul><li>由基本类型向对应的包装类转换称为装箱，例如把 int 包装成 Integer 类的对象；</li><li>包装类向对应的基本类型转换称为拆箱，例如把 Integer 类的对象重新简化为 int。</li></ul><h2 id="7-1-包装类的应用"><a href="#7-1-包装类的应用" class="headerlink" title="7.1 包装类的应用"></a>7.1 包装类的应用</h2><p>八个包装类的使用比较相似，下面是常见的应用场景。</p><ul><li>1）实现 int 和 Integer 的相互转换</li></ul><p>可以通过 Integer 类的构造方法将 int 装箱，通过 Integer 类的 intValue 方法将 Integer 拆箱。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Demo &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        int m = 500;</div><div class="line">        Integer obj = new Integer(m);  // 手动装箱</div><div class="line">        int n = obj.intValue();  // 手动拆箱</div><div class="line">        System.out.println(&quot;n = &quot; + n);</div><div class="line">       </div><div class="line">        Integer obj1 = new Integer(500);</div><div class="line">        System.out.println(&quot;obj 等价于 obj1？&quot; + obj.equals(obj1));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">n = 500</div><div class="line">obj 等价于 obj1？true</div></pre></td></tr></table></figure><ul><li>2）将字符串转换为整数</li></ul><p>Integer 类有一个静态的 paseInt() 方法，可以将字符串转换为整数，语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">parseInt(String s, int radix);</div></pre></td></tr></table></figure><p>s 为要转换的字符串，radix 为进制，可选，默认为十进制。</p><p>下面的代码将会告诉你什么样的字符串可以转换为整数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Demo &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        String str[] = &#123;&quot;123&quot;, &quot;123abc&quot;, &quot;abc123&quot;, &quot;abcxyz&quot;&#125;;</div><div class="line">       </div><div class="line">        for(String str1 : str)&#123;</div><div class="line">            try&#123;</div><div class="line">                int m = Integer.parseInt(str1, 10);</div><div class="line">                System.out.println(str1 + &quot; 可以转换为整数 &quot; + m);</div><div class="line">            &#125;catch(Exception e)&#123;</div><div class="line">                System.out.println(str1 + &quot; 无法转换为整数&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">123 可以转换为整数 123</div><div class="line">123abc 无法转换为整数</div><div class="line">abc123 无法转换为整数</div><div class="line">abcxyz 无法转换为整数</div></pre></td></tr></table></figure><ul><li>3）将整数转换为字符串</li></ul><p>Integer 类有一个静态的 toString() 方法，可以将整数转换为字符串。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Demo &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        int m = 500;</div><div class="line">        String s = Integer.toString(m);</div><div class="line">        System.out.println(&quot;s = &quot; + s);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s = 500</div></pre></td></tr></table></figure><h2 id="7-2-自动拆箱和装箱"><a href="#7-2-自动拆箱和装箱" class="headerlink" title="7.2 自动拆箱和装箱"></a>7.2 自动拆箱和装箱</h2><p>上面的例子都需要手动实例化一个包装类，称为手动拆箱装箱。Java 1.5(5.0) 之前必须手动拆箱装箱。</p><p>Java 1.5 之后可以自动拆箱装箱，也就是在进行基本数据类型和对应的包装类转换时，系统将自动进行，这将大大方便程序员的代码书写。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> m = <span class="number">500</span>;</div><div class="line">        Integer obj = m;  <span class="comment">// 自动装箱</span></div><div class="line">        <span class="keyword">int</span> n = obj;  <span class="comment">// 自动拆箱</span></div><div class="line">        System.out.println(<span class="string">"n = "</span> + n);</div><div class="line">      </div><div class="line">        Integer obj1 = <span class="number">500</span>;</div><div class="line">        System.out.println(<span class="string">"obj 等价于 obj1？"</span> + obj.equals(obj1));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">n = 500</div><div class="line">obj 等价于 obj1？true</div></pre></td></tr></table></figure><p>自动拆箱装箱是常用的一个功能，需要重点掌握。</p><h1 id="八、源文件的声明规则"><a href="#八、源文件的声明规则" class="headerlink" title="八、源文件的声明规则"></a>八、源文件的声明规则</h1><p>当在一个源文件中定义多个类，并且还有import语句和package语句时，要特别注意这些规则：</p><ul><li>一个源文件中只能有一个public类。</li><li>一个源文件可以有多个非public类。</li><li>源文件的名称应该和public类的类名保持一致。例如：源文件中public类的类名是Employee，那么源文件应该命名为Employee.java。</li><li>如果一个类定义在某个包中，那么package语句应该在源文件的首行。</li><li>如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面。</li><li>import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。</li><li>类有若干种访问级别，并且类也分不同的类型：抽象类和final类等。这些将在后续章节介绍。</li><li>除了上面提到的几种类型，Java还有一些特殊的类，如内部类、匿名类。</li></ul><h2 id="8-1-一个简单的例子"><a href="#8-1-一个简单的例子" class="headerlink" title="8.1 一个简单的例子"></a>8.1 一个简单的例子</h2><p>在该例子中，我们创建两个类 Employee 和 EmployeeTest，分别放在包 p1 和 p2 中。</p><p>Employee类有四个成员变量，分别是 name、age、designation和salary。该类显式声明了一个构造方法，该方法只有一个参数。</p><p>在Eclipse中，创建一个包，命名为 p1，在该包中创建一个类，命名为 Employee，将下面的代码复制到源文件中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> p1;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</div><div class="line">    String name;</div><div class="line">    <span class="keyword">int</span> age;</div><div class="line">    String designation;</div><div class="line">    <span class="keyword">double</span> salary;</div><div class="line">    <span class="comment">// Employee 类的构造方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 设置age的值</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">empAge</span><span class="params">(<span class="keyword">int</span> empAge)</span></span>&#123;</div><div class="line">        age =  empAge;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 设置designation的值</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">empDesignation</span><span class="params">(String empDesig)</span></span>&#123;</div><div class="line">        designation = empDesig;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 设置salary的值</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">empSalary</span><span class="params">(<span class="keyword">double</span> empSalary)</span></span>&#123;</div><div class="line">        salary = empSalary;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 输出信息</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printEmployee</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"Name:"</span>+ name );</div><div class="line">        System.out.println(<span class="string">"Age:"</span> + age );</div><div class="line">        System.out.println(<span class="string">"Designation:"</span> + designation );</div><div class="line">        System.out.println(<span class="string">"Salary:"</span> + salary);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>程序都是从main方法开始执行。为了能运行这个程序，必须包含main方法并且创建一个对象。</p><p>下面给出EmployeeTest类，该类创建两个Employee对象，并调用方法设置变量的值。</p><p>在Eclipse中再创建一个包，命名为 p2，在该包中创建一个类，命名为 EmployeeTest，将下面的代码复制到源文件中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> p2;</div><div class="line"><span class="keyword">import</span> p1.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeTest</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">        <span class="comment">// 创建两个对象</span></div><div class="line">        Employee empOne = <span class="keyword">new</span> Employee(<span class="string">"James Smith"</span>);</div><div class="line">        Employee empTwo = <span class="keyword">new</span> Employee(<span class="string">"Mary Anne"</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 调用这两个对象的成员方法</span></div><div class="line">        empOne.empAge(<span class="number">26</span>);</div><div class="line">        empOne.empDesignation(<span class="string">"Senior Software Engineer"</span>);</div><div class="line">        empOne.empSalary(<span class="number">1000</span>);</div><div class="line">        empOne.printEmployee();</div><div class="line"></div><div class="line">        empTwo.empAge(<span class="number">21</span>);</div><div class="line">        empTwo.empDesignation(<span class="string">"Software Engineer"</span>);</div><div class="line">        empTwo.empSalary(<span class="number">500</span>);</div><div class="line">        empTwo.printEmployee();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>编译并运行 EmployeeTest 类，可以看到如下的输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Name:James Smith</div><div class="line">Age:26</div><div class="line">Designation:Senior Software Engineer</div><div class="line">Salary:1000.0</div><div class="line">Name:Mary Anne</div><div class="line">Age:21</div><div class="line">Designation:Software Engineer</div><div class="line">Salary:500.0</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、类的定义及其实例化&quot;&gt;&lt;a href=&quot;#一、类的定义及其实例化&quot; class=&quot;headerlink&quot; title=&quot;一、类的定义及其实例化&quot;&gt;&lt;/a&gt;一、类的定义及其实例化&lt;/h1&gt;&lt;p&gt;类必须先定义才能使用。类是创建对象的模板，创建对象也叫类的实例化。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="类" scheme="http://yoursite.com/tags/%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记（1）：语法基础</title>
    <link href="http://yoursite.com/2017/08/20/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2017/08/20/Java学习笔记（1）：语法基础/</id>
    <published>2017-08-20T14:20:45.000Z</published>
    <updated>2017-09-01T06:45:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java是完全面向对象的语言。通过虚拟机的运行机制，实现“跨平台”的理念。一次编译，永久使用。</p><a id="more"></a><p>先来看一个 HelloWorld.java 程序。这个程序在屏幕上打印出一串字符”Hello World!”:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span></div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line">    &#123;</div><div class="line">        System.out.println(<span class="string">"Hello World!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>程序中包括Java的一些基本特征：</p><ul><li>类(class)：上面程序定义了一个 类 HelloWorld，该类的名字与.java文件的名字相同。</li><li>方法(method)：类的内部定义了该类的一个 方法 main。</li><li>语句(statement)：真正的“打印”功能由一个语句实现，即: System.out.println(“Hello World!”);</li></ul><p>下面两点有关Java的书写方式：</p><ul><li>Java中的语句要以 ; 结尾 (与C/C++相同)。</li><li>用花括号 {} 来整合语句，形成程序块。通过程序块，我们可以知道程序的不同部分的范围，比如类从哪里开始，到哪里结束。</li></ul><h2 id="一、编译与运行"><a href="#一、编译与运行" class="headerlink" title="一、编译与运行"></a>一、编译与运行</h2><p>Java程序要经过编译器编译才能执行。在Linux或Mac下，可以下载安装 <a href="http://www.oracle.com/technetwork/java/javase/downloads" target="_blank" rel="noopener">Java JDK</a></p><p>使用 javac 来编译。在命令行中输入下面语句 编译 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$javac HelloWorld.java</div></pre></td></tr></table></figure><p>当前路径下，将有一个名为HelloWorld.class的文件生成。<br>使用 java 命令来 运行 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$java HelloWorld</div></pre></td></tr></table></figure><p>Java会搜寻该类中的main方法，并执行。</p><h2 id="二、变量"><a href="#二、变量" class="headerlink" title="二、变量"></a>二、变量</h2><p>计算机语言通常需要在内存中存放数据，比如C语言中的变量，Java也有类似的变量。Java和C语言都是静态类型的语言。在使用变量之前，要声明变量的类型。</p><p>变量(variable) 占据一定的内存空间。不同类型的变量占据不同的大小。Java中的变量类型如下：</p><div class="table-container"><table><thead><tr><th>变量类型</th><th>存储大小</th><th>例值</th><th>注释</th></tr></thead><tbody><tr><td>byte</td><td>1byte</td><td>3</td><td>字节</td></tr><tr><td>int</td><td>4bytes</td><td>3</td><td>整数</td></tr><tr><td>short</td><td>2bytes</td><td>3</td><td>短整数</td></tr><tr><td>long</td><td>8bytes</td><td>3</td><td>长整数</td></tr><tr><td>float</td><td>4bytes</td><td>1.2</td><td>单精度浮点数</td></tr><tr><td>double</td><td>8bytes</td><td>1.2</td><td>双精度浮点数</td></tr><tr><td>char</td><td>2bytes</td><td>‘a’</td><td>字符</td></tr><tr><td>boolean</td><td>1bit</td><td>true</td><td>布尔值</td></tr></tbody></table></div><p>在Java中，变量需要先 声明(declare)才能使用。在声明中，我说明变量的类型，赋予变量以特别名字，以便在后面的程序中调用它。你可以在程序中的任意位置声明变量。 比如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line">    &#123;</div><div class="line">        System.out.println(<span class="string">"Declare in the middle:"</span>);</div><div class="line">        <span class="keyword">int</span> a;</div><div class="line">        a = <span class="number">5</span>;</div><div class="line">        System.out.println(a);  <span class="comment">// print an integer</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面a是变量名。可以在声明变量的同时，给变量赋值，比如 int a = 5;</p><ul><li>“变量”的概念实际上来自于面向过程的编程语言。在Java中，所谓的变量实际上是 “基本类型” (premitive type) 。我们将在类的讲解中更多深入。</li></ul><p>上面的程序还可以看到，Java中，可用 // 引领注释。</p><h2 id="二、数组"><a href="#二、数组" class="headerlink" title="二、数组"></a>二、数组</h2><p>Java中有 数组(array) 。数组包含相同类型的多个数据。我用下面方法来声明一个整数数组:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int[] a;</div></pre></td></tr></table></figure><p>在声明数组时，数组所需的空间并没有真正分配给数组。我可以在声明的同时，用new来创建数组所需空间:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int[] a = new int[100];</div></pre></td></tr></table></figure><p>这里创建了可以容纳100个整数的数组。相应的内存分配也完成了。</p><p>我还可以在声明的同时，给数组赋值。数组的大小也同时确定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int[] a = new int[] &#123;1, 3, 5, 7, 9&#125;;</div></pre></td></tr></table></figure><h3 id="2-1-数组初始化"><a href="#2-1-数组初始化" class="headerlink" title="2.1 数组初始化"></a>2.1 数组初始化</h3><p>你可以在声明数组的同时进行初始化（静态初始化），也可以在声明以后进行初始化（动态初始化）。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 静态初始化</div><div class="line">// 静态初始化的同时就为数组元素分配空间并赋值</div><div class="line">int intArray[] = &#123;1,2,3,4&#125;;</div><div class="line">String stringArray[] = &#123;&quot;程序员&quot;, &quot;http://www.baidu.com&quot;, &quot;一切编程语言都是纸老虎&quot;&#125;;</div><div class="line"></div><div class="line">// 动态初始化</div><div class="line">float floatArray[] = new float[3];</div><div class="line">floatArray[0] = 1.0f;</div><div class="line">floatArray[1] = 132.63f;</div><div class="line">floatArray[2] = 100F;</div></pre></td></tr></table></figure><h3 id="2-2-数组引用"><a href="#2-2-数组引用" class="headerlink" title="2.2 数组引用"></a>2.2 数组引用</h3><p>可以通过下标来引用数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arrayName[index];</div></pre></td></tr></table></figure><p>index从0开始。与C、C++不同，Java对数组元素要进行越界检查以保证安全性。</p><p>每个数组都有一个length属性来指明它的长度，例如 intArray.length 指明数组 intArray 的长度。</p><p>其他类型的数组与整数数组相似。</p><h3 id="2-3-数组的遍历"><a href="#2-3-数组的遍历" class="headerlink" title="2.3 数组的遍历"></a>2.3 数组的遍历</h3><p>实际开发中，经常需要遍历数组以获取数组中的每一个元素。最容易想到的方法是for循环，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int arrayDemo[] = &#123;1, 2, 4, 7, 9, 192, 100&#125;;</div><div class="line">for(int i=0,len=arrayDemo.length; i&lt;len; i++)&#123;</div><div class="line">    System.out.println(arrayDemo[i] + &quot;, &quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>不过，Java提供了”增强版“的for循环，专门用来遍历数组，语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for( arrayType varName: arrayName )&#123;</div><div class="line">    // Some Code</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>arrayType 为数组类型（也是数组元素的类型）；varName 是用来保存当前元素的变量，每次循环它的值都会改变；arrayName 为数组名称。</p><p>每循环一次，就会获取数组中下一个元素的值，保存到 varName 变量，直到数组结束。即，第一次循环 varName 的值为第0个元素，第二次循环为第1个元素……例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int arrayDemo[] = &#123;1, 2, 4, 7, 9, 192, 100&#125;;</div><div class="line">for(int x: arrayDemo)&#123;</div><div class="line">    System.out.println(x + &quot;, &quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这种增强版的for循环也被称为”foreach循环“，它是普通for循环语句的特殊简化版。所有的foreach循环都可以被改写成for循环。</p><p>但是，如果你希望使用数组的索引，那么增强版的 for 循环无法做到。</p><h3 id="2-4-二维数组"><a href="#2-4-二维数组" class="headerlink" title="2.4 二维数组"></a>2.4 二维数组</h3><p>二维数组的声明、初始化和引用与一维数组相似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int intArray[ ][ ] = &#123; &#123;1,2&#125;, &#123;2,3&#125;, &#123;4,5&#125; &#125;;</div><div class="line">int a[ ][ ] = new int[2][3];</div><div class="line">a[0][0] = 12;</div><div class="line">a[0][1] = 34;</div><div class="line">// ......</div><div class="line">a[1][2] = 93;</div></pre></td></tr></table></figure><p>Java语言中，由于把二维数组看作是数组的数组，数组空间不是连续分配的，所以不要求二维数组每一维的大小相同。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int intArray[ ][ ] = &#123; &#123;1,2&#125;, &#123;2,3&#125;, &#123;3,4,5&#125; &#125;;</div><div class="line">int a[ ][ ] = new int[2][ ];</div><div class="line">a[0] = new int[3];</div><div class="line">a[1] = new int[5];</div></pre></td></tr></table></figure><p>【示例】通过二维数组计算两个矩阵的乘积。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="comment">// 第一个矩阵（动态初始化一个二维数组）</span></div><div class="line">        <span class="keyword">int</span> a[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">3</span>];</div><div class="line">        <span class="comment">// 第二个矩阵（静态初始化一个二维数组）</span></div><div class="line">        <span class="keyword">int</span> b[][] = &#123; &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>&#125;, &#123;<span class="number">5</span>,<span class="number">9</span>,<span class="number">10</span>,-<span class="number">3</span>&#125;, &#123;<span class="number">2</span>,<span class="number">7</span>,-<span class="number">5</span>,-<span class="number">18</span>&#125; &#125;;</div><div class="line">        <span class="comment">// 结果矩阵</span></div><div class="line">        <span class="keyword">int</span> c[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">4</span>];</div><div class="line">       </div><div class="line">        <span class="comment">// 初始化第一个矩阵</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span> ;j++)</div><div class="line">                a[i][j] = (i+<span class="number">1</span>) * (j+<span class="number">2</span>);</div><div class="line">       </div><div class="line">        <span class="comment">// 计算矩阵乘积</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++)&#123;</div><div class="line">                c[i][j]=<span class="number">0</span>;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">3</span>; k++)</div><div class="line">                    c[i][j] += a[i][k] * b[k][j];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 输出结算结果</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++)</div><div class="line">                System.out.printf(<span class="string">"%-5d"</span>, c[i][j]);</div><div class="line">            System.out.println();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">运行结果：</div><div class="line">25   65   14   -65</div><div class="line">50   130  28   -130</div></pre></td></tr></table></figure><blockquote><p>几点说明</p></blockquote><ul><li>上面讲的是静态数组。静态数组一旦被声明，它的容量就固定了，不容改变。所以在声明数组时，一定要考虑数组的最大容量，防止容量不够的现象。</li><li>如果想在运行程序时改变容量，就需要用到数组列表(ArrayList，也称动态数组)或向量(Vector)。</li><li>正是由于静态数组容量固定的缺点，实际开发中使用频率不高，被 ArrayList 或 Vector 代替，因为实际开发中经常需要向数组中添加或删除元素，而它的容量不好预估。</li></ul><h2 id="三、表达式"><a href="#三、表达式" class="headerlink" title="三、表达式"></a>三、表达式</h2><p>表达式 是变量、常量和运算符的组合，它表示一个数据。 1 + 1 是常见的表达式。再比如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line">    &#123;</div><div class="line">        System.out.println(<span class="string">"Declare in the middle:"</span>);</div><div class="line">        <span class="keyword">int</span> a;</div><div class="line">        a = <span class="number">5</span> + <span class="number">1</span>;</div><div class="line">        System.out.println(a);  <span class="comment">// print an integer</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面的5 + 1也是一个表达式，等于6。</p><h3 id="3-1-数学表达式"><a href="#3-1-数学表达式" class="headerlink" title="3.1 数学表达式"></a>3.1 数学表达式</h3><p>数学运算，结果为一个数值</p><div class="table-container"><table><thead><tr><th>1 + 2</th><th>加法</th></tr></thead><tbody><tr><td>4 - 3.4</td><td>减法</td></tr><tr><td>7 * 1.5</td><td>乘法</td></tr><tr><td>3.5 / 7</td><td>除法</td></tr><tr><td>7 % 2</td><td>求余数</td></tr></tbody></table></div><h3 id="3-2-关系表达式"><a href="#3-2-关系表达式" class="headerlink" title="3.2 关系表达式"></a>3.2 关系表达式</h3><p>判断表达式是否成立。即一个boolean值，真假</p><div class="table-container"><table><thead><tr><th>a &gt; 4.2</th><th>大于</th></tr></thead><tbody><tr><td>3.4 &gt;= b</td><td>大于等于</td></tr><tr><td>1.5 &lt; 9</td><td>小于</td></tr><tr><td>6 &lt;= 1</td><td>小于等于</td></tr><tr><td>2 == 2</td><td>等于</td></tr><tr><td>2 != 2</td><td>不等于</td></tr></tbody></table></div><h3 id="3-3-布林表达式"><a href="#3-3-布林表达式" class="headerlink" title="3.3 布林表达式"></a>3.3 布林表达式</h3><p>两个boolean值的与、或、非的逻辑关系</p><div class="table-container"><table><thead><tr><th>true &amp;&amp; false</th><th>and</th></tr></thead><tbody><tr><td>(3 &gt; 1)</td><td></td><td>(2 == 1)</td><td>or</td></tr><tr><td>! true</td><td>not</td></tr></tbody></table></div><h3 id="3-4-位运算"><a href="#3-4-位运算" class="headerlink" title="3.4 位运算"></a>3.4 位运算</h3><p>对整数的二进制形式逐位进行逻辑运算，得到一个整数</p><div class="table-container"><table><thead><tr><th>&amp;</th><th>and</th></tr></thead><tbody><tr><td></td><td></td><td>or</td></tr><tr><td>^</td><td>xor</td></tr><tr><td>~</td><td>not</td></tr><tr><td>5 &lt;&lt; 3</td><td>0b101 left shift 3 bits</td></tr><tr><td>6 &gt;&gt; 1</td><td>0b110 right shift 1 bit</td></tr></tbody></table></div><p>还有下列在C中常见的运算符，我会在用到的时候进一步解释:</p><div class="table-container"><table><thead><tr><th>m ++</th><th>变量m加1</th></tr></thead><tbody><tr><td>n —</td><td>变量n减1</td></tr><tr><td>condition ? x1 : x2</td><td>condition为一个boolean值。根据condition，取x1或x2的值</td></tr></tbody></table></div><h2 id="四、控制结构"><a href="#四、控制结构" class="headerlink" title="四、控制结构"></a>四、控制结构</h2><p>Java中控制结构(control flow)的语法与C类似。它们都使用{}来表达隶属关系。</p><h3 id="4-1-选择（if）"><a href="#4-1-选择（if）" class="headerlink" title="4.1 选择（if）"></a>4.1 选择（if）</h3><p>condition是一个表示真假值的表达式。statements;是语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (conditon1) &#123;</div><div class="line">  statements;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (condition2) &#123;</div><div class="line">  statements;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">  statements;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="4-2-循环（while）"><a href="#4-2-循环（while）" class="headerlink" title="4.2 循环（while）"></a>4.2 循环（while）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">while (condition) &#123;</div><div class="line"></div><div class="line">statements;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="4-2-循环（do…while）"><a href="#4-2-循环（do…while）" class="headerlink" title="4.2 循环（do…while）"></a>4.2 循环（do…while）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">statements;</div><div class="line">&#125;<span class="keyword">while</span>(condition);  <span class="comment">// 注意结尾的;</span></div></pre></td></tr></table></figure><h3 id="4-3-循环（for）"><a href="#4-3-循环（for）" class="headerlink" title="4.3 循环（for）"></a>4.3 循环（for）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (initial; condition; update) &#123;</div><div class="line">statements;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="4-4-跳出或跳出循环"><a href="#4-4-跳出或跳出循环" class="headerlink" title="4.4 跳出或跳出循环"></a>4.4 跳出或跳出循环</h3><p>在循环中，可以使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">break</span>; <span class="comment">// 跳出循环</span></div><div class="line"><span class="keyword">continue</span>; <span class="comment">// 直接进入下一循环</span></div></pre></td></tr></table></figure><h3 id="4-5-选择（switch）"><a href="#4-5-选择（switch）" class="headerlink" title="4.5 选择（switch）"></a>4.5 选择（switch）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span>(expression) &#123;</div><div class="line"><span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">    statements; </div><div class="line">    <span class="keyword">break</span>; </div><div class="line"><span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">    statements; </div><div class="line">    <span class="keyword">break</span>; </div><div class="line">...</div><div class="line"><span class="keyword">default</span>:</div><div class="line">    statements; </div><div class="line">    <span class="keyword">break</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="五、字符串"><a href="#五、字符串" class="headerlink" title="五、字符串"></a>五、字符串</h2><p>从表面上看，字符串就是双引号之间的数据，例如“java”等。在Java中，可以使用下面的方法定义字符串：<br>String stringName = “string content”;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String webName = &quot;java学习&quot;;</div></pre></td></tr></table></figure><p>字符串可以通过“+”连接，基本数据类型与字符串进行“+”操作一般也会自动转换为字符串，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        String stuName = <span class="string">"小明"</span>;</div><div class="line">        <span class="keyword">int</span> stuAge = <span class="number">17</span>;</div><div class="line">        <span class="keyword">float</span> stuScore = <span class="number">92.5f</span>;</div><div class="line">       </div><div class="line">        String info = stuName + <span class="string">"的年龄是 "</span> + stuAge + <span class="string">"，成绩是 "</span> + stuScore;</div><div class="line">        System.out.println(info);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>String字符串与数组有一个共同点，就是它们被初始化后，长度是不变的，并且内容也不变。如果要改变它的值，就会产生一个新的字符串，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String str = &quot;Hello &quot;;</div><div class="line">str += &quot;World!&quot;;</div></pre></td></tr></table></figure><p>这个赋值表达式看起来有点像简单的接龙，在str后面直接加上一个“World!”字符串，形成最后的字符串“Hello World!”。其运行原理是这样的：程序首先产生了str1字符串，并在内存中申请了一段空间。此时要追加新的字符串是不可能的，因为字符串被初始化后，长度是固定的。如果要改变它，只有放弃原来的空间，重新申请能够容纳“Hello World!”字符串的内存空间，然后将“Hello World!”字符串放到内存中。</p><p>实际上，String 是java.lang包下的一个类，按照标准的面向对象的语法，其格式应该为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String stringName = new String(&quot;string content&quot;);</div></pre></td></tr></table></figure><p>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String url = new String(&quot;http://www.baidu.com&quot;);</div></pre></td></tr></table></figure><p>但是由于String特别常用，所以Java提供了一种简化的语法。</p><p>使用简化语法的另外一个原因是，按照标准的面向对象的语法，在内存使用上存在比较大的浪费。例如String str = new String(“abc”);实际上创建了两个String对象，一个是”abc”对象，存储在常量空间中，一个是使用new关键字为对象str申请的空间。</p><h3 id="5-1-常用的String对象方法"><a href="#5-1-常用的String对象方法" class="headerlink" title="5.1 常用的String对象方法"></a>5.1 常用的String对象方法</h3><h4 id="5-1-2-length-方法"><a href="#5-1-2-length-方法" class="headerlink" title="5.1.2 length()方法"></a>5.1.2 length()方法</h4><p>length() 返回字符串的长度，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String str1 = &quot;微学苑&quot;;</div><div class="line">String str2 = &quot;weixueyuan&quot;;</div><div class="line">System.out.println(&quot;The lenght of str1 is &quot; + str1.length());</div><div class="line">System.out.println(&quot;The lenght of str2 is &quot; + str2.length());</div></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">The lenght of str1 is 3</div><div class="line">The lenght of str2 is 10</div></pre></td></tr></table></figure><h4 id="5-1-2-charAt-方法"><a href="#5-1-2-charAt-方法" class="headerlink" title="5.1.2 charAt()方法"></a>5.1.2 charAt()方法</h4><p>charAt() 方法的作用是按照索引值获得字符串中的指定字符。Java规定，字符串中第一个字符的索引值是0，第二个字符的索引值是1，依次类推。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String str = &quot;123456789&quot;;</div><div class="line">System.out.println(str.charAt(0) + &quot;    &quot; + str.charAt(5) + &quot;    &quot; + str.charAt(8))</div></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1    6    9</div></pre></td></tr></table></figure><h4 id="5-1-3-contain-方法"><a href="#5-1-3-contain-方法" class="headerlink" title="5.1.3 contain()方法"></a>5.1.3 contain()方法</h4><p>contains() 方法用来检测字符串是否包含某个子串，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String str = &quot;baidu&quot;;</div><div class="line">System.out.println(str.contains(&quot;bai&quot;));</div></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">true</div></pre></td></tr></table></figure><h4 id="5-1-4-replace-方法"><a href="#5-1-4-replace-方法" class="headerlink" title="5.1.4 replace()方法"></a>5.1.4 replace()方法</h4><p>字符串替换，用来替换字符串中所有指定的子串，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ring str1 = &quot;The url of baidu is www.google.com!&quot;;</div><div class="line">String str2 = str1.replace(&quot;baidu&quot;, &quot;google&quot;);</div><div class="line">System.out.println(str1);</div><div class="line">System.out.println(str2);</div></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">The url of baidu is www.google.com!</div><div class="line">The url of google is www.google.com!</div></pre></td></tr></table></figure><p>注意：replace() 方法不会改变原来的字符串，而是生成一个新的字符串。</p><h4 id="5-1-5-split-方法"><a href="#5-1-5-split-方法" class="headerlink" title="5.1.5 split()方法"></a>5.1.5 split()方法</h4><p>以指定字符串作为分隔符，对当前字符串进行分割，分割的结果是一个数组，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import java.util.*;</div><div class="line">public class Demo &#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        String str = &quot;wei_xue_yuan_is_good&quot;;</div><div class="line">        String strArr[] = str.split(&quot;_&quot;);</div><div class="line">        System.out.println(Arrays.toString(strArr));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[wei, xue, yuan, is, good]</div></pre></td></tr></table></figure><p>以上仅仅列举了几个常用的String对象的方法，更多方法和详细解释请参考API文档。</p><h3 id="5-2-StringBuffer与StringBuider"><a href="#5-2-StringBuffer与StringBuider" class="headerlink" title="5.2 StringBuffer与StringBuider"></a>5.2 StringBuffer与StringBuider</h3><p>String 的值是不可变的，每次对String的操作都会生成新的String对象，不仅效率低，而且耗费大量内存空间。</p><p>StringBuffer类和String类一样，也用来表示字符串，但是StringBuffer的内部实现方式和String不同，在进行字符串处理时，不生成新的对象，在内存使用上要优于String。</p><p>StringBuffer 默认分配16字节长度的缓冲区，当字符串超过该大小时，会自动增加缓冲区长度，而不是生成新的对象。</p><p>StringBuffer不像String，只能通过 new 来创建对象，不支持简写方式，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">StringBuffer str1 = new StringBuffer();  // 分配16个字节长度的缓冲区</div><div class="line">StringBuffer str2 = =new StringBuffer(512);  // 分配512个字节长度的缓冲区</div><div class="line">// 在缓冲区中存放了字符串，并在后面预留了16个字节长度的空缓冲区</div><div class="line">StringBuffer str3 = new StringBuffer(&quot;www.baidu.com&quot;);</div></pre></td></tr></table></figure><h4 id="5-2-1-StringBuffer类的主要方法"><a href="#5-2-1-StringBuffer类的主要方法" class="headerlink" title="5.2.1 StringBuffer类的主要方法"></a>5.2.1 StringBuffer类的主要方法</h4><p>StringBuffer类中的方法主要偏重于对于字符串的操作，例如追加、插入和删除等，这个也是StringBuffer类和String类的主要区别。实际开发中，如果需要对一个字符串进行频繁的修改，建议使用 StringBuffer。</p><ul><li>1) append() 方法</li></ul><p>append() 方法用于向当前字符串的末尾追加内容，类似于字符串的连接。调用该方法以后，StringBuffer对象的内容也发生改变，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">StringBuffer str = new StringBuffer(“biancheng100”);</div><div class="line">str.append(true);</div></pre></td></tr></table></figure><p>则对象str的值将变成”biancheng100true”。注意是str指向的内容变了，不是str的指向变了。</p><p>字符串的”+“操作实际上也是先创建一个StringBuffer对象，然后调用append()方法将字符串片段拼接起来，最后调用toString()方法转换为字符串。</p><p>这样看来，String的连接操作就比StringBuffer多出了一些附加操作，效率上必然会打折扣。</p><p>但是，对于长度较小的字符串，”+“操作更加直观，更具可读性，有些时候可以稍微牺牲一下效率。</p><ul><li>2) deleteCharAt()</li></ul><p>deleteCharAt() 方法用来删除指定位置的字符，并将剩余的字符形成新的字符串。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">StringBuffer str = new StringBuffer(&quot;abcdef&quot;);</div><div class="line">str. deleteCharAt(3);</div></pre></td></tr></table></figure><p>该代码将会删除索引值为3的字符，即”d“字符。</p><p>你也可以通过delete()方法一次性删除多个字符，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">StingBuffer str = new StringBuffer(&quot;abcdef&quot;);</div><div class="line">str.delete(1, 4);</div></pre></td></tr></table></figure><p>该代码会删除索引值为1~4之间的字符，包括索引值1，但不包括4。</p><ul><li>3) insert()方法</li></ul><p>insert() 用来在指定位置插入字符串，可以认为是append()的升级版。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">StringBuffer str = new StringBuffer(&quot;abcdef&quot;);</div><div class="line">str.insert(3, &quot;xyz&quot;);</div></pre></td></tr></table></figure><p>最后str所指向的字符串为 abcdxyzef。</p><ul><li>4) setCharAt() 方法</li></ul><p>setCharAt() 方法用来修改指定位置的字符。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">StringBuffer str = new StringBuffer(&quot;abcdef&quot;);</div><div class="line">str.setCharAt(3, &apos;z&apos;);</div></pre></td></tr></table></figure><p>该代码将把索引值为3的字符修改为 z，最后str所指向的字符串为 abczef。</p><p>以上仅仅是部分常用方法的简单说明，更多方法和解释请查阅API文档。</p><h4 id="5-2-2-String和StringBuffer的效率对比"><a href="#5-2-2-String和StringBuffer的效率对比" class="headerlink" title="5.2.2 String和StringBuffer的效率对比"></a>5.2.2 String和StringBuffer的效率对比</h4><p>为了更加明显地看出它们的执行效率，下面的代码，将26个英文字母加了10000次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        String fragment = <span class="string">"abcdefghijklmnopqrstuvwxyz"</span>;</div><div class="line">        <span class="keyword">int</span> times = <span class="number">10000</span>;</div><div class="line">       </div><div class="line">        <span class="comment">// 通过String对象</span></div><div class="line">        <span class="keyword">long</span> timeStart1 = System.currentTimeMillis();</div><div class="line">        String str1 = <span class="string">""</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;times; i++) &#123;</div><div class="line">            str1 += fragment;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> timeEnd1 = System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"String: "</span> + (timeEnd1 - timeStart1) + <span class="string">"ms"</span>);</div><div class="line">       </div><div class="line">        <span class="comment">// 通过StringBuffer</span></div><div class="line">        <span class="keyword">long</span> timeStart2 = System.currentTimeMillis();</div><div class="line">        StringBuffer str2 = <span class="keyword">new</span> StringBuffer();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;times; i++) &#123;</div><div class="line">            str2.append(fragment);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> timeEnd2 = System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"StringBuffer: "</span> + (timeEnd2 - timeStart2) + <span class="string">"ms"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String: 5287ms</div><div class="line">StringBuffer: 3ms</div></pre></td></tr></table></figure><p>结论很明显，StringBuffer的执行效率比String快上千倍，这个差异随着叠加次数的增加越来越明显，当叠加次数达到30000次的时候，运行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String: 35923ms</div><div class="line">StringBuffer: 8ms</div></pre></td></tr></table></figure><p>所以，强烈建议在涉及大量字符串操作时使用StringBuffer。</p><h4 id="5-2-3-StringBuilder类"><a href="#5-2-3-StringBuilder类" class="headerlink" title="5.2.3 StringBuilder类"></a>5.2.3 StringBuilder类</h4><p>StringBuilder类和StringBuffer类功能基本相似，方法也差不多，主要区别在于StringBuffer类的方法是多线程安全的，而StringBuilder不是线程安全的，相比而言，StringBuilder类会略微快一点。</p><p>StringBuffer、StringBuilder、String中都实现了CharSequence接口。CharSequence是一个定义字符串操作的接口，它只包括length()、charAt(int index)、subSequence(int start, int end) 这几个API。</p><p>StringBuffer、StringBuilder、String对CharSequence接口的实现过程不一样，如下图所示：<br><img src="http://omu7tit09.bkt.clouddn.com/15024502085934.png" alt=""></p><p>可见，String直接实现了CharSequence接口；StringBuilder 和 StringBuffer都是可变的字符序列，它们都继承于AbstractStringBuilder，实现了CharSequence接口。</p><p>总结一下：</p><ul><li>线程安全：<ul><li>StringBuffer：线程安全</li><li>StringBuilder：线程不安全</li></ul></li><li><p>速度：</p><ul><li>一般情况下，速度从快到慢为 StringBuilder &gt; StringBuffer &gt; String，当然这是相对的，不是绝对的。</li></ul></li><li><p>使用环境：</p><ul><li>操作少量的数据使用 String；</li><li>单线程操作大量数据使用 StringBuilder；</li><li>多线程操作大量数据使用 StringBuffer。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java是完全面向对象的语言。通过虚拟机的运行机制，实现“跨平台”的理念。一次编译，永久使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java集合学习手册（11）：Java HashMap源码全剖析</title>
    <link href="http://yoursite.com/2017/08/19/Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C%EF%BC%8811%EF%BC%89%EF%BC%9AJava%20HashMap%E6%BA%90%E7%A0%81%E5%85%A8%E5%89%96%E6%9E%90/"/>
    <id>http://yoursite.com/2017/08/19/Java集合学习手册（11）：Java HashMap源码全剖析/</id>
    <published>2017-08-19T14:20:45.000Z</published>
    <updated>2017-12-26T08:18:00.062Z</updated>
    
    <content type="html"><![CDATA[<p>HashMap简介 HashMap是基于哈希表实现的，每一个元素都是一个key-value对，其内部通过单链表解决冲突问题，容量不足（超过了阈值）时，同样会自动增长。</p><a id="more"></a><p>HashMap是非线程安全的，只是用于单线程环境下，多线程环境下可以采用concurrent并发包下的concurrentHashMap。</p><p>HashMap实现了Serializable接口，因此它支持序列化，实现了Cloneable接口，能被克隆。</p><h2 id="一、HashMap源码剖析"><a href="#一、HashMap源码剖析" class="headerlink" title="一、HashMap源码剖析"></a>一、HashMap源码剖析</h2><p>HashMap的源码如下（加入了比较详细的注释）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div><div class="line">437</div><div class="line">438</div><div class="line">439</div><div class="line">440</div><div class="line">441</div><div class="line">442</div><div class="line">443</div><div class="line">444</div><div class="line">445</div><div class="line">446</div><div class="line">447</div><div class="line">448</div><div class="line">449</div><div class="line">450</div><div class="line">451</div><div class="line">452</div><div class="line">453</div><div class="line">454</div><div class="line">455</div><div class="line">456</div><div class="line">457</div><div class="line">458</div><div class="line">459</div><div class="line">460</div><div class="line">461</div><div class="line">462</div><div class="line">463</div><div class="line">464</div><div class="line">465</div><div class="line">466</div><div class="line">467</div><div class="line">468</div><div class="line">469</div><div class="line">470</div><div class="line">471</div><div class="line">472</div><div class="line">473</div><div class="line">474</div><div class="line">475</div><div class="line">476</div><div class="line">477</div><div class="line">478</div><div class="line">479</div><div class="line">480</div><div class="line">481</div><div class="line">482</div><div class="line">483</div><div class="line">484</div><div class="line">485</div><div class="line">486</div><div class="line">487</div><div class="line">488</div><div class="line">489</div><div class="line">490</div><div class="line">491</div><div class="line">492</div><div class="line">493</div><div class="line">494</div><div class="line">495</div><div class="line">496</div><div class="line">497</div><div class="line">498</div><div class="line">499</div><div class="line">500</div><div class="line">501</div><div class="line">502</div><div class="line">503</div><div class="line">504</div><div class="line">505</div><div class="line">506</div><div class="line">507</div><div class="line">508</div><div class="line">509</div><div class="line">510</div><div class="line">511</div><div class="line">512</div><div class="line">513</div><div class="line">514</div><div class="line">515</div><div class="line">516</div><div class="line">517</div><div class="line">518</div><div class="line">519</div><div class="line">520</div><div class="line">521</div><div class="line">522</div><div class="line">523</div><div class="line">524</div><div class="line">525</div><div class="line">526</div><div class="line">527</div><div class="line">528</div><div class="line">529</div><div class="line">530</div><div class="line">531</div><div class="line">532</div><div class="line">533</div><div class="line">534</div><div class="line">535</div><div class="line">536</div><div class="line">537</div><div class="line">538</div><div class="line">539</div><div class="line">540</div><div class="line">541</div><div class="line">542</div><div class="line">543</div><div class="line">544</div><div class="line">545</div><div class="line">546</div><div class="line">547</div><div class="line">548</div><div class="line">549</div><div class="line">550</div><div class="line">551</div><div class="line">552</div><div class="line">553</div><div class="line">554</div><div class="line">555</div><div class="line">556</div><div class="line">557</div><div class="line">558</div><div class="line">559</div><div class="line">560</div><div class="line">561</div><div class="line">562</div><div class="line">563</div><div class="line">564</div><div class="line">565</div><div class="line">566</div><div class="line">567</div><div class="line">568</div><div class="line">569</div><div class="line">570</div><div class="line">571</div><div class="line">572</div><div class="line">573</div><div class="line">574</div><div class="line">575</div><div class="line">576</div><div class="line">577</div><div class="line">578</div><div class="line">579</div><div class="line">580</div><div class="line">581</div><div class="line">582</div><div class="line">583</div><div class="line">584</div><div class="line">585</div><div class="line">586</div><div class="line">587</div><div class="line">588</div><div class="line">589</div><div class="line">590</div><div class="line">591</div><div class="line">592</div><div class="line">593</div><div class="line">594</div><div class="line">595</div><div class="line">596</div><div class="line">597</div><div class="line">598</div><div class="line">599</div><div class="line">600</div><div class="line">601</div><div class="line">602</div><div class="line">603</div><div class="line">604</div><div class="line">605</div><div class="line">606</div><div class="line">607</div><div class="line">608</div><div class="line">609</div><div class="line">610</div><div class="line">611</div><div class="line">612</div><div class="line">613</div><div class="line">614</div><div class="line">615</div><div class="line">616</div><div class="line">617</div><div class="line">618</div><div class="line">619</div><div class="line">620</div><div class="line">621</div><div class="line">622</div><div class="line">623</div><div class="line">624</div><div class="line">625</div><div class="line">626</div><div class="line">627</div><div class="line">628</div><div class="line">629</div><div class="line">630</div><div class="line">631</div><div class="line">632</div><div class="line">633</div><div class="line">634</div><div class="line">635</div><div class="line">636</div><div class="line">637</div><div class="line">638</div><div class="line">639</div><div class="line">640</div><div class="line">641</div><div class="line">642</div><div class="line">643</div><div class="line">644</div><div class="line">645</div><div class="line">646</div><div class="line">647</div><div class="line">648</div><div class="line">649</div><div class="line">650</div><div class="line">651</div><div class="line">652</div><div class="line">653</div><div class="line">654</div><div class="line">655</div><div class="line">656</div><div class="line">657</div><div class="line">658</div><div class="line">659</div><div class="line">660</div><div class="line">661</div><div class="line">662</div><div class="line">663</div><div class="line">664</div><div class="line">665</div><div class="line">666</div><div class="line">667</div><div class="line">668</div><div class="line">669</div><div class="line">670</div><div class="line">671</div><div class="line">672</div><div class="line">673</div><div class="line">674</div><div class="line">675</div><div class="line">676</div><div class="line">677</div><div class="line">678</div><div class="line">679</div><div class="line">680</div><div class="line">681</div><div class="line">682</div><div class="line">683</div><div class="line">684</div><div class="line">685</div><div class="line">686</div><div class="line">687</div><div class="line">688</div><div class="line">689</div><div class="line">690</div><div class="line">691</div><div class="line">692</div><div class="line">693</div><div class="line">694</div><div class="line">695</div><div class="line">696</div><div class="line">697</div><div class="line">698</div><div class="line">699</div><div class="line">700</div><div class="line">701</div><div class="line">702</div><div class="line">703</div><div class="line">704</div><div class="line">705</div><div class="line">706</div><div class="line">707</div><div class="line">708</div><div class="line">709</div><div class="line">710</div><div class="line">711</div><div class="line">712</div><div class="line">713</div><div class="line">714</div><div class="line">715</div><div class="line">716</div><div class="line">717</div><div class="line">718</div><div class="line">719</div><div class="line">720</div><div class="line">721</div><div class="line">722</div><div class="line">723</div><div class="line">724</div><div class="line">725</div><div class="line">726</div><div class="line">727</div><div class="line">728</div><div class="line">729</div><div class="line">730</div><div class="line">731</div><div class="line">732</div><div class="line">733</div><div class="line">734</div><div class="line">735</div><div class="line">736</div><div class="line">737</div><div class="line">738</div><div class="line">739</div><div class="line">740</div><div class="line">741</div><div class="line">742</div><div class="line">743</div><div class="line">744</div><div class="line">745</div><div class="line">746</div><div class="line">747</div><div class="line">748</div><div class="line">749</div><div class="line">750</div><div class="line">751</div><div class="line">752</div><div class="line">753</div><div class="line">754</div></pre></td><td class="code"><pre><div class="line">package java.util;    </div><div class="line">import java.io.*;    </div><div class="line">   </div><div class="line">public class HashMap&lt;K,V&gt;    </div><div class="line">    extends AbstractMap&lt;K,V&gt;    </div><div class="line">    implements Map&lt;K,V&gt;, Cloneable, Serializable    </div><div class="line">&#123;    </div><div class="line">   </div><div class="line">    // 默认的初始容量（容量为HashMap中槽的数目）是16，且实际容量必须是2的整数次幂。    </div><div class="line">    static final int DEFAULT_INITIAL_CAPACITY = 16;    </div><div class="line">   </div><div class="line">    // 最大容量（必须是2的幂且小于2的30次方，传入容量过大将被这个值替换）    </div><div class="line">    static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;    </div><div class="line">   </div><div class="line">    // 默认加载因子为0.75   </div><div class="line">    static final float DEFAULT_LOAD_FACTOR = 0.75f;    </div><div class="line">   </div><div class="line">    // 存储数据的Entry数组，长度是2的幂。    </div><div class="line">    // HashMap采用链表法解决冲突，每一个Entry本质上是一个单向链表    </div><div class="line">    transient Entry[] table;    </div><div class="line">   </div><div class="line">    // HashMap的底层数组中已用槽的数量    </div><div class="line">    transient int size;    </div><div class="line">   </div><div class="line">    // HashMap的阈值，用于判断是否需要调整HashMap的容量（threshold = 容量*加载因子）    </div><div class="line">    int threshold;    </div><div class="line">   </div><div class="line">    // 加载因子实际大小    </div><div class="line">    final float loadFactor;    </div><div class="line">   </div><div class="line">    // HashMap被改变的次数    </div><div class="line">    transient volatile int modCount;    </div><div class="line">   </div><div class="line">    // 指定“容量大小”和“加载因子”的构造函数    </div><div class="line">    public HashMap(int initialCapacity, float loadFactor) &#123;    </div><div class="line">        if (initialCapacity &lt; 0)    </div><div class="line">            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +    </div><div class="line">                                               initialCapacity);    </div><div class="line">        // HashMap的最大容量只能是MAXIMUM_CAPACITY    </div><div class="line">        if (initialCapacity &gt; MAXIMUM_CAPACITY)    </div><div class="line">            initialCapacity = MAXIMUM_CAPACITY;    </div><div class="line">        //加载因此不能小于0  </div><div class="line">        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))    </div><div class="line">            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +    </div><div class="line">                                               loadFactor);    </div><div class="line">   </div><div class="line">        // 找出“大于initialCapacity”的最小的2的幂    </div><div class="line">        int capacity = 1;    </div><div class="line">        while (capacity &lt; initialCapacity)    </div><div class="line">            capacity &lt;&lt;= 1;    </div><div class="line">   </div><div class="line">        // 设置“加载因子”    </div><div class="line">        this.loadFactor = loadFactor;    </div><div class="line">        // 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。    </div><div class="line">        threshold = (int)(capacity * loadFactor);    </div><div class="line">        // 创建Entry数组，用来保存数据    </div><div class="line">        table = new Entry[capacity];    </div><div class="line">        init();    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">   </div><div class="line">    // 指定“容量大小”的构造函数    </div><div class="line">    public HashMap(int initialCapacity) &#123;    </div><div class="line">        this(initialCapacity, DEFAULT_LOAD_FACTOR);    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 默认构造函数。    </div><div class="line">    public HashMap() &#123;    </div><div class="line">        // 设置“加载因子”为默认加载因子0.75    </div><div class="line">        this.loadFactor = DEFAULT_LOAD_FACTOR;    </div><div class="line">        // 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。    </div><div class="line">        threshold = (int)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);    </div><div class="line">        // 创建Entry数组，用来保存数据    </div><div class="line">        table = new Entry[DEFAULT_INITIAL_CAPACITY];    </div><div class="line">        init();    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 包含“子Map”的构造函数    </div><div class="line">    public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;    </div><div class="line">        this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1,    </div><div class="line">                      DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);    </div><div class="line">        // 将m中的全部元素逐个添加到HashMap中    </div><div class="line">        putAllForCreate(m);    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    //求hash值的方法，重新计算hash值  </div><div class="line">    static int hash(int h) &#123;    </div><div class="line">        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);    </div><div class="line">        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 返回h在数组中的索引值，这里用&amp;代替取模，旨在提升效率   </div><div class="line">    // h &amp; (length-1)保证返回值的小于length    </div><div class="line">    static int indexFor(int h, int length) &#123;    </div><div class="line">        return h &amp; (length-1);    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    public int size() &#123;    </div><div class="line">        return size;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    public boolean isEmpty() &#123;    </div><div class="line">        return size == 0;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 获取key对应的value    </div><div class="line">    public V get(Object key) &#123;    </div><div class="line">        if (key == null)    </div><div class="line">            return getForNullKey();    </div><div class="line">        // 获取key的hash值    </div><div class="line">        int hash = hash(key.hashCode());    </div><div class="line">        // 在“该hash值对应的链表”上查找“键值等于key”的元素    </div><div class="line">        for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];    </div><div class="line">             e != null;    </div><div class="line">             e = e.next) &#123;    </div><div class="line">            Object k;    </div><div class="line">            //判断key是否相同  </div><div class="line">            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))    </div><div class="line">                return e.value;    </div><div class="line">        &#125;  </div><div class="line">        //没找到则返回null  </div><div class="line">        return null;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 获取“key为null”的元素的值    </div><div class="line">    // HashMap将“key为null”的元素存储在table[0]位置，但不一定是该链表的第一个位置！    </div><div class="line">    private V getForNullKey() &#123;    </div><div class="line">        for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123;    </div><div class="line">            if (e.key == null)    </div><div class="line">                return e.value;    </div><div class="line">        &#125;    </div><div class="line">        return null;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // HashMap是否包含key    </div><div class="line">    public boolean containsKey(Object key) &#123;    </div><div class="line">        return getEntry(key) != null;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 返回“键为key”的键值对    </div><div class="line">    final Entry&lt;K,V&gt; getEntry(Object key) &#123;    </div><div class="line">        // 获取哈希值    </div><div class="line">        // HashMap将“key为null”的元素存储在table[0]位置，“key不为null”的则调用hash()计算哈希值    </div><div class="line">        int hash = (key == null) ? 0 : hash(key.hashCode());    </div><div class="line">        // 在“该hash值对应的链表”上查找“键值等于key”的元素    </div><div class="line">        for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];    </div><div class="line">             e != null;    </div><div class="line">             e = e.next) &#123;    </div><div class="line">            Object k;    </div><div class="line">            if (e.hash == hash &amp;&amp;    </div><div class="line">                ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))    </div><div class="line">                return e;    </div><div class="line">        &#125;    </div><div class="line">        return null;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 将“key-value”添加到HashMap中    </div><div class="line">    public V put(K key, V value) &#123;    </div><div class="line">        // 若“key为null”，则将该键值对添加到table[0]中。    </div><div class="line">        if (key == null)    </div><div class="line">            return putForNullKey(value);    </div><div class="line">        // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。    </div><div class="line">        int hash = hash(key.hashCode());    </div><div class="line">        int i = indexFor(hash, table.length);    </div><div class="line">        for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;    </div><div class="line">            Object k;    </div><div class="line">            // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！    </div><div class="line">            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;    </div><div class="line">                V oldValue = e.value;    </div><div class="line">                e.value = value;    </div><div class="line">                e.recordAccess(this);    </div><div class="line">                return oldValue;    </div><div class="line">            &#125;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        // 若“该key”对应的键值对不存在，则将“key-value”添加到table中    </div><div class="line">        modCount++;  </div><div class="line">        //将key-value添加到table[i]处  </div><div class="line">        addEntry(hash, key, value, i);    </div><div class="line">        return null;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // putForNullKey()的作用是将“key为null”键值对添加到table[0]位置    </div><div class="line">    private V putForNullKey(V value) &#123;    </div><div class="line">        for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123;    </div><div class="line">            if (e.key == null) &#123;    </div><div class="line">                V oldValue = e.value;    </div><div class="line">                e.value = value;    </div><div class="line">                e.recordAccess(this);    </div><div class="line">                return oldValue;    </div><div class="line">            &#125;    </div><div class="line">        &#125;    </div><div class="line">        // 如果没有存在key为null的键值对，则直接题阿见到table[0]处!    </div><div class="line">        modCount++;    </div><div class="line">        addEntry(0, null, value, 0);    </div><div class="line">        return null;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 创建HashMap对应的“添加方法”，    </div><div class="line">    // 它和put()不同。putForCreate()是内部方法，它被构造函数等调用，用来创建HashMap    </div><div class="line">    // 而put()是对外提供的往HashMap中添加元素的方法。    </div><div class="line">    private void putForCreate(K key, V value) &#123;    </div><div class="line">        int hash = (key == null) ? 0 : hash(key.hashCode());    </div><div class="line">        int i = indexFor(hash, table.length);    </div><div class="line">   </div><div class="line">        // 若该HashMap表中存在“键值等于key”的元素，则替换该元素的value值    </div><div class="line">        for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;    </div><div class="line">            Object k;    </div><div class="line">            if (e.hash == hash &amp;&amp;    </div><div class="line">                ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123;    </div><div class="line">                e.value = value;    </div><div class="line">                return;    </div><div class="line">            &#125;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        // 若该HashMap表中不存在“键值等于key”的元素，则将该key-value添加到HashMap中    </div><div class="line">        createEntry(hash, key, value, i);    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 将“m”中的全部元素都添加到HashMap中。    </div><div class="line">    // 该方法被内部的构造HashMap的方法所调用。    </div><div class="line">    private void putAllForCreate(Map&lt;? extends K, ? extends V&gt; m) &#123;    </div><div class="line">        // 利用迭代器将元素逐个添加到HashMap中    </div><div class="line">        for (Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; i = m.entrySet().iterator(); i.hasNext(); ) &#123;    </div><div class="line">            Map.Entry&lt;? extends K, ? extends V&gt; e = i.next();    </div><div class="line">            putForCreate(e.getKey(), e.getValue());    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 重新调整HashMap的大小，newCapacity是调整后的容量    </div><div class="line">    void resize(int newCapacity) &#123;    </div><div class="line">        Entry[] oldTable = table;    </div><div class="line">        int oldCapacity = oldTable.length;   </div><div class="line">        //如果就容量已经达到了最大值，则不能再扩容，直接返回  </div><div class="line">        if (oldCapacity == MAXIMUM_CAPACITY) &#123;    </div><div class="line">            threshold = Integer.MAX_VALUE;    </div><div class="line">            return;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        // 新建一个HashMap，将“旧HashMap”的全部元素添加到“新HashMap”中，    </div><div class="line">        // 然后，将“新HashMap”赋值给“旧HashMap”。    </div><div class="line">        Entry[] newTable = new Entry[newCapacity];    </div><div class="line">        transfer(newTable);    </div><div class="line">        table = newTable;    </div><div class="line">        threshold = (int)(newCapacity * loadFactor);    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 将HashMap中的全部元素都添加到newTable中    </div><div class="line">    void transfer(Entry[] newTable) &#123;    </div><div class="line">        Entry[] src = table;    </div><div class="line">        int newCapacity = newTable.length;    </div><div class="line">        for (int j = 0; j &lt; src.length; j++) &#123;    </div><div class="line">            Entry&lt;K,V&gt; e = src[j];    </div><div class="line">            if (e != null) &#123;    </div><div class="line">                src[j] = null;    </div><div class="line">                do &#123;    </div><div class="line">                    Entry&lt;K,V&gt; next = e.next;    </div><div class="line">                    int i = indexFor(e.hash, newCapacity);    </div><div class="line">                    e.next = newTable[i];    </div><div class="line">                    newTable[i] = e;    </div><div class="line">                    e = next;    </div><div class="line">                &#125; while (e != null);    </div><div class="line">            &#125;    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 将&quot;m&quot;的全部元素都添加到HashMap中    </div><div class="line">    public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123;    </div><div class="line">        // 有效性判断    </div><div class="line">        int numKeysToBeAdded = m.size();    </div><div class="line">        if (numKeysToBeAdded == 0)    </div><div class="line">            return;    </div><div class="line">   </div><div class="line">        // 计算容量是否足够，    </div><div class="line">        // 若“当前阀值容量 &lt; 需要的容量”，则将容量x2。    </div><div class="line">        if (numKeysToBeAdded &gt; threshold) &#123;    </div><div class="line">            int targetCapacity = (int)(numKeysToBeAdded / loadFactor + 1);    </div><div class="line">            if (targetCapacity &gt; MAXIMUM_CAPACITY)    </div><div class="line">                targetCapacity = MAXIMUM_CAPACITY;    </div><div class="line">            int newCapacity = table.length;    </div><div class="line">            while (newCapacity &lt; targetCapacity)    </div><div class="line">                newCapacity &lt;&lt;= 1;    </div><div class="line">            if (newCapacity &gt; table.length)    </div><div class="line">                resize(newCapacity);    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        // 通过迭代器，将“m”中的元素逐个添加到HashMap中。    </div><div class="line">        for (Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; i = m.entrySet().iterator(); i.hasNext(); ) &#123;    </div><div class="line">            Map.Entry&lt;? extends K, ? extends V&gt; e = i.next();    </div><div class="line">            put(e.getKey(), e.getValue());    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 删除“键为key”元素    </div><div class="line">    public V remove(Object key) &#123;    </div><div class="line">        Entry&lt;K,V&gt; e = removeEntryForKey(key);    </div><div class="line">        return (e == null ? null : e.value);    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 删除“键为key”的元素    </div><div class="line">    final Entry&lt;K,V&gt; removeEntryForKey(Object key) &#123;    </div><div class="line">        // 获取哈希值。若key为null，则哈希值为0；否则调用hash()进行计算    </div><div class="line">        int hash = (key == null) ? 0 : hash(key.hashCode());    </div><div class="line">        int i = indexFor(hash, table.length);    </div><div class="line">        Entry&lt;K,V&gt; prev = table[i];    </div><div class="line">        Entry&lt;K,V&gt; e = prev;    </div><div class="line">   </div><div class="line">        // 删除链表中“键为key”的元素    </div><div class="line">        // 本质是“删除单向链表中的节点”    </div><div class="line">        while (e != null) &#123;    </div><div class="line">            Entry&lt;K,V&gt; next = e.next;    </div><div class="line">            Object k;    </div><div class="line">            if (e.hash == hash &amp;&amp;    </div><div class="line">                ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123;    </div><div class="line">                modCount++;    </div><div class="line">                size--;    </div><div class="line">                if (prev == e)    </div><div class="line">                    table[i] = next;    </div><div class="line">                else   </div><div class="line">                    prev.next = next;    </div><div class="line">                e.recordRemoval(this);    </div><div class="line">                return e;    </div><div class="line">            &#125;    </div><div class="line">            prev = e;    </div><div class="line">            e = next;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        return e;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 删除“键值对”    </div><div class="line">    final Entry&lt;K,V&gt; removeMapping(Object o) &#123;    </div><div class="line">        if (!(o instanceof Map.Entry))    </div><div class="line">            return null;    </div><div class="line">   </div><div class="line">        Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o;    </div><div class="line">        Object key = entry.getKey();    </div><div class="line">        int hash = (key == null) ? 0 : hash(key.hashCode());    </div><div class="line">        int i = indexFor(hash, table.length);    </div><div class="line">        Entry&lt;K,V&gt; prev = table[i];    </div><div class="line">        Entry&lt;K,V&gt; e = prev;    </div><div class="line">   </div><div class="line">        // 删除链表中的“键值对e”    </div><div class="line">        // 本质是“删除单向链表中的节点”    </div><div class="line">        while (e != null) &#123;    </div><div class="line">            Entry&lt;K,V&gt; next = e.next;    </div><div class="line">            if (e.hash == hash &amp;&amp; e.equals(entry)) &#123;    </div><div class="line">                modCount++;    </div><div class="line">                size--;    </div><div class="line">                if (prev == e)    </div><div class="line">                    table[i] = next;    </div><div class="line">                else   </div><div class="line">                    prev.next = next;    </div><div class="line">                e.recordRemoval(this);    </div><div class="line">                return e;    </div><div class="line">            &#125;    </div><div class="line">            prev = e;    </div><div class="line">            e = next;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        return e;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 清空HashMap，将所有的元素设为null    </div><div class="line">    public void clear() &#123;    </div><div class="line">        modCount++;    </div><div class="line">        Entry[] tab = table;    </div><div class="line">        for (int i = 0; i &lt; tab.length; i++)    </div><div class="line">            tab[i] = null;    </div><div class="line">        size = 0;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 是否包含“值为value”的元素    </div><div class="line">    public boolean containsValue(Object value) &#123;    </div><div class="line">    // 若“value为null”，则调用containsNullValue()查找    </div><div class="line">    if (value == null)    </div><div class="line">            return containsNullValue();    </div><div class="line">   </div><div class="line">    // 若“value不为null”，则查找HashMap中是否有值为value的节点。    </div><div class="line">    Entry[] tab = table;    </div><div class="line">        for (int i = 0; i &lt; tab.length ; i++)    </div><div class="line">            for (Entry e = tab[i] ; e != null ; e = e.next)    </div><div class="line">                if (value.equals(e.value))    </div><div class="line">                    return true;    </div><div class="line">    return false;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 是否包含null值    </div><div class="line">    private boolean containsNullValue() &#123;    </div><div class="line">    Entry[] tab = table;    </div><div class="line">        for (int i = 0; i &lt; tab.length ; i++)    </div><div class="line">            for (Entry e = tab[i] ; e != null ; e = e.next)    </div><div class="line">                if (e.value == null)    </div><div class="line">                    return true;    </div><div class="line">    return false;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 克隆一个HashMap，并返回Object对象    </div><div class="line">    public Object clone() &#123;    </div><div class="line">        HashMap&lt;K,V&gt; result = null;    </div><div class="line">        try &#123;    </div><div class="line">            result = (HashMap&lt;K,V&gt;)super.clone();    </div><div class="line">        &#125; catch (CloneNotSupportedException e) &#123;    </div><div class="line">            // assert false;    </div><div class="line">        &#125;    </div><div class="line">        result.table = new Entry[table.length];    </div><div class="line">        result.entrySet = null;    </div><div class="line">        result.modCount = 0;    </div><div class="line">        result.size = 0;    </div><div class="line">        result.init();    </div><div class="line">        // 调用putAllForCreate()将全部元素添加到HashMap中    </div><div class="line">        result.putAllForCreate(this);    </div><div class="line">   </div><div class="line">        return result;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // Entry是单向链表。    </div><div class="line">    // 它是 “HashMap链式存储法”对应的链表。    </div><div class="line">    // 它实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数    </div><div class="line">    static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;    </div><div class="line">        final K key;    </div><div class="line">        V value;    </div><div class="line">        // 指向下一个节点    </div><div class="line">        Entry&lt;K,V&gt; next;    </div><div class="line">        final int hash;    </div><div class="line">   </div><div class="line">        // 构造函数。    </div><div class="line">        // 输入参数包括&quot;哈希值(h)&quot;, &quot;键(k)&quot;, &quot;值(v)&quot;, &quot;下一节点(n)&quot;    </div><div class="line">        Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123;    </div><div class="line">            value = v;    </div><div class="line">            next = n;    </div><div class="line">            key = k;    </div><div class="line">            hash = h;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        public final K getKey() &#123;    </div><div class="line">            return key;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        public final V getValue() &#123;    </div><div class="line">            return value;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        public final V setValue(V newValue) &#123;    </div><div class="line">            V oldValue = value;    </div><div class="line">            value = newValue;    </div><div class="line">            return oldValue;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        // 判断两个Entry是否相等    </div><div class="line">        // 若两个Entry的“key”和“value”都相等，则返回true。    </div><div class="line">        // 否则，返回false    </div><div class="line">        public final boolean equals(Object o) &#123;    </div><div class="line">            if (!(o instanceof Map.Entry))    </div><div class="line">                return false;    </div><div class="line">            Map.Entry e = (Map.Entry)o;    </div><div class="line">            Object k1 = getKey();    </div><div class="line">            Object k2 = e.getKey();    </div><div class="line">            if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) &#123;    </div><div class="line">                Object v1 = getValue();    </div><div class="line">                Object v2 = e.getValue();    </div><div class="line">                if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2)))    </div><div class="line">                    return true;    </div><div class="line">            &#125;    </div><div class="line">            return false;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        // 实现hashCode()    </div><div class="line">        public final int hashCode() &#123;    </div><div class="line">            return (key==null   ? 0 : key.hashCode()) ^    </div><div class="line">                   (value==null ? 0 : value.hashCode());    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        public final String toString() &#123;    </div><div class="line">            return getKey() + &quot;=&quot; + getValue();    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        // 当向HashMap中添加元素时，绘调用recordAccess()。    </div><div class="line">        // 这里不做任何处理    </div><div class="line">        void recordAccess(HashMap&lt;K,V&gt; m) &#123;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        // 当从HashMap中删除元素时，绘调用recordRemoval()。    </div><div class="line">        // 这里不做任何处理    </div><div class="line">        void recordRemoval(HashMap&lt;K,V&gt; m) &#123;    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 新增Entry。将“key-value”插入指定位置，bucketIndex是位置索引。    </div><div class="line">    void addEntry(int hash, K key, V value, int bucketIndex) &#123;    </div><div class="line">        // 保存“bucketIndex”位置的值到“e”中    </div><div class="line">        Entry&lt;K,V&gt; e = table[bucketIndex];    </div><div class="line">        // 设置“bucketIndex”位置的元素为“新Entry”，    </div><div class="line">        // 设置“e”为“新Entry的下一个节点”    </div><div class="line">        table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e);    </div><div class="line">        // 若HashMap的实际大小 不小于 “阈值”，则调整HashMap的大小    </div><div class="line">        if (size++ &gt;= threshold)    </div><div class="line">            resize(2 * table.length);    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 创建Entry。将“key-value”插入指定位置。    </div><div class="line">    void createEntry(int hash, K key, V value, int bucketIndex) &#123;    </div><div class="line">        // 保存“bucketIndex”位置的值到“e”中    </div><div class="line">        Entry&lt;K,V&gt; e = table[bucketIndex];    </div><div class="line">        // 设置“bucketIndex”位置的元素为“新Entry”，    </div><div class="line">        // 设置“e”为“新Entry的下一个节点”    </div><div class="line">        table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e);    </div><div class="line">        size++;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // HashIterator是HashMap迭代器的抽象出来的父类，实现了公共了函数。    </div><div class="line">    // 它包含“key迭代器(KeyIterator)”、“Value迭代器(ValueIterator)”和“Entry迭代器(EntryIterator)”3个子类。    </div><div class="line">    private abstract class HashIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123;    </div><div class="line">        // 下一个元素    </div><div class="line">        Entry&lt;K,V&gt; next;    </div><div class="line">        // expectedModCount用于实现fast-fail机制。    </div><div class="line">        int expectedModCount;    </div><div class="line">        // 当前索引    </div><div class="line">        int index;    </div><div class="line">        // 当前元素    </div><div class="line">        Entry&lt;K,V&gt; current;    </div><div class="line">   </div><div class="line">        HashIterator() &#123;    </div><div class="line">            expectedModCount = modCount;    </div><div class="line">            if (size &gt; 0) &#123; // advance to first entry    </div><div class="line">                Entry[] t = table;    </div><div class="line">                // 将next指向table中第一个不为null的元素。    </div><div class="line">                // 这里利用了index的初始值为0，从0开始依次向后遍历，直到找到不为null的元素就退出循环。    </div><div class="line">                while (index &lt; t.length &amp;&amp; (next = t[index++]) == null)    </div><div class="line">                    ;    </div><div class="line">            &#125;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        public final boolean hasNext() &#123;    </div><div class="line">            return next != null;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        // 获取下一个元素    </div><div class="line">        final Entry&lt;K,V&gt; nextEntry() &#123;    </div><div class="line">            if (modCount != expectedModCount)    </div><div class="line">                throw new ConcurrentModificationException();    </div><div class="line">            Entry&lt;K,V&gt; e = next;    </div><div class="line">            if (e == null)    </div><div class="line">                throw new NoSuchElementException();    </div><div class="line">   </div><div class="line">            // 注意！！！    </div><div class="line">            // 一个Entry就是一个单向链表    </div><div class="line">            // 若该Entry的下一个节点不为空，就将next指向下一个节点;    </div><div class="line">            // 否则，将next指向下一个链表(也是下一个Entry)的不为null的节点。    </div><div class="line">            if ((next = e.next) == null) &#123;    </div><div class="line">                Entry[] t = table;    </div><div class="line">                while (index &lt; t.length &amp;&amp; (next = t[index++]) == null)    </div><div class="line">                    ;    </div><div class="line">            &#125;    </div><div class="line">            current = e;    </div><div class="line">            return e;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        // 删除当前元素    </div><div class="line">        public void remove() &#123;    </div><div class="line">            if (current == null)    </div><div class="line">                throw new IllegalStateException();    </div><div class="line">            if (modCount != expectedModCount)    </div><div class="line">                throw new ConcurrentModificationException();    </div><div class="line">            Object k = current.key;    </div><div class="line">            current = null;    </div><div class="line">            HashMap.this.removeEntryForKey(k);    </div><div class="line">            expectedModCount = modCount;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // value的迭代器    </div><div class="line">    private final class ValueIterator extends HashIterator&lt;V&gt; &#123;    </div><div class="line">        public V next() &#123;    </div><div class="line">            return nextEntry().value;    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // key的迭代器    </div><div class="line">    private final class KeyIterator extends HashIterator&lt;K&gt; &#123;    </div><div class="line">        public K next() &#123;    </div><div class="line">            return nextEntry().getKey();    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // Entry的迭代器    </div><div class="line">    private final class EntryIterator extends HashIterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123;    </div><div class="line">        public Map.Entry&lt;K,V&gt; next() &#123;    </div><div class="line">            return nextEntry();    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 返回一个“key迭代器”    </div><div class="line">    Iterator&lt;K&gt; newKeyIterator()   &#123;    </div><div class="line">        return new KeyIterator();    </div><div class="line">    &#125;    </div><div class="line">    // 返回一个“value迭代器”    </div><div class="line">    Iterator&lt;V&gt; newValueIterator()   &#123;    </div><div class="line">        return new ValueIterator();    </div><div class="line">    &#125;    </div><div class="line">    // 返回一个“entry迭代器”    </div><div class="line">    Iterator&lt;Map.Entry&lt;K,V&gt;&gt; newEntryIterator()   &#123;    </div><div class="line">        return new EntryIterator();    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // HashMap的Entry对应的集合    </div><div class="line">    private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = null;    </div><div class="line">   </div><div class="line">    // 返回“key的集合”，实际上返回一个“KeySet对象”    </div><div class="line">    public Set&lt;K&gt; keySet() &#123;    </div><div class="line">        Set&lt;K&gt; ks = keySet;    </div><div class="line">        return (ks != null ? ks : (keySet = new KeySet()));    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // Key对应的集合    </div><div class="line">    // KeySet继承于AbstractSet，说明该集合中没有重复的Key。    </div><div class="line">    private final class KeySet extends AbstractSet&lt;K&gt; &#123;    </div><div class="line">        public Iterator&lt;K&gt; iterator() &#123;    </div><div class="line">            return newKeyIterator();    </div><div class="line">        &#125;    </div><div class="line">        public int size() &#123;    </div><div class="line">            return size;    </div><div class="line">        &#125;    </div><div class="line">        public boolean contains(Object o) &#123;    </div><div class="line">            return containsKey(o);    </div><div class="line">        &#125;    </div><div class="line">        public boolean remove(Object o) &#123;    </div><div class="line">            return HashMap.this.removeEntryForKey(o) != null;    </div><div class="line">        &#125;    </div><div class="line">        public void clear() &#123;    </div><div class="line">            HashMap.this.clear();    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 返回“value集合”，实际上返回的是一个Values对象    </div><div class="line">    public Collection&lt;V&gt; values() &#123;    </div><div class="line">        Collection&lt;V&gt; vs = values;    </div><div class="line">        return (vs != null ? vs : (values = new Values()));    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // “value集合”    </div><div class="line">    // Values继承于AbstractCollection，不同于“KeySet继承于AbstractSet”，    </div><div class="line">    // Values中的元素能够重复。因为不同的key可以指向相同的value。    </div><div class="line">    private final class Values extends AbstractCollection&lt;V&gt; &#123;    </div><div class="line">        public Iterator&lt;V&gt; iterator() &#123;    </div><div class="line">            return newValueIterator();    </div><div class="line">        &#125;    </div><div class="line">        public int size() &#123;    </div><div class="line">            return size;    </div><div class="line">        &#125;    </div><div class="line">        public boolean contains(Object o) &#123;    </div><div class="line">            return containsValue(o);    </div><div class="line">        &#125;    </div><div class="line">        public void clear() &#123;    </div><div class="line">            HashMap.this.clear();    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 返回“HashMap的Entry集合”    </div><div class="line">    public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;    </div><div class="line">        return entrySet0();    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 返回“HashMap的Entry集合”，它实际是返回一个EntrySet对象    </div><div class="line">    private Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet0() &#123;    </div><div class="line">        Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet;    </div><div class="line">        return es != null ? es : (entrySet = new EntrySet());    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // EntrySet对应的集合    </div><div class="line">    // EntrySet继承于AbstractSet，说明该集合中没有重复的EntrySet。    </div><div class="line">    private final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123;    </div><div class="line">        public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;    </div><div class="line">            return newEntryIterator();    </div><div class="line">        &#125;    </div><div class="line">        public boolean contains(Object o) &#123;    </div><div class="line">            if (!(o instanceof Map.Entry))    </div><div class="line">                return false;    </div><div class="line">            Map.Entry&lt;K,V&gt; e = (Map.Entry&lt;K,V&gt;) o;    </div><div class="line">            Entry&lt;K,V&gt; candidate = getEntry(e.getKey());    </div><div class="line">            return candidate != null &amp;&amp; candidate.equals(e);    </div><div class="line">        &#125;    </div><div class="line">        public boolean remove(Object o) &#123;    </div><div class="line">            return removeMapping(o) != null;    </div><div class="line">        &#125;    </div><div class="line">        public int size() &#123;    </div><div class="line">            return size;    </div><div class="line">        &#125;    </div><div class="line">        public void clear() &#123;    </div><div class="line">            HashMap.this.clear();    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // java.io.Serializable的写入函数    </div><div class="line">    // 将HashMap的“总的容量，实际容量，所有的Entry”都写入到输出流中    </div><div class="line">    private void writeObject(java.io.ObjectOutputStream s)    </div><div class="line">        throws IOException    </div><div class="line">    &#123;    </div><div class="line">        Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i =    </div><div class="line">            (size &gt; 0) ? entrySet0().iterator() : null;    </div><div class="line">   </div><div class="line">        // Write out the threshold, loadfactor, and any hidden stuff    </div><div class="line">        s.defaultWriteObject();    </div><div class="line">   </div><div class="line">        // Write out number of buckets    </div><div class="line">        s.writeInt(table.length);    </div><div class="line">   </div><div class="line">        // Write out size (number of Mappings)    </div><div class="line">        s.writeInt(size);    </div><div class="line">   </div><div class="line">        // Write out keys and values (alternating)    </div><div class="line">        if (i != null) &#123;    </div><div class="line">            while (i.hasNext()) &#123;    </div><div class="line">            Map.Entry&lt;K,V&gt; e = i.next();    </div><div class="line">            s.writeObject(e.getKey());    </div><div class="line">            s.writeObject(e.getValue());    </div><div class="line">            &#125;    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">   </div><div class="line">    private static final long serialVersionUID = 362498820763181265L;    </div><div class="line">   </div><div class="line">    // java.io.Serializable的读取函数：根据写入方式读出    </div><div class="line">    // 将HashMap的“总的容量，实际容量，所有的Entry”依次读出    </div><div class="line">    private void readObject(java.io.ObjectInputStream s)    </div><div class="line">         throws IOException, ClassNotFoundException    </div><div class="line">    &#123;    </div><div class="line">        // Read in the threshold, loadfactor, and any hidden stuff    </div><div class="line">        s.defaultReadObject();    </div><div class="line">   </div><div class="line">        // Read in number of buckets and allocate the bucket array;    </div><div class="line">        int numBuckets = s.readInt();    </div><div class="line">        table = new Entry[numBuckets];    </div><div class="line">   </div><div class="line">        init();  // Give subclass a chance to do its thing.    </div><div class="line">   </div><div class="line">        // Read in size (number of Mappings)    </div><div class="line">        int size = s.readInt();    </div><div class="line">   </div><div class="line">        // Read the keys and values, and put the mappings in the HashMap    </div><div class="line">        for (int i=0; i&lt;size; i++) &#123;    </div><div class="line">            K key = (K) s.readObject();    </div><div class="line">            V value = (V) s.readObject();    </div><div class="line">            putForCreate(key, value);    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 返回“HashMap总的容量”    </div><div class="line">    int   capacity()     &#123; return table.length; &#125;    </div><div class="line">    // 返回“HashMap的加载因子”    </div><div class="line">    float loadFactor()   &#123; return loadFactor;   &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="二、HashMap细节剖析"><a href="#二、HashMap细节剖析" class="headerlink" title="二、HashMap细节剖析"></a>二、HashMap细节剖析</h2><h3 id="2-1-存储结构"><a href="#2-1-存储结构" class="headerlink" title="2.1 存储结构"></a>2.1 存储结构</h3><p> 首先要清楚HashMap的存储结构，如下图所示：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15032354567744.jpg" alt=""></p><p>图中，紫色部分即代表哈希表，也称为哈希数组，数组的每个元素都是一个单链表的头节点，链表是用来解决冲突的，如果不同的key映射到了数组的同一位置处，就将其放入单链表中。</p><h3 id="2-2-链表节点的数据结构"><a href="#2-2-链表节点的数据结构" class="headerlink" title="2.2 链表节点的数据结构"></a>2.2 链表节点的数据结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">// Entry是单向链表。    </div><div class="line">// 它是 “HashMap链式存储法”对应的链表。    </div><div class="line">// 它实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数    </div><div class="line">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;    </div><div class="line">    final K key;    </div><div class="line">    V value;    </div><div class="line">    // 指向下一个节点    </div><div class="line">    Entry&lt;K,V&gt; next;    </div><div class="line">    final int hash;    </div><div class="line">  </div><div class="line">    // 构造函数。    </div><div class="line">    // 输入参数包括&quot;哈希值(h)&quot;, &quot;键(k)&quot;, &quot;值(v)&quot;, &quot;下一节点(n)&quot;    </div><div class="line">    Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123;    </div><div class="line">        value = v;    </div><div class="line">        next = n;    </div><div class="line">        key = k;    </div><div class="line">        hash = h;    </div><div class="line">    &#125;    </div><div class="line">  </div><div class="line">    public final K getKey() &#123;    </div><div class="line">        return key;    </div><div class="line">    &#125;    </div><div class="line">  </div><div class="line">    public final V getValue() &#123;    </div><div class="line">        return value;    </div><div class="line">    &#125;    </div><div class="line">  </div><div class="line">    public final V setValue(V newValue) &#123;    </div><div class="line">        V oldValue = value;    </div><div class="line">        value = newValue;    </div><div class="line">        return oldValue;    </div><div class="line">    &#125;    </div><div class="line">  </div><div class="line">    // 判断两个Entry是否相等    </div><div class="line">    // 若两个Entry的“key”和“value”都相等，则返回true。    </div><div class="line">    // 否则，返回false    </div><div class="line">    public final boolean equals(Object o) &#123;    </div><div class="line">        if (!(o instanceof Map.Entry))    </div><div class="line">            return false;    </div><div class="line">        Map.Entry e = (Map.Entry)o;    </div><div class="line">        Object k1 = getKey();    </div><div class="line">        Object k2 = e.getKey();    </div><div class="line">        if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) &#123;    </div><div class="line">            Object v1 = getValue();    </div><div class="line">            Object v2 = e.getValue();    </div><div class="line">            if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2)))    </div><div class="line">                return true;    </div><div class="line">        &#125;    </div><div class="line">        return false;    </div><div class="line">    &#125;    </div><div class="line">  </div><div class="line">    // 实现hashCode()    </div><div class="line">    public final int hashCode() &#123;    </div><div class="line">        return (key==null   ? 0 : key.hashCode()) ^    </div><div class="line">               (value==null ? 0 : value.hashCode());    </div><div class="line">    &#125;    </div><div class="line">  </div><div class="line">    public final String toString() &#123;    </div><div class="line">        return getKey() + &quot;=&quot; + getValue();    </div><div class="line">    &#125;    </div><div class="line">  </div><div class="line">    // 当向HashMap中添加元素时，绘调用recordAccess()。    </div><div class="line">    // 这里不做任何处理    </div><div class="line">    void recordAccess(HashMap&lt;K,V&gt; m) &#123;    </div><div class="line">    &#125;    </div><div class="line">  </div><div class="line">    // 当从HashMap中删除元素时，会调用recordRemoval()。    </div><div class="line">    // 这里不做任何处理    </div><div class="line">    void recordRemoval(HashMap&lt;K,V&gt; m) &#123;    </div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>它的结构元素除了key、value、hash外，还有next，next指向下一个节点。另外，这里覆写了equals和hashCode方法来保证键值对的独一无二。</p><h3 id="2-3-构造方法"><a href="#2-3-构造方法" class="headerlink" title="2.3 构造方法"></a>2.3 构造方法</h3><p>HashMap共有四个构造方法。构造方法中提到了两个很重要的参数：初始容量和加载因子。这两个参数是影响HashMap性能的重要参数，其中容量表示哈希表中槽的数量（即哈希数组的长度），初始容量是创建哈希表时的容量（从构造函数中可以看出，如果不指明，则默认为16），加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 resize 操作（即扩容）。</p><p>下面说下加载因子，如果加载因子越大，对空间的利用更充分，但是查找效率会降低（链表长度会越来越长）；如果加载因子太小，那么表中的数据将过于稀疏（很多空间还没用，就开始扩容了），对空间造成严重浪费。如果我们在构造方法中不指定，则系统默认加载因子为0.75，这是一个比较理想的值，一般情况下我们是无需修改的。</p><p>另外，无论我们指定的容量为多少，构造方法都会将实际容量设为不小于指定容量的2的次方的一个数，且最大值不能超过2的30次方</p><h3 id="2-4-HashMap中key和value都允许为null。"><a href="#2-4-HashMap中key和value都允许为null。" class="headerlink" title="2.4 HashMap中key和value都允许为null。"></a>2.4 HashMap中key和value都允许为null。</h3><h3 id="2-5-重点分析put和get"><a href="#2-5-重点分析put和get" class="headerlink" title="2.5 重点分析put和get"></a>2.5 重点分析put和get</h3><p>要重点分析下HashMap中用的最多的两个方法put和get。先从比较简单的get方法着手，源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">// 获取key对应的value    </div><div class="line">public V get(Object key) &#123;    </div><div class="line">    if (key == null)    </div><div class="line">        return getForNullKey();    </div><div class="line">    // 获取key的hash值    </div><div class="line">    int hash = hash(key.hashCode());    </div><div class="line">    // 在“该hash值对应的链表”上查找“键值等于key”的元素    </div><div class="line">    for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];    </div><div class="line">         e != null;    </div><div class="line">         e = e.next) &#123;    </div><div class="line">        Object k;    </div><div class="line">/判断key是否相同  </div><div class="line">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))    </div><div class="line">            return e.value;    </div><div class="line">    &#125;  </div><div class="line">没找到则返回null  </div><div class="line">    return null;    </div><div class="line">&#125;    </div><div class="line">  </div><div class="line">// 获取“key为null”的元素的值    </div><div class="line">// HashMap将“key为null”的元素存储在table[0]位置，但不一定是该链表的第一个位置！    </div><div class="line">private V getForNullKey() &#123;    </div><div class="line">    for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123;    </div><div class="line">        if (e.key == null)    </div><div class="line">            return e.value;    </div><div class="line">    &#125;    </div><div class="line">    return null;    </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>首先，如果key为null，则直接从哈希表的第一个位置table[0]对应的链表上查找。记住，key为null的键值对永远都放在以table[0]为头结点的链表中，当然不一定是存放在头结点table[0]中。</p><p>如果key不为null，则先求的key的hash值，根据hash值找到在table中的索引，在该索引对应的单链表中查找是否有键值对的key与目标key相等，有就返回对应的value，没有则返回null。</p><p>put方法稍微复杂些，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">  // 将“key-value”添加到HashMap中    </div><div class="line">  public V put(K key, V value) &#123;    </div><div class="line">      // 若“key为null”，则将该键值对添加到table[0]中。    </div><div class="line">      if (key == null)    </div><div class="line">          return putForNullKey(value);    </div><div class="line">      // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。    </div><div class="line">      int hash = hash(key.hashCode());    </div><div class="line">      int i = indexFor(hash, table.length);    </div><div class="line">      for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;    </div><div class="line">          Object k;    </div><div class="line">          // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！    </div><div class="line">          if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;    </div><div class="line">              V oldValue = e.value;    </div><div class="line">              e.value = value;    </div><div class="line">              e.recordAccess(this);    </div><div class="line">              return oldValue;    </div><div class="line">          &#125;    </div><div class="line">      &#125;    </div><div class="line">  </div><div class="line">      // 若“该key”对应的键值对不存在，则将“key-value”添加到table中    </div><div class="line">      modCount++;  </div><div class="line">//将key-value添加到table[i]处  </div><div class="line">      addEntry(hash, key, value, i);    </div><div class="line">      return null;    </div><div class="line">  &#125;</div></pre></td></tr></table></figure><p>如果key为null，则将其添加到table[0]对应的链表中，putForNullKey的源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// putForNullKey()的作用是将“key为null”键值对添加到table[0]位置    </div><div class="line">private V putForNullKey(V value) &#123;    </div><div class="line">    for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123;    </div><div class="line">        if (e.key == null) &#123;    </div><div class="line">            V oldValue = e.value;    </div><div class="line">            e.value = value;    </div><div class="line">            e.recordAccess(this);    </div><div class="line">            return oldValue;    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">    // 如果没有存在key为null的键值对，则直接题阿见到table[0]处!    </div><div class="line">    modCount++;    </div><div class="line">    addEntry(0, null, value, 0);    </div><div class="line">    return null;    </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果key不为null，则同样先求出key的hash值，根据hash值得出在table中的索引，而后遍历对应的单链表，如果单链表中存在与目标key相等的键值对，则将新的value覆盖旧的value，比将旧的value返回，如果找不到与目标key相等的键值对，或者该单链表为空，则将该键值对插入到改单链表的头结点位置（每次新插入的节点都是放在头结点的位置），该操作是有addEntry方法实现的，它的源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 新增Entry。将“key-value”插入指定位置，bucketIndex是位置索引。    </div><div class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;    </div><div class="line">    // 保存“bucketIndex”位置的值到“e”中    </div><div class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];    </div><div class="line">    // 设置“bucketIndex”位置的元素为“新Entry”，    </div><div class="line">    // 设置“e”为“新Entry的下一个节点”    </div><div class="line">    table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e);    </div><div class="line">    // 若HashMap的实际大小 不小于 “阈值”，则调整HashMap的大小    </div><div class="line">    if (size++ &gt;= threshold)    </div><div class="line">        resize(2 * table.length);    </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>注意这里倒数第三行的构造方法，将key-value键值对赋给table[bucketIndex]，并将其next指向元素e，这便将key-value放到了头结点中，并将之前的头结点接在了它的后面。该方法也说明，每次put键值对的时候，总是将新的该键值对放在table[bucketIndex]处（即头结点处）。</p><p>两外注意最后两行代码，每次加入键值对时，都要判断当前已用的槽的数目是否大于等于阀值（容量*加载因子），如果大于等于，则进行扩容，将容量扩为原来容量的2倍。</p><h3 id="2-6-关于扩容"><a href="#2-6-关于扩容" class="headerlink" title="2.6 关于扩容"></a>2.6 关于扩容</h3><p>上面我们看到了扩容的方法，resize方法，它的源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// 重新调整HashMap的大小，newCapacity是调整后的单位    </div><div class="line">void resize(int newCapacity) &#123;    </div><div class="line">    Entry[] oldTable = table;    </div><div class="line">    int oldCapacity = oldTable.length;    </div><div class="line">    if (oldCapacity == MAXIMUM_CAPACITY) &#123;    </div><div class="line">        threshold = Integer.MAX_VALUE;    </div><div class="line">        return;    </div><div class="line">    &#125;    </div><div class="line">  </div><div class="line">    // 新建一个HashMap，将“旧HashMap”的全部元素添加到“新HashMap”中，    </div><div class="line">    // 然后，将“新HashMap”赋值给“旧HashMap”。    </div><div class="line">    Entry[] newTable = new Entry[newCapacity];    </div><div class="line">    transfer(newTable);    </div><div class="line">    table = newTable;    </div><div class="line">    threshold = (int)(newCapacity * loadFactor);    </div><div class="line">&#125;   </div><div class="line">``` </div><div class="line">很明显，是新建了一个HashMap的底层数组，而后调用transfer方法，将就HashMap的全部元素添加到新的HashMap中（要重新计算元素在新的数组中的索引位置）。transfer方法的源码如下：</div></pre></td></tr></table></figure><p>// 将HashMap中的全部元素都添加到newTable中<br>void transfer(Entry[] newTable) {<br>    Entry[] src = table;<br>    int newCapacity = newTable.length;<br>    for (int j = 0; j &lt; src.length; j++) {<br>        Entry<k,v> e = src[j];<br>        if (e != null) {<br>            src[j] = null;<br>            do {<br>                Entry<k,v> next = e.next;<br>                int i = indexFor(e.hash, newCapacity);<br>                e.next = newTable[i];<br>                newTable[i] = e;<br>                e = next;<br>            } while (e != null);<br>        }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">很明显，扩容是一个相当耗时的操作，因为它需要重新计算这些元素在新的数组中的位置并进行复制处理。因此，我们在用HashMap的时，最好能提前预估下HashMap中元素的个数，这样有助于提高HashMap的性能。</div><div class="line"></div><div class="line">### 2..7 containsKey方法和containsValue方法。</div><div class="line"></div><div class="line">注意containsKey方法和containsValue方法。前者直接可以通过key的哈希值将搜索范围定位到指定索引对应的链表，而后者要对哈希数组的每个链表进行搜索。</div><div class="line"></div><div class="line">### 2.8 求hash值和索引值的方法</div><div class="line"></div><div class="line">我们重点来分析下求hash值和索引值的方法，这两个方法便是HashMap设计的最为核心的部分，二者结合能保证哈希表中的元素尽可能均匀地散列。</div><div class="line"></div><div class="line">计算哈希值的方法如下：</div></pre></td></tr></table></figure></k,v></k,v></p><p>static int hash(int h) {<br>        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);<br>        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);<br>    }  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">它只是一个数学公式，IDK这样设计对hash值的计算，自然有它的好处，至于为什么这样设计，我们这里不去追究，只要明白一点，用的位的操作使hash值的计算效率很高。</div><div class="line"></div><div class="line">由hash值找到对应索引的方法如下：</div></pre></td></tr></table></figure><p>static int indexFor(int h, int length) {<br>        return h &amp; (length-1);<br>    }<br>```<br>这个我们要重点说下，我们一般对哈希表的散列很自然地会想到用hash值对length取模（即除法散列法），Hashtable中也是这样实现的，这种方法基本能保证元素在哈希表中散列的比较均匀，但取模会用到除法运算，效率很低，HashMap中则通过h&amp;(length-1)的方法来代替取模，同样实现了均匀的散列，但效率要高很多，这也是HashMap对Hashtable的一个改进。</p><p>接下来，我们分析下为什么哈希表的容量一定要是2的整数次幂。首先，length为2的整数次幂的话，h&amp;(length-1)就相当于对length取模，这样便保证了散列的均匀，同时也提升了效率；其次，length为2的整数次幂的话，为偶数，这样length-1为奇数，奇数的最后一位是1，这样便保证了h&amp;(length-1)的最后一位可能为0，也可能为1（这取决于h的值），即与后的结果可能为偶数，也可能为奇数，这样便可以保证散列的均匀性，而如果length为奇数的话，很明显length-1为偶数，它的最后一位是0，这样h&amp;(length-1)的最后一位肯定为0，即只能为偶数，这样任何hash值都只会被散列到数组的偶数下标位置上，这便浪费了近一半的空间，因此，length取2的整数次幂，是为了使不同hash值发生碰撞的概率较小，这样就能使元素在哈希表中均匀地散列。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HashMap简介 HashMap是基于哈希表实现的，每一个元素都是一个key-value对，其内部通过单链表解决冲突问题，容量不足（超过了阈值）时，同样会自动增长。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="HashMap" scheme="http://yoursite.com/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>Java集合学习手册（10）：hashCode方法与equal方法</title>
    <link href="http://yoursite.com/2017/08/18/Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C%EF%BC%8810%EF%BC%89%EF%BC%9AhashCode%E6%96%B9%E6%B3%95%E4%B8%8Eequal%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2017/08/18/Java集合学习手册（10）：hashCode方法与equal方法/</id>
    <published>2017-08-18T14:20:45.000Z</published>
    <updated>2017-09-01T06:44:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>哈希表这个数据结构想必大多数人都不陌生，而且在很多地方都会利用到hash表来提高查找效率。在Java的Object类中有一个方法:</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public native int hashCode();</div></pre></td></tr></table></figure><p>根据这个方法的声明可知，该方法返回一个int类型的数值，并且是本地方法，因此在Object类中并没有给出具体的实现。</p><p>为何Object类需要这样一个方法？它有什么作用呢？今天我们就来具体探讨一下hashCode方法。</p><h2 id="一、hashCode-方法的作用"><a href="#一、hashCode-方法的作用" class="headerlink" title="一、hashCode()方法的作用"></a>一、hashCode()方法的作用</h2><p>对于包含容器类型的程序设计语言来说，基本上都会涉及到hashCode。在Java中也一样，hashCode方法的主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及HashTable。</p><p>为什么这么说呢？考虑一种情况，当向集合中插入对象时，如何判别在集合中是否已经存在该对象了？（注意：集合中不允许重复的元素存在）</p><p>也许大多数人都会想到调用equals方法来逐个进行比较，这个方法确实可行。但是如果集合中已经存在一万条数据或者更多的数据，如果采用equals方法去逐一比较，效率必然是一个问题。此时hashCode方法的作用就体现出来了，当集合要添加新的对象时，先调用这个对象的hashCode方法，得到对应的hashcode值，实际上在HashMap的具体实现中会用一个table保存已经存进去的对象的hashcode值，如果table中没有该hashcode值，它就可以直接存进去，不用再进行任何比较了；如果存在该hashcode值， 就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址，所以这里存在一个冲突解决的问题，这样一来实际调用equals方法的次数就大大降低了，说通俗一点：Java中的hashCode方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为散列值。下面这段代码是java.util.HashMap的中put方法的具体实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public V put(K key, V value) &#123;</div><div class="line">        if (key == null)</div><div class="line">            return putForNullKey(value);</div><div class="line">        int hash = hash(key.hashCode());</div><div class="line">        int i = indexFor(hash, table.length);</div><div class="line">        for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</div><div class="line">            Object k;</div><div class="line">            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</div><div class="line">                V oldValue = e.value;</div><div class="line">                e.value = value;</div><div class="line">                e.recordAccess(this);</div><div class="line">                return oldValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        modCount++;</div><div class="line">        addEntry(hash, key, value, i);</div><div class="line">        return null;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>put方法是用来向HashMap中添加新的元素，从put方法的具体实现可知，会先调用hashCode方法得到该元素的hashCode值，然后查看table中是否存在该hashCode值，如果存在则调用equals方法重新确定是否存在该元素，如果存在，则更新value值，否则将新的元素添加到HashMap中。从这里可以看出，hashCode方法的存在是为了减少equals方法的调用次数，从而提高程序效率。</p><p>有些朋友误以为默认情况下，hashCode返回的就是对象的存储地址，事实上这种看法是不全面的，确实有些JVM在实现时是直接返回对象的存储地址，但是大多时候并不是这样，只能说可能存储地址有一定关联。下面是HotSpot JVM中生成hash散列值的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">static inline intptr_t get_next_hash(Thread * Self, oop obj) &#123;</div><div class="line">  intptr_t value = 0 ;</div><div class="line">  if (hashCode == 0) &#123;</div><div class="line">     // This form uses an unguarded global Park-Miller RNG,</div><div class="line">     // so it&apos;s possible for two threads to race and generate the same RNG.</div><div class="line">     // On MP system we&apos;ll have lots of RW access to a global, so the</div><div class="line">     // mechanism induces lots of coherency traffic.</div><div class="line">     value = os::random() ;</div><div class="line">  &#125; else</div><div class="line">  if (hashCode == 1) &#123;</div><div class="line">     // This variation has the property of being stable (idempotent)</div><div class="line">     // between STW operations.  This can be useful in some of the 1-0</div><div class="line">     // synchronization schemes.</div><div class="line">     intptr_t addrBits = intptr_t(obj) &gt;&gt; 3 ;</div><div class="line">     value = addrBits ^ (addrBits &gt;&gt; 5) ^ GVars.stwRandom ;</div><div class="line">  &#125; else</div><div class="line">  if (hashCode == 2) &#123;</div><div class="line">     value = 1 ;            // for sensitivity testing</div><div class="line">  &#125; else</div><div class="line">  if (hashCode == 3) &#123;</div><div class="line">     value = ++GVars.hcSequence ;</div><div class="line">  &#125; else</div><div class="line">  if (hashCode == 4) &#123;</div><div class="line">     value = intptr_t(obj) ;</div><div class="line">  &#125; else &#123;</div><div class="line">     // Marsaglia&apos;s xor-shift scheme with thread-specific state</div><div class="line">     // This is probably the best overall implementation -- we&apos;ll</div><div class="line">     // likely make this the default in future releases.</div><div class="line">     unsigned t = Self-&gt;_hashStateX ;</div><div class="line">     t ^= (t &lt;&lt; 11) ;</div><div class="line">     Self-&gt;_hashStateX = Self-&gt;_hashStateY ;</div><div class="line">     Self-&gt;_hashStateY = Self-&gt;_hashStateZ ;</div><div class="line">     Self-&gt;_hashStateZ = Self-&gt;_hashStateW ;</div><div class="line">     unsigned v = Self-&gt;_hashStateW ;</div><div class="line">     v = (v ^ (v &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8)) ;</div><div class="line">     Self-&gt;_hashStateW = v ;</div><div class="line">     value = v ;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  value &amp;= markOopDesc::hash_mask;</div><div class="line">  if (value == 0) value = 0xBAD ;</div><div class="line">  assert (value != markOopDesc::no_hash, &quot;invariant&quot;) ;</div><div class="line">  TEVENT (hashCode: GENERATE) ;</div><div class="line">  return value;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>因此有人会说，可以直接根据hashcode值判断两个对象是否相等吗？肯定是不可以的，因为不同的对象可能会生成相同的hashcode值。虽然不能根据hashcode值判断两个对象是否相等，但是可以直接根据hashcode值判断两个对象不等，如果两个对象的hashcode值不等，则必定是两个不同的对象。如果要判断两个对象是否真正相等，必须通过equals方法。也就是说对于两个对象:</p><ul><li>如果调用equals方法得到的结果为true，则两个对象的hashcode值必定相等；</li><li>如果equals方法得到的结果为false，则两个对象的hashcode值不一定不同；</li><li>如果两个对象的hashcode值不等，则equals方法得到的结果必定为false；</li><li>如果两个对象的hashcode值相等，则equals方法得到的结果未知。</li></ul><h1 id="二、equal方法和hashCode方法"><a href="#二、equal方法和hashCode方法" class="headerlink" title="二、equal方法和hashCode方法"></a>二、equal方法和hashCode方法</h1><p>在有些情况下，程序设计者在设计一个类的时候为需要重写equals方法，比如String类，但是千万要注意，在重写equals方法的同时，必须重写hashCode方法。为什么这么说呢？</p><p>下面看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">import java.util.HashMap;</div><div class="line">import java.util.HashSet;</div><div class="line">import java.util.Set;</div><div class="line"> </div><div class="line">class People&#123;</div><div class="line">    private String name;</div><div class="line">    private int age;</div><div class="line">     </div><div class="line">    public People(String name,int age) &#123;</div><div class="line">        this.name = name;</div><div class="line">        this.age = age;</div><div class="line">    &#125;  </div><div class="line">     </div><div class="line">    public void setAge(int age)&#123;</div><div class="line">        this.age = age;</div><div class="line">    &#125;</div><div class="line">         </div><div class="line">    @Override</div><div class="line">    public boolean equals(Object obj) &#123;</div><div class="line">        // TODO Auto-generated method stub</div><div class="line">        return this.name.equals(((People)obj).name) &amp;&amp; this.age== ((People)obj).age;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">public class Demo &#123;</div><div class="line"> </div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">         </div><div class="line">        People p1 = new People(&quot;Jack&quot;, 12);</div><div class="line">        System.out.println(p1.hashCode());</div><div class="line">             </div><div class="line">        HashMap&lt;People, Integer&gt; hashMap = new HashMap&lt;People, Integer&gt;();</div><div class="line">        hashMap.put(p1, 1);</div><div class="line">         </div><div class="line">        System.out.println(hashMap.get(new People(&quot;Jack&quot;, 12)));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在这里我只重写了equals方法，也就说如果两个People对象，如果它的姓名和年龄相等，则认为是同一个人。</p><p>这段代码本来的意愿是想这段代码输出结果为“1”，但是事实上它输出的是“null”。为什么呢？原因就在于重写equals方法的同时忘记重写hashCode方法。</p><p>虽然通过重写equals方法使得逻辑上姓名和年龄相同的两个对象被判定为相等的对象（跟String类类似），但是要知道默认情况下，hashCode方法是将对象的存储地址进行映射。那么上述代码的输出结果为“null”就不足为奇了。原因很简单，p1指向的对象和System.out.println(hashMap.get(new People(“Jack”, 12)));这句中的new People(“Jack”, 12)生成的是两个对象，它们的存储地址肯定不同。下面是HashMap的get方法的具体实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public V get(Object key) &#123;</div><div class="line">        if (key == null)</div><div class="line">            return getForNullKey();</div><div class="line">        int hash = hash(key.hashCode());</div><div class="line">        for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</div><div class="line">             e != null;</div><div class="line">             e = e.next) &#123;</div><div class="line">            Object k;</div><div class="line">            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</div><div class="line">                return e.value;</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>所以在hashmap进行get操作时，因为得到的hashCode值不同（注意，上述代码也许在某些情况下会得到相同的hashcode值，不过这种概率比较小，因为虽然两个对象的存储地址不同也有可能得到相同的hashcode值），所以导致在get方法中for循环不会执行，直接返回null。</p><p>因此如果想上述代码输出结果为“1”，很简单，只需要重写hashCode方法，让equals方法和hashCode方法始终在逻辑上保持一致性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">import java.util.HashMap;</div><div class="line">import java.util.HashSet;</div><div class="line">import java.util.Set;</div><div class="line"> </div><div class="line"> </div><div class="line">class People&#123;</div><div class="line">    private String name;</div><div class="line">    private int age;</div><div class="line">     </div><div class="line">    public People(String name,int age) &#123;</div><div class="line">        this.name = name;</div><div class="line">        this.age = age;</div><div class="line">    &#125;  </div><div class="line">     </div><div class="line">    public void setAge(int age)&#123;</div><div class="line">        this.age = age;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    @Override</div><div class="line">    public int hashCode() &#123;</div><div class="line">        // TODO Auto-generated method stub</div><div class="line">        return name.hashCode()+age;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    @Override</div><div class="line">    public boolean equals(Object obj) &#123;</div><div class="line">        // TODO Auto-generated method stub</div><div class="line">        return this.name.equals(((People)obj).name) &amp;&amp; this.age== ((People)obj).age;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">public class Demo &#123;</div><div class="line"> </div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">         </div><div class="line">        People p1 = new People(&quot;Jack&quot;, 12);</div><div class="line">        System.out.println(p1.hashCode());</div><div class="line">             </div><div class="line">        HashMap&lt;People, Integer&gt; hashMap = new HashMap&lt;People, Integer&gt;();</div><div class="line">        hashMap.put(p1, 1);</div><div class="line">         </div><div class="line">        System.out.println(hashMap.get(new People(&quot;Jack&quot;, 12)));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样一来的话，输出结果就为“1”了。</p><p>下面这段话摘自Effective Java一书：</p><ul><li>在程序执行期间，只要equals方法的比较操作用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法必须始终如一地返回同一个整数。</li><li>如果两个对象根据equals方法比较是相等的，那么调用两个对象的hashCode方法必须返回相同的整数结果。</li><li>如果两个对象根据equals方法比较是不等的，则hashCode方法不一定得返回不同的整数。</li></ul><p>对于第二条和第三条很好理解，但是第一条，很多时候就会忽略。在《Java编程思想》一书中的P495页也有同第一条类似的一段话：</p><p>“设计hashCode()时最重要的因素就是：无论何时，对同一个对象调用hashCode()都应该产生同样的值。如果在将一个对象用put()添加进HashMap时产生一个hashCdoe值，而用get()取出时却产生了另一个hashCode值，那么就无法获取该对象了。所以如果你的hashCode方法依赖于对象中易变的数据，用户就要当心了，因为此数据发生变化时，hashCode()方法就会生成一个不同的散列码”。</p><p>下面举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">import java.util.HashMap;</div><div class="line">import java.util.HashSet;</div><div class="line">import java.util.Set;</div><div class="line"> </div><div class="line"> </div><div class="line">class People&#123;</div><div class="line">    private String name;</div><div class="line">    private int age;</div><div class="line">     </div><div class="line">    public People(String name,int age) &#123;</div><div class="line">        this.name = name;</div><div class="line">        this.age = age;</div><div class="line">    &#125;  </div><div class="line">     </div><div class="line">    public void setAge(int age)&#123;</div><div class="line">        this.age = age;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    @Override</div><div class="line">    public int hashCode() &#123;</div><div class="line">        // TODO Auto-generated method stub</div><div class="line">        return name.hashCode()*37+age;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    @Override</div><div class="line">    public boolean equals(Object obj) &#123;</div><div class="line">        // TODO Auto-generated method stub</div><div class="line">        return this.name.equals(((People)obj).name) &amp;&amp; this.age== ((People)obj).age;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">public class Demo &#123;</div><div class="line"> </div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">         </div><div class="line">        People p1 = new People(&quot;Jack&quot;, 12);</div><div class="line">        System.out.println(p1.hashCode());</div><div class="line">         </div><div class="line">        HashMap&lt;People, Integer&gt; hashMap = new HashMap&lt;People, Integer&gt;();</div><div class="line">        hashMap.put(p1, 2);</div><div class="line">         </div><div class="line">        p1.setAge(13);</div><div class="line">         </div><div class="line">        System.out.println(hashMap.get(p1));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这段代码输出的结果为“null”，想必其中的原因大家应该都清楚了。</p><p>因此，在设计hashCode方法和equals方法的时候，如果对象中的数据易变，则最好在equals方法和hashCode方法中不要依赖于该字段。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;哈希表这个数据结构想必大多数人都不陌生，而且在很多地方都会利用到hash表来提高查找效率。在Java的Object类中有一个方法:&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java集合" scheme="http://yoursite.com/tags/Java%E9%9B%86%E5%90%88/"/>
    
      <category term="HashCode()" scheme="http://yoursite.com/tags/HashCode/"/>
    
      <category term="equal()" scheme="http://yoursite.com/tags/equal/"/>
    
  </entry>
  
  <entry>
    <title>Java集合学习手册（9）：Java 集合对比</title>
    <link href="http://yoursite.com/2017/08/17/Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C%EF%BC%889%EF%BC%89%EF%BC%9AJava%20%E9%9B%86%E5%90%88%E5%AF%B9%E6%AF%94/"/>
    <id>http://yoursite.com/2017/08/17/Java集合学习手册（9）：Java 集合对比/</id>
    <published>2017-08-17T14:20:45.000Z</published>
    <updated>2017-09-01T06:43:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、HashMap与HashTable的区别"><a href="#一、HashMap与HashTable的区别" class="headerlink" title="一、HashMap与HashTable的区别"></a>一、HashMap与HashTable的区别</h1><p>HashMap和Hashtable的比较是Java面试中的常见问题，用来考验程序员是否能够正确使用集合类以及是否可以随机应变使用多种思路解决问题。HashMap的工作原理、ArrayList与Vector的比较以及这个问题是有关Java 集合框架的最经典的问题。</p><a id="more"></a><p>Hashtable是个过时的集合类，存在于Java API中很久了。在Java 4中被重写了，实现了Map接口，所以自此以后也成了Java集合框架中的一部分。Hashtable和HashMap在Java面试中相当容易被问到，甚至成为了集合框架面试题中最常被考的问题，所以在参加任何Java面试之前，都不要忘了准备这一题。</p><p>HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：</p><div class="table-container"><table><thead><tr><th>HashMap</th><th>HashTable</th></tr></thead><tbody><tr><td>非线程安全（非线程同步）</td><td>线程安全（线程同步）</td></tr><tr><td>更适合于单线程</td><td>更适合于多线程</td></tr><tr><td>允许null值</td><td>不允许null值</td></tr><tr><td>迭代器Iterator是fail-fast迭代器</td><td>迭代器enumerator不是fail-fast的</td></tr><tr><td>初始容量为16</td><td>初始容量为11</td></tr></tbody></table></div><ul><li>两者最主要的区别在于Hashtable是线程安全，而HashMap则非线程安全</li></ul><p>HashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的</p><p>由于Hashtable的实现方法里面都添加了synchronized关键字来确保线程同步，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。仅在你需要完全的线程安全的时候使用Hashtable，而如果你使用Java 5或以上的话，请使用ConcurrentHashMap吧。</p><p>线程安全的实现原理：jvm有一个main memory，而每个线程有自己的working memory，一个线程对一个变量进行操作时，都要在自己的working memory里面建立一个copy，操作完之后再写入main memory。多个线程同时操作同一个变量，就可能会出现不可预知的结果。用synchronized的关键是建立一个镜像，这个镜像可以是要修改的变量也可以其他你认为合适的对象比如方法和类，然后通过给这个镜像加锁来实现线程安全，每个线程在获得这个锁之后，要执行完才会释放它得到的锁。这样就实现了所谓的线程安全。sychronized意味着在一次仅有一个线程能够更改Hashtable。就是说任何线程要更新Hashtable时要首先获得同步锁，其它线程要等到同步锁被释放之后才能再次获得同步锁更新Hashtable。</p><p>我们平时使用时若无特殊需求建议使用HashMap，在多线程环境下若使用HashMap需要使用Collections.synchronizedMap()方法来获取一个线程安全的集合（Collections.synchronizedMap()实现原理是Collections定义了一个SynchronizedMap的内部类，这个类实现了Map接口，在调用方法时使用synchronized来保证线程同步,当然了实际上操作的还是我们传入的HashMap实例，简单的说就是Collections.synchronizedMap()方法帮我们在操作HashMap时自动添加了synchronized来实现线程同步，类似的其它Collections.synchronizedXX方法也是类似原理）</p><ul><li>HashMap的迭代器Iterator是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。</li></ul><p>当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。</p><p>Fail-safe和iterator迭代器相关。如果某个集合对象创建了Iterator或者ListIterator，然后其它的线程试图“结构上”更改集合对象，将会抛出ConcurrentModificationException异常。但其它线程可以通过set()方法更改集合对象是允许的，因为这并没有从“结构上”更改集合。但是假如已经从结构上进行了更改，再调用set()方法，将会抛出IllegalArgumentException异常。</p><p>结构上的更改指的是删除或者插入一个元素，这样会影响到map的结构。</p><ul><li>HashMap可以使用null作为key，而Hashtable则不允许null作为key</li></ul><p>虽说HashMap支持null值作为key，不过建议还是尽量避免这样使用，因为一旦不小心使用了，若因此引发一些问题，排查起来很是费事。HashMap以null作为key时，总是存储在table数组的第一个节点上</p><ul><li>HashMap是对Map接口的实现，HashTable实现了Map接口和Dictionary抽象类</li><li>HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75</li><li>HashMap扩容时是当前容量翻倍即:$capacity<em>2$，Hashtable扩容时是容量翻倍+1即:$capacity</em>2+1$</li><li>两者计算hash的方法不同</li></ul><p>Hashtable计算hash是直接使用key的hashcode对table数组的长度直接进行取模</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int hash = key.hashCode();</div><div class="line">int index = (hash &amp; 0x7FFFFFFF) % tab.length;</div></pre></td></tr></table></figure><p>HashMap计算hash对key的hashcode进行了二次hash，以获得更好的散列值，然后对table数组长度取摸</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">static final int hash(Object key) &#123;</div><div class="line">    int h;</div><div class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static int indexFor(int h, int n) &#123;</div><div class="line">        return h &amp; (n-1);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h1 id="二、HashSet与HashMap的区别"><a href="#二、HashSet与HashMap的区别" class="headerlink" title="二、HashSet与HashMap的区别"></a>二、HashSet与HashMap的区别</h1><p>HashMap和HashSet的区别是Java面试中最常被问到的问题。如果没有涉及到Collection框架以及多线程的面试，可以说是不完整。而Collection框架的问题不涉及到HashSet和HashMap，也可以说是不完整。HashMap和HashSet都是collection框架的一部分，它们让我们能够使用对象的集合。collection框架有自己的接口和实现，主要分为Set接口，List接口和Queue接口。它们有各自的特点，Set的集合里不允许对象有重复的值，List允许有重复，它对集合中的对象进行索引，Queue的工作原理是FCFS算法(First Come, First Serve)。</p><p>首先让我们来看看什么是HashMap和HashSet，然后再来比较它们之间的分别。</p><h2 id="2-1-什么是HashSet"><a href="#2-1-什么是HashSet" class="headerlink" title="2.1 什么是HashSet"></a>2.1 什么是HashSet</h2><p>HashSet实现了Set接口，它不允许集合中有重复的值，当我们提到HashSet时，第一件事情就是在将对象存储在HashSet之前，要先确保对象重写equals()和hashCode()方法，这样才能比较对象的值是否相等，以确保set中没有储存相等的对象。如果我们没有重写这两个方法，将会使用这个方法的默认实现。</p><p>public boolean add(Object o)方法用来在Set中添加元素，当元素值重复时则会立即返回false，如果成功添加的话会返回true。</p><p>HashSet不是key value结构，仅仅是存储不重复的元素，相当于简化版的HashMap，只是仅仅包含HashMap中的key而已。通过查看源码也证实了这一点，HashSet内部就是使用HashMap实现，只不过HashSet里面的HashMap所有的value都是同一个Object而已，因此HashSet也是非线程安全的，至于HashSet和Hashtable的区别，HashSet就是个简化的HashMap的。</p><p>下面是HashSet几个主要方法的实现，更具体的可以参考【Java学习手册：Java HashSet】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">private transient HashMap&lt;E,Object&gt; map;</div><div class="line"> private static final Object PRESENT = new Object();</div><div class="line"> </div><div class="line"> public HashSet() &#123;</div><div class="line">   map = new HashMap&lt;E,Object&gt;();</div><div class="line">   &#125;</div><div class="line">public boolean contains(Object o) &#123;</div><div class="line">   return map.containsKey(o);</div><div class="line">   &#125;</div><div class="line">public boolean add(E e) &#123;</div><div class="line">   return map.put(e, PRESENT)==null;</div><div class="line">   &#125;</div><div class="line">public boolean add(E e) &#123;</div><div class="line">   return map.put(e, PRESENT)==null;</div><div class="line">   &#125;</div><div class="line">public boolean remove(Object o) &#123;</div><div class="line">   return map.remove(o)==PRESENT;</div><div class="line">   &#125;</div><div class="line"></div><div class="line"></div><div class="line">public void clear() &#123;</div><div class="line">   map.clear();</div><div class="line">   &#125;</div></pre></td></tr></table></figure><h2 id="2-2-什么是HashMap"><a href="#2-2-什么是HashMap" class="headerlink" title="2.2 什么是HashMap"></a>2.2 什么是HashMap</h2><p>HashMap实现了Map接口，Map接口对键值对进行映射。Map中不允许重复的键。Map接口有两个基本的实现，HashMap和TreeMap。TreeMap保存了对象的排列次序，而HashMap则不能。HashMap允许键和值为null。HashMap是非synchronized的，但collection框架提供方法能保证HashMap synchronized，这样多个线程同时访问HashMap时，能保证只有一个线程更改Map。</p><p>public Object put(Object Key,Object value)方法用来将元素添加到map中。</p><h2 id="2-3-HashSet和HashMap的区别"><a href="#2-3-HashSet和HashMap的区别" class="headerlink" title="2.3 HashSet和HashMap的区别"></a>2.3 HashSet和HashMap的区别</h2><div class="table-container"><table><thead><tr><th>HashMap</th><th>HashSet</th></tr></thead><tbody><tr><td>HashMap实现了Map接口</td><td>HashSet实现了Set接口</td></tr><tr><td>HashMap储存键值对</td><td>HashSet仅仅存储对象</td></tr><tr><td>使用put()方法将元素放入map中</td><td>使用add()方法将元素放入set中</td></tr><tr><td>HashMap中使用键对象来计算hashcode值</td><td>HashSet使用成员对象来计算hashcode值，equals()方法判断对象相等性，不同返回false</td></tr><tr><td>HashMap比较快，因为是使用唯一的键来获取对象</td><td>HashSet较HashMap来说比较慢</td></tr></tbody></table></div><h1 id="三、HashSet和TreeSet的区别"><a href="#三、HashSet和TreeSet的区别" class="headerlink" title="三、HashSet和TreeSet的区别"></a>三、HashSet和TreeSet的区别</h1><ul><li>Hashset 的底层是由hashTable实现的，add()，remove()，contains()方法的时间复杂度是O(1).可以放入null，但只能放入一个null。Treeset 底层是由红黑树实现的,add()，remove()，contains()方法的时间复杂度是O(logn)。不允许放入null值</li><li>如果需要在Treeset 中插入对象，需要实现Comparable 接口，为其指定比较策略：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class TreeSet&lt;E&gt;</div><div class="line">   extends AbstractSet&lt;E&gt;</div><div class="line">   implements SortedSet&lt;E&gt;, Cloneable, java.io.Serializable</div><div class="line">public class HashSet&lt;E&gt;</div><div class="line">   extends AbstractSet&lt;E&gt;</div><div class="line">   implements Set&lt;E&gt;, Cloneable, java.io.Serializable</div></pre></td></tr></table></figure><p>其中SortedSet中组合了一个：Comparator&lt;? super E&gt; comparator();</p><p>HashSet是基于Hash算法实现的,其性能通常优于TreeSet,我们通常都应该使用HashSet,在我们需要排序的功能时,我门才使用TreeSet</p><h1 id="四、ArrayList、LinkedList、Vector的底层实现和区别"><a href="#四、ArrayList、LinkedList、Vector的底层实现和区别" class="headerlink" title="四、ArrayList、LinkedList、Vector的底层实现和区别"></a>四、ArrayList、LinkedList、Vector的底层实现和区别</h1><h2 id="4-1-ArrayList"><a href="#4-1-ArrayList" class="headerlink" title="4.1 ArrayList"></a>4.1 ArrayList</h2><p>ArrayList是一个可以处理变长数组的类型，这里不局限于“数”组，ArrayList是一个泛型类，可以存放任意类型的对象。顾名思义，ArrayList是一个数组列表，因此其内部是使用一个数组来存放对象的，因为Object是一切类型的父类，因而ArrayList内部是有一个Object类型的数组类存放对象。ArrayList类常用的方法有add()、clear()、get()、indexOf()、remove()、sort()、toArray()、toString()等等，同时ArrayList内部有一个私有类实现Iterator接口，因此可以使用iterator()方法得到ArrayList的迭代器，同时，还有一个私有类实现了ListIterator接口，因此ArrayList也可以调用listIterator()方法得到ListIterator迭代器。</p><p>由于ArrayList是依靠数组来存放对象的，只不过封装起来了而已，因此其一些查找方法的效率都是O(n)，跟普通的数组效率差不多，只不过这个ArrayList是一个可变”数组“，并且可以存放一切指定的对象。</p><p>另外，由于ArrayList的所有方法都是默认在单一线程下进行的，因此ArrayList不具有线程安全性。若想在多线程下使用，应该使用Colletions类中的静态方法synchronizedList()对ArrayList进行调用即可。</p><h2 id="4-2-LinkedList"><a href="#4-2-LinkedList" class="headerlink" title="4.2 LinkedList"></a>4.2 LinkedList</h2><p>LinkedList可以看做为一个双向链表，所有的操作都可以认为是一个双向链表的操作，因为它实现了Deque接口和List接口。同样，LinkedList也是线程不安全的，如果在并发环境下使用它，同样用Colletions类中的静态方法synchronizedList()对LinkedList进行调用即可。</p><p>在LinkedList的内部实现中，并不是用普通的数组来存放数据的，而是使用结点<node>来存放数据的，有一个指向链表头的结点first和一个指向链表尾的结点last。不同于ArrayList只能在数组末尾添加数据，LinkList可以很方便在链表头或者链表尾插入数据，或者在指定结点前后插入数据，还提供了取走链表头或链表尾的结点，或取走中间某个结点，还可以查询某个结点是否存在。add()方法默认在链表尾部插入数据。总之，LinkedList提供了大量方便的操作方法，并且它的插入或增加等方法的效率明显高于ArrayList类型，但是查询的效率要低一点，因为它是一个双向链表。</node></p><p>因此，LinkedList与ArrayList最大的区别是LinkedList更加灵活，并且部分方法的效率比ArrayList对应方法的效率要高很多，对于数据频繁出入的情况下，并且要求操作要足够灵活，建议使用LinkedList；对于数组变动不大，主要是用来查询的情况下，可以使用ArrayList。</p><h2 id="4-3-Vector"><a href="#4-3-Vector" class="headerlink" title="4.3 Vector"></a>4.3 Vector</h2><p>Vector也是一个类似于ArrayList的可变长度的数组类型，它的内部也是使用数组来存放数据对象的。值得注意的是Vector与ArrayList唯一的区别是，Vector是线程安全的，即它的大部分方法都包含有关键字synchronized，因此，若对于单一线程的应用来说，最好使用ArrayList代替Vector，因为这样效率会快很多（类似的情况有StringBuffer与StringBuilder）；而在多线程程序中，为了保证数据的同步和一致性，可以使用Vector代替ArrayList实现同样的功能。</p><h1 id="五、数组-Array-和列表-ArrayList-的区别"><a href="#五、数组-Array-和列表-ArrayList-的区别" class="headerlink" title="五、数组(Array)和列表(ArrayList)的区别"></a>五、数组(Array)和列表(ArrayList)的区别</h1><ul><li>Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。</li><li>Array大小是固定的，ArrayList的大小是动态变化的。</li><li>ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。</li><li>ArrayList可以存任何Object，如String等。</li></ul><p>ArrayList与数组的区别主要就是由于动态增容的效率问题了。<br>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。因此基本类型用Array，动态变化用ArrayList。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、HashMap与HashTable的区别&quot;&gt;&lt;a href=&quot;#一、HashMap与HashTable的区别&quot; class=&quot;headerlink&quot; title=&quot;一、HashMap与HashTable的区别&quot;&gt;&lt;/a&gt;一、HashMap与HashTable的区别&lt;/h1&gt;&lt;p&gt;HashMap和Hashtable的比较是Java面试中的常见问题，用来考验程序员是否能够正确使用集合类以及是否可以随机应变使用多种思路解决问题。HashMap的工作原理、ArrayList与Vector的比较以及这个问题是有关Java 集合框架的最经典的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java集合" scheme="http://yoursite.com/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Java集合学习手册（8）：Java 集合框架</title>
    <link href="http://yoursite.com/2017/08/16/Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C%EF%BC%888%EF%BC%89%EF%BC%9AJava%20%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2017/08/16/Java集合学习手册（8）：Java 集合框架/</id>
    <published>2017-08-16T14:20:45.000Z</published>
    <updated>2017-09-01T06:43:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><h2 id="1-1-什么是集合？"><a href="#1-1-什么是集合？" class="headerlink" title="1.1 什么是集合？"></a>1.1 什么是集合？</h2><p>Java官方的入门文档是这样描述集合的：</p><a id="more"></a><p>Collection(有时候也叫container)是一个简单的对象，它把多个元素组织成一个单元。集合可以用来存储、检索、操作、通信。通常情况下，集合代表了一个自然数据项，比如一组手牌(牌的集合)、邮件文件夹(邮件的集合)、电话目录(姓名到电话的映射)。如果你使用过Java或者其他语言，你应该很熟悉集合。</p><h2 id="1-2-什么是集合框架？"><a href="#1-2-什么是集合框架？" class="headerlink" title="1.2 什么是集合框架？"></a>1.2 什么是集合框架？</h2><p>Collections Framework是一个用来表示和操作集合的统一的架构。集合的框架包括了：</p><ul><li>Interfaces:这些是表示集合的抽象数据类型，接口允许集合完成操作，独立与其详细的实现。在面向对象的语言中，接口构成了体系架构；</li><li>Implementations:这些是接口的具体实现。本质上，是一些可复用的数据结构；</li><li>Algorithms:这些方法可以对接口实现的对象进行有用的计算，比如搜索、排序。这些算法是具有多态性的：也就是说，同样的方法可以用在合适的接口的不同实现。本质上，是一些可复用的函数。</li></ul><p>除了Java的集合框架，还有一些著名的集合框架的例子：比如C++的STL和Smalltalk的集合架构。从历史上来看，集合框架可能比较复杂，也可能有一些很陡峭的学习曲线。不过我们相信Java的集合框架会突破这样的传统，在这章你就可以自己学会。</p><h2 id="1-3-使用集合框架有什么好处？"><a href="#1-3-使用集合框架有什么好处？" class="headerlink" title="1.3 使用集合框架有什么好处？"></a>1.3 使用集合框架有什么好处？</h2><p>Java的集合框架提供了一下优点：</p><ul><li>减少编程的工作量：通过提供有用的数据结构和算法，集合框架能让你更专注的实现程序的核心功能，而不是去做一个底层的“管道工”。Java框架通过促进无关API的互操作性，使得你不用自己去实现不同API的适配</li><li>提高程序的速度与质量：集合框架提供了一些有用数据结构和算法的高性能、高质量的实现。每个接口的不同的实现也是可以互换的，所以程序可以通过切换集合来做一些调整。正因为你从实现数据结构的那些苦差事中脱离出来，你才可以有更多的实现去改善你自己程序的性能和质量</li><li>允许无关APIs的互操作：集合接口是API之间传递集合的一个“方言”，比如我的网络管理API有一个节点名的集合，而GUI工具需要一个列标题的集合，即使是分开实现它们，我们的APIs也可以无缝的接合。</li><li>省力地学习和使用新API：这是另一个领先的优势，设计者和实现者没必要在每次都重新设计API的时候都“推倒重来”地实现集合，而是直接使用标准的集合接口就好了。</li><li>促进软件的复用：符合标准集合接口的新数据结构本质上是可以复用的。对于操作这些新数据结构算法也是一样可以复用的。</li></ul><h1 id="二、集合框架"><a href="#二、集合框架" class="headerlink" title="二、集合框架"></a>二、集合框架</h1><p>Java集合工具包位于Java.util包下，包含了很多常用的数据结构，如数组、链表、栈、队列、集合、哈希表等。学习Java集合框架下大致可以分为如下五个部分：List列表、Set集合、Map映射、迭代器（Iterator、Enumeration）、工具类（Arrays、Collections）。</p><p>Java集合类的整体框架如下：<br><img src="http://omu7tit09.bkt.clouddn.com/15030392418135.jpg" alt=""></p><p>从上图中可以看出，集合类主要分为两大类：Collection和Map。</p><p>Collection是List、Set等集合高度抽象出来的接口，它包含了这些集合的基本操作，它主要又分为两大部分：List和Set。</p><p>List接口通常表示一个列表（数组、队列、链表、栈等），其中的元素可以重复，常用实现类为ArrayList和LinkedList，另外还有不常用的Vector。</p><p>另外，LinkedList还是实现了Queue接口，因此也可以作为队列使用。</p><p>Set接口通常表示一个集合，其中的元素不允许重复（通过hashcode和equals函数保证），常用实现类有HashSet和TreeSet，HashSet是通过Map中的HashMap实现的，而TreeSet是通过Map中的TreeMap实现的。另外，TreeSet还实现了SortedSet接口，因此是有序的集合（集合中的元素要实现Comparable接口，并覆写Compartor函数才行）。我们看到，抽象类AbstractCollection、AbstractList和AbstractSet分别实现了Collection、List和Set接口，这就是在Java集合框架中用的很多的适配器设计模式，用这些抽象类去实现接口，在抽象类中实现接口中的若干或全部方法，这样下面的一些类只需直接继承该抽象类，并实现自己需要的方法即可，而不用实现接口中的全部抽象方法。</p><p>Map是一个映射接口，其中的每个元素都是一个key-value键值对，同样抽象类AbstractMap通过适配器模式实现了Map接口中的大部分函数，TreeMap、HashMap、WeakHashMap等实现类都通过继承AbstractMap来实现，另外，不常用的HashTable直接实现了Map接口，它和Vector都是JDK1.0就引入的集合类。</p><p>Iterator是遍历集合的迭代器（不能遍历Map，只用来遍历Collection），Collection的实现类都实现了iterator()函数，它返回一个Iterator对象，用来遍历集合，ListIterator则专门用来遍历List。而Enumeration则是JDK1.0时引入的，作用与Iterator相同，但它的功能比Iterator要少，它只能再Hashtable、Vector和Stack中使用。</p><p>Arrays和Collections是用来操作数组、集合的两个工具类，例如在ArrayList和Vector中大量调用了Arrays.Copyof()方法，而Collections中有很多静态方法可以返回各集合类的synchronized版本，即线程安全的版本，当然了，如果要用线程安全的结合类，首选Concurrent并发包下的对应的集合类。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、概念&quot;&gt;&lt;a href=&quot;#一、概念&quot; class=&quot;headerlink&quot; title=&quot;一、概念&quot;&gt;&lt;/a&gt;一、概念&lt;/h1&gt;&lt;h2 id=&quot;1-1-什么是集合？&quot;&gt;&lt;a href=&quot;#1-1-什么是集合？&quot; class=&quot;headerlink&quot; title=&quot;1.1 什么是集合？&quot;&gt;&lt;/a&gt;1.1 什么是集合？&lt;/h2&gt;&lt;p&gt;Java官方的入门文档是这样描述集合的：&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java集合" scheme="http://yoursite.com/tags/Java%E9%9B%86%E5%90%88/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="LinkedList" scheme="http://yoursite.com/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>Java集合学习手册（7）：Java LinkedList</title>
    <link href="http://yoursite.com/2017/08/15/Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C%EF%BC%887%EF%BC%89%EF%BC%9AJava%20LinkedList/"/>
    <id>http://yoursite.com/2017/08/15/Java集合学习手册（7）：Java LinkedList/</id>
    <published>2017-08-15T14:20:45.000Z</published>
    <updated>2017-09-01T06:43:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>LinkedList和ArrayList一样，都实现了List接口，但其内部的数据结构有本质的不同。LinkedList是基于链表实现的（通过名字也能区分开来），所以它的插入和删除操作比ArrayList更加高效。但也是由于其为基于链表的，所以随机访问的效率要比ArrayList差。</p><a id="more"></a><p>看一下LinkedList的类的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public class LinkedList&lt;E&gt;</div><div class="line">    extends AbstractSequentialList&lt;E&gt;</div><div class="line">    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</div><div class="line">&#123;&#125;</div></pre></td></tr></table></figure><p>LinkedList继承自AbstractSequenceList，实现了List、Deque、Cloneable、java.io.Serializable接口。AbstractSequenceList提供了List接口骨干性的实现以减少实现List接口的复杂度，Deque接口定义了双端队列的操作。</p><p>在LinkedList中除了本身自己的方法外，还提供了一些可以使其作为栈、队列或者双端队列的方法。这些方法可能彼此之间只是名字不同，以使得这些名字在特定的环境中显得更加合适。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">LinkedList&lt;String&gt; list = new LinkedList&lt;String&gt;();</div><div class="line">list.add(&quot;语文: 1&quot;);</div><div class="line">list.add(&quot;数学: 2&quot;);</div><div class="line">list.add(&quot;英语: 3&quot;);</div></pre></td></tr></table></figure><p>结构也相对简单一些，如下图所示：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15024160251749.png" alt=""></p><h2 id="二、数据结构"><a href="#二、数据结构" class="headerlink" title="二、数据结构"></a>二、数据结构</h2><p>LinkedList是基于链表结构实现，所以在类中包含了first和last两个指针(Node)。Node中包含了上一个节点和下一个节点的引用，这样就构成了双向的链表。每个Node只能知道自己的前一个节点和后一个节点，但对于链表来说，这已经足够了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line"><span class="keyword">transient</span> Node&lt;E&gt; first; <span class="comment">//链表的头指针</span></div><div class="line"><span class="keyword">transient</span> Node&lt;E&gt; last; <span class="comment">//尾指针</span></div><div class="line"><span class="comment">//存储对象的结构 Node, LinkedList的内部类</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    E item;</div><div class="line">    Node&lt;E&gt; next; <span class="comment">// 指向下一个节点</span></div><div class="line">    Node&lt;E&gt; prev; <span class="comment">//指向上一个节点</span></div><div class="line"></div><div class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</div><div class="line">        <span class="keyword">this</span>.item = element;</div><div class="line">        <span class="keyword">this</span>.next = next;</div><div class="line">        <span class="keyword">this</span>.prev = prev;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="三、存储"><a href="#三、存储" class="headerlink" title="三、存储"></a>三、存储</h2><h3 id="3-1-add-E-e"><a href="#3-1-add-E-e" class="headerlink" title="3.1 add(E e)"></a>3.1 add(E e)</h3><p>该方法是在链表的end添加元素，其调用了自己的方法linkLast(E e)。</p><p>该方法首先将last的Node引用指向了一个新的Node(l)，然后根据l新建了一个newNode，其中的元素就为要添加的e；而后，我们让last指向了newNode。接下来是自身进行维护该链表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Appends the specified element to the end of this list.</div><div class="line">     *</div><div class="line">     * &lt;p&gt;This method is equivalent to &#123;@link #addLast&#125;.</div><div class="line">     *</div><div class="line">     * @param e element to be appended to this list</div><div class="line">     * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;)</div><div class="line">     */</div><div class="line">public boolean add(E e) &#123;</div><div class="line">    linkLast(e);</div><div class="line">    return true;</div><div class="line">&#125;</div><div class="line">/**</div><div class="line">* Links e as last element.</div><div class="line">*/</div><div class="line">void linkLast(E e) &#123;</div><div class="line">    final Node&lt;E&gt; l = last;</div><div class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</div><div class="line">    last = newNode;</div><div class="line">    if (l == null)</div><div class="line">        first = newNode;</div><div class="line">    else</div><div class="line">        l.next = newNode;</div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-2-add-int-index-E-element"><a href="#3-2-add-int-index-E-element" class="headerlink" title="3.2 add(int index, E element)"></a>3.2 add(int index, E element)</h3><p>该方法是在指定index位置插入元素。如果index位置正好等于size，则调用linkLast(element)将其插入末尾；否则调用 linkBefore(element, node(index))方法进行插入。该方法的实现在下面，大家可以自己仔细的分析一下。（分析链表的时候最好能够边画图边分析）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">    * Inserts the specified element at the specified position in this list.</div><div class="line">    * Shifts the element currently at that position (if any) and any</div><div class="line">    * subsequent elements to the right (adds one to their indices).</div><div class="line">    *</div><div class="line">    * @param index index at which the specified element is to be inserted</div><div class="line">    * @param element element to be inserted</div><div class="line">    * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</div><div class="line">    */</div><div class="line">   public void add(int index, E element) &#123;</div><div class="line">       checkPositionIndex(index);</div><div class="line"></div><div class="line">       if (index == size)</div><div class="line">           linkLast(element);</div><div class="line">       else</div><div class="line">           linkBefore(element, node(index));</div><div class="line">   &#125;</div><div class="line">   /**</div><div class="line">        * Inserts element e before non-null Node succ.</div><div class="line">        */</div><div class="line">       void linkBefore(E e, Node&lt;E&gt; succ) &#123;</div><div class="line">           // assert succ != null;</div><div class="line">           final Node&lt;E&gt; pred = succ.prev;</div><div class="line">           final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);</div><div class="line">           succ.prev = newNode;</div><div class="line">           if (pred == null)</div><div class="line">               first = newNode;</div><div class="line">           else</div><div class="line">               pred.next = newNode;</div><div class="line">           size++;</div><div class="line">           modCount++;</div><div class="line">       &#125;</div></pre></td></tr></table></figure><p>LinkedList的方法实在是太多，在这没法一一举例分析。但很多方法其实都只是在调用别的方法而已，所以建议大家将其几个最核心的添加的方法搞懂就可以了，比如linkBefore、linkLast。其本质也就是链表之间的删除添加等。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;p&gt;LinkedList和ArrayList一样，都实现了List接口，但其内部的数据结构有本质的不同。LinkedList是基于链表实现的（通过名字也能区分开来），所以它的插入和删除操作比ArrayList更加高效。但也是由于其为基于链表的，所以随机访问的效率要比ArrayList差。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java集合" scheme="http://yoursite.com/tags/Java%E9%9B%86%E5%90%88/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="LinkedList" scheme="http://yoursite.com/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>Java集合学习手册（6）：Java ArrayList</title>
    <link href="http://yoursite.com/2017/08/14/Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C%EF%BC%886%EF%BC%89%EF%BC%9AJava%20ArrayList/"/>
    <id>http://yoursite.com/2017/08/14/Java集合学习手册（6）：Java ArrayList/</id>
    <published>2017-08-14T14:20:45.000Z</published>
    <updated>2017-09-01T06:43:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>ArrayList可以理解为动态数组，就是Array的复杂版本。与Java中的数组相比，它的容量能动态增长。ArrayList是List接口的可变数组的实现。实现了所有可选列表操作，并允许包括 null 在内的所有元素。除了实现 List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。（此类大致上等同于 Vector 类，除了此类是不同步的。）</p><a id="more"></a><p>每个ArrayList实例都有一个容量，该容量是指用来存储列表元素的数组的大小。它总是至少等于列表的大小。随着向ArrayList中不断添加元素，其容量也自动增长。自动增长会带来数据向新数组的重新拷贝，因此，如果可预知数据量的多少，可在构造ArrayList时指定其容量。在添加大量元素前，应用程序也可以使用ensureCapacity操作来增加ArrayList实例的容量，这可以减少递增式再分配的数量。</p><p>注意，此实现不是同步的。如果多个线程同时访问一个ArrayList实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。（结构上的修改是指任何添加或删除一个或多个元素的操作，或者显式调整底层数组的大小；仅仅设置元素的值不是结构上的修改。）</p><p>我们先学习了解其内部的实现原理，才能更好的理解其应用。</p><h2 id="二、ArrayList的实现"><a href="#二、ArrayList的实现" class="headerlink" title="二、ArrayList的实现"></a>二、ArrayList的实现</h2><p>对于ArrayList而言，它实现List接口、底层使用数组保存所有元素。其操作基本上是对数组的操作。下面我们来分析ArrayList的源代码：</p><h3 id="2-1-List接口"><a href="#2-1-List接口" class="headerlink" title="2.1 List接口"></a>2.1 List接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></div><div class="line">&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>ArrayList继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。</p><p>ArrayList实现了RandmoAccess接口，即提供了随机访问功能。RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在ArrayList中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。</p><p>ArrayList实现了Cloneable接口，即覆盖了函数clone()，能被克隆。</p><p>ArrayList实现java.io.Serializable接口，这意味着ArrayList支持序列化，能通过序列化去传输。</p><h3 id="2-2-底层使用数组实现"><a href="#2-2-底层使用数组实现" class="headerlink" title="2.2 底层使用数组实现"></a>2.2 底层使用数组实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* The array buffer into which the elements of the ArrayList are stored.</div><div class="line">* The capacity of the ArrayList is the length of this array buffer.</div><div class="line">*/</div><div class="line">private transient Object[] elementData;</div></pre></td></tr></table></figure><h3 id="2-3-构造方法"><a href="#2-3-构造方法" class="headerlink" title="2.3 构造方法"></a>2.3 构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Constructs an empty list with an initial capacity of ten.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(<span class="number">10</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * Constructs an empty list with the specified initial capacity.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span>  initialCapacity  the initial capacity of the list</div><div class="line"> * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</div><div class="line"> *         is negative</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</div><div class="line">                                           initialCapacity);</div><div class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Constructs a list containing the elements of the specified</div><div class="line"> * collection, in the order they are returned by the collection's</div><div class="line"> * iterator.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> c the collection whose elements are to be placed into this list</div><div class="line"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">    elementData = c.toArray();</div><div class="line">    size = elementData.length;</div><div class="line">    <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></div><div class="line">    <span class="keyword">if</span> (elementData.getClass() != Object[].class)</div><div class="line">        elementData = Arrays.copyOf(elementData, size, Object[].class);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>ArrayList提供了三种方式的构造器：</p><ul><li>public ArrayList()：可以构造一个默认初始容量为10的空列表；</li><li>public ArrayList(int initialCapacity)：构造一个指定初始容量的空列表；</li><li>public ArrayList(Collection&lt;? extends E&gt; c)：构造一个包含指定collection的元素的列表，这些元素按照该collection的迭代器返回它们的顺序排列的。</li></ul><h3 id="2-4-存储"><a href="#2-4-存储" class="headerlink" title="2.4 存储"></a>2.4 存储</h3><p>ArrayList提供了set(int index, E element)、add(E e)、add(int index, E element)、addAll(Collection&lt;? extends E&gt; c)、addAll(int index, Collection&lt;? extends E&gt; c)这些添加元素的方法。下面我们一一讲解：</p><ul><li>set(int index, E element)：该方法首先调用rangeCheck(index)来校验index变量是否超出数组范围，超出则抛出异常。而后，取出原index位置的值，并且将新的element放入Index位置，返回oldValue。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Replaces the element at the specified position in this list with</div><div class="line"> * the specified element.</div><div class="line"> *</div><div class="line"> * @param index index of the element to replace</div><div class="line"> * @param element element to be stored at the specified position</div><div class="line"> * @return the element previously at the specified position</div><div class="line"> * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</div><div class="line"> */</div><div class="line"> // 用指定的元素替代此列表中指定位置上的元素，并返回以前位于该位置上的元素。</div><div class="line">public E set(int index, E element) &#123;</div><div class="line">    rangeCheck(index);</div><div class="line"></div><div class="line">    E oldValue = elementData(index);</div><div class="line">    elementData[index] = element;</div><div class="line">    return oldValue;</div><div class="line">&#125;</div><div class="line">/**</div><div class="line">  * Checks if the given index is in range.  If not, throws an appropriate</div><div class="line">  * runtime exception.  This method does *not* check if the index is</div><div class="line">  * negative: It is always used immediately prior to an array access,</div><div class="line">  * which throws an ArrayIndexOutOfBoundsException if index is negative.</div><div class="line">  */</div><div class="line">  private void rangeCheck(int index) &#123;</div><div class="line">    if (index &gt;= size)</div><div class="line">    throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line">  &#125;</div></pre></td></tr></table></figure><ul><li>add(E e)：该方法是将指定的元素添加到列表的尾部。当容量不足时，会调用grow方法增长容量。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Appends the specified element to the end of this list.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> e element to be appended to this list</div><div class="line"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</div><div class="line"> */</div><div class="line"> <span class="comment">// 将指定的元素添加到此列表的尾部。</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">    elementData[size++] = e;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line">    <span class="comment">// overflow-conscious code</span></div><div class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</div><div class="line">        grow(minCapacity);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">// overflow-conscious code</span></div><div class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">        newCapacity = minCapacity;</div><div class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</div><div class="line">        newCapacity = hugeCapacity(minCapacity);</div><div class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></div><div class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>add(int index, E element)：在index位置插入element。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Inserts the specified element at the specified position in this</div><div class="line"> * list. Shifts the element currently at that position (if any) and</div><div class="line"> * any subsequent elements to the right (adds one to their indices).</div><div class="line"> *</div><div class="line"> * @param index index at which the specified element is to be inserted</div><div class="line"> * @param element element to be inserted</div><div class="line"> * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</div><div class="line"> */</div><div class="line"> // 将指定的元素插入此列表中的指定位置。  </div><div class="line">// 如果当前位置有元素，则向右移动当前位于该位置的元素以及所有后续元素（将其索引加1）。</div><div class="line">public void add(int index, E element) &#123;</div><div class="line">    rangeCheckForAdd(index);</div><div class="line">    // 如果数组长度不足，将进行扩容。</div><div class="line">    ensureCapacityInternal(size + 1);  // Increments modCount!!</div><div class="line">    // 将 elementData中从Index位置开始、长度为size-index的元素，  </div><div class="line">    // 拷贝到从下标为index+1位置开始的新的elementData数组中。  </div><div class="line">    // 即将当前位于该位置的元素以及所有后续元素右移一个位置。</div><div class="line">    System.arraycopy(elementData, index, elementData, index + 1,</div><div class="line">                     size - index);</div><div class="line">    elementData[index] = element;</div><div class="line">    size++;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>addAll(Collection&lt;? extends E&gt; c)和addAll(int index, Collection&lt;? extends E&gt; c)：将特定Collection中的元素添加到Arraylist末尾。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Appends all of the elements in the specified collection to the end of</div><div class="line">     * this list, in the order that they are returned by the</div><div class="line">     * specified collection&apos;s Iterator.  The behavior of this operation is</div><div class="line">     * undefined if the specified collection is modified while the operation</div><div class="line">     * is in progress.  (This implies that the behavior of this call is</div><div class="line">     * undefined if the specified collection is this list, and this</div><div class="line">     * list is nonempty.)</div><div class="line">     *</div><div class="line">     * @param c collection containing elements to be added to this list</div><div class="line">     * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call</div><div class="line">     * @throws NullPointerException if the specified collection is null</div><div class="line">     */</div><div class="line">     // 按照指定collection的迭代器所返回的元素顺序，将该collection中的所有元素添加到此列表的尾部。 </div><div class="line">    public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</div><div class="line">        Object[] a = c.toArray();</div><div class="line">        int numNew = a.length;</div><div class="line">        ensureCapacityInternal(size + numNew);  // Increments modCount</div><div class="line">        System.arraycopy(a, 0, elementData, size, numNew);</div><div class="line">        size += numNew;</div><div class="line">        return numNew != 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Inserts all of the elements in the specified collection into this</div><div class="line">     * list, starting at the specified position.  Shifts the element</div><div class="line">     * currently at that position (if any) and any subsequent elements to</div><div class="line">     * the right (increases their indices).  The new elements will appear</div><div class="line">     * in the list in the order that they are returned by the</div><div class="line">     * specified collection&apos;s iterator.</div><div class="line">     *</div><div class="line">     * @param index index at which to insert the first element from the</div><div class="line">     *              specified collection</div><div class="line">     * @param c collection containing elements to be added to this list</div><div class="line">     * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call</div><div class="line">     * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</div><div class="line">     * @throws NullPointerException if the specified collection is null</div><div class="line">     */</div><div class="line">     // 从指定的位置开始，将指定collection中的所有元素插入到此列表中。</div><div class="line">    public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</div><div class="line">        rangeCheckForAdd(index);</div><div class="line"></div><div class="line">        Object[] a = c.toArray();</div><div class="line">        int numNew = a.length;</div><div class="line">        ensureCapacityInternal(size + numNew);  // Increments modCount</div><div class="line"></div><div class="line">        int numMoved = size - index;</div><div class="line">        if (numMoved &gt; 0)</div><div class="line">            System.arraycopy(elementData, index, elementData, index + numNew,</div><div class="line">                             numMoved);</div><div class="line"></div><div class="line">        System.arraycopy(a, 0, elementData, index, numNew);</div><div class="line">        size += numNew;</div><div class="line">        return numNew != 0;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>在ArrayList的存储方法，其核心本质是在数组的某个位置将元素添加进入。但其中又会涉及到关于数组容量不够而增长等因素。</p><h3 id="2-5-读取"><a href="#2-5-读取" class="headerlink" title="2.5 读取"></a>2.5 读取</h3><p>这个方法就比较简单了，ArrayList能够支持随机访问的原因也是很显然的，因为它内部的数据结构是数组，而数组本身就是支持随机访问。该方法首先会判断输入的index值是否越界，然后将数组的index位置的元素返回即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* Returns the element at the specified position in this list.</div><div class="line">*</div><div class="line">* @param  index index of the element to return</div><div class="line">* @return the element at the specified position in this list</div><div class="line">* @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</div><div class="line">*/</div><div class="line">// 返回此列表中指定位置上的元素。</div><div class="line">public E get(int index) &#123;</div><div class="line">    rangeCheck(index);</div><div class="line">    return (E) elementData[index];</div><div class="line">&#125;</div><div class="line">private void rangeCheck(int index) &#123;</div><div class="line">    if (index &gt;= size)</div><div class="line">    throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-6-删除"><a href="#2-6-删除" class="headerlink" title="2.6 删除"></a>2.6 删除</h3><p>ArrayList提供了根据下标或者指定对象两种方式的删除功能。需要注意的是该方法的返回值并不相同，如下：</p><ul><li>根据下标删除：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">// 移除此列表中指定位置上的元素。</div><div class="line">    /**</div><div class="line">     * Removes the element at the specified position in this list.</div><div class="line">     * Shifts any subsequent elements to the left (subtracts one from their</div><div class="line">     * indices).</div><div class="line">     *</div><div class="line">     * @param index the index of the element to be removed</div><div class="line">     * @return the element that was removed from the list</div><div class="line">     * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</div><div class="line">     */</div><div class="line">    public E remove(int index) &#123;</div><div class="line">        rangeCheck(index);</div><div class="line"></div><div class="line">        modCount++;</div><div class="line">        E oldValue = elementData(index);</div><div class="line"></div><div class="line">        int numMoved = size - index - 1;</div><div class="line">        if (numMoved &gt; 0)</div><div class="line">            System.arraycopy(elementData, index+1, elementData, index,</div><div class="line">                             numMoved);</div><div class="line">        elementData[--size] = null; // Let gc do its work</div><div class="line"></div><div class="line">        return oldValue;</div><div class="line">    &#125;</div><div class="line">```   </div><div class="line"></div><div class="line">- 指定对象删除：</div><div class="line"></div><div class="line"></div><div class="line">```java</div><div class="line">/**</div><div class="line">     * Removes the first occurrence of the specified element from this list,</div><div class="line">     * if it is present.  If the list does not contain the element, it is</div><div class="line">     * unchanged.  More formally, removes the element with the lowest index</div><div class="line">     * &lt;tt&gt;i&lt;/tt&gt; such that</div><div class="line">     * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;</div><div class="line">     * (if such an element exists).  Returns &lt;tt&gt;true&lt;/tt&gt; if this list</div><div class="line">     * contained the specified element (or equivalently, if this list</div><div class="line">     * changed as a result of the call).</div><div class="line">     *</div><div class="line">     * @param o element to be removed from this list, if present</div><div class="line">     * @return &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element</div><div class="line">     */</div><div class="line">     // 移除此列表中首次出现的指定元素（如果存在）。这是应为ArrayList中允许存放重复的元素。</div><div class="line">    public boolean remove(Object o) &#123;</div><div class="line">    // 由于ArrayList中允许存放null，因此下面通过两种情况来分别处理。</div><div class="line">        if (o == null) &#123;</div><div class="line">            for (int index = 0; index &lt; size; index++)</div><div class="line">                if (elementData[index] == null) &#123;</div><div class="line">                // 类似remove(int index)，移除列表中指定位置上的元素。</div><div class="line">                    fastRemove(index);</div><div class="line">                    return true;</div><div class="line">                &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            for (int index = 0; index &lt; size; index++)</div><div class="line">                if (o.equals(elementData[index])) &#123;</div><div class="line">                    fastRemove(index);</div><div class="line">                    return true;</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>注意：从数组中移除元素的操作，也会导致被移除的元素以后的所有元素的向左移动一个位置。</p><h3 id="2-7-调整数组容量"><a href="#2-7-调整数组容量" class="headerlink" title="2.7 调整数组容量"></a>2.7 调整数组容量</h3><p>从上面介绍的向ArrayList中存储元素的代码中，我们看到，每当向数组中添加元素时，都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行扩容，以满足添加数据的需求。数组扩容有两个方法，其中开发者可以通过一个public的方法ensureCapacity(int minCapacity)来增加ArrayList的容量，而在存储元素等操作过程中，如果遇到容量不足，会调用priavte方法private void ensureCapacityInternal(int minCapacity)实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public void ensureCapacity(int minCapacity) &#123;</div><div class="line">    if (minCapacity &gt; 0)</div><div class="line">        ensureCapacityInternal(minCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void ensureCapacityInternal(int minCapacity) &#123;</div><div class="line">    modCount++;</div><div class="line">    // overflow-conscious code</div><div class="line">    if (minCapacity - elementData.length &gt; 0)</div><div class="line">        grow(minCapacity);</div><div class="line">&#125;</div><div class="line">/**</div><div class="line"> * Increases the capacity to ensure that it can hold at least the</div><div class="line"> * number of elements specified by the minimum capacity argument.</div><div class="line"> *</div><div class="line"> * @param minCapacity the desired minimum capacity</div><div class="line"> */</div><div class="line">private void grow(int minCapacity) &#123;</div><div class="line">    // overflow-conscious code</div><div class="line">    int oldCapacity = elementData.length;</div><div class="line">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</div><div class="line">    if (newCapacity - minCapacity &lt; 0)</div><div class="line">        newCapacity = minCapacity;</div><div class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</div><div class="line">        newCapacity = hugeCapacity(minCapacity);</div><div class="line">    // minCapacity is usually close to size, so this is a win:</div><div class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>从上述代码中可以看出，数组进行扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量的增长大约是其原容量的1.5倍（从int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)这行代码得出）。这种操作的代价是很高的，因此在实际使用时，我们应该尽量避免数组容量的扩张。当我们可预知要保存的元素的多少时，要在构造ArrayList实例时，就指定其容量，以避免数组扩容的发生。或者根据实际需求，通过调用ensureCapacity方法来手动增加ArrayList实例的容量。</p><p>ArrayList还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能。它可以通过trimToSize方法来实现。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void trimToSize() &#123;  </div><div class="line">    modCount++;  </div><div class="line">    int oldCapacity = elementData.length;  </div><div class="line">    if (size &lt; oldCapacity) &#123;  </div><div class="line">        elementData = Arrays.copyOf(elementData, size);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-8-Fail-Fast机制"><a href="#2-8-Fail-Fast机制" class="headerlink" title="2.8 Fail-Fast机制"></a>2.8 Fail-Fast机制</h3><p>ArrayList也采用了快速失败的机制，通过记录modCount参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。关于Fail-Fast的更详细的介绍，在之前HashMap中已经提到。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;p&gt;ArrayList可以理解为动态数组，就是Array的复杂版本。与Java中的数组相比，它的容量能动态增长。ArrayList是List接口的可变数组的实现。实现了所有可选列表操作，并允许包括 null 在内的所有元素。除了实现 List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。（此类大致上等同于 Vector 类，除了此类是不同步的。）&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java集合" scheme="http://yoursite.com/tags/Java%E9%9B%86%E5%90%88/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="ArrayList" scheme="http://yoursite.com/tags/ArrayList/"/>
    
  </entry>
  
  <entry>
    <title>Java集合学习手册（5）：Java LinkedHashSet</title>
    <link href="http://yoursite.com/2017/08/13/Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C%EF%BC%885%EF%BC%89%EF%BC%9AJava%20LinkedHashSet/"/>
    <id>http://yoursite.com/2017/08/13/Java集合学习手册（5）：Java LinkedHashSet/</id>
    <published>2017-08-13T12:20:45.000Z</published>
    <updated>2017-09-01T06:43:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>首先我们需要知道的是它是一个Set的实现，所以它其中存的肯定不是键值对，而是值。此实现与HashSet的不同之处在于，LinkedHashSet维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可为插入顺序或是访问顺序。</p><a id="more"></a><p>看到上面的介绍，是不是感觉其与HashMap和LinkedHashMap的关系很像？</p><p>注意，此实现不是同步的。如果多个线程同时访问链接的哈希Set，而其中至少一个线程修改了该Set，则它必须保持外部同步。</p><p>在【Java学习手册：LinkedHashMap】中，通过例子演示了HashMap和LinkedHashMap的区别。举一反三，我们现在学习的LinkedHashSet与之前的很相同，只不过之前存的是键值对，而现在存的只有值。</p><p>LinkedHashSet是可以按照插入顺序或者访问顺序进行迭代。</p><h2 id="二、LinkedHashSet的实现"><a href="#二、LinkedHashSet的实现" class="headerlink" title="二、LinkedHashSet的实现"></a>二、LinkedHashSet的实现</h2><p>对于LinkedHashSet而言，它继承与HashSet、又基于LinkedHashMap来实现的。<br>LinkedHashSet底层使用LinkedHashMap来保存所有元素，它继承与HashSet，其所有的方法操作上又与HashSet相同，因此LinkedHashSet的实现上非常简单，只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个LinkedHashMap来实现，在相关操作上与父类HashSet的操作相同，直接调用父类HashSet的方法即可。LinkedHashSet的源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSet</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">    <span class="keyword">extends</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</div><div class="line">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2851667679971038690L</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构造一个带有指定初始容量和加载因子的新空链接哈希set。</div><div class="line">     *</div><div class="line">     * 底层会调用父类的构造方法，构造一个有指定初始容量和加载因子的LinkedHashMap实例。</div><div class="line">     * <span class="doctag">@param</span> initialCapacity 初始容量。</div><div class="line">     * <span class="doctag">@param</span> loadFactor 加载因子。</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor, <span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构造一个带指定初始容量和默认加载因子0.75的新空链接哈希set。</div><div class="line">     *</div><div class="line">     * 底层会调用父类的构造方法，构造一个带指定初始容量和默认加载因子0.75的LinkedHashMap实例。</div><div class="line">     * <span class="doctag">@param</span> initialCapacity 初始容量。</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(initialCapacity, .<span class="number">75f</span>, <span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构造一个带默认初始容量16和加载因子0.75的新空链接哈希set。</div><div class="line">     *</div><div class="line">     * 底层会调用父类的构造方法，构造一个带默认初始容量16和加载因子0.75的LinkedHashMap实例。</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(<span class="number">16</span>, .<span class="number">75f</span>, <span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构造一个与指定collection中的元素相同的新链接哈希set。</div><div class="line">     *</div><div class="line">     * 底层会调用父类的构造方法，构造一个足以包含指定collection</div><div class="line">     * 中所有元素的初始容量和加载因子为0.75的LinkedHashMap实例。</div><div class="line">     * <span class="doctag">@param</span> c 其中的元素将存放在此set中的collection。</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(Math.max(<span class="number">2</span>*c.size(), <span class="number">11</span>), .<span class="number">75f</span>, <span class="keyword">true</span>);</div><div class="line">        addAll(c);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>以上几乎就是LinkedHashSet的全部代码了，那么读者可能就会怀疑了，不是说LinkedHashSet是基于LinkedHashMap实现的吗？那我为什么在源码中甚至都没有看到出现过LinkedHashMap。不要着急，我们可以看到在LinkedHashSet的构造方法中，其调用了父类的构造方法。我们可以进去看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。</div><div class="line">     * 此构造函数为包访问权限，不对外公开，实际只是是对LinkedHashSet的支持。</div><div class="line">     *</div><div class="line">     * 实际底层会以指定的参数构造一个空LinkedHashMap实例来实现。</div><div class="line">     * @param initialCapacity 初始容量。</div><div class="line">     * @param loadFactor 加载因子。</div><div class="line">     * @param dummy 标记。</div><div class="line">     */</div><div class="line">HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;</div><div class="line">    map = new LinkedHashMap&lt;E,Object&gt;(initialCapacity, loadFactor);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在父类HashSet中，专为LinkedHashSet提供的构造方法如下，该方法为包访问权限，并未对外公开。<br>由上述源代码可见，LinkedHashSet通过继承HashSet，底层使用LinkedHashMap，以很简单明了的方式来实现了其自身的所有功能。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>以上就是关于LinkedHashSet的内容，我们只是从概述上以及构造方法这几个方面介绍了，并不是我们不想去深入其读取或者写入方法，而是其本身没有实现，只是继承于父类HashSet的方法。</p><p>所以我们需要注意的点是：</p><ul><li>LinkedHashSet是Set的一个具体实现，其维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可为插入顺序或是访问顺序。</li><li>LinkedHashSet继承与HashSet，并且其内部是通过LinkedHashMap来实现的。有点类似于我们之前说的LinkedHashMap其内部是基于Hashmap实现一样，不过还是有一点点区别的（具体的区别大家可以自己去思考一下）。</li><li>如果我们需要迭代的顺序为插入顺序或者访问顺序，那么LinkedHashSet是需要你首先考虑的。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;p&gt;首先我们需要知道的是它是一个Set的实现，所以它其中存的肯定不是键值对，而是值。此实现与HashSet的不同之处在于，LinkedHashSet维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可为插入顺序或是访问顺序。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java集合" scheme="http://yoursite.com/tags/Java%E9%9B%86%E5%90%88/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="LinkedHashSet" scheme="http://yoursite.com/tags/LinkedHashSet/"/>
    
  </entry>
  
  <entry>
    <title>Java集合学习手册（4）：Java LinkedHashMap</title>
    <link href="http://yoursite.com/2017/08/12/Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C%EF%BC%884%EF%BC%89%EF%BC%9AJava%20LinkedHashMap/"/>
    <id>http://yoursite.com/2017/08/12/Java集合学习手册（4）：Java LinkedHashMap/</id>
    <published>2017-08-12T11:20:45.000Z</published>
    <updated>2017-09-01T06:43:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>HashMap是无序的，HashMap在put的时候是根据key的hashcode进行hash然后放入对应的地方。所以在按照一定顺序put进HashMap中，然后遍历出HashMap的顺序跟put的顺序不同（除非在put的时候key已经按照hashcode排序好了，这种几率非常小）</p><a id="more"></a><p>JAVA在JDK1.4以后提供了LinkedHashMap来帮助我们实现了有序的HashMap。</p><p>LinkedHashMap是HashMap的一个子类，它保留插入的顺序， 如果需要输出的顺序和输入时的相同，那么就选用LinkedHashMap。</p><p>LinkedHashMap是Map接口的哈希表和链接列表实现，具有可预知的迭代顺序。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p><p>LinkedHashMap实现与HashMap的不同之处在于，LinkedHashMap维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。</p><p>注意，此实现不是同步的。如果多个线程同时访问链接的哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步。</p><p>根据链表中元素的顺序可以分为：按插入顺序的链表和按访问顺序(调用get方法)的链表。默认是按插入顺序排序，如果指定按访问顺序排序，那么调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。</p><p>我们写一个简单的LinkedHashMap的程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">LinkedHashMap&lt;String, Integer&gt; lmap = <span class="keyword">new</span> LinkedHashMap&lt;String, Integer&gt;();</div><div class="line">lmap.put(<span class="string">"语文"</span>, <span class="number">1</span>);</div><div class="line">lmap.put(<span class="string">"数学"</span>, <span class="number">2</span>);</div><div class="line">lmap.put(<span class="string">"英语"</span>, <span class="number">3</span>);</div><div class="line">lmap.put(<span class="string">"历史"</span>, <span class="number">4</span>);</div><div class="line">lmap.put(<span class="string">"政治"</span>, <span class="number">5</span>);</div><div class="line">lmap.put(<span class="string">"地理"</span>, <span class="number">6</span>);</div><div class="line">lmap.put(<span class="string">"生物"</span>, <span class="number">7</span>);</div><div class="line">lmap.put(<span class="string">"化学"</span>, <span class="number">8</span>);</div><div class="line"><span class="keyword">for</span>(Entry&lt;String, Integer&gt; entry : lmap.entrySet()) &#123;</div><div class="line">    System.out.println(entry.getKey() + <span class="string">": "</span> + entry.getValue());</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">语文: 1</div><div class="line">数学: 2</div><div class="line">英语: 3</div><div class="line">历史: 4</div><div class="line">政治: 5</div><div class="line">地理: 6</div><div class="line">生物: 7</div><div class="line">化学: 8</div></pre></td></tr></table></figure><p>我们可以观察到，和HashMap的运行结果不同，LinkedHashMap的迭代输出的结果保持了插入顺序。是什么样的结构使得LinkedHashMap具有如此特性呢？我们还是一样的看看LinkedHashMap的内部结构，对它有一个感性的认识：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15023793078176.png" alt=""></p><blockquote><p>Hash table and linked list implementation of the Map interface, with predictable iteration order. This implementation differs from HashMap in that it maintains a doubly-linked list running through all of its entries. This linked list defines the iteration ordering, which is normally the order in which keys were inserted into the map (insertion-order).</p></blockquote><p>没错，正如官方文档所说：LinkedHashMap是Hash表和链表的实现，并且依靠着双向链表保证了迭代顺序是插入的顺序。</p><h2 id="二、插入顺序、访问顺序的演示"><a href="#二、插入顺序、访问顺序的演示" class="headerlink" title="二、插入顺序、访问顺序的演示"></a>二、插入顺序、访问顺序的演示</h2><p>先做几个demo来演示一下LinkedHashMap的使用。看懂了其效果，然后再来研究其原理。</p><h3 id="2-1-HashMap"><a href="#2-1-HashMap" class="headerlink" title="2.1 HashMap"></a>2.1 HashMap</h3><p>看下面这个代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();</div><div class="line">map.put(&quot;apple&quot;, &quot;苹果&quot;);</div><div class="line">map.put(&quot;watermelon&quot;, &quot;西瓜&quot;);</div><div class="line">map.put(&quot;banana&quot;, &quot;香蕉&quot;);</div><div class="line">map.put(&quot;peach&quot;, &quot;桃子&quot;);</div><div class="line"></div><div class="line">Iterator iter = map.entrySet().iterator();</div><div class="line">while (iter.hasNext()) &#123;</div><div class="line">Map.Entry entry = (Map.Entry) iter.next();</div><div class="line">System.out.println(entry.getKey() + &quot;=&quot; + entry.getValue());</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>一个比较简单的测试HashMap的代码，通过控制台的输出，我们可以看到HashMap是没有顺序的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">banana=香蕉</div><div class="line">apple=苹果</div><div class="line">peach=桃子</div><div class="line">watermelon=西瓜</div></pre></td></tr></table></figure><h3 id="2-2-LinkedHashMap"><a href="#2-2-LinkedHashMap" class="headerlink" title="2.2 LinkedHashMap"></a>2.2 LinkedHashMap</h3><p>我们现在将map的实现换成LinkedHashMap，其他代码不变：<code>Map&lt;String, String&gt; map = new LinkedHashMap&lt;String, String&gt;();</code><br>看一下控制台的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">apple=苹果</div><div class="line">watermelon=西瓜</div><div class="line">banana=香蕉</div><div class="line">peach=桃子</div></pre></td></tr></table></figure><p>我们可以看到，其输出顺序是完成按照插入顺序的！也就是我们上面所说的保留了插入的顺序。我们不是在上面还提到过其可以按照访问顺序进行排序么？好的，我们还是通过一个例子来验证一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">Map&lt;String, String&gt; map = new LinkedHashMap&lt;String, String&gt;(16,0.75f,true);</div><div class="line">map.put(&quot;apple&quot;, &quot;苹果&quot;);</div><div class="line">map.put(&quot;watermelon&quot;, &quot;西瓜&quot;);</div><div class="line">map.put(&quot;banana&quot;, &quot;香蕉&quot;);</div><div class="line">map.put(&quot;peach&quot;, &quot;桃子&quot;);</div><div class="line"></div><div class="line">map.get(&quot;banana&quot;);</div><div class="line">map.get(&quot;apple&quot;);</div><div class="line"></div><div class="line">Iterator iter = map.entrySet().iterator();</div><div class="line">while (iter.hasNext()) &#123;</div><div class="line">Map.Entry entry = (Map.Entry) iter.next();</div><div class="line">System.out.println(entry.getKey() + &quot;=&quot; + entry.getValue());</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>代码与之前的都差不多，但我们多了两行代码，并且初始化LinkedHashMap的时候，用的构造函数也不相同，看一下控制台的输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">watermelon=西瓜</div><div class="line">peach=桃子</div><div class="line">banana=香蕉</div><div class="line">apple=苹果</div></pre></td></tr></table></figure><p>这也就是我们之前提到过的，LinkedHashMap可以选择按照访问顺序进行排序。</p><h2 id="三、LinkedHashMap的实现"><a href="#三、LinkedHashMap的实现" class="headerlink" title="三、LinkedHashMap的实现"></a>三、LinkedHashMap的实现</h2><p>对于LinkedHashMap而言，它继承于HashMap、底层使用哈希表与双向链表来保存所有元素。其基本操作与父类HashMap相似，它通过重写父类相关的方法，来实现自己的链接列表特性。下面我们来分析LinkedHashMap的源代码：</p><h3 id="3-1-成员变量"><a href="#3-1-成员变量" class="headerlink" title="3.1 成员变量"></a>3.1 成员变量</h3><p>LinkedHashMap采用的hash算法和HashMap相同，但是它重新定义了数组中保存的元素Entry，该Entry除了保存当前对象的引用外，还保存了其上一个元素before和下一个元素after的引用，从而在哈希表的基础上又构成了双向链接列表。看源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;</div><div class="line">* for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order.</div><div class="line">* 如果为true，则按照访问顺序；如果为false，则按照插入顺序。</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 双向链表的表头元素。</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; header;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* LinkedHashMap的Entry元素。</div><div class="line">* 继承HashMap的Entry元素，又保存了其上一个元素before和下一个元素after的引用。</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; before, after;</div><div class="line">    ……</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>LinkedHashMap中的Entry集成与HashMap的Entry，但是其增加了before和after的引用，指的是上一个元素和下一个元素的引用。</p><h3 id="3-2-初始化"><a href="#3-2-初始化" class="headerlink" title="3.2 初始化"></a>3.2 初始化</h3><p>通过源代码可以看出，在LinkedHashMap的构造方法中，实际调用了父类HashMap的相关构造方法来构造一个底层存放的table数组，但额外可以增加accessOrder这个参数，如果不设置，默认为false，代表按照插入顺序进行迭代；当然可以显式设置为true，代表以访问顺序进行迭代。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public LinkedHashMap(int initialCapacity, float loadFactor,boolean accessOrder) &#123;</div><div class="line">    super(initialCapacity, loadFactor);</div><div class="line">    this.accessOrder = accessOrder;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p> HashMap中的相关构造方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public HashMap(int initialCapacity, float loadFactor) &#123;  </div><div class="line">    if (initialCapacity &lt; 0)  </div><div class="line">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +  </div><div class="line">                                           initialCapacity);  </div><div class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)  </div><div class="line">        initialCapacity = MAXIMUM_CAPACITY;  </div><div class="line">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))  </div><div class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +  </div><div class="line">                                           loadFactor);  </div><div class="line">  </div><div class="line">    // Find a power of 2 &gt;= initialCapacity  </div><div class="line">    int capacity = 1;  </div><div class="line">    while (capacity &lt; initialCapacity)  </div><div class="line">        capacity &lt;&lt;= 1;  </div><div class="line">  </div><div class="line">    this.loadFactor = loadFactor;  </div><div class="line">    threshold = (int)(capacity * loadFactor);  </div><div class="line">    table = new Entry[capacity];  </div><div class="line">    init();  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们已经知道LinkedHashMap的Entry元素继承HashMap的Entry，提供了双向链表的功能。在上述HashMap的构造器<br>中，最后会调用init()方法，进行相关的初始化，这个方法在HashMap的实现中并无意义，只是提供给子类实现相关的初始化调用。</p><p>LinkedHashMap重写了init()方法，在调用父类的构造方法完成构造后，进一步实现了对其元素Entry的初始化操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* Called by superclass constructors and pseudoconstructors (clone,</div><div class="line">* readObject) before any entries are inserted into the map.  Initializes</div><div class="line">* the chain.</div><div class="line">*/</div><div class="line">@Override</div><div class="line">void init() &#123;</div><div class="line">  header = new Entry&lt;&gt;(-1, null, null, null);</div><div class="line">  header.before = header.after = header;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-3-存储"><a href="#3-3-存储" class="headerlink" title="3.3 存储"></a>3.3 存储</h3><p>LinkedHashMap并未重写父类HashMap的put方法，而是重写了父类HashMap的put方法调用的子方法void recordAccess(HashMap m) ，void addEntry(int hash, K key, V value, int bucketIndex) 和void createEntry(int hash, K key, V value, int bucketIndex)，提供了自己特有的双向链接列表的实现。我们在之前的文章中已经讲解了HashMap的put方法，我们在这里重新贴一下HashMap的put方法的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> putForNullKey(value);</div><div class="line">        <span class="keyword">int</span> hash = hash(key);</div><div class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">            Object k;</div><div class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</div><div class="line">                V oldValue = e.value;</div><div class="line">                e.value = value;</div><div class="line">                e.recordAccess(<span class="keyword">this</span>);</div><div class="line">                <span class="keyword">return</span> oldValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        modCount++;</div><div class="line">        addEntry(hash, key, value, i);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>重写方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</div><div class="line">    LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;</div><div class="line">    <span class="keyword">if</span> (lm.accessOrder) &#123;</div><div class="line">        lm.modCount++;</div><div class="line">        remove();</div><div class="line">        addBefore(lm.header);</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</div><div class="line">    <span class="comment">// 调用create方法，将新元素以双向链表的的形式加入到映射中。</span></div><div class="line">    createEntry(hash, key, value, bucketIndex);</div><div class="line"></div><div class="line">    <span class="comment">// 删除最近最少使用元素的策略定义</span></div><div class="line">    Entry&lt;K,V&gt; eldest = header.after;</div><div class="line">    <span class="keyword">if</span> (removeEldestEntry(eldest)) &#123;</div><div class="line">        removeEntryForKey(eldest.key);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (size &gt;= threshold)</div><div class="line">            resize(<span class="number">2</span> * table.length);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</div><div class="line">    HashMap.Entry&lt;K,V&gt; old = table[bucketIndex];</div><div class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;K,V&gt;(hash, key, value, old);</div><div class="line">    table[bucketIndex] = e;</div><div class="line">    <span class="comment">// 调用元素的addBrefore方法，将元素加入到哈希、双向链接列表。  </span></div><div class="line">    e.addBefore(header);</div><div class="line">    size++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addBefore</span><span class="params">(Entry&lt;K,V&gt; existingEntry)</span> </span>&#123;</div><div class="line">    after  = existingEntry;</div><div class="line">    before = existingEntry.before;</div><div class="line">    before.after = <span class="keyword">this</span>;</div><div class="line">    after.before = <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-4-读取"><a href="#3-4-读取" class="headerlink" title="3.4 读取"></a>3.4 读取</h3><p>LinkedHashMap重写了父类HashMap的get方法，实际在调用父类getEntry()方法取得查找的元素后，再判断当排序模式accessOrder为true时，记录访问顺序，将最新访问的元素添加到双向链表的表头，并从原来的位置删除。由于的链表的增加、删除操作是常量级的，故并不会带来性能的损失。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="comment">// 调用父类HashMap的getEntry()方法，取得要查找的元素。</span></div><div class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)getEntry(key);</div><div class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    <span class="comment">// 记录访问顺序。</span></div><div class="line">    e.recordAccess(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">return</span> e.value;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</div><div class="line">    LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;</div><div class="line">    <span class="comment">// 如果定义了LinkedHashMap的迭代顺序为访问顺序，</span></div><div class="line">    <span class="comment">// 则删除以前位置上的元素，并将最新访问的元素添加到链表表头。  </span></div><div class="line">    <span class="keyword">if</span> (lm.accessOrder) &#123;</div><div class="line">        lm.modCount++;</div><div class="line">        remove();</div><div class="line">        addBefore(lm.header);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* Removes this entry from the linked list.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">    before.after = after;</div><div class="line">    after.before = before;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**clear链表，设置header为初始状态*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="keyword">super</span>.clear();</div><div class="line"> header.before = header.after = header;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>LinkedHashMap的这些额外操作基本上都是为了维护好那个具有访问顺序的双向链表，目的就是保持双向链表中节点的顺序要从eldest到youngest。</p><h3 id="3-4-排序模式"><a href="#3-4-排序模式" class="headerlink" title="3.4 排序模式"></a>3.4 排序模式</h3><p>LinkedHashMap定义了排序模式accessOrder，该属性为boolean型变量，对于访问顺序，为true；对于插入顺序，则为false。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private final boolean accessOrder;</div></pre></td></tr></table></figure><p>一般情况下，不必指定排序模式，其迭代顺序即为默认为插入顺序。看LinkedHashMap的构造方法，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public LinkedHashMap(int initialCapacity, float loadFactor) &#123;  </div><div class="line">    super(initialCapacity, loadFactor);  </div><div class="line">    accessOrder = false;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这些构造方法都会默认指定排序模式为插入顺序。如果你想构造一个LinkedHashMap，并打算按从近期访问最少到近期访问最多的顺序（即访问顺序）来保存元素，那么请使用下面的构造方法构造LinkedHashMap：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public LinkedHashMap(int initialCapacity,  </div><div class="line">         float loadFactor,  </div><div class="line">                     boolean accessOrder) &#123;  </div><div class="line">    super(initialCapacity, loadFactor);  </div><div class="line">    this.accessOrder = accessOrder;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>该哈希映射的迭代顺序就是最后访问其条目的顺序，这种映射很适合构建LRU缓存。LinkedHashMap提供了removeEldestEntry(Map.Entry<k,v> eldest)方法，在将新条目插入到映射后，put和 putAll将调用此方法。该方法可以提供在每次添加新条目时移除最旧条目的实现程序，默认返回false，这样，此映射的行为将类似于正常映射，即永远不能移除最旧的元素。</k,v></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123;  </div><div class="line">    return false;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>此方法通常不以任何方式修改映射，相反允许映射在其返回值的指引下进行自我修改。如果用此映射构建LRU缓存，则非常方便，它允许映射通过删除旧条目来减少内存损耗。</p><p>例如：重写此方法，维持此映射只保存100个条目的稳定状态，在每次添加新条目时删除最旧的条目。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private static final int MAX_ENTRIES = 100;  </div><div class="line">protected boolean removeEldestEntry(Map.Entry eldest) &#123;  </div><div class="line">    return size() &gt; MAX_ENTRIES;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>其实LinkedHashMap几乎和HashMap一样：从技术上来说，不同的是它定义了一个Entry header，这个header不是放在Table里，它是额外独立出来的。LinkedHashMap通过继承hashMap中的Entry,并添加两个属性Entry before,after,和header结合起来组成一个双向链表，来实现按插入顺序或访问顺序排序。</p><p>在写关于LinkedHashMap的过程中，记起来之前面试的过程中遇到的一个问题，也是问我Map的哪种实现可以做到按照插入顺序进行迭代？当时脑子是突然短路的，但现在想想，也只能怪自己对这个知识点还是掌握的不够扎实，所以又从头认真的把代码看了一遍。</p><p>不过，我的建议是，大家首先首先需要记住的是：LinkedHashMap能够做到按照插入顺序或者访问顺序进行迭代，这样在我们以后的开发中遇到相似的问题，才能想到用LinkedHashMap来解决，否则就算对其内部结构非常了解，不去使用也是没有什么用的。我们学习的目的是为了更好的应用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;p&gt;HashMap是无序的，HashMap在put的时候是根据key的hashcode进行hash然后放入对应的地方。所以在按照一定顺序put进HashMap中，然后遍历出HashMap的顺序跟put的顺序不同（除非在put的时候key已经按照hashcode排序好了，这种几率非常小）&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java集合" scheme="http://yoursite.com/tags/Java%E9%9B%86%E5%90%88/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="LinkedHashMap" scheme="http://yoursite.com/tags/LinkedHashMap/"/>
    
  </entry>
  
  <entry>
    <title>Java集合学习手册（3）：Java HashTable</title>
    <link href="http://yoursite.com/2017/08/11/Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C%EF%BC%883%EF%BC%89%EF%BC%9AJava%20HashTable/"/>
    <id>http://yoursite.com/2017/08/11/Java集合学习手册（3）：Java HashTable/</id>
    <published>2017-08-11T10:20:45.000Z</published>
    <updated>2017-09-01T06:43:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>和HashMap一样，Hashtable也是一个散列表，它存储的内容是键值对。</p><a id="more"></a><p>Hashtable在Java中的定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;  </span></div><div class="line">    <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;  </div><div class="line">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>&#123;&#125;</div></pre></td></tr></table></figure><p>从源码中，我们可以看出，Hashtable继承于Dictionary类，实现了Map, Cloneable, java.io.Serializable接口。其中Dictionary类是任何可将键映射到相应值的类（如 Hashtable）的抽象父类，每个键和值都是对象（源码注释为：The Dictionary class is the abstract parent of any class, such as Hashtable, which maps keys to values. Every key and every value is an object.）。但其Dictionary源码注释是这样的：NOTE: This class is obsolete. New implementations should implement the Map interface, rather than extending this class. 该话指出Dictionary这个类过时了，新的实现类应该实现Map接口。</p><h2 id="二、成员变量"><a href="#二、成员变量" class="headerlink" title="二、成员变量"></a>二、成员变量</h2><p>Hashtable是通过”拉链法”实现的哈希表。它包括几个重要的成员变量：table, count, threshold, loadFactor, modCount。</p><ul><li>table是一个Entry[]数组类型，而Entry（在HashMap中有讲解过）实际上就是一个单向链表。哈希表的”key-value键值对”都是存储在Entry数组中的。</li><li>count是Hashtable的大小，它是Hashtable保存的键值对的数量。</li><li>threshold是Hashtable的阈值，用于判断是否需要调整Hashtable的容量。threshold的值=”容量*加载因子”。</li><li>loadFactor就是加载因子。</li><li>modCount是用来实现fail-fast机制的。</li></ul><p>变量的解释在源码注释中如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * The hash table data.</div><div class="line">     */</div><div class="line">    private transient Entry&lt;K,V&gt;[] table;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * The total number of entries in the hash table.</div><div class="line">     */</div><div class="line">    private transient int count;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * The table is rehashed when its size exceeds this threshold.  (The</div><div class="line">     * value of this field is (int)(capacity * loadFactor).)</div><div class="line">     *</div><div class="line">     * @serial</div><div class="line">     */</div><div class="line">    private int threshold;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * The load factor for the hashtable.</div><div class="line">     *</div><div class="line">     * @serial</div><div class="line">     */</div><div class="line">    private float loadFactor;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * The number of times this Hashtable has been structurally modified</div><div class="line">     * Structural modifications are those that change the number of entries in</div><div class="line">     * the Hashtable or otherwise modify its internal structure (e.g.,</div><div class="line">     * rehash).  This field is used to make iterators on Collection-views of</div><div class="line">     * the Hashtable fail-fast.  (See ConcurrentModificationException).</div><div class="line">     */</div><div class="line">    private transient int modCount = 0;</div></pre></td></tr></table></figure><h2 id="三、构造方法"><a href="#三、构造方法" class="headerlink" title="三、构造方法"></a>三、构造方法</h2><p>Hashtable一共提供了4个构造方法：</p><ul><li>public Hashtable(int initialCapacity, float loadFactor)： 用指定初始容量和指定加载因子构造一个新的空哈希表。useAltHashing为boolean，其如果为真，则执行另一散列的字符串键，以减少由于弱哈希计算导致的哈希冲突的发生。</li><li>public Hashtable(int initialCapacity)：用指定初始容量和默认的加载因子 (0.75) 构造一个新的空哈希表。</li><li>public Hashtable()：默认构造函数，容量为11，加载因子为0.75。</li><li>public Hashtable(Map&lt;? extends K, ? extends V&gt; t)：构造一个与给定的 Map 具有相同映射关系的新哈希表。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Constructs a new, empty hashtable with the specified initial</div><div class="line">     * capacity and the specified load factor.</div><div class="line">     *</div><div class="line">     * @param      initialCapacity   the initial capacity of the hashtable.</div><div class="line">     * @param      loadFactor        the load factor of the hashtable.</div><div class="line">     * @exception  IllegalArgumentException  if the initial capacity is less</div><div class="line">     *             than zero, or if the load factor is nonpositive.</div><div class="line">     */</div><div class="line">    public Hashtable(int initialCapacity, float loadFactor) &#123;</div><div class="line">        if (initialCapacity &lt; 0)</div><div class="line">            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</div><div class="line">                                               initialCapacity);</div><div class="line">        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</div><div class="line">            throw new IllegalArgumentException(&quot;Illegal Load: &quot;+loadFactor);</div><div class="line"></div><div class="line">        if (initialCapacity==0)</div><div class="line">            initialCapacity = 1;</div><div class="line">        this.loadFactor = loadFactor;</div><div class="line">        table = new Entry[initialCapacity];</div><div class="line">        threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1);</div><div class="line">        useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</div><div class="line">                (initialCapacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Constructs a new, empty hashtable with the specified initial capacity</div><div class="line">     * and default load factor (0.75).</div><div class="line">     *</div><div class="line">     * @param     initialCapacity   the initial capacity of the hashtable.</div><div class="line">     * @exception IllegalArgumentException if the initial capacity is less</div><div class="line">     *              than zero.</div><div class="line">     */</div><div class="line">    public Hashtable(int initialCapacity) &#123;</div><div class="line">        this(initialCapacity, 0.75f);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Constructs a new, empty hashtable with a default initial capacity (11)</div><div class="line">     * and load factor (0.75).</div><div class="line">     */</div><div class="line">    public Hashtable() &#123;</div><div class="line">        this(11, 0.75f);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Constructs a new hashtable with the same mappings as the given</div><div class="line">     * Map.  The hashtable is created with an initial capacity sufficient to</div><div class="line">     * hold the mappings in the given Map and a default load factor (0.75).</div><div class="line">     *</div><div class="line">     * @param t the map whose mappings are to be placed in this map.</div><div class="line">     * @throws NullPointerException if the specified map is null.</div><div class="line">     * @since   1.2</div><div class="line">     */</div><div class="line">    public Hashtable(Map&lt;? extends K, ? extends V&gt; t) &#123;</div><div class="line">        this(Math.max(2*t.size(), 11), 0.75f);</div><div class="line">        putAll(t);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h2 id="四、put方法"><a href="#四、put方法" class="headerlink" title="四、put方法"></a>四、put方法</h2><p>put方法的整个流程为：</p><ul><li>判断value是否为空，为空则抛出异常；</li><li>计算key的hash值，并根据hash值获得key在table数组中的位置index，如果table[index]元素不为空，则进行迭代，如果遇到相同的key，则直接替换，并返回旧value；</li><li>否则，我们可以将其插入到table[index]位置。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">        <span class="comment">// Make sure the value is not null确保value不为null</span></div><div class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// Makes sure the key is not already in the hashtable.</span></div><div class="line">        <span class="comment">//确保key不在hashtable中</span></div><div class="line">        <span class="comment">//首先，通过hash方法计算key的哈希值，并计算得出index值，确定其在table[]中的位置</span></div><div class="line">        <span class="comment">//其次，迭代index索引位置的链表，如果该位置处的链表存在相同的key，则替换value，返回旧的value</span></div><div class="line">        Entry tab[] = table;</div><div class="line">        <span class="keyword">int</span> hash = hash(key);</div><div class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</div><div class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</div><div class="line">                V old = e.value;</div><div class="line">                e.value = value;</div><div class="line">                <span class="keyword">return</span> old;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        modCount++;</div><div class="line">        <span class="keyword">if</span> (count &gt;= threshold) &#123;</div><div class="line">            <span class="comment">// Rehash the table if the threshold is exceeded</span></div><div class="line">            <span class="comment">//如果超过阀值，就进行rehash操作</span></div><div class="line">            rehash();</div><div class="line"></div><div class="line">            tab = table;</div><div class="line">            hash = hash(key);</div><div class="line">            index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Creates the new entry.</span></div><div class="line">        <span class="comment">//将值插入，返回的为null</span></div><div class="line">        Entry&lt;K,V&gt; e = tab[index];</div><div class="line">        <span class="comment">// 创建新的Entry节点，并将新的Entry插入Hashtable的index位置，并设置e为新的Entry的下一个元素</span></div><div class="line">        tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</div><div class="line">        count++;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>通过一个实际的例子来演示一下这个过程：<br>假设我们现在Hashtable的容量为5，已经存在了(5,5)，(13,13)，(16,16)，(17,17)，(21,21)这5个键值对，目前他们在Hashtable中的位置如下：<br><img src="http://omu7tit09.bkt.clouddn.com/15023714291484.png" alt=""></p><p>现在，我们插入一个新的键值对，put(16,22)，假设key=16的索引为1.但现在索引1的位置有两个Entry了，所以程序会对链表进行迭代。迭代的过程中，发现其中有一个Entry的key和我们要插入的键值对的key相同，所以现在会做的工作就是将newValue=22替换oldValue=16，然后返回oldValue=16.<br><img src="http://omu7tit09.bkt.clouddn.com/15023714474343.png" alt=""></p><p>然后我们现在再插入一个，put(33,33)，key=33的索引为3，并且在链表中也不存在key=33的Entry，所以将该节点插入链表的第一个位置。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15023714638218.png" alt=""></p><h2 id="五、get方法"><a href="#五、get方法" class="headerlink" title="五、get方法"></a>五、get方法</h2><p>相比较于put方法，get方法则简单很多。其过程就是首先通过hash()方法求得key的哈希值，然后根据hash值得到index索引（上述两步所用的算法与put方法都相同）。然后迭代链表，返回匹配的key的对应的value；找不到则返回null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        Entry tab[] = table;</div><div class="line">        <span class="keyword">int</span> hash = hash(key);</div><div class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</div><div class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</div><div class="line">                <span class="keyword">return</span> e.value;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h2 id="六、遍历方式"><a href="#六、遍历方式" class="headerlink" title="六、遍历方式"></a>六、遍历方式</h2><p>Hashtable有多种遍历方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">//1、使用keys()</div><div class="line">Enumeration&lt;String&gt; en1 = table.keys();</div><div class="line">    while(en1.hasMoreElements()) &#123;</div><div class="line">    en1.nextElement();</div><div class="line">&#125;</div><div class="line"></div><div class="line">//2、使用elements()</div><div class="line">Enumeration&lt;String&gt; en2 = table.elements();</div><div class="line">    while(en2.hasMoreElements()) &#123;</div><div class="line">    en2.nextElement();</div><div class="line">&#125;</div><div class="line"></div><div class="line">//3、使用keySet()</div><div class="line">Iterator&lt;String&gt; it1 = table.keySet().iterator();</div><div class="line">    while(it1.hasNext()) &#123;</div><div class="line">    it1.next();</div><div class="line">&#125;</div><div class="line"></div><div class="line">//4、使用entrySet()</div><div class="line">Iterator&lt;Entry&lt;String, String&gt;&gt; it2 = table.entrySet().iterator();</div><div class="line">    while(it2.hasNext()) &#123;</div><div class="line">    it2.next();</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;p&gt;和HashMap一样，Hashtable也是一个散列表，它存储的内容是键值对。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java集合" scheme="http://yoursite.com/tags/Java%E9%9B%86%E5%90%88/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
  </entry>
  
  <entry>
    <title>Java集合学习手册（2）：Java HashSet</title>
    <link href="http://yoursite.com/2017/08/10/Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C%EF%BC%882%EF%BC%89%EF%BC%9AJava%20HashSet/"/>
    <id>http://yoursite.com/2017/08/10/Java集合学习手册（2）：Java HashSet/</id>
    <published>2017-08-10T15:20:45.000Z</published>
    <updated>2017-09-01T06:43:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><blockquote><p>This class implements the Set interface, backed by a hash table (actually a HashMap instance). It makes no guarantees as to the iteration order of the set; in particular, it does not guarantee that the order will remain constant over time. This class permits the null element.</p></blockquote><a id="more"></a><p>HashSet实现Set接口，由哈希表（实际上是一个HashMap实例）支持。它不保证set 的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用null元素。</p><p>HashSet是基于HashMap来实现的，操作很简单，更像是对HashMap做了一次“封装”，而且只使用了HashMap的key来实现各种特性，我们先来感性的认识一下这个结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">HashSet&lt;String&gt; set = new HashSet&lt;String&gt;();</div><div class="line">set.add(&quot;语文&quot;);</div><div class="line">set.add(&quot;数学&quot;);</div><div class="line">set.add(&quot;英语&quot;);</div><div class="line">set.add(&quot;历史&quot;);</div><div class="line">set.add(&quot;政治&quot;);</div><div class="line">set.add(&quot;地理&quot;);</div><div class="line">set.add(&quot;生物&quot;);</div><div class="line">set.add(&quot;化学&quot;);</div></pre></td></tr></table></figure><p><img src="http://omu7tit09.bkt.clouddn.com/15023694419846.png" alt=""></p><p>通过HashSet最简单的构造函数和几个成员变量来看一下，证明咱们上边说的，其底层是HashMap：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</div><div class="line"></div><div class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</div><div class="line"> * default initial capacity (16) and load factor (0.75).</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</div><div class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其实在英文注释中已经说的比较明确了。首先有一个HashMap的成员变量，我们在HashSet的构造函数中将其初始化，默认情况下采用的是initial capacity为16，load factor为0.75。</p><h2 id="二、HashSet的实现"><a href="#二、HashSet的实现" class="headerlink" title="二、HashSet的实现"></a>二、HashSet的实现</h2><p> 对于HashSet而言，它是基于HashMap实现的，HashSet底层使用HashMap来保存所有元素，因此HashSet 的实现比较简单，相关HashSet的操作，基本上都是直接调用底层HashMap的相关方法来完成，只不过HashSet里面的HashMap所有的value都是同一个Object而已。HashSet的源代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div></pre></td><td class="code"><pre><div class="line">public class HashSet&lt;E&gt;  </div><div class="line">    extends AbstractSet&lt;E&gt;  </div><div class="line">    implements Set&lt;E&gt;, Cloneable, java.io.Serializable  </div><div class="line">&#123;  </div><div class="line">    static final long serialVersionUID = -5024744406713321676L;  </div><div class="line">  </div><div class="line">    // 底层使用HashMap来保存HashSet中所有元素。  </div><div class="line">    private transient HashMap&lt;E,Object&gt; map;  </div><div class="line">      </div><div class="line">    // 定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。  </div><div class="line">    private static final Object PRESENT = new Object();  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 默认的无参构造器，构造一个空的HashSet。 </div><div class="line">     *  </div><div class="line">     * 实际底层会初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。 </div><div class="line">     */  </div><div class="line">    public HashSet() &#123;  </div><div class="line">    map = new HashMap&lt;E,Object&gt;();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 构造一个包含指定collection中的元素的新set。 </div><div class="line">     * </div><div class="line">     * 实际底层使用默认的加载因子0.75和足以包含指定 </div><div class="line">     * collection中所有元素的初始容量来创建一个HashMap。 </div><div class="line">     * @param c 其中的元素将存放在此set中的collection。 </div><div class="line">     */  </div><div class="line">    public HashSet(Collection&lt;? extends E&gt; c) &#123;  </div><div class="line">    map = new HashMap&lt;E,Object&gt;(Math.max((int) (c.size()/.75f) + 1, 16));  </div><div class="line">    addAll(c);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 以指定的initialCapacity和loadFactor构造一个空的HashSet。 </div><div class="line">     * </div><div class="line">     * 实际底层以相应的参数构造一个空的HashMap。 </div><div class="line">     * @param initialCapacity 初始容量。 </div><div class="line">     * @param loadFactor 加载因子。 </div><div class="line">     */  </div><div class="line">    public HashSet(int initialCapacity, float loadFactor) &#123;  </div><div class="line">    map = new HashMap&lt;E,Object&gt;(initialCapacity, loadFactor);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 以指定的initialCapacity构造一个空的HashSet。 </div><div class="line">     * </div><div class="line">     * 实际底层以相应的参数及加载因子loadFactor为0.75构造一个空的HashMap。 </div><div class="line">     * @param initialCapacity 初始容量。 </div><div class="line">     */  </div><div class="line">    public HashSet(int initialCapacity) &#123;  </div><div class="line">    map = new HashMap&lt;E,Object&gt;(initialCapacity);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。 </div><div class="line">     * 此构造函数为包访问权限，不对外公开，实际只是是对LinkedHashSet的支持。 </div><div class="line">     * </div><div class="line">     * 实际底层会以指定的参数构造一个空LinkedHashMap实例来实现。 </div><div class="line">     * @param initialCapacity 初始容量。 </div><div class="line">     * @param loadFactor 加载因子。 </div><div class="line">     * @param dummy 标记。 </div><div class="line">     */  </div><div class="line">    HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;  </div><div class="line">    map = new LinkedHashMap&lt;E,Object&gt;(initialCapacity, loadFactor);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 返回对此set中元素进行迭代的迭代器。返回元素的顺序并不是特定的。 </div><div class="line">     *  </div><div class="line">     * 底层实际调用底层HashMap的keySet来返回所有的key。 </div><div class="line">     * 可见HashSet中的元素，只是存放在了底层HashMap的key上， </div><div class="line">     * value使用一个static final的Object对象标识。 </div><div class="line">     * @return 对此set中元素进行迭代的Iterator。 </div><div class="line">     */  </div><div class="line">    public Iterator&lt;E&gt; iterator() &#123;  </div><div class="line">    return map.keySet().iterator();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 返回此set中的元素的数量（set的容量）。 </div><div class="line">     * </div><div class="line">     * 底层实际调用HashMap的size()方法返回Entry的数量，就得到该Set中元素的个数。 </div><div class="line">     * @return 此set中的元素的数量（set的容量）。 </div><div class="line">     */  </div><div class="line">    public int size() &#123;  </div><div class="line">    return map.size();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 如果此set不包含任何元素，则返回true。 </div><div class="line">     * </div><div class="line">     * 底层实际调用HashMap的isEmpty()判断该HashSet是否为空。 </div><div class="line">     * @return 如果此set不包含任何元素，则返回true。 </div><div class="line">     */  </div><div class="line">    public boolean isEmpty() &#123;  </div><div class="line">    return map.isEmpty();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 如果此set包含指定元素，则返回true。 </div><div class="line">     * 更确切地讲，当且仅当此set包含一个满足(o==null ? e==null : o.equals(e)) </div><div class="line">     * 的e元素时，返回true。 </div><div class="line">     * </div><div class="line">     * 底层实际调用HashMap的containsKey判断是否包含指定key。 </div><div class="line">     * @param o 在此set中的存在已得到测试的元素。 </div><div class="line">     * @return 如果此set包含指定元素，则返回true。 </div><div class="line">     */  </div><div class="line">    public boolean contains(Object o) &#123;  </div><div class="line">    return map.containsKey(o);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 如果此set中尚未包含指定元素，则添加指定元素。 </div><div class="line">     * 更确切地讲，如果此 set 没有包含满足(e==null ? e2==null : e.equals(e2)) </div><div class="line">     * 的元素e2，则向此set 添加指定的元素e。 </div><div class="line">     * 如果此set已包含该元素，则该调用不更改set并返回false。 </div><div class="line">     * </div><div class="line">     * 底层实际将将该元素作为key放入HashMap。 </div><div class="line">     * 由于HashMap的put()方法添加key-value对时，当新放入HashMap的Entry中key </div><div class="line">     * 与集合中原有Entry的key相同（hashCode()返回值相等，通过equals比较也返回true）， </div><div class="line">     * 新添加的Entry的value会将覆盖原来Entry的value，但key不会有任何改变， </div><div class="line">     * 因此如果向HashSet中添加一个已经存在的元素时，新添加的集合元素将不会被放入HashMap中， </div><div class="line">     * 原来的元素也不会有任何改变，这也就满足了Set中元素不重复的特性。 </div><div class="line">     * @param e 将添加到此set中的元素。 </div><div class="line">     * @return 如果此set尚未包含指定元素，则返回true。 </div><div class="line">     */  </div><div class="line">    public boolean add(E e) &#123;  </div><div class="line">    return map.put(e, PRESENT)==null;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 如果指定元素存在于此set中，则将其移除。 </div><div class="line">     * 更确切地讲，如果此set包含一个满足(o==null ? e==null : o.equals(e))的元素e， </div><div class="line">     * 则将其移除。如果此set已包含该元素，则返回true </div><div class="line">     * （或者：如果此set因调用而发生更改，则返回true）。（一旦调用返回，则此set不再包含该元素）。 </div><div class="line">     * </div><div class="line">     * 底层实际调用HashMap的remove方法删除指定Entry。 </div><div class="line">     * @param o 如果存在于此set中则需要将其移除的对象。 </div><div class="line">     * @return 如果set包含指定元素，则返回true。 </div><div class="line">     */  </div><div class="line">    public boolean remove(Object o) &#123;  </div><div class="line">    return map.remove(o)==PRESENT;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 从此set中移除所有元素。此调用返回后，该set将为空。 </div><div class="line">     * </div><div class="line">     * 底层实际调用HashMap的clear方法清空Entry中所有元素。 </div><div class="line">     */  </div><div class="line">    public void clear() &#123;  </div><div class="line">    map.clear();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 返回此HashSet实例的浅表副本：并没有复制这些元素本身。 </div><div class="line">     * </div><div class="line">     * 底层实际调用HashMap的clone()方法，获取HashMap的浅表副本，并设置到HashSet中。 </div><div class="line">     */  </div><div class="line">    public Object clone() &#123;  </div><div class="line">        try &#123;  </div><div class="line">            HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) super.clone();  </div><div class="line">            newSet.map = (HashMap&lt;E, Object&gt;) map.clone();  </div><div class="line">            return newSet;  </div><div class="line">        &#125; catch (CloneNotSupportedException e) &#123;  </div><div class="line">            throw new InternalError();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>对于HashSet中保存的对象，请注意正确重写其equals和hashCode方法，以保证放入的对象的唯一性。这两个方法是比较重要的，希望大家在以后的开发过程中需要注意一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;This class implements the Set interface, backed by a hash table (actually a HashMap instance). It makes no guarantees as to the iteration order of the set; in particular, it does not guarantee that the order will remain constant over time. This class permits the null element.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java集合" scheme="http://yoursite.com/tags/Java%E9%9B%86%E5%90%88/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="HashSet" scheme="http://yoursite.com/tags/HashSet/"/>
    
  </entry>
  
  <entry>
    <title>Java集合学习手册（1）：Java HashMap</title>
    <link href="http://yoursite.com/2017/08/09/Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C%EF%BC%881%EF%BC%89%EF%BC%9AJava%20HashMap/"/>
    <id>http://yoursite.com/2017/08/09/Java集合学习手册（1）：Java HashMap/</id>
    <published>2017-08-09T15:20:45.000Z</published>
    <updated>2017-09-01T07:04:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>从本文你可以学习到：</p><a id="more"></a><ol><li>什么时候会使用HashMap？他有什么特点？</li><li>你知道HashMap的工作原理吗？</li><li>你知道get和put的原理吗？equals()和hashCode()的都有什么作用？</li><li>你知道hash的实现吗？为什么要这样实现？</li><li>如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</li></ol><p>当我们执行下面的操作时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">HashMap&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();</div><div class="line">map.put(&quot;语文&quot;, 1);</div><div class="line">map.put(&quot;数学&quot;, 2);</div><div class="line">map.put(&quot;英语&quot;, 3);</div><div class="line">map.put(&quot;历史&quot;, 4);</div><div class="line">map.put(&quot;政治&quot;, 5);</div><div class="line">map.put(&quot;地理&quot;, 6);</div><div class="line">map.put(&quot;生物&quot;, 7);</div><div class="line">map.put(&quot;化学&quot;, 8);</div><div class="line">for(Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</div><div class="line">    System.out.println(entry.getKey() + &quot;: &quot; + entry.getValue());</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">政治: 5</div><div class="line">生物: 7</div><div class="line">历史: 4</div><div class="line">数学: 2</div><div class="line">化学: 8</div><div class="line">语文: 1</div><div class="line">英语: 3</div><div class="line">地理: 6</div></pre></td></tr></table></figure><p>发生了什么呢？下面是一个大致的结构，希望我们对HashMap的结构有一个感性的认识：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15023464953825.png" alt=""><br>在官方文档中是这样描述HashMap的：<br>&gt;<br>Hash table based <strong>implementation of the Map interface</strong>. This implementation provides all of the optional map operations, and <strong>permits null values and the null key</strong>. (<strong>The HashMap class is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls.</strong>) This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time.</p><p>几个关键的信息：基于Map接口实现、允许null键/值、非同步、不保证有序(比如插入的顺序)、也不保证序不随时间变化。</p><p>在HashMap中有两个很重要的参数，容量(Capacity)和负载因子(Load factor)</p><ul><li>Initial capacity： The capacity is the number of buckets in the hash table, The initial capacity is simply the capacity at the time the hash table is created.</li><li>Load factor： The load factor is a measure of how full the hash table is allowed to get before its capacity is automatically increased.</li></ul><p>简单的说，Capacity就是bucket的大小，Load factor就是bucket填满程度的最大比例。如果对迭代性能要求很高的话不要把capacity设置过大，也不要把load factor设置过小。当bucket中的entries的数目大于capacity*load factor时就需要调整bucket的大小为当前的2倍。</p><h2 id="二、构造函数"><a href="#二、构造函数" class="headerlink" title="二、构造函数"></a>二、构造函数</h2><p>HashMap底层维护一个数组，当新建一个HashMap的时候，就会初始化一个数组。我们看一下JDK源码中的HashMap构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</div><div class="line">                                               initialCapacity);</div><div class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">            initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</div><div class="line">                                               loadFactor);</div><div class="line"></div><div class="line">        <span class="comment">// Find a power of 2 &gt;= initialCapacity</span></div><div class="line">        <span class="keyword">int</span> capacity = <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (capacity &lt; initialCapacity)</div><div class="line">            capacity &lt;&lt;= <span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">        threshold = (<span class="keyword">int</span>)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</div><div class="line">        table = <span class="keyword">new</span> Entry[capacity];</div><div class="line">        useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</div><div class="line">                (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</div><div class="line">        init();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到其中一行为<code>table = new Entry[capacity];</code>。在构造函数中，其创建了一个Entry的数组，其大小为capacity，那么Entry又是什么结构呢？看一下源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">transient Entry&lt;K,V&gt;[] table;</div><div class="line">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</div><div class="line">    final K key;</div><div class="line">    V value;</div><div class="line">    Entry&lt;K,V&gt; next;</div><div class="line">    final int hash;</div><div class="line">    ……</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>HashMap中的是通过transient Entry<k,v>[] table来存储数据，该变量是通过transient进行修饰的。</k,v></p><p>Entry是一个static class，其中包含了key和value，也就是键值对，另外还包含了一个next的Entry指针。我们可以总结出：Entry就是数组中的元素，每个Entry其实就是一个key-value对，它持有一个指向下一个元素的引用，这就构成了链表。</p><h2 id="三、put-方法和get-方法"><a href="#三、put-方法和get-方法" class="headerlink" title="三、put()方法和get()方法"></a>三、put()方法和get()方法</h2><h3 id="3-1-put-方法"><a href="#3-1-put-方法" class="headerlink" title="3.1 put()方法"></a>3.1 put()方法</h3><p>put函数大致的思路为：</p><ol><li>对key的hashCode()做hash，然后再计算index;</li><li>如果没碰撞直接放到bucket里；</li><li>如果碰撞了，以链表的形式存在buckets后；</li><li>如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树；</li><li>如果节点已经存在就替换old value(保证key的唯一性)</li><li>如果bucket满了(超过load factor*current capacity)，就要resize。</li></ol><p>具体代码的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="comment">// 对key的hashCode()做hash</span></div><div class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line">               <span class="keyword">boolean</span> evict) &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</div><div class="line">    <span class="comment">//如果当前map中无数据，执行resize方法。并且返回n</span></div><div class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</div><div class="line">        n = (tab = resize()).length;</div><div class="line">    <span class="comment">///如果要插入的键值对要存放的这个位置刚好没有元素，那么把他封装成Node对象，放在这个位置上就完事了</span></div><div class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</div><div class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">    <span class="comment">//否则的话，说明这上面有元素</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        Node&lt;K,V&gt; e; K k;</div><div class="line">        <span class="comment">//如果这个元素的key与要插入的一样，那么就替换一下，也完事。</span></div><div class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            e = p;</div><div class="line">        <span class="comment">//1.如果当前节点是TreeNode类型的数据，执行putTreeVal方法</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</div><div class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</div><div class="line">        <span class="comment">//还是遍历这条链子上的数据，跟jdk7没什么区别</span></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">                    <span class="comment">//2.完成了操作后多做了一件事情，判断，并且可能执行treeifyBin方法，treeifyBin()就是将链表转换成红黑树。</span></div><div class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></div><div class="line">                        treeifyBin(tab, hash);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                p = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 写入</span></div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></div><div class="line">            V oldValue = e.value;</div><div class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line">                e.value = value;</div><div class="line">            afterNodeAccess(e);</div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ++modCount;</div><div class="line">    <span class="comment">//判断阈值，决定是否扩容</span></div><div class="line">    <span class="keyword">if</span> (++size &gt; threshold)</div><div class="line">        resize();</div><div class="line">    afterNodeInsertion(evict);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>一直到JDK7为止，HashMap的结构基于一个数组以及多个链表的实现，hash值冲突的时候，就将对应节点以链表的形式存储。</p><p>这样子的HashMap性能上就抱有一定疑问，如果说成百上千个节点在hash时发生碰撞，存储一个链表中，那么如果要查找其中一个节点，那就不可避免的花费O(N)的查找时间，这将是多么大的性能损失。这个问题终于在JDK8中得到了解决。再最坏的情况下，链表查找的时间复杂度为O(n),而红黑树一直是O(logn),这样会提高HashMap的效率。JDK7中HashMap采用的是位桶+链表的方式，即我们常说的散列链表的方式，而JDK8中采用的是位桶+链表/红黑树（有关红黑树请查看红黑树）的方式，也是非线程安全的。当某个位桶的链表的长度达到某个阀值的时候，这个链表就将转换成红黑树。</p><p>JDK8中，当同一个hash值的节点数不小于8时，将不再以单链表的形式存储了，会被调整成一颗红黑树。这就是JDK7与JDK8中HashMap实现的最大区别。JDK中Entry的名字变成了Node，原因是和红黑树的实现TreeNode相关联。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</div></pre></td></tr></table></figure><p>当冲突节点数不小于8-1时，转换成红黑树。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">static final int TREEIFY_THRESHOLD = 8;</div></pre></td></tr></table></figure><p>总结下put的过程：</p><p>当程序试图将一个key-value对放入HashMap中时，程序首先根据该 key 的 hashCode() 返回值决定该 Entry 的存储位置， 该位置就是此对象准备往数组中存放的位置。</p><p>如果该位置没有对象存在，就将此对象直接放进数组当中；如果该位置已经有对象存在了，则顺着此存在的对象的链开始寻找(为了判断是否是否值相同，map不允许<key,value>键值对重复)， 使用 equals方法进行比较，如果对此链上的 key 通过 equals 比较有一个返回 true，新添加 Entry 的 value 将覆盖集合中原有 Entry 的 value，但key不会覆盖；如果对此链上的每个对象的 equals 方法比较都为 false，则将该对象放到数组当中，然后将数组中该位置以前存在的那个对象链接到此对象的后面，即新值存放在数组中，旧值在新值的链表上。</key,value></p><p><img src="http://omu7tit09.bkt.clouddn.com/15023557536340.jpg" alt=""></p><h3 id="3-2-get-方法"><a href="#3-2-get-方法" class="headerlink" title="3.2 get()方法"></a>3.2 get()方法</h3><p>在理解了put之后，get就很简单了。大致思路如下：</p><ol><li>bucket里的第一个节点，直接命中；</li><li>如果有冲突，则通过key.equals(k)去查找对应的entry<ul><li>若为树，则在树中通过key.equals(k)查找，O(logn)；</li><li>若为链表，则在链表中通过key.equals(k)查找，O(n)。 </li></ul></li></ol><p>具体代码的实现如下：    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public V get(Object key) &#123;</div><div class="line">    Node&lt;K,V&gt; e;</div><div class="line">    return (e = getNode(hash(key), key)) == null ? null : e.value;</div><div class="line">&#125;</div><div class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</div><div class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</div><div class="line">        (first = tab[(n - 1) &amp; hash]) != null) &#123;</div><div class="line">        // 直接命中</div><div class="line">        if (first.hash == hash &amp;&amp; // always check first node</div><div class="line">            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div class="line">            return first;</div><div class="line">        // 未命中</div><div class="line">        if ((e = first.next) != null) &#123;</div><div class="line">            // 在树中get</div><div class="line">            if (first instanceof TreeNode)</div><div class="line">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</div><div class="line">            // 在链表中get</div><div class="line">            do &#123;</div><div class="line">                if (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div class="line">                    return e;</div><div class="line">            &#125; while ((e = e.next) != null);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-3-null-key存取"><a href="#3-3-null-key存取" class="headerlink" title="3.3 null key存取"></a>3.3 null key存取</h3><p>对于put方法来说，HashMap会对null值key进行特殊处理，总是放到table[0]位置<br>对于get方法来说，同样当key为null时会进行特殊处理，在table[0]的链表上查找key为null的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">            <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</div><div class="line">                V oldValue = e.value;</div><div class="line">                e.value = value;</div><div class="line">                e.recordAccess(<span class="keyword">this</span>);</div><div class="line">                <span class="keyword">return</span> oldValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        modCount++;</div><div class="line">        addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h2 id="四、hash-与indexFor"><a href="#四、hash-与indexFor" class="headerlink" title="四、hash()与indexFor()"></a>四、hash()与indexFor()</h2><h3 id="4-1-hash-方法"><a href="#4-1-hash-方法" class="headerlink" title="4.1 hash()方法"></a>4.1 hash()方法</h3><p>在get和put的过程中，计算下标时，先对hashCode进行hash操作，然后再通过hash值进一步计算下标，如下图所示：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15023472197345.png" alt=""></p><p>在对hashCode()计算hash时具体实现是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">static final int hash(Object key) &#123;</div><div class="line">    int h;</div><div class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>按位取并，作用上相当于取模mod或者取余%。这意味着数组下标相同，并不表示hashCode相同。</p><p>可以看到这个函数大概的作用就是：高16bit不变，低16bit和高16bit做了一个异或。其中代码注释是这样写的：</p><p>&gt;<br>Computes key.hashCode() and spreads (XORs) higher bits of hash to lower. Because the table uses power-of-two masking, sets of hashes that vary only in bits above the current mask will always collide. (Among known examples are sets of Float keys holding consecutive whole numbers in small tables.) So we apply a transform that spreads the impact of higher bits downward. There is a tradeoff between speed, utility, and quality of bit-spreading. Because many common sets of hashes are already reasonably distributed (so don’t benefit from spreading), and because we use trees to handle large sets of collisions in bins, we just XOR some shifted bits in the cheapest possible way to reduce systematic lossage, as well as to incorporate impact of the highest bits that would otherwise never be used in index calculations because of table bounds.</p><h3 id="4-2-indexFor-方法"><a href="#4-2-indexFor-方法" class="headerlink" title="4.2 indexFor()方法"></a>4.2 indexFor()方法</h3><p>在设计hash函数时，因为目前的table长度length n为2的幂，而计算下标的时候，是这样实现的(使用&amp;位操作，而非%求余)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">static int indexFor(int h, int n) &#123;</div><div class="line">        return h &amp; (n-1);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>设计者认为这方法很容易发生碰撞。为什么这么说呢？不妨思考一下，在n - 1为15(0x1111)时，其实散列真正生效的只是低4bit的有效位，当然容易碰撞了。</p><p>因此，设计者想了一个顾全大局的方法(综合考虑了速度、作用、质量)，就是把高16bit和低16bit异或了一下。设计者还解释到因为现在大多数的hashCode的分布已经很不错了，就算是发生了碰撞也用O(logn)的tree去做了。仅仅异或一下，既减少了系统的开销，也不会造成的因为高位没有参与下标的计算(table长度比较小时)，从而引起的碰撞。</p><p>如果还是产生了频繁的碰撞，会发生什么问题呢？作者注释说，他们使用树来处理频繁的碰撞(we use trees to handle large sets of collisions in bins)，在JEP-180中，描述了这个问题：<br>&gt;<br>Improve the performance of java.util.HashMap under high hash-collision conditions by using balanced trees rather than linked lists to store map entries. Implement the same improvement in the LinkedHashMap class.</p><p>之前已经提过，在获取HashMap的元素时，基本分两步：</p><ol><li>首先根据hashCode()做hash，然后确定bucket的index；</li><li>如果bucket的节点的key不是我们需要的，则通过keys.equals()在链中找。</li></ol><p>在Java 8之前的实现中是用链表解决冲突的，在产生碰撞的情况下，进行get时，两步的时间复杂度是O(1)+O(n)。因此，当碰撞很厉害的时候n很大，O(n)的速度显然是影响速度的。</p><p>因此在Java 8中，利用红黑树替换链表，这样复杂度就变成了O(1)+O(logn)了，这样在n很大的时候，能够比较理想的解决这个问题，在Java 8：HashMap的性能提升一文中有性能测试的结果。</p><h2 id="五、resize-方法"><a href="#五、resize-方法" class="headerlink" title="五、resize()方法"></a>五、resize()方法</h2><p>当put时，如果发现目前的bucket占用程度已经超过了Load Factor所希望的比例，那么就会发生resize。在resize的过程，简单的说就是把bucket扩充为2倍，之后重新计算index，把节点再放到新的bucket中。resize的注释是这样描述的：</p><p>&gt;<br>Initializes or doubles table size. If null, allocates in accord with initial capacity target held in field threshold. Otherwise, because we are using power-of-two expansion, the elements from each bin must either stay at same index, or move with a power of two offset in the new table.</p><p>大致意思就是说，当超过限制的时候会resize，然而又因为我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。</p><p>怎么理解呢？例如我们从16扩展为32时，具体的变化如下所示：<br><img src="http://omu7tit09.bkt.clouddn.com/15023478436620.png" alt=""></p><p>因此元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：<br><img src="http://omu7tit09.bkt.clouddn.com/15023478667595.png" alt=""></p><p>因此，我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。可以看看下图为16扩充为32的resize示意图：<br><img src="http://omu7tit09.bkt.clouddn.com/15023479367792.png" alt=""></p><p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。</p><p>下面是代码的具体实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">final Node&lt;K,V&gt;[] resize() &#123;</div><div class="line">    Node&lt;K,V&gt;[] oldTab = table;</div><div class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</div><div class="line">    int oldThr = threshold;</div><div class="line">    int newCap, newThr = 0;</div><div class="line">    if (oldCap &gt; 0) &#123;</div><div class="line">        // 超过最大值就不再扩充了，就只好随你碰撞去吧</div><div class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</div><div class="line">            threshold = Integer.MAX_VALUE;</div><div class="line">            return oldTab;</div><div class="line">        &#125;</div><div class="line">        // 没超过最大值，就扩充为原来的2倍</div><div class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</div><div class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</div><div class="line">    &#125;</div><div class="line">    else if (oldThr &gt; 0) // initial capacity was placed in threshold</div><div class="line">        newCap = oldThr;</div><div class="line">    else &#123;               // zero initial threshold signifies using defaults</div><div class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</div><div class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</div><div class="line">    &#125;</div><div class="line">    // 计算新的resize上限</div><div class="line">    if (newThr == 0) &#123;</div><div class="line">        float ft = (float)newCap * loadFactor;</div><div class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</div><div class="line">                  (int)ft : Integer.MAX_VALUE);</div><div class="line">    &#125;</div><div class="line">    threshold = newThr;</div><div class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</div><div class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</div><div class="line">    table = newTab;</div><div class="line">    if (oldTab != null) &#123;</div><div class="line">        // 把每个bucket都移动到新的buckets中</div><div class="line">        for (int j = 0; j &lt; oldCap; ++j) &#123;</div><div class="line">            Node&lt;K,V&gt; e;</div><div class="line">            if ((e = oldTab[j]) != null) &#123;</div><div class="line">                oldTab[j] = null;</div><div class="line">                if (e.next == null)</div><div class="line">                    newTab[e.hash &amp; (newCap - 1)] = e;</div><div class="line">                else if (e instanceof TreeNode)</div><div class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</div><div class="line">                else &#123; // preserve order</div><div class="line">                    Node&lt;K,V&gt; loHead = null, loTail = null;</div><div class="line">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</div><div class="line">                    Node&lt;K,V&gt; next;</div><div class="line">                    do &#123;</div><div class="line">                        next = e.next;</div><div class="line">                        // 原索引</div><div class="line">                        if ((e.hash &amp; oldCap) == 0) &#123;</div><div class="line">                            if (loTail == null)</div><div class="line">                                loHead = e;</div><div class="line">                            else</div><div class="line">                                loTail.next = e;</div><div class="line">                            loTail = e;</div><div class="line">                        &#125;</div><div class="line">                        // 原索引+oldCap</div><div class="line">                        else &#123;</div><div class="line">                            if (hiTail == null)</div><div class="line">                                hiHead = e;</div><div class="line">                            else</div><div class="line">                                hiTail.next = e;</div><div class="line">                            hiTail = e;</div><div class="line">                        &#125;</div><div class="line">                    &#125; while ((e = next) != null);</div><div class="line">                    // 原索引放到bucket里</div><div class="line">                    if (loTail != null) &#123;</div><div class="line">                        loTail.next = null;</div><div class="line">                        newTab[j] = loHead;</div><div class="line">                    &#125;</div><div class="line">                    // 原索引+oldCap放到bucket里</div><div class="line">                    if (hiTail != null) &#123;</div><div class="line">                        hiTail.next = null;</div><div class="line">                        newTab[j + oldCap] = hiHead;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return newTab;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="六、remove-、clear-、containsKey-和containsValue"><a href="#六、remove-、clear-、containsKey-和containsValue" class="headerlink" title="六、remove()、clear()、containsKey()和containsValue()"></a>六、remove()、clear()、containsKey()和containsValue()</h2><h3 id="6-1-remove-方法"><a href="#6-1-remove-方法" class="headerlink" title="6.1 remove()方法"></a>6.1 remove()方法</h3><p>remove方法和put get类似，计算hash，计算index，然后遍历查找，将找到的元素从table[index]链表移除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public V remove(Object key) &#123;</div><div class="line">       Entry&lt;K,V&gt; e = removeEntryForKey(key);</div><div class="line">       return (e == null ? null : e.value);</div><div class="line">   &#125;</div><div class="line">   final Entry&lt;K,V&gt; removeEntryForKey(Object key) &#123;</div><div class="line">       int hash = (key == null) ? 0 : hash(key.hashCode());</div><div class="line">       int i = indexFor(hash, table.length);</div><div class="line">       Entry&lt;K,V&gt; prev = table[i];</div><div class="line">       Entry&lt;K,V&gt; e = prev;</div><div class="line"></div><div class="line">       while (e != null) &#123;</div><div class="line">           Entry&lt;K,V&gt; next = e.next;</div><div class="line">           Object k;</div><div class="line">           if (e.hash == hash &amp;&amp;</div><div class="line">               ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123;</div><div class="line">               modCount++;</div><div class="line">               size--;</div><div class="line">               if (prev == e)</div><div class="line">                   table[i] = next;</div><div class="line">               else</div><div class="line">                   prev.next = next;</div><div class="line">               e.recordRemoval(this);</div><div class="line">               return e;</div><div class="line">           &#125;</div><div class="line">           prev = e;</div><div class="line">           e = next;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       return e;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p><h3 id="6-2-clear-方法"><a href="#6-2-clear-方法" class="headerlink" title="6.2 clear()方法"></a>6.2 clear()方法</h3><p>clear方法非常简单，就是遍历table然后把每个位置置为null，同时修改元素个数为0<br>需要注意的是clear方法只会清楚里面的元素，并不会重置capactiy</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">       modCount++;</div><div class="line">       Entry[] tab = table;</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; i++)</div><div class="line">           tab[i] = <span class="keyword">null</span>;</div><div class="line">       size = <span class="number">0</span>;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><h3 id="6-3-containsKey-方法"><a href="#6-3-containsKey-方法" class="headerlink" title="6.3 containsKey()方法"></a>6.3 containsKey()方法</h3><p>containsKey方法是先计算hash然后使用hash和table.length取摸得到index值，遍历table[index]元素查找是否包含key相同的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> getEntry(key) != <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key.hashCode());</div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</div><div class="line">             e != <span class="keyword">null</span>;</div><div class="line">             e = e.next) &#123;</div><div class="line">            Object k;</div><div class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                <span class="keyword">return</span> e;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="6-4-containsValue-方法"><a href="#6-4-containsValue-方法" class="headerlink" title="6.4 containsValue()方法"></a>6.4 containsValue()方法</h3><p>containsValue方法就比较粗暴了，就是直接遍历所有元素直到找到value，由此可见HashMap的containsValue方法本质上和普通数组和list的contains方法没什么区别，你别指望它会像containsKey那么高效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public boolean containsValue(Object value) &#123;</div><div class="line">    if (value == null)</div><div class="line">            return containsNullValue();</div><div class="line"></div><div class="line">    Entry[] tab = table;</div><div class="line">        for (int i = 0; i &lt; tab.length ; i++)</div><div class="line">            for (Entry e = tab[i] ; e != null ; e = e.next)</div><div class="line">                if (value.equals(e.value))</div><div class="line">                    return true;</div><div class="line">    return false;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="6-5-Fail-Fast机制"><a href="#6-5-Fail-Fast机制" class="headerlink" title="6.5 Fail-Fast机制"></a>6.5 Fail-Fast机制</h3><p>我们知道java.util.HashMap不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。</p><p>fail-fast 机制是java集合(Collection)中的一种错误机制。 当多个线程对同一个集合的内容进行操作时，就可能会产生 fail-fast 事件。</p><p>例如：当某一个线程A通过 iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出 ConcurrentModificationException异常，产生 fail-fast 事件。</p><p>这一策略在源码中的实现是通过modCount域，modCount顾名思义就是修改次数，对HashMap内容（当然不仅仅是HashMap才会有，其他例如ArrayList也会）的修改都将增加这个值（大家可以再回头看一下其源码，在很多操作中都有modCount++这句），那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">HashIterator() &#123;</div><div class="line">    expectedModCount = modCount;</div><div class="line">    if (size &gt; 0) &#123; // advance to first entry</div><div class="line">    Entry[] t = table;</div><div class="line">    while (index &lt; t.length &amp;&amp; (next = t[index++]) == null)  </div><div class="line">        ;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map：</p><p>注意到modCount声明为volatile，保证线程之间修改的可见性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">final Entry&lt;K,V&gt; nextEntry() &#123;</div><div class="line">    if (modCount != expectedModCount)</div><div class="line">        throw new ConcurrentModificationException();</div></pre></td></tr></table></figure><p>在HashMap的API中指出：</p><p>由所有HashMap类的“collection 视图方法”所返回的迭代器都是快速失败的：在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器本身的 remove 方法，其他任何时间任何方式的修改，迭代器都将抛出 ConcurrentModificationException。因此，面对并发的修改，迭代器很快就会完全失败，而不冒在将来不确定的时间发生任意不确定行为的风险。</p><p>注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。</p><p>在上文中也提到，fail-fast机制，是一种错误检测机制。它只能被用来检测错误，因为JDK并不保证fail-fast机制一定会发生。若在多线程环境下使用 fail-fast机制的集合，建议使用“java.util.concurrent包下的类”去取代“java.util包下的类”。</p><h3 id="6-6-两种遍历方式"><a href="#6-6-两种遍历方式" class="headerlink" title="6.6 两种遍历方式"></a>6.6 两种遍历方式</h3><p>第一种效率高,以后一定要使用此种方式！</p><p>　<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">　　Map map = <span class="keyword">new</span> HashMap();</div><div class="line">　　Iterator iter = map.entrySet().iterator();</div><div class="line">　　<span class="keyword">while</span> (iter.hasNext()) &#123;</div><div class="line">　　Map.Entry entry = (Map.Entry) iter.next();</div><div class="line">　　Object key = entry.getKey();</div><div class="line">　　Object val = entry.getValue();</div><div class="line">　　&#125;</div></pre></td></tr></table></figure></p><p>　<br>第二种效率低,以后尽量少使用！<br>　<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">　　　Map map = <span class="keyword">new</span> HashMap();</div><div class="line">　　Iterator iter = map.keySet().iterator();</div><div class="line">　　<span class="keyword">while</span> (iter.hasNext()) &#123;</div><div class="line">　　Object key = iter.next();</div><div class="line">　　Object val = map.get(key);</div><div class="line">　　&#125;</div></pre></td></tr></table></figure></p><h2 id="七、一些问题"><a href="#七、一些问题" class="headerlink" title="七、一些问题"></a>七、一些问题</h2><p>我们现在可以回答开始的几个问题，加深对HashMap的理解：</p><ol><li>什么时候会使用HashMap？他有什么特点？<br>是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，HashMap存储着Entry(hash, key, value, next)对象。</li></ol><ol><li><p>你知道HashMap的工作原理吗？<br>通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。</p></li><li><p>你知道get和put的原理吗？equals()和hashCode()的都有什么作用？<br>通过对key的hashCode()进行hashing，并计算下标( n-1 &amp; hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点。</p></li><li><p>你知道hash的实现吗？为什么要这样实现？<br>在Java 1.8的实现中，是通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在bucket的n比较小的时候，也能保证考虑到高低bit都参与到hash的计算中，同时不会有太大的开销。</p></li><li><p>如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？<br>如果超过了负载因子(默认0.75)，则会重新resize一个原来长度两倍的HashMap，并且重新调用hash方法。</p></li><li><p>Java集合小抄<br>以Entry[]数组实现的哈希桶数组，用Key的哈希值取模桶数组的大小可得到数组下标。<br>插入元素时，如果两条Key落在同一个桶(比如哈希值1和17取模16后都属于第一个哈希桶)，Entry用一个next属性实现多个Entry以单向链表存放，后入桶的Entry将next指向桶当前的Entry。<br>查找哈希值为17的key时，先定位到第一个哈希桶，然后以链表遍历桶里所有元素，逐个比较其key值。<br>当Entry数量达到桶数量的75%时(很多文章说使用的桶数量达到了75%，但看代码不是)，会成倍扩容桶数组，并重新分配所有原来的Entry，所以这里也最好有个预估值。<br>取模用位运算(hash &amp; (arrayLength-1))会比较快，所以数组的大小永远是2的N次方， 你随便给一个初始值比如17会转为32。默认第一次放入元素时的初始值是16。<br>iterator()时顺着哈希桶数组来遍历，看起来是个乱序。<br>在JDK8里，新增默认为8的閥值，当一个桶里的Entry超过閥值，就不以单向链表而以红黑树来存放以加快Key的查找速度。</p></li><li><p>一个很棒的面试题</p></li></ol><p>HashMap的工作原理是近年来常见的Java面试题。几乎每个Java程序员都知道HashMap，都知道哪里要用HashMap，知道Hashtable和HashMap之间的区别，那么为何这道面试题如此特殊呢？是因为这道题考察的深度很深。这题经常出现在高级或中高级面试中。投资银行更喜欢问这个问题，甚至会要求你实现HashMap来考察你的编程能力。ConcurrentHashMap和其它同步集合的引入让这道题变得更加复杂。让我们开始探索的旅程吧！</p><p>先来些简单的问题</p><p>“你用过HashMap吗？” “什么是HashMap？你为什么用到它？”</p><p>几乎每个人都会回答“是的”，然后回答HashMap的一些特性，譬如HashMap可以接受null键值和值，而Hashtable则不能；HashMap是非synchronized;HashMap很快；以及HashMap储存的是键值对等等。这显示出你已经用过HashMap，而且对它相当的熟悉。但是面试官来个急转直下，从此刻开始问出一些刁钻的问题，关于HashMap的更多基础的细节。面试官可能会问出下面的问题：</p><p>“你知道HashMap的工作原理吗？” “你知道HashMap的get()方法的工作原理吗？”</p><p>你也许会回答“我没有详查标准的Java API，你可以看看Java源代码或者Open JDK。”“我可以用Google找到答案。”</p><p>但一些面试者可能可以给出答案，“HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来储存Entry对象。”这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Entry。这一点有助于理解获取对象的逻辑。如果你没有意识到这一点，或者错误的认为仅仅只在bucket中存储值的话，你将不会回答如何从HashMap中获取对象的逻辑。这个答案相当的正确，也显示出面试者确实知道hashing以及HashMap的工作原理。但是这仅仅是故事的开始，当面试官加入一些Java程序员每天要碰到的实际场景的时候，错误的答案频现。下个问题可能是关于HashMap中的碰撞探测(collision detection)以及碰撞的解决方法：</p><p>“当两个对象的hashcode相同会发生什么？” 从这里开始，真正的困惑开始了，一些面试者会回答因为hashcode相同，所以两个对象是相等的，HashMap将会抛出异常，或者不会存储它们。然后面试官可能会提醒他们有equals()和hashCode()两个方法，并告诉他们两个对象就算hashcode相同，但是它们可能并不相等。一些面试者可能就此放弃，而另外一些还能继续挺进，他们回答“因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。”这个答案非常的合理，虽然有很多种处理碰撞的方法，这种方法是最简单的，也正是HashMap的处理方法。但故事还没有完结，面试官会继续问：</p><p>“如果两个键的hashcode相同，你如何获取值对象？” 面试者会回答：当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，然后获取值对象。面试官提醒他如果有两个值对象储存在同一个bucket，他给出答案:将会遍历链表直到找到值对象。面试官会问因为你并没有值对象去比较，你是如何确定确定找到值对象的？除非面试者直到HashMap在链表中存储的是键值对，否则他们不可能回答出这一题。</p><p>其中一些记得这个重要知识点的面试者会说，找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。完美的答案！</p><p>许多情况下，面试者会在这个环节中出错，因为他们混淆了hashCode()和equals()方法。因为在此之前hashCode()屡屡出现，而equals()方法仅仅在获取值对象的时候才出现。一些优秀的开发者会指出使用不可变的、声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生，提高效率。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择。</p><p>如果你认为到这里已经完结了，那么听到下面这个问题的时候，你会大吃一惊。“如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？”除非你真正知道HashMap的工作原理，否则你将回答不出这道题。默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。</p><p>如果你能够回答这道问题，下面的问题来了：“你了解重新调整HashMap大小存在什么问题吗？”你可能回答不上来，这时面试官会提醒你当多线程的情况下，可能产生条件竞争(race condition)。</p><p>当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。这个时候，你可以质问面试官，为什么这么奇怪，要在多线程的环境下使用HashMap呢？：）</p><p>热心的读者贡献了更多的关于HashMap的问题：</p><p>为什么String, Interger这样的wrapper类适合作为键？ String, Interger这样的wrapper类作为HashMap的键是再适合不过了，而且String最为常用。因为String是不可变的，也是final的，而且已经重写了equals()和hashCode()方法了。其他的wrapper类也有这个特点。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。不可变性还有其他的优点如线程安全。如果你可以仅仅通过将某个field声明成final就能保证hashCode是不变的，那么请这么做吧。因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的。如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这样就能提高HashMap的性能。</p><p>我们可以使用自定义的对象作为键吗？ 这是前一个问题的延伸。当然你可能使用任何对象作为键，只要它遵守了equals()和hashCode()方法的定义规则，并且当对象插入到Map中之后将不会再改变了。如果这个自定义对象时不可变的，那么它已经满足了作为键的条件，因为当它创建之后就已经不能改变了。</p><p>我们可以使用CocurrentHashMap来代替Hashtable吗？这是另外一个很热门的面试题，因为ConcurrentHashMap越来越多人用了。我们知道Hashtable是synchronized的，但是ConcurrentHashMap同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁。ConcurrentHashMap当然可以代替HashTable，但是HashTable提供更强的线程安全性。看看这篇博客查看Hashtable和ConcurrentHashMap的区别。</p><p>我个人很喜欢这个问题，因为这个问题的深度和广度，也不直接的涉及到不同的概念。让我们再来看看这些问题设计哪些知识点：</p><ul><li>hashing的概念</li><li>HashMap中解决碰撞的方法</li><li>equals()和hashCode()的应用，以及它们在HashMap中的重要性</li><li>不可变对象的好处</li><li>HashMap多线程的条件竞争</li><li>重新调整HashMap的大小</li></ul><p>总结</p><p>HashMap的工作原理<br>HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。</p><p>当两个不同的键对象的hashcode相同时会发生什么？ 它们会储存在同一个bucket位置的链表中。键对象的equals()方法用来找到键值对。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;p&gt;从本文你可以学习到：&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java集合" scheme="http://yoursite.com/tags/Java%E9%9B%86%E5%90%88/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="HashMap" scheme="http://yoursite.com/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法题解（11）：最长回文子串</title>
    <link href="http://yoursite.com/2017/08/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%EF%BC%8811%EF%BC%89%EF%BC%9A%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2017/08/09/数据结构与算法题解（11）：最长回文子串/</id>
    <published>2017-08-09T12:20:45.000Z</published>
    <updated>2017-12-16T14:30:14.073Z</updated>
    
    <content type="html"><![CDATA[<p>给定字符串S，求它的最长回文子串。假设S的最长长度为1000，并且仅有唯一的最长回文子串。</p><a id="more"></a><h2 id="一、暴力法（-Brute-Force）"><a href="#一、暴力法（-Brute-Force）" class="headerlink" title="一、暴力法（ Brute Force）"></a>一、暴力法（ Brute Force）</h2><p>最简便，但同时时间复杂度也是最高的肯定是暴力解法，就是遍历字符串的“所有子串”，并判断每个子串是否为对称回文。因为字符串所有子串的复杂度为$O(n^2)$，在判断回文，总体的复杂度达到$O(n^3)$。</p><ul><li><p>复杂度：时间 $O(n^3) $空间 $O(1)$<br>可以做一些简单的优化：</p></li><li><p>从最长的子串开始遍历，一旦找到一个回文，就终止迭代。</p></li><li>判断回文采用收缩法，从最外一对字符往中心推进。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public String longestPalindrome(String s) &#123;</div><div class="line">        for (int size = s.length(); size &gt; 0; size--) &#123;</div><div class="line">            for (int low = 0, high = low+size-1; high &lt; s.length(); low++, high++) &#123;</div><div class="line">                if (shrinkCheckPalindrome(s,low,high)) &#123;</div><div class="line">                    return s.substring(low,high+1);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return s.substring(0,1);</div><div class="line">    &#125;</div><div class="line">    public boolean shrinkCheckPalindrome(String s, int low, int high) &#123;</div><div class="line">        while (low &lt;= high) &#123;</div><div class="line">            if (s.charAt(low) == s.charAt(high)) &#123;</div><div class="line">                low++; high--;</div><div class="line">            &#125; else &#123;</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="二、动态规划"><a href="#二、动态规划" class="headerlink" title="二、动态规划"></a>二、动态规划</h2><p>根据回文的特性，一个大回文按比例缩小后的字符串也必定是回文，比如ABCCBA，那BCCB肯定也是回文。所以我们可以根据动态规划的两个特点：第一大问题拆解为小问题，第二重复利用之前的计算结果，来解答这道题。那如何划分小问题呢，我们可以先把所有长度最短为1的子字符串计算出来，根据起始位置从左向右，这些必定是回文。然后计算所有长度为2的子字符串，再根据起始位置从左向右。到长度为3的时候，我们就可以利用上次的计算结果：如果中心对称的短字符串不是回文，那长字符串也不是，如果短字符串是回文，那就要看长字符串两头是否一样。这样，一直到长度最大的子字符串，我们就把整个字符串集穷举完了，但是由于使用动态规划，使计算时间从$O(N^3)$减少到$O(n^2)$。</p><ul><li>复杂度：时间 $O(n^2) $空间 $O(n^2)$</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">    public String longestPalindrome(String s) &#123;</div><div class="line">      int n = s.length();</div><div class="line">      String res = null;</div><div class="line">      boolean[][] dp = new boolean[n][n];</div><div class="line">      for (int i = n - 1; i &gt;= 0; i--) &#123;</div><div class="line">        for (int j = i; j &lt; n; j++) &#123;</div><div class="line">          dp[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt; 3 || dp[i + 1][j - 1]);</div><div class="line">          if (dp[i][j] &amp;&amp; (res == null || j - i + 1 &gt; res.length())) &#123;</div><div class="line">            res = s.substring(i, j + 1);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      return res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="三、中心扩散法"><a href="#三、中心扩散法" class="headerlink" title="三、中心扩散法"></a>三、中心扩散法</h2><p>动态规划虽然优化了时间，但也浪费了空间。实际上我们并不需要一直存储所有子字符串的回文情况，我们需要知道的只是中心对称的较小一层是否是回文。所以如果我们从小到大连续以某点为个中心的所有子字符串进行计算，就能省略这个空间。  这种解法中，外层循环遍历的是子字符串的中心点，内层循环则是从中心扩散，一旦不是回文就不再计算其他以此为中心的较大的字符串。由于中心对称有两种情况，一是奇数个字母以某个字母对称，而是偶数个字母以两个字母中间为对称，所以我们要分别计算这两种对称情况。</p><ul><li>复杂度：时间 O(n^2) 空间 O(1)<br><img src="http://omu7tit09.bkt.clouddn.com/15047510886053.png" alt=""></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    private int max = 0;</div><div class="line">    private String res = &quot;&quot;;</div><div class="line">    public String longestPalindrome(String s) &#123;</div><div class="line">        if (s.length() == 1) &#123; return s; &#125;</div><div class="line">        for (int i = 0; i &lt; s.length()-1; i++) &#123;</div><div class="line">            checkPalindromeExpand(s,i,i);</div><div class="line">            checkPalindromeExpand(s,i,i+1);</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">    public void checkPalindromeExpand(String s, int low, int high) &#123;</div><div class="line">        while (low &gt;= 0 &amp;&amp; high &lt; s.length()) &#123;</div><div class="line">            if (s.charAt(low) == s.charAt(high)) &#123;</div><div class="line">                if (high - low + 1 &gt; max) &#123;</div><div class="line">                    max = high - low + 1;</div><div class="line">                    res = s.substring(low,high+1);</div><div class="line">                &#125;</div><div class="line">                low--; high++;</div><div class="line">            &#125; else &#123;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="四、马拉车算法"><a href="#四、马拉车算法" class="headerlink" title="四、马拉车算法"></a>四、马拉车算法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(s.length()&lt;=<span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> s;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 预处理字符串，避免奇偶问题</span></div><div class="line">        String str = preProcess(s);</div><div class="line">        <span class="comment">// idx是当前能够向右延伸的最远的回文串中心点，随着迭代而更新</span></div><div class="line">        <span class="comment">// max是当前最长回文串在总字符串中所能延伸到的最右端的位置</span></div><div class="line">        <span class="comment">// maxIdx是当前已知的最长回文串中心点</span></div><div class="line">        <span class="comment">// maxSpan是当前已知的最长回文串向左或向右能延伸的长度</span></div><div class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>, max = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> maxIdx = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> maxSpan = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span>[] p = <span class="keyword">new</span> <span class="keyword">int</span>[str.length()];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> curr = <span class="number">1</span>; curr &lt; str.length(); curr++)&#123;</div><div class="line">            <span class="comment">// 找出当前下标相对于idx的对称点</span></div><div class="line">            <span class="keyword">int</span> symmetryOfCurr = <span class="number">2</span> * idx - curr;</div><div class="line">            <span class="comment">// 如果当前已知延伸的最右端大于当前下标，我们可以用对称点的P值，否则记为1等待检查</span></div><div class="line">            p[curr] = max &gt; curr? Math.min(p[symmetryOfCurr], max - curr):<span class="number">1</span>;</div><div class="line">            <span class="comment">// 检查并更新当前下标为中心的回文串最远延伸的长度</span></div><div class="line">            <span class="keyword">while</span>((curr+p[curr])&lt;str.length() &amp;&amp; str.charAt(curr+p[curr])==str.charAt(curr-p[curr]))&#123;</div><div class="line">                p[curr]++;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 检查并更新当前已知能够延伸最远的回文串信息</span></div><div class="line">            <span class="keyword">if</span>(curr+p[curr]&gt;max)&#123;</div><div class="line">                max = p[curr] + curr;</div><div class="line">                idx = curr;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 检查并更新当前已知的最长回文串信息</span></div><div class="line">            <span class="keyword">if</span>(p[curr]&gt;maxSpan)&#123;</div><div class="line">                maxSpan = p[curr];</div><div class="line">                maxIdx = curr;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//去除占位符</span></div><div class="line">        <span class="keyword">return</span> s.substring((maxIdx-maxSpan)/<span class="number">2</span>,(maxSpan+maxIdx)/<span class="number">2</span>-<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 预处理，如ABC,变为$#A#B#C#</span></div><div class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">preProcess</span><span class="params">(String s)</span></span>&#123;</div><div class="line">        </div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">        sb.append(<span class="string">"$"</span>);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</div><div class="line">            sb.append(<span class="string">"#"</span>);</div><div class="line">            sb.append(s.charAt(i));</div><div class="line">        &#125;</div><div class="line">        sb.append(<span class="string">"#"</span>);</div><div class="line">        <span class="keyword">return</span> sb.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定字符串S，求它的最长回文子串。假设S的最长长度为1000，并且仅有唯一的最长回文子串。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="最长回文子串" scheme="http://yoursite.com/tags/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法题解（10）：0-1背包问题与部分背包问题</title>
    <link href="http://yoursite.com/2017/08/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%EF%BC%8810%EF%BC%89%EF%BC%9A0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E4%B8%8E%E9%83%A8%E5%88%86%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/08/09/数据结构与算法题解（10）：0-1背包问题与部分背包问题/</id>
    <published>2017-08-09T12:20:45.000Z</published>
    <updated>2017-09-01T07:04:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>假设我们有n件物品，分别编号为1, 2…n。其中编号为i的物品价值为$v_i$，它的重量为$w_i$。为了简化问题，假定价值和重量都是整数值。现在，假设我们有一个背包，它能够承载的重量是W。现在，我们希望往包里装这些物品，使得包里装的物品价值最大化，那么我们该如何来选择装的东西呢？问题结构如下图所示：</p><a id="more"></a><p><img src="http://omu7tit09.bkt.clouddn.com/15036769826658.png" alt=""></p><p>这个问题其实根据不同的情况可以归结为不同的解决方法。假定我们这里选取的物品每个都是独立的，不能选取部分。也就是说我们要么选取某个物品，要么不能选取，不能只选取一个物品的一部分。这种情况，我们称之为0-1背包问题。而如果我们可以使用部分的物品的话，这个问题则成为部分背包(fractional knapsack)问题。下面我们针对每种情况具体分析一下。</p><h2 id="一、0-1背包"><a href="#一、0-1背包" class="headerlink" title="一、0-1背包"></a>一、0-1背包</h2><h3 id="1-1-初步分析"><a href="#1-1-初步分析" class="headerlink" title="1.1 初步分析"></a>1.1 初步分析</h3><p>对于这个问题，一开始确实有点不太好入手。一堆的物品，每一个都有一定的质量和价值，我们能够装入的总重量有限制，该怎么来装使得价值最大呢？对于这n个物品，每个物品我们可能会选，也可能不选，那么我们总共就可能有2^n种组合选择方式。如果我们采用这种办法来硬算的话，则整体的时间复杂度就达到指数级别的，肯定不可行。</p><p>现在我们换一种思路。既然每一种物品都有价格和重量，我们优先挑选那些单位价格最高的是否可行呢？比如在下图中，我们有3种物品，他们的重量和价格分别是10, 20, 30 kg和60, 100, 120。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15036772299557.jpg" alt=""></p><p>那么按照单位价格来算的话，我们最先应该挑选的是价格为60的元素，选择它之后，背包还剩下50 - 10 = 40kg。再继续前面的选择，我们应该挑选价格为100的元素，这样背包里的总价值为60 + 100 = 160。所占用的重量为30, 剩下20kg。因为后面需要挑选的物品为30kg已经超出背包的容量了。我们按照这种思路能选择到的最多就是前面两个物品。如下图：<br><img src="http://omu7tit09.bkt.clouddn.com/15036772528268.jpg" alt=""></p><p>按照我们前面的期望，这样选择得到的价值应该是最大的。可是由于有一个背包重量的限制，这里只用了30kg，还有剩下20kg浪费了。这会是最优的选择吗？我们看看所有的选择情况：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15036772765340.jpg" alt=""></p><p>很遗憾，在这几种选择情况中，我们前面的选择反而是带来价值最低的。而选择重量分别为20kg和30kg的物品带来了最大的价值。看来，我们刚才这种选择最佳单位价格的方式也行不通。 </p><h3 id="1-2-动态规划"><a href="#1-2-动态规划" class="headerlink" title="1.2 动态规划"></a>1.2 动态规划</h3><p>既然前面两种办法都不可行，我们再来看看有没有别的方法。我们再来看这个问题。我们需要选择n个元素中的若干个来形成最优解，假定为k个。那么对于这k个元素a1, a2, …ak来说，它们组成的物品组合必然满足总重量&lt;=背包重量限制，而且它们的价值必然是最大的。因为它们是我们假定的最优选择嘛，肯定价值应该是最大的。假定$a_k$是我们按照前面顺序放入的最后一个物品。它的重量为$w_k$，它的价值为$v_k$。既然我们前面选择的这k个元素构成了最优选择，如果我们把这个$a_k$物品拿走，对应于$k-1$个物品来说，它们所涵盖的重量范围为$0-(W-w_k)$。假定W为背包允许承重的量。假定最终的价值是V，剩下的物品所构成的价值为$V-v_k$。这剩下的$k-1$个元素是不是构成了一个这种$W-w_k$的最优解呢？</p><p>我们可以用反证法来推导。假定拿走$a_k$这个物品后，剩下的这些物品没有构成$W-w_k$重量范围的最佳价值选择。那么我们肯定有另外$k-1$个元素，他们在$W-w_k$重量范围内构成的价值更大。如果这样的话，我们用这$k-1$个物品再加上第k个，他们构成的最终W重量范围内的价值就是最优的。这岂不是和我们前面假设的k个元素构成最佳矛盾了吗？所以我们可以肯定，在这k个元素里拿掉最后那个元素，前面剩下的元素依然构成一个最佳解。</p><p>现在我们经过前面的推理已经得到了一个基本的递推关系，就是一个最优解的子解集也是最优的。可是，我们该怎么来求得这个最优解呢？我们这样来看。假定我们定义一个函数$c[i, w]$表示到第i个元素为止，在限制总重量为w的情况下我们所能选择到的最优解。那么这个最优解要么包含有i这个物品，要么不包含，肯定是这两种情况中的一种。如果我们选择了第i个物品，那么实际上这个最优解是c[i - 1, w-wi] + vi。而如果我们没有选择第i个物品，这个最优解是c[i-1, w]。这样，实际上对于到底要不要取第i个物品，我们只要比较这两种情况，哪个的结果值更大不就是最优的么？</p><p>在前面讨论的关系里，还有一个情况我们需要考虑的就是，我们这个最优解是基于选择物品i时总重量还是在w范围内的，如果超出了呢？我们肯定不能选择它，这就和c[i-1, w]一样。</p><p>另外，对于初始的情况呢？很明显c[0, w]里不管w是多少，肯定为0。因为它表示我们一个物品都不选择的情况。c[i, 0]也一样，当我们总重量限制为0时，肯定价值为0。</p><p>这样，基于我们前面讨论的这3个部分，我们可以得到一个如下的递推公式：<br><img src="http://omu7tit09.bkt.clouddn.com/15037121550876.jpg" alt=""></p><p>有了这个关系，我们可以更进一步的来考虑代码实现了。我们有这么一个递归的关系，其中，后面的函数结果其实是依赖于前面的结果的。我们只要按照前面求出来最基础的最优条件，然后往后面一步步递推，就可以找到结果了。</p><p>我们再来考虑一下具体实现的细节。这一组物品分别有价值和重量，我们可以定义两个数组int[] v, int[] w。v[i]表示第i个物品的价值，w[i]表示第i个物品的重量。为了表示c[i, w]，我们可以使用一个int[i][w]的矩阵。其中i的最大值为物品的数量，而w表示最大的重量限制。按照前面的递推关系，c[i][0]和c[0][w]都是0。而我们所要求的最终结果是c[n][w]。所以我们实际中创建的矩阵是(n + 1) x (w + 1)的规格。下面是该过程的一个代码参考实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">public class DynamicKnapSack &#123;</div><div class="line">    private int[] v;</div><div class="line">    private int[] w;</div><div class="line">    private int[][] c;</div><div class="line">    private int weight;</div><div class="line"></div><div class="line">    public DynamicKnapSack(int length, int weight, int[] vin, int[] win) &#123;</div><div class="line">        v = new int[length + 1];</div><div class="line">        w = new int[length + 1];</div><div class="line">        c = new int[length + 1][weight + 1];</div><div class="line">        this.weight = weight;</div><div class="line">        for(int i = 0; i &lt; length + 1; i++) &#123;</div><div class="line">            v[i] = vin[i];</div><div class="line">            w[i] = win[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void solve() &#123;</div><div class="line">       for(int i = 1; i &lt; v.length; i++) &#123;</div><div class="line">            for(int k = 1; k &lt;= weight; k++) &#123;</div><div class="line">                if(w[i] &lt;= k) &#123;</div><div class="line">                    if(v[i] + c[i - 1][k - w[i]] &gt; c[i - 1][k])</div><div class="line">                        c[i][k] = v[i] + c[i - 1][k - w[i]];</div><div class="line">                    else</div><div class="line">                        c[i][k] = c[i - 1][k];</div><div class="line">                &#125; else</div><div class="line">                    c[i][k] = c[i - 1][k];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void printResult() &#123;</div><div class="line">        for(int i = 0; i &lt; v. length; i++) &#123;</div><div class="line">            for(int j = 0; j &lt;= weight; j++)</div><div class="line">                System.out.print(c[i][j] + &quot; &quot;);</div><div class="line">            System.out.println();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        int[] v = &#123;0, 60, 100, 120&#125;;</div><div class="line">        int[] w = &#123;0, 10, 20, 30&#125;;</div><div class="line">        int weight = 50;</div><div class="line">        DynamicKnapSack knapsack = new DynamicKnapSack(3, weight, v, w);</div><div class="line">        knapsack.solve();</div><div class="line">        knapsack.printResult();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这部分代码里关键的就是solve方法。里面两个遍历循环，i表示从1到n的范围，对应于我们递归方法里描述的c(i, w)中到第i位。而k表示的是当前的重量限制。下面是程序运行的输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 </div><div class="line">0 0 0 0 0 0 0 0 0 0 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 60 </div><div class="line">0 0 0 0 0 0 0 0 0 0 60 60 60 60 60 60 60 60 60 60 100 100 100 100 100 100 100 100 100 100 160 160 160 160 160 160 160 160 160 160 160 160 160 160 160 160 160 160 160 160 160 </div><div class="line">0 0 0 0 0 0 0 0 0 0 60 60 60 60 60 60 60 60 60 60 100 100 100 100 100 100 100 100 100 100 160 160 160 160 160 160 160 160 160 160 180 180 180 180 180 180 180 180 180 180 220</div></pre></td></tr></table></figure><p>最右下角的数值220就是c[3, 50]的解。<br>    至此，我们对于这种问题的解决方法已经分析出来了。它的总体时间复杂度为O(nw) ，其中w是设定的一个重量范围，因此也可以说它的时间复杂度为O(n)。</p><h2 id="二、部分背包问题"><a href="#二、部分背包问题" class="headerlink" title="二、部分背包问题"></a>二、部分背包问题</h2><p>和前面使用动态规划方法解决问题不一样。因为这里是部分背包问题，我们可以采用前面讨论过的一个思路。就是每次选择最优单位价格的物品，直到达到背包重量限制要求。</p><p>以前面的示例来看，我们按照这种方式选择的物品结果应该如下图：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15037122735013.jpg" alt=""></p><p>现在，我们从实现的角度再来考虑一下。我们这里的最优解是每次挑选性价比最高的物品。对于这一组物品来说，我们需要将他们按照性价比从最高到最低的顺序来取。我们可能需要将他们进行排序。然后再依次取出来放入背包中。假定我们已经有数组v，w，他们已经按照性价比排好序了。一个参考代码的实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public double selectMax() &#123;</div><div class="line">        double maxValue = 0.0;</div><div class="line">        int sum = 0;</div><div class="line">        int i;</div><div class="line">        for(i = 0; i &lt; v.length; i++) &#123;</div><div class="line">            if(sum + w[i] &lt; weight) &#123;</div><div class="line">                sum += w[i];</div><div class="line">                maxValue += v[i];</div><div class="line">            &#125; else</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">        if(i &lt; v.length &amp;&amp; sum &lt; weight) &#123;</div><div class="line">           maxValue += (double)(weight - sum) / w[i] * v[i];</div><div class="line">        &#125;</div><div class="line">        return maxValue;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>这里省略了对数组v, w的定义。关键点在于我们选择了若干了物品后要判断是否装满了背包重量。如果没有，还要从后面的里面挑选一部分。所以有一个if(i &lt; v.length &amp;&amp; sum &lt; weight)的判断。</p><p>在实现后我们来看该问题这种解法的时间复杂度，因为需要将数组排序，我们的时间复杂度为O(nlgn)。</p><p>在前面我们挑选按照性价比排好序的物品时，排序消耗了主要的时间。在这里，我们是否真的需要去把这些物品排序呢？在某些情况下，我们只要选择一堆物品，保证他们物品重量在指定范围内。如果我们一次挑出来一批这样的物品，而且他们满足这样的条件是不是更好呢？这一种思路是借鉴快速排序里对元素进行划分的思路。主要过程如下：</p><ol><li>求每个元素的单位价值，pi = vi /wi。然后数组按照pi进行划分，这样会被分成3个部分，L, M, N。其中L &lt; M &lt; N。这里L表示单位价值小于某个指定值的集合，M是等于这个值的集合，而N是大于这个值的集合。</li><li>我们可以首先看N的集合，因为这里都是单位价值高的集合。我们将他们的重量累加，如果WN的重量等于我们期望的值W，则N中间的结果就是我们找到的结果。</li><li>如果WN的重量大于W，我们需要在N集合里做进一步划分。</li><li>如果WN的重量小于W，我们需要在N的基础上再去L的集合里划分，找里面大的一部分。</li></ol><p>这样重复步骤1到4.</p><p>这里和快速排序的思路基本上差不多，只是需要将一个分割的集合给记录下来。其时间复杂度也更好一点，为O(N)。这里就简单的描述下思路，等后续再将具体的实现代码给补上。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>我们这里讨论的两种背包问题因为问题的不同其本质解决方法也不同。对于0-1背包来说，他们构成了一个最优解问题的基础。我们可以通过从最小的结果集递推出最终最优结果。他们之间构成了一个递归的关系。而对于部分背包问题来说，我们可以考虑用贪婪算法，每次选择当前看来最优的结果。最终也构成了一个最优的结果。一个小小的前提变化，问题解决的思路却大不同。里面的思想值得反复体会。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假设我们有n件物品，分别编号为1, 2…n。其中编号为i的物品价值为$v_i$，它的重量为$w_i$。为了简化问题，假定价值和重量都是整数值。现在，假设我们有一个背包，它能够承载的重量是W。现在，我们希望往包里装这些物品，使得包里装的物品价值最大化，那么我们该如何来选择装的东西呢？问题结构如下图所示：&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="0-1背包" scheme="http://yoursite.com/tags/0-1%E8%83%8C%E5%8C%85/"/>
    
      <category term="部分背包" scheme="http://yoursite.com/tags/%E9%83%A8%E5%88%86%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法题解（9）：最长公共子序列和最长公共子串</title>
    <link href="http://yoursite.com/2017/08/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%EF%BC%889%EF%BC%89%EF%BC%9A%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2017/08/08/数据结构与算法题解（9）：最长公共子序列和最长公共子串/</id>
    <published>2017-08-08T14:20:45.000Z</published>
    <updated>2017-09-01T06:40:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、最长公共子序列（LCS）"><a href="#一、最长公共子序列（LCS）" class="headerlink" title="一、最长公共子序列（LCS）"></a>一、最长公共子序列（LCS）</h2><p>求最长公共子序列的数目，注意这里的子序列可以不是连续序列，务必问清楚题意。求『最长』类的题目往往与动态规划有点关系，这里是两个字符串，故应为双序列动态规划。</p><a id="more"></a><p>这道题的状态很容易找，不妨先试试以$f[i][j]$表示字符串 A 的前 i 位和字符串 B 的前 j 位的最长公共子序列数目，那么接下来试试寻找其状态转移方程。</p><p>从实际例子ABCD和EDCA出发，首先初始化f的长度为字符串长度加1，那么有$f[0][0] = 0, f[0][<em>] = 0, f[</em>][0] = 0$,最后应该返回$f[lenA][lenB]$. 即 f 中索引与字符串索引对应(字符串索引从1开始算起)，那么在A 的第一个字符与 B 的第一个字符相等时，$f[1][1] = 1 + f[0][0]$, 否则$f[1][1] = max(f[0][1], f[1][0])$。</p><p>推而广之，也就意味着若$A[i] == B[j]$, 则分别去掉这两个字符后，原 LCS 数目减一，那为什么一定是1而不是0或者2呢？因为不管公共子序列是以哪个字符结尾，在$A[i] == B[j]$时 LCS 最多只能增加1. 而在$A[i] != B[j]$时，由于A[i] 或者 B[j] 不可能同时出现在最终的 LCS 中，故这个问题可进一步缩小，$f[i][j] = max(f[i - 1][j], f[i][j - 1])$. 需要注意的是这种状态转移方程只依赖最终的 LCS 数目，而不依赖于公共子序列到底是以第几个索引结束。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15034696397233.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String A, String B)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span> || A.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (B == <span class="keyword">null</span> || B.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> lenA = A.length();</div><div class="line">        <span class="keyword">int</span> lenB = B.length();</div><div class="line">        <span class="keyword">int</span>[][] lcs = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span> + lenA][<span class="number">1</span> + lenB];</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1</span> + lenA; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">1</span> + lenB; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (A.charAt(i - <span class="number">1</span>) == B.charAt(j - <span class="number">1</span>)) &#123;</div><div class="line">                    lcs[i][j] = <span class="number">1</span> + lcs[i - <span class="number">1</span>][j - <span class="number">1</span>];</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    lcs[i][j] = Math.max(lcs[i - <span class="number">1</span>][j], lcs[i][j - <span class="number">1</span>]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> lcs[lenA][lenB];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        String source = <span class="string">"zhanghua"</span>;  </div><div class="line">        String target = <span class="string">"zhanghau"</span>;  </div><div class="line">        System.out.println(<span class="string">"longestCommonSubsequence="</span> + longestCommonSubsequence(source, target));  </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="二、最长公共子串"><a href="#二、最长公共子串" class="headerlink" title="二、最长公共子串"></a>二、最长公共子串</h2><h3 id="2-1-简单考虑"><a href="#2-1-简单考虑" class="headerlink" title="2.1 简单考虑"></a>2.1 简单考虑</h3><p>可以使用两根指针索引分别指向两个字符串的当前遍历位置，若遇到相等的字符时则同时向后移动一位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">longestCommonSubstring</span><span class="params">(String A, String B)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (A == <span class="keyword">null</span> || A.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (B == <span class="keyword">null</span> || B.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> lenA = A.length();</div><div class="line">        <span class="keyword">int</span> lenB = B.length();     </div><div class="line">        <span class="keyword">int</span> lcs = <span class="number">0</span>, lcs_temp = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenA; ++i) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lenB; ++j) &#123;</div><div class="line">                lcs_temp = <span class="number">0</span>;</div><div class="line">                <span class="keyword">while</span> ((i + lcs_temp &lt; lenA) &amp;&amp;</div><div class="line">                       (j + lcs_temp &lt; lenB) &amp;&amp;</div><div class="line">                       (A.charAt(i + lcs_temp) == B.charAt(j + lcs_temp)))</div><div class="line">                &#123;</div><div class="line">                    ++lcs_temp;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (lcs_temp &gt; lcs) &#123;</div><div class="line">                    lcs = lcs_temp;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> lcs;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        String source = <span class="string">"zhanghua"</span>;  </div><div class="line">        String target = <span class="string">"zhanghau"</span>;  </div><div class="line">        System.out.println(<span class="string">"longestCommonString="</span> + longestCommonSubstring(source, target));  </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-2-动态规划"><a href="#2-2-动态规划" class="headerlink" title="2.2 动态规划"></a>2.2 动态规划</h3><p>把$D[i][j] $定义为：两个string的前i个和前j个字符串，尾部连到最后的最长子串。</p><p>然后$D[i][j] = $</p><ol><li>$i = 0 || j = 0 : 0$</li><li>$s1.char[i - 1] = s2.char[j - 1] ? D[i-1][j-1] + 1 : 0;$</li></ol><p>另外，创建一个max的缓存，不段更新即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">longestCommonSubstring</span><span class="params">(String A, String B)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (A == <span class="keyword">null</span> || A.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (B == <span class="keyword">null</span> || B.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> lenA = A.length();</div><div class="line">        <span class="keyword">int</span> lenB = B.length();        </div><div class="line">        <span class="keyword">int</span>[][] D = <span class="keyword">new</span> <span class="keyword">int</span>[lenA + <span class="number">1</span>][lenB + <span class="number">1</span>];        </div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">      </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= lenA; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= lenB; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</div><div class="line">                    D[i][j] = <span class="number">0</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (A.charAt(i - <span class="number">1</span>) == B.charAt(j - <span class="number">1</span>)) &#123;</div><div class="line">                        D[i][j] = D[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        D[i][j] = <span class="number">0</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;                </div><div class="line">                max = Math.max(max, D[i][j]);</div><div class="line">            &#125;</div><div class="line">        &#125;        </div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        String source = <span class="string">"zhanghua"</span>;  </div><div class="line">        String target = <span class="string">"zhanghau"</span>;  </div><div class="line">        System.out.println(<span class="string">"longestCommonString="</span> + longestCommonSubstring(source, target));  </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、最长公共子序列（LCS）&quot;&gt;&lt;a href=&quot;#一、最长公共子序列（LCS）&quot; class=&quot;headerlink&quot; title=&quot;一、最长公共子序列（LCS）&quot;&gt;&lt;/a&gt;一、最长公共子序列（LCS）&lt;/h2&gt;&lt;p&gt;求最长公共子序列的数目，注意这里的子序列可以不是连续序列，务必问清楚题意。求『最长』类的题目往往与动态规划有点关系，这里是两个字符串，故应为双序列动态规划。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="最长公共子序列" scheme="http://yoursite.com/tags/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    
      <category term="最长公共子串" scheme="http://yoursite.com/tags/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法题解（8）：KMP算法</title>
    <link href="http://yoursite.com/2017/08/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%EF%BC%888%EF%BC%89%EF%BC%9AKMP%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2017/08/08/数据结构与算法题解（8）：KMP算法/</id>
    <published>2017-08-08T11:20:45.000Z</published>
    <updated>2017-09-01T07:05:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>KMP算法是三位大牛：D.E.Knuth、J.H.Morris和V.R.Pratt同时发现的。其中第一位就是《计算机程序设计艺术》的作者！</p><a id="more"></a><p>KMP算法要解决的问题就是在字符串（也叫主串）中的模式（pattern）定位问题。说简单点就是我们平时常说的关键字搜索。模式串就是关键字（接下来称它为P），如果它在一个主串（接下来称为T）中出现，就返回它的具体位置，否则返回-1（常用手段）。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15036521901218.png" alt=""></p><p>首先，对于这个问题有一个很单纯的想法：从左到右一个个匹配，如果这个过程中有某个字符不匹配，就跳回去，将模式串向右移动一位。这有什么难的？</p><p>我们可以这样初始化：<br><img src="http://omu7tit09.bkt.clouddn.com/15036522704129.png" alt=""></p><p>之后我们只需要比较i指针指向的字符和j指针指向的字符是否一致。如果一致就都向后移动，如果不一致，如下图：<br><img src="http://omu7tit09.bkt.clouddn.com/15036522864541.png" alt=""></p><p>A和E不相等，那就把i指针移回第1位（假设下标从0开始），j移动到模式串的第0位，然后又重新开始这个步骤：<br><img src="http://omu7tit09.bkt.clouddn.com/15036523099449.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class Demo&#123;</div><div class="line">public static int bf(String ts,String ps) &#123;</div><div class="line">char[] t = ts.toCharArray();</div><div class="line">char[] p = ps.toCharArray();</div><div class="line">int i = 0; // 主串的位置</div><div class="line">int j = 0; // 模式串的位置</div><div class="line">while (i &lt; t.length &amp;&amp; j &lt; p.length) &#123;</div><div class="line">    if (t[i] == p[j]) &#123; // 当两个字符相同，就比较下一个</div><div class="line">    i++;</div><div class="line">    j++;</div><div class="line">    &#125;else &#123;</div><div class="line">    i = i - j + 1; // 一旦不匹配，i后退</div><div class="line">    j = 0; // j归0</div><div class="line">    &#125;</div><div class="line">    &#125;</div><div class="line">if (j == p.length) &#123;</div><div class="line">return i - j;</div><div class="line">     &#125;else &#123;</div><div class="line">        return -1;</div><div class="line">     &#125; </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面的程序是没有问题的，但不够好！如果是人为来寻找的话，肯定不会再把i移动回第1位，因为主串匹配失败的位置前面除了第一个A之外再也没有A了，我们为什么能知道主串前面只有一个A？因为我们已经知道前面三个字符都是匹配的！（这很重要）。移动过去肯定也是不匹配的！有一个想法，i可以不动，我们只需要移动j即可，如下图：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15036591308626.png" alt=""></p><p>上面的这种情况还是比较理想的情况，我们最多也就多比较了再次。但假如是在主串“SSSSSSSSSSSSSA”中查找“SSSSB”，比较到最后一个才知道不匹配，然后i回溯，这个的效率是显然是最低的。</p><p>大牛们是无法忍受“暴力破解”这种低效的手段的，于是他们三个研究出了KMP算法。其思想就如同我们上边所看到的一样：“利用已经部分匹配这个有效信息，保持i指针不回溯，通过修改j指针，让模式串尽量地移动到有效的位置。”</p><p>所以，整个KMP的重点就在于当某一个字符与主串不匹配时，我们应该知道j指针要移动到哪？</p><p>接下来我们自己来发现j的移动规律：<br><img src="http://omu7tit09.bkt.clouddn.com/15036591850964.png" alt=""></p><p>如图：C和D不匹配了，我们要把j移动到哪？显然是第1位。为什么？因为前面有一个A相同啊：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15036591696046.png" alt=""></p><p>如下图也是一样的情况：<br><img src="http://omu7tit09.bkt.clouddn.com/15036592059994.png" alt=""></p><p>可以把j指针移动到第2位，因为前面有两个字母是一样的：<br><img src="http://omu7tit09.bkt.clouddn.com/15036592316849.png" alt=""></p><p>至此我们可以大概看出一点端倪，当匹配失败时，j要移动的下一个位置k。存在着这样的性质：最前面的k个字符和j之前的最后k个字符是一样的。</p><p>如果用数学公式来表示是这样的</p><script type="math/tex; mode=display">P[0，k-1] == P[j-k， j-1]</script><p>这个相当重要，如果觉得不好记的话，可以通过下图来理解：<br><img src="http://omu7tit09.bkt.clouddn.com/15036593863265.png" alt=""></p><p>弄明白了这个就应该可能明白为什么可以直接将j移动到k位置了。</p><p>因为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">当T[i] != P[j]时</div><div class="line"></div><div class="line">有T[i-j ~ i-1] == P[0 ~ j-1]</div><div class="line"></div><div class="line">由P[0 ~ k-1] == P[j-k ~ j-1]</div><div class="line"></div><div class="line">必然：T[i-k ~ i-1] == P[0 ~ k-1]</div></pre></td></tr></table></figure><p>公式很无聊，能看明白就行了，不需要记住。</p><p>这一段只是为了证明我们为什么可以直接将j移动到k而无须再比较前面的k个字符。</p><p>好，接下来就是重点了，怎么求这个（这些）k呢？因为在P的每一个位置都可能发生不匹配，也就是说我们要计算每一个位置j对应的k，所以用一个数组next来保存，next[j] = k，表示当T[i] != P[j]时，j指针的下一个位置。</p><p>很多教材或博文在这个地方都是讲得比较含糊或是根本就一笔带过，甚至就是贴一段代码上来，为什么是这样求？怎么可以这样求？根本就没有说清楚。而这里恰恰是整个算法最关键的地方。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class Demo&#123;</div><div class="line">    public static int[] getNext(String ps) &#123;</div><div class="line">        char[] p = ps.toCharArray();  </div><div class="line">int[] next = new int[p.length];  </div><div class="line">next[0] = -1;  </div><div class="line">int j = 0; </div><div class="line">int k = -1; </div><div class="line">while (j &lt; p.length - 1) &#123;</div><div class="line">    if (k == -1 || p[j] == p[k]) &#123;</div><div class="line">        next[++j] = ++k;</div><div class="line">    &#125; else &#123;</div><div class="line">    k = next[k]; </div><div class="line">    &#125;</div><div class="line">        &#125;</div><div class="line">return next;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个版本的求next数组的算法应该是流传最广泛的，代码是很简洁。可是真的很让人摸不到头脑，它这样计算的依据到底是什么？<br>好，先把这个放一边，我们自己来推导思路，现在要始终记住一点，next[j]的值（也就是k）表示，当P[j] != T[i]时，j指针的下一步移动位置。<br>先来看第一个：当j为0时，如果这时候不匹配，怎么办？<br><img src="http://omu7tit09.bkt.clouddn.com/15036596409499.png" alt=""><br>像上图这种情况，j已经在最左边了，不可能再移动了，这时候要应该是i指针后移。所以在代码中才会有next[0] = -1;这个初始化。<br>如果是当j为1的时候呢？<br><img src="http://omu7tit09.bkt.clouddn.com/15036596563400.png" alt=""></p><p>显然，j指针一定是后移到0位置的。因为它前面也就只有这一个位置了~~~<br>下面这个是最重要的，请看如下图：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15036596826271.png" alt=""><br><img src="http://omu7tit09.bkt.clouddn.com/15036596746756.png" alt=""></p><p>请仔细对比这两个图。我们发现一个规律：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">当P[k] == P[j]时，</div><div class="line">有next[j+1] == next[j] + 1</div></pre></td></tr></table></figure><p>其实这个是可以证明的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">因为在P[j]之前已经有P[0 ~ k-1] == p[j-k ~ j-1]。（next[j] == k）</div><div class="line">这时候现有P[k] == P[j]，我们是不是可以得到P[0 ~ k-1] + P[k] == p[j-k ~ j-1] + P[j]。</div><div class="line">即：P[0 ~ k] == P[j-k ~ j]，即next[j+1] == k + 1 == next[j] + 1。</div></pre></td></tr></table></figure><p>这里的公式不是很好懂，还是看图会容易理解些。<br>那如果P[k] != P[j]呢？比如下图所示：<br><img src="http://omu7tit09.bkt.clouddn.com/15036597544967.png" alt=""><br>像这种情况，如果你从代码上看应该是这一句：k = next[k];为什么是这样子？你看下面应该就明白了。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15036597847125.png" alt=""></p><p>现在你应该知道为什么要k = next[k]了吧！像上边的例子，我们已经不可能找到[ A，B，A，B ]这个最长的后缀串了，但我们还是可能找到[ A，B ]、[ B ]这样的前缀串的。所以这个过程像不像在定位[ A，B，A，C ]这个串，当C和主串不一样了（也就是k位置不一样了），那当然是把指针移动到next[k]啦。</p><p>在P[K]!=P[j]时，我们已经知道（0，k-1）串和（j-k,j-1）串是相等的，所以可以把（0，k-1）串当做一个新的模式串，发现在新模式串中（0，next[k]-1）串与（k-next[k],k-1）串相等，所以（j-k,j-1）中存在与（0，next[k]-1）相等的串，所以可以把j移动到next[k],继续比较和移动。</p><p>有了next数组之后就一切好办了，我们可以动手写KMP算法了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">KMP</span><span class="params">(String ts, String ps)</span> </span>&#123;</div><div class="line">    <span class="keyword">char</span>[] t = ts.toCharArray();</div><div class="line">    <span class="keyword">char</span>[] p = ps.toCharArray();</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// 主串的位置</span></div><div class="line">    <span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">// 模式串的位置</span></div><div class="line">    <span class="keyword">int</span>[] next = getNext(ps);</div><div class="line">    <span class="keyword">while</span> (i &lt; t.length &amp;&amp; j &lt; p.length) &#123;</div><div class="line">        <span class="keyword">if</span> (j == -<span class="number">1</span> || t[i] == p[j]) &#123; <span class="comment">// 当j为-1时，要移动的是i，当然j也要归0</span></div><div class="line">        i++;</div><div class="line">        j++;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// i不需要回溯了</span></div><div class="line">        <span class="comment">// i = i - j + 1;</span></div><div class="line">        j = next[j]; <span class="comment">// j回到指定位置</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (j == p.length) &#123;</div><div class="line">    <span class="keyword">return</span> i - j;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>和暴力破解相比，就改动了4个地方。其中最主要的一点就是，i不需要回溯了。</p><p>最后，来看一下上边的算法存在的缺陷。来看第一个例子：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15036600188582.png" alt=""><br>显然，当我们上边的算法得到的next数组应该是[ -1，0，0，1 ]</p><p>所以下一步我们应该是把j移动到第1个元素咯：<img src="http://omu7tit09.bkt.clouddn.com/15036600286300.png" alt=""><br>不难发现，这一步是完全没有意义的。因为后面的B已经不匹配了，那前面的B也一定是不匹配的，同样的情况其实还发生在第2个元素A上。<br>显然，发生问题的原因在于P[j] == P[next[j]]。<br>所以我们也只需要添加一个判断条件即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getNext(String ps) &#123;</div><div class="line">        <span class="keyword">char</span>[] p = ps.toCharArray();  </div><div class="line"><span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[p.length];  </div><div class="line">next[<span class="number">0</span>] = -<span class="number">1</span>;  </div><div class="line"><span class="keyword">int</span> j = <span class="number">0</span>; </div><div class="line"><span class="keyword">int</span> k = -<span class="number">1</span>; </div><div class="line"><span class="keyword">while</span> (j &lt; p.length - <span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (k == -<span class="number">1</span> || p[j] == p[k]) &#123;</div><div class="line">    <span class="keyword">if</span> (p[++j] == p[++k]) &#123; <span class="comment">// 当两个字符相等时要跳过</span></div><div class="line">    next[++j] = ++k;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">    next[j] = k;;</div><div class="line">    &#125; </div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">    k = next[k];</div><div class="line">    &#125;</div><div class="line">        &#125;</div><div class="line"><span class="keyword">return</span> next;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;KMP算法是三位大牛：D.E.Knuth、J.H.Morris和V.R.Pratt同时发现的。其中第一位就是《计算机程序设计艺术》的作者！&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="KMP算法" scheme="http://yoursite.com/tags/KMP%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法题解（7）：最短编辑距离</title>
    <link href="http://yoursite.com/2017/08/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%EF%BC%887%EF%BC%89%EF%BC%9A%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    <id>http://yoursite.com/2017/08/07/数据结构与算法题解（7）：最短编辑距离/</id>
    <published>2017-08-07T14:20:45.000Z</published>
    <updated>2017-09-01T06:40:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>现代搜索技术的发展很多以提供优质、高效的服务作为目标。比如说：baidu、google、sousou等知名全文搜索系统。当我们输入一个错误的query=”Jave” 的时候，返回中有大量包含正确的拼写 “Java”的网页。是怎么做到的呢？这其中，字符串的相似度计算是做到这一点的方法之一。</p><a id="more"></a><h2 id="一、字符串编辑距离"><a href="#一、字符串编辑距离" class="headerlink" title="一、字符串编辑距离"></a>一、字符串编辑距离</h2><p>是一种字符串之间相似度计算的方法。给定两个字符串S、T，将S转换成T所需要的删除，插入，替换操作的数量就叫做S到T的编辑路径。而最短的编辑路径就叫做字符串S和T的编辑距离。</p><p>举个例子：S=“eeba”   T=”abac”   我们可以按照这样的步骤转变：(1) 将S中的第一个e变成a;(2) 删除S中的第二个e;(3)在S中最后添加一个c; 那么S到T的编辑路径就等于3。当然，这种变换并不是唯一的，但如果3是所有变换中最小值的话。那么我们就可以说S和T的编辑距离等于3了。</p><h2 id="二、动态规划解决编辑距离"><a href="#二、动态规划解决编辑距离" class="headerlink" title="二、动态规划解决编辑距离"></a>二、动态规划解决编辑距离</h2><p>动态规划(dynamic programming)是一种解决复杂问题最优解的策略。它的基本思路就是：将一个复杂的最优解问题分解成一系列较为简单的最优解问题，再将较为简单的的最优解问题进一步分解，直到可以一眼看出最优解为止。</p><p>动态规划算法是解决复杂问题最优解的重要算法。其算法的难度并不在于算法本身的递归难以实现，而主要是编程者对问题本身的认识是否符合动态规划的思想。现在我们就来看看动态规划是如何解决编辑距离的。</p><p>假设$dp[i-1][j-1]$表示一个长为$i-1$的字符串$str1$变为长为$j-1$的字符串str2的最短距离，如果我们此时想要把$str1a$这个字符串变成$str2b$这个字符串，我们有如下几种选择：</p><ul><li>替换： 在str1变成str2的步骤后，我们将str1a中的a替换为b，就得到str2b (如果a和b相等，就不用操作)</li><li>增加： 在str1a变成str2的步骤后，我们再在末尾添加一个b，就得到str2b (str1a先根据已知距离变成str2，再加个b)</li><li>删除： 在str1变成str2b的步骤后，对于str1a，我们将末尾的a删去，就得到str2b (str1a将a删去得到str1，而str1到str2b的编辑距离已知)</li></ul><p>根据这三种操作，我们可以得到递推式</p><p>若a和b相等：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dp[i][j] = min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1])</div></pre></td></tr></table></figure><p>若a和b不相等：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dp[i][j] = min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+1)</div></pre></td></tr></table></figure><p>因为将一个非空字符串变成空字符串的最小操作数是字母个数（全删），反之亦然，所以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dp[0][j]=j, dp[i][0]=i</div></pre></td></tr></table></figure><p>最后我们只要返回dp[m][n]即可，其中m是word1的长度，n是word2的长度</p><h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class Demo &#123;</div><div class="line">    public static int minDistance(String word1, String word2) &#123;</div><div class="line">        int m = word1.length(), n = word2.length();</div><div class="line">        int[][] dp = new int[m + 1][n + 1];</div><div class="line">        // 初始化空字符串的情况</div><div class="line">        for(int i = 1; i &lt;= m; i++)&#123;</div><div class="line">            dp[i][0] = i;</div><div class="line">        &#125;</div><div class="line">        for(int i = 1; i &lt;= n; i++)&#123;</div><div class="line">            dp[0][i] = i;</div><div class="line">        &#125;</div><div class="line">        for(int i = 1; i &lt;= m; i++)&#123;</div><div class="line">            for(int j = 1; j &lt;= n; j++)&#123;</div><div class="line">                // 增加操作：str1a变成str2后再加上b，得到str2b</div><div class="line">                int insertion = dp[i][j-1] + 1;</div><div class="line">                // 删除操作：str1a删除a后，再由str1变为str2b</div><div class="line">                int deletion = dp[i-1][j] + 1;</div><div class="line">                // 替换操作：先由str1变为str2，然后str1a的a替换为b，得到str2b</div><div class="line">                int replace = dp[i-1][j-1] + (word1.charAt(i - 1) == word2.charAt(j - 1) ? 0 : 1);</div><div class="line">                // 三者取最小</div><div class="line">                dp[i][j] = Math.min(replace, Math.min(insertion, deletion));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return dp[m][n];</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">        String source = &quot;zhanghua&quot;;  </div><div class="line">        String target = &quot;zhanghau&quot;;  </div><div class="line">        System.out.println(&quot;minDistance=&quot; + minDistance(source, target));  </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>测试结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">minDistance=2</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现代搜索技术的发展很多以提供优质、高效的服务作为目标。比如说：baidu、google、sousou等知名全文搜索系统。当我们输入一个错误的query=”Jave” 的时候，返回中有大量包含正确的拼写 “Java”的网页。是怎么做到的呢？这其中，字符串的相似度计算是做到这一点的方法之一。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="最短编辑距离" scheme="http://yoursite.com/tags/%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法题解（6）：重点掌握</title>
    <link href="http://yoursite.com/2017/08/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%EF%BC%886%EF%BC%89%EF%BC%9A%E9%87%8D%E7%82%B9%E6%8E%8C%E6%8F%A1/"/>
    <id>http://yoursite.com/2017/08/06/数据结构与算法题解（6）：重点掌握/</id>
    <published>2017-08-06T14:20:45.000Z</published>
    <updated>2017-09-01T06:39:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>最基础的数据结构与算法java实现。</p><a id="more"></a><h2 id="一、排序"><a href="#一、排序" class="headerlink" title="一、排序"></a>一、排序</h2><p>排序面试题：</p><ul><li>实现快速排序以及时空复杂度分析</li><li>实现归并排序以及时空复杂度分析</li><li>实现堆排序以及时空复杂度分析</li></ul><h3 id="1-1-归并排序"><a href="#1-1-归并排序" class="headerlink" title="1.1 归并排序"></a>1.1 <a href="http://flyingcat2013.blog.51cto.com/7061638/1281026" target="_blank" rel="noopener">归并排序</a></h3><p>归并排序是典型的二路合并排序，将原始数据集分成两部分(不一定能够均分)，分别对它们进行排序，然后将排序后的子数据集进行合并，典型的分治法策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSortTest</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        <span class="keyword">int</span>[] data = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span> &#125;;  </div><div class="line">        print(data);  </div><div class="line">        mergesort(data);  </div><div class="line">        System.out.println(<span class="string">"排序后的数组："</span>);  </div><div class="line">        print(data);  </div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</div><div class="line">        sort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</div><div class="line">        <span class="comment">//当left==right的时，已经不需要再划分了</span></div><div class="line">        <span class="keyword">if</span> (left&lt;right)&#123;</div><div class="line">            <span class="keyword">int</span> middle = (left+right)/<span class="number">2</span>;</div><div class="line">            sort(a, left, middle);          <span class="comment">//左子数组</span></div><div class="line">            sort(a, middle+<span class="number">1</span>, right);       <span class="comment">//右子数组</span></div><div class="line">            merge(a, left, middle, right);    <span class="comment">//合并两个子数组</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 合并两个有序子序列 arr[left, ..., middle] 和 arr[middle+1, ..., right]。temp是辅助数组。</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> middle, <span class="keyword">int</span> right)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[right - left + <span class="number">1</span>];</div><div class="line">        <span class="keyword">int</span> i=left;     </div><div class="line">        <span class="keyword">int</span> j=middle+<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</div><div class="line">        <span class="comment">//将记录由小到大地放进temp数组</span></div><div class="line">        <span class="keyword">while</span> ( i&lt;=middle &amp;&amp; j&lt;=right)&#123;</div><div class="line">            <span class="keyword">if</span> (arr[i] &lt;=arr[j])&#123;</div><div class="line">                temp[k++] = arr[i++];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                temp[k++] = arr[j++];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (i &lt;=middle)&#123;</div><div class="line">            temp[k++] = arr[i++];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> ( j&lt;=right)&#123;</div><div class="line">            temp[k++] = arr[j++];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//把数据复制回原数组</span></div><div class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;k; ++i)&#123;</div><div class="line">            arr[left+i] = temp[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;  </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;  </div><div class="line">            System.out.print(data[i] + <span class="string">"\t"</span>);  </div><div class="line">        &#125;  </div><div class="line">        System.out.println();  </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在合并数组的时候需要一个temp数组。我们当然有足够的理由在每次调用的时候重新new一个数组（例如，减少一个参数），但是，注意到多次的创建数组对象会造成额外的开销，我们可以在开始就创建一个足够大的数组（等于原数组长度就行），以后都使用这个数组。实际上，上面的代码就是这么写的。</p><ul><li>时间复杂度：在归并排序中，进行一趟归并需要的关键字比较次数和数据元素移动次数最多为$n$，需要归并的趟数$log n$，故归并排序的时间复杂度为$O(nlog n)$。并且由于归并算法是固定的，不受输入数据影响，所以它在最好、最坏、平均情况下表现几乎相同，均为$O(log n)$。</li></ul><ul><li><p>空间复杂度：归并排序需要长度等于序列长度为$n$的辅助存储单元，故归并排序的空间复杂度为$O(n)$。归并排序最大的缺陷在于其空间复杂度。可不可以省略这个数组呢？不行!如果取消辅助数组而又要保证原来的数组中数据不被覆盖，那就必须要在数组中花费大量时间来移动数据。不仅容易出错，还降低了效率。因此这个辅助空间是少不掉的。</p></li><li><p>稳定性：因为我们在遇到相等的数据的时候必然是按顺序“抄写”到辅助数组上的，所以，归并排序是稳定的排序算法。</p></li></ul><h3 id="1-2-快速排序"><a href="#1-2-快速排序" class="headerlink" title="1.2 快速排序"></a>1.2 <a href="http://flyingcat2013.blog.51cto.com/7061638/1281614" target="_blank" rel="noopener">快速排序</a></h3><p>快速排序是图灵奖得主C.R.A Hoare于1960年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为<a href="https://www.wikiwand.com/en/Quicksort" target="_blank" rel="noopener">分治法（Divide-and-Conquer Method）</a></p><p>分治法的基本思想是：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题组合为原问题的解。</p><p>利用分治法可将快速排序分为三步：</p><ol><li>从数列中挑出一个元素作为“基准”（pivot）。</li><li>分区过程，将比基准数大的放到右边，小于或等于它的数都放到左边。这个操作称为“分区操作”，分区操作结束后，基准元素所处的位置就是最终排序后它的位置</li><li>再对“基准”左右两边的子集不断重复第一步和第二步，直到所有子集只剩下一个元素为止。</li></ol><p><img src="http://omu7tit09.bkt.clouddn.com/15005341612963.gif" alt=""></p><p><img src="http://omu7tit09.bkt.clouddn.com/15003837844027.gif" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">quickSortTest</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        <span class="keyword">int</span>[] data = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span> &#125;;  </div><div class="line">        print(data);  </div><div class="line">        quickSort(data);  </div><div class="line">        System.out.println(<span class="string">"排序后的数组："</span>);  </div><div class="line">        print(data);  </div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</div><div class="line">        qsort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (left &lt; right)&#123;</div><div class="line">            <span class="keyword">int</span> pivot=partition(arr, left, right);        <span class="comment">//将数组分为两部分</span></div><div class="line">            qsort(arr, left, pivot-<span class="number">1</span>);                   <span class="comment">//递归排序左子数组</span></div><div class="line">            qsort(arr, pivot+<span class="number">1</span>, right);                  <span class="comment">//递归排序右子数组</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> pivot = arr[left];     <span class="comment">//基准记录</span></div><div class="line">        <span class="keyword">while</span> (left&lt;right)&#123;</div><div class="line">            <span class="keyword">while</span> (left&lt;right &amp;&amp; arr[right]&gt;=pivot) --right;</div><div class="line">            arr[left]=arr[right];             <span class="comment">//交换比基准小的记录到左端</span></div><div class="line">            <span class="keyword">while</span> (left&lt;right &amp;&amp; arr[left]&lt;=pivot) ++left;</div><div class="line">            arr[right] = arr[left];           <span class="comment">//交换比基准大的记录到右端</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//扫描完成，基准到位</span></div><div class="line">        arr[left] = pivot;</div><div class="line">        <span class="comment">//返回的是基准的位置</span></div><div class="line">        <span class="keyword">return</span> left;</div><div class="line">    &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;  </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;  </div><div class="line">            System.out.print(data[i] + <span class="string">"\t"</span>);  </div><div class="line">        &#125;  </div><div class="line">        System.out.println();  </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="二、查找"><a href="#二、查找" class="headerlink" title="二、查找"></a>二、查找</h2><h3 id="2-1-二分查找"><a href="#2-1-二分查找" class="headerlink" title="2.1 二分查找"></a>2.1 二分查找</h3><p><img src="http://omu7tit09.bkt.clouddn.com/15013013945001.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">int binary_search(int array[],int n,int value)    </div><div class="line">&#123;    </div><div class="line">    int left=0;    </div><div class="line">    int right=n-1;    </div><div class="line">    while (left&lt;=right)  </div><div class="line">    &#123;    </div><div class="line">        int middle=left + ((right-left)&gt;&gt;1);      </div><div class="line">        if (array[middle]&gt;value)    </div><div class="line">        &#123;    </div><div class="line">            right =middle-1;   //right赋值，适时而变    </div><div class="line">        &#125;     </div><div class="line">        else if(array[middle]&lt;value)    </div><div class="line">        &#123;    </div><div class="line">            left=middle+1;    </div><div class="line">        &#125;    </div><div class="line">        else    </div><div class="line">            return middle;          </div><div class="line">    &#125;    </div><div class="line">    return -1;    </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="三、二叉树"><a href="#三、二叉树" class="headerlink" title="三、二叉树"></a>三、二叉树</h2><p>这块内容讨论二叉树的常见遍历方式的代码（java）实现，包括前序（preorder）、中序（inorder）、后序（postorder）、层序（levelorder），进一步考虑递归和非递归的实现方式。</p><p>递归的实现方法相对简单，但由于递归的执行方式每次都会产生一个新的方法调用栈，如果递归层级较深，会造成较大的内存开销，相比之下，非递归的方式则可以避免这个问题。递归遍历容易实现，非递归则没那么简单，非递归调用本质上是通过维护一个栈，模拟递归调用的方法调用栈的行为。</p><p>在此之前，先简单定义节点的数据结构：</p><p>二叉树节点最多只有两个儿子，并保存一个节点的值，为了实验的方便，假定它为 int。同时，我们直接使用 Java 的 System.out.print 方法来输出节点值，以显示遍历结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;  </div><div class="line">    <span class="keyword">public</span> Node left;  </div><div class="line">    <span class="keyword">public</span> Node right;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;  </div><div class="line">        <span class="keyword">this</span>.value=v;  </div><div class="line">        <span class="keyword">this</span>.left=<span class="keyword">null</span>;  </div><div class="line">        <span class="keyword">this</span>.right=<span class="keyword">null</span>;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-1-前序遍历"><a href="#3-1-前序遍历" class="headerlink" title="3.1 前序遍历"></a>3.1 前序遍历</h3><h4 id="3-1-1-递归实现"><a href="#3-1-1-递归实现" class="headerlink" title="3.1.1 递归实现"></a>3.1.1 递归实现</h4><p>递归实现很简单，在每次访问到某个节点时，先输出节点值，然后再依次递归的对左儿子、右儿子调用遍历的方法。代码如下</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</div><div class="line">        System.out.print(root.value);</div><div class="line">        preOrder(root.left);</div><div class="line">        preOrder(root.right);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="3-1-2-非递归实现"><a href="#3-1-2-非递归实现" class="headerlink" title="3.1.2 非递归实现"></a>3.1.2 非递归实现</h4><p>利用栈实现循环先序遍历二叉树，维护一个栈，将根节点入栈，只要栈不为空，出栈并访问，接着依次将访问节点的右节点、左节点入栈。这种方式是对先序遍历的一种特殊实现，简洁明了，但是不具备很好地扩展性，在中序和后序方式中不适用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span>;</div><div class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</div><div class="line">    stack.push(root);</div><div class="line">    <span class="keyword">while</span>(!stack.isEmpty)&#123;</div><div class="line">        Node temp = stack.pop();</div><div class="line">        System.out.print(temp.value);</div><div class="line">        <span class="keyword">if</span>(temp.right!=<span class="keyword">null</span>)stack.push(temp.right);</div><div class="line">        <span class="keyword">if</span>(temp.left!=<span class="keyword">null</span>)stack.push(temp.left);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>还有一种方式就是利用栈模拟递归过程实现循环先序遍历二叉树。这种方式具备扩展性，它模拟了递归的过程，将左子树不断的压入栈，直到null，然后处理栈顶节点的右子树。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span>;</div><div class="line">    Stack&lt;Node&gt; s = <span class="keyword">new</span> Stack&lt;Node&gt;();</div><div class="line">    <span class="keyword">while</span>(root!=<span class="keyword">null</span>||!s.isEmtpy())&#123;</div><div class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</div><div class="line">            System.out.print(root.value);、<span class="comment">//先访问</span></div><div class="line">            s.push(root);<span class="comment">//再入栈</span></div><div class="line">            root = root.left;</div><div class="line">        &#125;</div><div class="line">        root = s.pop();</div><div class="line">        root = root.right;<span class="comment">//如果是null，出栈并处理右子树</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-2-中序遍历"><a href="#3-2-中序遍历" class="headerlink" title="3.2 中序遍历"></a>3.2 中序遍历</h3><h4 id="3-2-1-递归实现"><a href="#3-2-1-递归实现" class="headerlink" title="3.2.1 递归实现"></a>3.2.1 递归实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</div><div class="line">        preOrder(root.left);</div><div class="line">        System.out.print(root.value);</div><div class="line">        preOrder(root.right);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="3-2-2-非递归实现"><a href="#3-2-2-非递归实现" class="headerlink" title="3.2.2 非递归实现"></a>3.2.2 非递归实现</h4><p>利用栈模拟递归过程实现循环中序遍历二叉树。跟前序遍历的非递归实现方法二很类似。唯一的不同是访问当前节点的时机：前序遍历在入栈前访问，而中序遍历在出栈后访问。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span>;</div><div class="line">    Stack&lt;Node&gt; s = Stack&lt;Node&gt;();</div><div class="line">    <span class="keyword">while</span>(root!=<span class="keyword">null</span>||s.isEmpty())&#123;</div><div class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</div><div class="line">            s.push(root);</div><div class="line">            root=root.left;</div><div class="line">        &#125;</div><div class="line">        root = s.pop(root);</div><div class="line">        System.out.print(root.value);</div><div class="line">        root = root.right;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-3-后序遍历"><a href="#3-3-后序遍历" class="headerlink" title="3.3 后序遍历"></a>3.3 后序遍历</h3><h4 id="3-3-1-递归实现"><a href="#3-3-1-递归实现" class="headerlink" title="3.3.1 递归实现"></a>3.3.1 递归实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</div><div class="line">        preOrder(root.left);</div><div class="line">        preOrder(root.right);</div><div class="line">        System.out.print(root.value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="3-3-2-非递归实现"><a href="#3-3-2-非递归实现" class="headerlink" title="3.3.2 非递归实现"></a>3.3.2 非递归实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span>;</div><div class="line">    Stack&lt;Node&gt; s1 = <span class="keyword">new</span> Stack&lt;Node&gt;();</div><div class="line">    Stack&lt;Node&gt; s2 = <span class="keyword">new</span> Stack&lt;Node&gt;();</div><div class="line">    Node node = root;</div><div class="line">    s1.push(node);</div><div class="line">    <span class="keyword">while</span>(s1!=<span class="keyword">null</span>)&#123;<span class="comment">//这个while循环的功能是找出后序遍历的逆序，存在s2里面</span></div><div class="line">        node = s1.pop();</div><div class="line">        <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) s1.push(node.left);</div><div class="line">        <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)s1.push(node.right);</div><div class="line">        s2.push(node);     </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(s2!=<span class="keyword">null</span>)&#123;<span class="comment">//将s2中的元素出栈，即为后序遍历次序</span></div><div class="line">        node = s2.pop();</div><div class="line">        System.out.print(node.value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-4-层序遍历"><a href="#3-4-层序遍历" class="headerlink" title="3.4 层序遍历"></a>3.4 层序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">levelTravel</span><span class="params">(Node root)</span></span>&#123;  </div><div class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span>;  </div><div class="line">        Queue&lt;Node&gt; q=<span class="keyword">new</span> LinkedList&lt;Node&gt;();  </div><div class="line">        q.add(root);  </div><div class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;  </div><div class="line">            Node temp =  q.poll();  </div><div class="line">            System.out.println(temp.value);  </div><div class="line">            <span class="keyword">if</span>(temp.left!=<span class="keyword">null</span>)q.add(temp.left);  </div><div class="line">            <span class="keyword">if</span>(temp.right!=<span class="keyword">null</span>)q.add(temp.right);  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最基础的数据结构与算法java实现。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法题解（5）：剑指offer解题报告</title>
    <link href="http://yoursite.com/2017/08/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%EF%BC%885%EF%BC%89%EF%BC%9A%E5%89%91%E6%8C%87offer%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <id>http://yoursite.com/2017/08/05/数据结构与算法题解（5）：剑指offer解题报告/</id>
    <published>2017-08-05T14:20:45.000Z</published>
    <updated>2017-12-26T06:34:34.200Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer编程题java实现整理。</p><a id="more"></a><h2 id="3-二维数组中的查找（数组）"><a href="#3-二维数组中的查找（数组）" class="headerlink" title="3. 二维数组中的查找（数组）"></a>3. 二维数组中的查找（数组）</h2><p>在一个二维数组中，每一行都按照从左到右的递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一维数组和一个整数，判断数组中是否含有该整数。</p><p>首先选取数组中右上角的数字，如果该数字等于我们要查找的数组，查找过程结束；如果该数字大于要查找的数组，剔除这个数字所在的列；如果该数字小于要查找的数组，剔除这个数字所在的行。也就是说如果要查找的数字不再数组的右上角，则每一次都在数组的查找范围中剔除一行或者一列，这样每一步都可以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-28 上午12.21.28.png" alt="屏幕快照 2017-07-28 上午12.21.28"></p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> col = array[<span class="number">0</span>].length - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(row&lt;=array.length-<span class="number">1</span>&amp;&amp;col&gt;=<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(target == array[row][col])&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target&gt;array[row][col])&#123;</div><div class="line">                row++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                col--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>python</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">class Solution:</div><div class="line">    # array 二维列表</div><div class="line">    def Find(self, target, array):</div><div class="line">        # write code here</div><div class="line">        row = 0</div><div class="line">        col = len(array[0])-1</div><div class="line">        while row&lt;=len(array)-1 and col&gt;=0:</div><div class="line">            if target==array[row][col]:</div><div class="line">                return True</div><div class="line">            elif target&gt;array[row][col]:</div><div class="line">                row+=1</div><div class="line">            else:</div><div class="line">                col-=1</div><div class="line">        return False</div></pre></td></tr></table></figure><p>也可以把每一行看做是一个递增的序列，利用二分查找。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</div><div class="line">            <span class="keyword">int</span> low =<span class="number">0</span>;</div><div class="line">            <span class="keyword">int</span> high = array[i].length-<span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span>(low&lt;=high)&#123;</div><div class="line">                <span class="keyword">int</span> mid = (low+high)/<span class="number">2</span>;</div><div class="line">                <span class="keyword">if</span>(array[i][mid]==target)</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(array[i][mid]&gt;target)</div><div class="line">                    high =mid-<span class="number">1</span>;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    low=mid+<span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="4-替换空格（字符串）"><a href="#4-替换空格（字符串）" class="headerlink" title="4. 替换空格（字符串）"></a>4. 替换空格（字符串）</h2><p>请实现一个函数，把字符串中的每个空格替换成”%20”。例如输入“We are happy.”，则输出“We%20are20happy”</p><p>网络编程中，要把特殊符号转换成服务器可识别的字符。转换的规则是在“%”后面跟上ASCII码的两位十六进制的表示。比如空格的ASCII码是32，即十六进制的0X20，因此空格被替换成“%20”。</p><p>问题1：替换字符串，是在原来的字符串上做替换，还是新开辟一个字符串做替换！<br>问题2：在当前字符串替换，怎么替换才更有效率（不考虑java里现有的replace方法）。从前往后替换，后面的字符要不断往后移动，要多次移动，所以效率低下；从后往前，先计算需要多少空间，然后从后往前移动，则每个字符只为移动一次，这样效率更高一点。<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-28 上午9.44.36.png" alt="屏幕快照 2017-07-28 上午9.44.36"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> spacenum = <span class="number">0</span>;<span class="comment">//spacenum为计算空格数</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(str.charAt(i)==<span class="string">' '</span>)</div><div class="line">                spacenum++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> indexold = str.length()-<span class="number">1</span>;<span class="comment">//indexold为为替换前的str下标</span></div><div class="line">        <span class="keyword">int</span> newlength = str.length()+<span class="number">2</span>*spacenum;<span class="comment">//计算空格转换成%20之后的str长度</span></div><div class="line">        <span class="keyword">int</span> indexnew = newlength-<span class="number">1</span>;<span class="comment">//indexold为为把空格替换为%20后的str下标</span></div><div class="line">        str.setLength(newlength);<span class="comment">//使str的长度扩大到转换成%20之后的长度,防止下标越界,setLength方法</span></div><div class="line">        <span class="keyword">for</span>(;indexold&gt;=<span class="number">0</span>&amp;&amp;indexold&lt;newlength;--indexold)&#123;</div><div class="line">            <span class="keyword">if</span>(str.charAt(indexold)==<span class="string">' '</span>)&#123;<span class="comment">//charAt方法</span></div><div class="line">                str.setCharAt(indexnew--,<span class="string">'0'</span>);</div><div class="line">                str.setCharAt(indexnew--,<span class="string">'2'</span>);</div><div class="line">                str.setCharAt(indexnew--,<span class="string">'%'</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                str.setCharAt(indexnew--,str.charAt(indexold));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> str.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="5-从尾到头打印链表（链表）"><a href="#5-从尾到头打印链表（链表）" class="headerlink" title="5. 从尾到头打印链表（链表）"></a>5. 从尾到头打印链表（链表）</h2><p>输入一个链表的头结点，从尾到头反过来打印每个结点的值（注意不能改变链表的结构）。</p><p>解决这个问题肯定要遍历链表。遍历的顺序是从头到尾的顺序，可输出的顺序却是从尾到头。也就是说第一个遍历到的结点最后一个输出，而最后一个遍历到的结点第一个输出。这就是典型的“后进先出”，我们可以用栈实现这种顺序。没经过一个节点的时候，把该结点放到一个栈中。当遍历完整个链表后，再从栈顶开始逐个输出结点的值，此时输出的结点的顺序就翻转过来了。实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Stack;</div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</div><div class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        <span class="keyword">while</span> (listNode!=<span class="keyword">null</span>)&#123;</div><div class="line">            stack.push(listNode.val);</div><div class="line">            listNode = listNode.next;</div><div class="line">        &#125;</div><div class="line">        ArrayList&lt;Integer&gt; List = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</div><div class="line">            List.add(stack.pop());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> List;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>既然想到了用栈来实现这个函数，而递归在本质上就是一个栈结构，因此可用递归来实现。要实现反过来输出链表，我们每访问到一个节点的时候，先递归输出它后面的结点，再输出该结点自身，这样链表的输出结果就反过来了。实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</div><div class="line">        ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        </div><div class="line">        ListNode pNode=listNode;</div><div class="line">        <span class="keyword">if</span>(pNode!=<span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(pNode.next!=<span class="keyword">null</span>)&#123;</div><div class="line">                list=printListFromTailToHead(pNode.next);</div><div class="line">            &#125;</div><div class="line">            list.add(pNode.val);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> list;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="6-重建二叉树（二叉树）"><a href="#6-重建二叉树（二叉树）" class="headerlink" title="6. 重建二叉树（二叉树）"></a>6. 重建二叉树（二叉树）</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p>例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><p><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-28 上午10.49.39.png" alt="屏幕快照 2017-07-28 上午10.49.39"></p><ol><li>根据前序遍历的特点，我们知道根结点为1</li><li>观察中序遍历。其中root节点G左侧的472必然是root的左子树，G右侧的5386必然是root的右子树。</li><li>观察左子树472，左子树的中的根节点必然是大树的root的leftchild。在前序遍历中，大树的root的leftchild位于root之后，所以左子树的根节点为2。</li><li>同样的道理，root的右子树节点5386中的根节点也可以通过前序遍历求得。在前序遍历中，一定是先把root和root的所有左子树节点遍历完之后才会遍历右子树，并且遍历的左子树的第一个节点就是左子树的根节点。同理，遍历的右子树的第一个节点就是右子树的根节点。</li><li>观察发现，上面的过程是递归的。先找到当前树的根节点，然后划分为左子树，右子树，然后进入左子树重复上面的过程，然后进入右子树重复上面的过程。最后就可以还原一棵树了。</li></ol><p>该步递归的过程可以简洁表达如下：</p><ol><li>确定根,确定左子树，确定右子树。</li><li>在左子树中递归。</li><li>在右子树中递归。</li><li>打印当前根。</li></ol><p><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-28 上午10.51.43.png" alt="屏幕快照 2017-07-28 上午10.51.43"></p><p>递归代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; </div><div class="line">        return reConBTree(pre,0,pre.length-1,in,0,in.length-1);</div><div class="line">    &#125;</div><div class="line">    public TreeNode reConBTree(int [] pre,int preleft,int preright,int [] in,int inleft,int inright)&#123;</div><div class="line">        if(preleft &gt; preright || inleft&gt; inright)//当到达边界条件时候返回null</div><div class="line">            return null;</div><div class="line">        //新建一个TreeNode</div><div class="line">        TreeNode root = new TreeNode(pre[preleft]);</div><div class="line">        //对中序数组进行输入边界的遍历</div><div class="line">        for(int i = inleft; i&lt;= inright; i++)&#123;</div><div class="line">            if(pre[preleft] == in[i])&#123;</div><div class="line">                //重构左子树，注意边界条件</div><div class="line">                root.left = reConBTree(pre,preleft+1,preleft+i-inleft,in,inleft,i-1);</div><div class="line">                //重构右子树，注意边界条件</div><div class="line">                root.right = reConBTree(pre,preleft+i+1-inleft,preright,in,i+1,inright);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return root;      </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="7-用两个栈实现队列（栈与队列）"><a href="#7-用两个栈实现队列（栈与队列）" class="headerlink" title="7. 用两个栈实现队列（栈与队列）"></a>7. 用两个栈实现队列（栈与队列）</h2><p>栈是一个非常常见的数据结构，它在计算机领域中被广泛应用，比如操作系统会给每个线程创建一个栈来存储函数调用时各个函数的参数、返回地址及临时变量等。栈的特点是后进先出，即最后被压入（push）栈的元素会第一个被弹出（pop）。</p><p>队列是另外一种很重要的数据结构。和栈不同的是，队列的特点是先进先出，即第一个进入队列的元素将会第一个出来。</p><p>栈和队列虽然是针锋相对的两个数据结构，但有意思的是他们却相互联系。</p><p>通过一个具体的例子来分析往队列插入和删除元素的过程。首先插入一个元素a，不妨先把它插入到stack1，此时stack1中的元素有{a}，stack2为空，再向stack1压入b和c，此时stack1中的元素有{a,b,c}，其中c处于栈顶，而stack2仍然是空的。</p><p>因为a是最先进的，最先被删除的元素应该是a，但a位于栈低。我们可以把stack1中的元素逐个弹出并压入stack2，元素在stack2的顺序正好和原来在stack1的顺序相反因此经过三次弹出stack1和压入stack2操作之后，stack1为空，而stack2的元素是{c,b,a}，这时就可以弹出stack2的栈顶a了，随后弹出stack2中的b和c，而这个过程中stack1始终为空.</p><p>从上面的分析我们可以总结出删除一个元素的步骤：<strong>当stack2中不为空时，在stack2的栈顶元素是最先进入队列的元素，可以弹出。如果stack2为空时，我们把stack1中的元素逐个弹出并压入stack2。由于先进入队列的元素被压到stack1的底端，经过弹出和压入之后就处于stack2的顶端了，又可以直接弹出。</strong><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-28 上午10.58.44.png" alt="屏幕快照 2017-07-28 上午10.58.44"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">import java.util.Stack;</div><div class="line">public class Solution &#123;</div><div class="line">    Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;();</div><div class="line">    Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;();</div><div class="line">    </div><div class="line">    public void push(int node) &#123;</div><div class="line">        stack1.push(node);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public int pop() &#123;</div><div class="line">        while(!stack2.isEmpty())&#123;</div><div class="line">            return stack2.pop();</div><div class="line">        &#125;</div><div class="line">        while(!stack1.isEmpty())&#123;</div><div class="line">            stack2.push(stack1.pop());</div><div class="line">        &#125;</div><div class="line">        return stack2.pop();</div><div class="line">    </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="8-旋转数组的最小数字-数组"><a href="#8-旋转数组的最小数字-数组" class="headerlink" title="8. 旋转数组的最小数字(数组)"></a>8. 旋转数组的最小数字(数组)</h2><p>在准备面试的时候，我们应该重点掌握二分查找、归并排序和快速排序，做到能随时正确、完整地写出它们的代码。</p><p>若面试题是要求在排序的数组（或部分排序的数组）中查找一个数字或者统计某个数字出现的次数，我们都可以尝试用二分查找算法。</p><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。</p><p>可以采用二分法解答这个问题， mid = low + (high - low)/2 ，需要考虑三种情况： </p><ol><li>array[mid] &gt; array[high]:<br>出现这种情况的array类似[3,4,5,6,0,1,2]，此时最小数字一定在mid的右边。<br>low = mid + 1 <ol><li>array[mid] == array[high]: 出现这种情况的array类似 [1,0,1,1,1]   或者[1,1,1,0,1]，此时最小数字不好判断在mid左边，还是右边,这时只好一个一个试，low = low + 1 或者 high = high - 1 </li><li>array[mid] &lt; array[high]: 出现这种情况的array类似[2,2,3,4,5,6,6],此时最小数字一定就是array[mid]或者在mid的左边。因为右边必然都是递增的。   high = mid。注意这里有个坑：如果待查询的范围最后只剩两个数，那么mid一定会指向下标靠前的数字，比如 array = [4,6]，array[low] = 4 ;array[mid] = 4 ; array[high] = 6 ; 如果high = mid - 1，就会产生错误， 因此high = mid，但情形(1)中low = mid + 1就不会错误。</li></ol></li></ol><p>代码如下：</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> high = array.length-<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(low&lt;high)&#123;</div><div class="line">            <span class="keyword">int</span> mid = low+(high-low)/<span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>(array[mid]&gt;array[high])&#123;</div><div class="line">                low=mid+<span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[mid]==array[high])&#123;</div><div class="line">                high=high-<span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                high = mid;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> array[low];</div><div class="line">    </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="9-斐波那契数列-数组"><a href="#9-斐波那契数列-数组" class="headerlink" title="9. 斐波那契数列(数组)"></a>9. 斐波那契数列(数组)</h2><h3 id="9-1-斐波那契数列"><a href="#9-1-斐波那契数列" class="headerlink" title="9.1 斐波那契数列"></a>9.1 斐波那契数列</h3><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。n&lt;=39。<br>这个题可以说是迭代（Iteration） VS 递归（Recursion），f(n) = f(n-1) + f(n-2)，第一眼看就是递归啊，简直完美的递归环境，递归肯定很爽，这样想着关键代码两三行就搞定了，注意这题的n是从0开始的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> n;</div><div class="line"><span class="keyword">else</span> <span class="keyword">return</span> Fibonacci(n-<span class="number">1</span>)+Fibonacci(n-<span class="number">2</span>);</div></pre></td></tr></table></figure><p>然而并没有什么用，测试用例里肯定准备着一个超大的n来让Stack Overflow，为什么会溢出？因为重复计算，而且重复的情况还很严重，举个小点的例子，n=4，看看程序怎么跑的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Fibonacci(4) = Fibonacci(3) + Fibonacci(2);</div><div class="line">                    = Fibonacci(2) + Fibonacci(1) + Fibonacci(1) + Fibonacci(0);</div><div class="line">                    = Fibonacci(1) + Fibonacci(0) + Fibonacci(1) + Fibonacci(1) + Fibonacci(0);</div></pre></td></tr></table></figure><p>由于我们的代码并没有记录Fibonacci(1)和Fibonacci(0)的结果，对于程序来说它每次递归都是未知的，因此光是n=4时f(1)就重复计算了3次之多。</p><p>更简单的办法是从下往上计算，首先根据f(0)和f(1)算出f(2)，再根据f(1)和f(2)算出f(3)……依此类推就可以算出第n项了。很容易理解，这种思路的时间复杂度是O(n)。实现代码如下：</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> num1 = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> num2 = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> fibN=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</div><div class="line">            fibN=num1+num2;</div><div class="line">            num1=num2;</div><div class="line">            num2=fibN;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> fibN;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="9-2-跳台阶"><a href="#9-2-跳台阶" class="headerlink" title="9.2 跳台阶"></a>9.2 跳台阶</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级台阶总共有多少种跳法。</p><p>我们把n级台阶的跳法看成是n的函数，记为f(n)。当n&gt;2时，第一次跳的时候就有两种不同的选择：一是第一次只跳1级，此时跳法数目等于后面剩下的n-1级台阶的跳法数目，即为f(n-1)；另外一种选择是第一次跳2级，此时跳法数目等于后面剩下的n-2级台阶的跳法数目，即为f(n-2)，因此n级台阶的不同跳法的总数f(n)=f(n-1)+f(n-2)。分析到这里，我们不难看出这实际上是斐波那契数列了。<br>代码如下：</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(target == <span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(target == <span class="number">2</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">        <span class="keyword">int</span> num1 = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> num2 = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> jump = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;target;i++)&#123;</div><div class="line">            jump = num1+num2;</div><div class="line">            num1=num2;</div><div class="line">            num2=jump;                </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> jump;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="9-3-变态跳台阶"><a href="#9-3-变态跳台阶" class="headerlink" title="9.3 变态跳台阶"></a>9.3 变态跳台阶</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><p>因为n级台阶，第一步有n种跳法：跳1级、跳2级、到跳n级。跳1级，剩下n-1级，则剩下跳法是f(n-1)，跳2级，剩下n-2级，则剩下跳法是f(n-2)。所以f(n)=f(n-1)+f(n-2)+…+f(1)，因为f(n-1)=f(n-2)+f(n-3)+…+f(1)，所以f(n)=2*f(n-1)</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(target==<span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">2</span>*JumpFloorII(target-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="9-4-矩形覆盖"><a href="#9-4-矩形覆盖" class="headerlink" title="9.4 矩形覆盖"></a>9.4 矩形覆盖</h3><p>我们可以用$2<em>1$的小矩形横着或者竖着去覆盖更大的矩形。请问用n个$2</em>1$的小矩形无重叠地覆盖一个$2*n$的大矩形，总共有多少种方法？</p><p>把$2<em>8$的覆盖方法记为f(8)。用一个$1</em>2$小矩形去覆盖大矩形的最左边有两个选择。竖着放或者横着放。当竖着放时，右边剩下$2<em>7$的区域，记为f(7)。横着放时，当$1</em>2$的小矩阵横着放在左上角的时候，左下角必须横着放一个$1<em>2$的小矩阵，剩下$2</em>6$，记为f(6)，因此f(8)=f(7)+f(6)。此时可以看出，仍然是斐波那契数列。</p><p>代码如下：</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(target==<span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> num1=<span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> num2=<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> cover =<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;target;i++)&#123;</div><div class="line">            cover = num1+num2;</div><div class="line">            num1=num2;</div><div class="line">            num2=cover; </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> cover;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="10-二进制中1的个数-位运算"><a href="#10-二进制中1的个数-位运算" class="headerlink" title="10. 二进制中1的个数(位运算)"></a>10. 二进制中1的个数(位运算)</h2><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><p>如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。<br>举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&amp;1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count =<span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</div><div class="line">            count++;</div><div class="line">            n=(n-<span class="number">1</span>)&amp;n;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="11-数值的整数次方（位运算）"><a href="#11-数值的整数次方（位运算）" class="headerlink" title="11. 数值的整数次方（位运算）"></a>11. 数值的整数次方（位运算）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;  </div><div class="line">    public double Power(double base, int n) &#123;</div><div class="line">        double res = 1,curr = base;</div><div class="line">        int exponent;</div><div class="line">        if(n&gt;0)&#123;</div><div class="line">            exponent = n;</div><div class="line">        &#125;else if(n&lt;0)&#123;</div><div class="line">            if(base==0)</div><div class="line">                throw new RuntimeException(&quot;分母不能为0&quot;);  </div><div class="line">            exponent = -n;</div><div class="line">        &#125;else&#123;// n==0</div><div class="line">            return 1;// 0的0次方</div><div class="line">        &#125;</div><div class="line">        while(exponent!=0)&#123;</div><div class="line">            if((exponent&amp;1)==1)</div><div class="line">                res*=curr;</div><div class="line">            curr*=curr;// 翻倍</div><div class="line">            exponent&gt;&gt;=1;// 右移一位</div><div class="line">        &#125;</div><div class="line">        return n&gt;=0?res:(1/res);        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="12-打印1到最大的n位数（null）"><a href="#12-打印1到最大的n位数（null）" class="headerlink" title="12. 打印1到最大的n位数（null）"></a>12. 打印1到最大的n位数（null）</h2><h2 id="13-在O-1-时间删除链表结点（链表）"><a href="#13-在O-1-时间删除链表结点（链表）" class="headerlink" title="13. 在O(1)时间删除链表结点（链表）"></a>13. 在O(1)时间删除链表结点（链表）</h2><p>给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点。</p><p>我们要删除结点i，先把i的下一个结点i.next的内容复制到i，然后在把i的指针指向i.next结点的下一个结点即i.next.next，它的效果刚好是把结点i给删除了。</p><p>此外还要考虑删除的结点是头尾结点、链表中只有一个结点、链表为空这几种情况。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteNode</span> </span>&#123;  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 链表结点 </div><div class="line">     */  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;  </div><div class="line">        <span class="keyword">int</span> value; <span class="comment">// 保存链表的值  </span></div><div class="line">        ListNode next; <span class="comment">// 下一个结点  </span></div><div class="line">    &#125;  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 给定单向链表的头指针和一个结点指针，定义一个函数在0(1)时间删除该结点, </div><div class="line">     * 【注意1：这个方法和文本上的不一样，书上的没有返回值，这个因为JAVA引用传递的原因， </div><div class="line">     * 如果删除的结点是头结点，如果不采用返回值的方式，那么头结点永远删除不了】 </div><div class="line">     * 【注意2：输入的待删除结点必须是待链表中的结点，否则会引起错误，这个条件由用户进行保证】 </div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> head        链表表的头 </div><div class="line">     * <span class="doctag">@param</span> toBeDeleted 待删除的结点 </div><div class="line">     * <span class="doctag">@return</span> 删除后的头结点 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head, ListNode toBeDeleted)</span> </span>&#123;  </div><div class="line">        <span class="comment">// 如果输入参数有空值就返回表头结点  </span></div><div class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || toBeDeleted == <span class="keyword">null</span>) &#123;  </div><div class="line">            <span class="keyword">return</span> head;  </div><div class="line">        &#125;  </div><div class="line">        <span class="comment">// 如果删除的是头结点，直接返回头结点的下一个结点  </span></div><div class="line">        <span class="keyword">if</span> (head == toBeDeleted) &#123;  </div><div class="line">            <span class="keyword">return</span> head.next;  </div><div class="line">        &#125;  </div><div class="line">          <span class="comment">// 下面的情况链表至少有两个结点  </span></div><div class="line">        <span class="comment">// 在多个节点的情况下，如果删除的是最后一个元素  </span></div><div class="line">        <span class="keyword">if</span> (toBeDeleted.next == <span class="keyword">null</span>) &#123;  </div><div class="line">            <span class="comment">// 找待删除元素的前驱  </span></div><div class="line">            ListNode tmp = head;  </div><div class="line">            <span class="keyword">while</span> (tmp.next != toBeDeleted) &#123;  </div><div class="line">                tmp = tmp.next;  </div><div class="line">            &#125;  </div><div class="line">            <span class="comment">// 删除待结点  </span></div><div class="line">            tmp.next = <span class="keyword">null</span>;  </div><div class="line">        &#125;  </div><div class="line">        <span class="comment">// 在多个节点的情况下，如果删除的是某个中间结点  </span></div><div class="line">        <span class="keyword">else</span> &#123;  </div><div class="line">            <span class="comment">// 将下一个结点的值输入当前待删除的结点  </span></div><div class="line">            toBeDeleted.value = toBeDeleted.next.value;  </div><div class="line">            <span class="comment">// 待删除的结点的下一个指向原先待删除引号的下下个结点，即将待删除的下一个结点删除  </span></div><div class="line">            toBeDeleted.next = toBeDeleted.next.next;  </div><div class="line">        &#125;  </div><div class="line">        <span class="comment">// 返回删除节点后的链表头结点  </span></div><div class="line">        <span class="keyword">return</span> head;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure><h2 id="14-调整数组顺序使奇数位于偶数前面（排序）"><a href="#14-调整数组顺序使奇数位于偶数前面（排序）" class="headerlink" title="14. 调整数组顺序使奇数位于偶数前面（排序）"></a>14. 调整数组顺序使奇数位于偶数前面（排序）</h2><p><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-28 下午6.04.43.png" alt="屏幕快照 2017-07-28 下午6.04.43"></p><p>书上的方法类似于快排，但快排是不稳定的，即其相对位置会发生变化。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> length = array.length;</div><div class="line">        <span class="keyword">if</span>(array==<span class="keyword">null</span>||length==<span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> right = length-<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</div><div class="line">            <span class="keyword">while</span>(left&lt;right&amp;&amp;array[left]%<span class="number">2</span>==<span class="number">1</span>)&#123;</div><div class="line">                left++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">while</span>(left&lt;right&amp;&amp;array[right]%<span class="number">2</span>==<span class="number">0</span>)&#123;</div><div class="line">                right--;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">int</span> temp =array[right];</div><div class="line">            array[right]=array[left];</div><div class="line">            array[left]=temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里要保证奇数和奇数，偶数和偶数之间的相对位置不变。可以使用插入排序的思想</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> length = array.length;</div><div class="line">        <span class="keyword">if</span>(array==<span class="keyword">null</span>||length==<span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(array[i]%<span class="number">2</span>==<span class="number">1</span>)&#123;</div><div class="line">                <span class="keyword">int</span> curr = array[i];</div><div class="line">                <span class="keyword">int</span> j=i-<span class="number">1</span>;</div><div class="line">                <span class="keyword">while</span>(j&gt;=<span class="number">0</span>&amp;&amp;array[j]%<span class="number">2</span>==<span class="number">0</span>)&#123;</div><div class="line">                    array[j+<span class="number">1</span>]=array[j];</div><div class="line">                    j--;</div><div class="line">                &#125;</div><div class="line">                array[j+<span class="number">1</span>]=curr;</div><div class="line">            &#125;    </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="15-链表中倒数第K个结点（链表）"><a href="#15-链表中倒数第K个结点（链表）" class="headerlink" title="15. 链表中倒数第K个结点（链表）"></a>15. 链表中倒数第K个结点（链表）</h2><p>输入一个链表，输出该链表中倒数第k个结点。为了符合大多数人的习惯，本题从1 开始计数，即链表的尾结点是倒数第1个结点。例如一个链表有6个结点，从头结点开始它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个结点的值为4的结点。</p><p>很自然的想法是先走到链表尾端，再从尾端回溯k步。可是我们从链表结点的定义可以看出本题中的链表是单向链表，单向链表的结点只有从前向后的指针而没有从后往前的指针，这种思路行不通。</p><p>既然不能从尾结点开始遍历链表，我们还是把思路回到头结点上来。假设整个链表有n个结点，那么倒数第k个结点就是从头结点开始往后走n-k+1步就可以了。如何得到结点树n？只需要从头开始遍历链表，每经过一个结点，计数器加1就行了。</p><p>也就是说我们需要遍历链表两次，第一次统计出链表中的结点的个数，第二次就能找到倒数第k个结点。但是面试官期待的解法是只需要遍历链表一次。</p><p>为了实现只遍历链表一次就能找到倒数第k个结点，我们可以定义两个指针。第一个指针从链表的头指针开始遍历向前走k-1步，第二个指针保持不动；从第k步开始，第二个指针也开始从链表的头指针开始遍历。由于两个指针的距离保持在k-1，当第一个（走在前面的）指针到达链表的尾结点时，第二个指针（走在后边的）指针正好是倒数第k个结点。<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-25 上午11.06.17.png" alt="屏幕快照 2017-07-25 上午11.06.17"></p><p>但是这样写出来的代码不够鲁棒，面试官可以找出三种办法让这段代码崩溃：</p><ul><li>输入的ListHead为空指针。由于代码会试图访问空指针指向的内存，程序崩溃。</li><li><ol><li>输入的以ListHead为头结点的链表的结点总数少于k。由于在for循环中会在链表上向前走k-1步，仍然会由于空指针造成的程序奔溃。</li></ol></li><li><ol><li>输入的参数k为0.由于k是一个无符号整数，那么在for循环中k-1得到的将不是-1，而是4294967295（无符号的0xFFFFFFFFF），因此for循环执行的次数远远超过我们的预计，同样也会造成程序崩溃。</li></ol></li></ul><p>面试过程中写代码特别要注意鲁棒性，若写出的代码存在多处崩溃的风险，那我们很可能和offer失之交臂。针对前面三个问题，分别处理。若输入的链表头指针为null，那么整个链表为空，此时查找倒数第k个结点自然应该返回null。若输入的k为0，也就是试图查找倒数第0个结点，由于我们计数是从1开始的，因此输入0是没有实际意义，也可以返回null。若链表的结点数少于k，在for循环中遍历链表可能会出现指向null的next，因此我们在for循环中应该加一个if循环。</p><p>代码如下：</p><blockquote><p>java版本</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">public class ListNode &#123;</div><div class="line">    int val;</div><div class="line">    ListNode next = null;</div><div class="line"></div><div class="line">    ListNode(int val) &#123;</div><div class="line">        this.val = val;</div><div class="line">    &#125;</div><div class="line">&#125;*/</div><div class="line">public class Solution &#123;</div><div class="line">    public ListNode FindKthToTail(ListNode head,int k) &#123;</div><div class="line">        if(head==null||k &lt;=0)&#123;return null;&#125;</div><div class="line">        ListNode pAhead = head;</div><div class="line">        ListNode pBehind = head;</div><div class="line">        </div><div class="line">        for(int i=1;i&lt;k;i++)&#123;</div><div class="line">            if(pAhead.next != null)</div><div class="line">               &#123;pAhead = pAhead.next;&#125;</div><div class="line">            else</div><div class="line">                &#123;return null;&#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        </div><div class="line">        while(pAhead.next!=null)</div><div class="line">            &#123;</div><div class="line">            pAhead = pAhead.next;</div><div class="line">            pBehind = pBehind.next;        </div><div class="line">        &#125;</div><div class="line">        return pBehind;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>python版本</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line"># class ListNode:</div><div class="line">#     def __init__(self, x):</div><div class="line">#         self.val = x</div><div class="line">#         self.next = None</div><div class="line">class Solution:</div><div class="line">    def FindKthToTail(self, head, k):</div><div class="line">        # write code here</div><div class="line">        if not head or k == 0:</div><div class="line">            return None</div><div class="line">        pAhead = head</div><div class="line">        pBehind = None</div><div class="line">        for i in xrange(0,k-1):</div><div class="line">            if pAhead.next != None:                </div><div class="line">              pAhead = pAhead.next</div><div class="line">            else:</div><div class="line">                return None</div><div class="line">        pBehind = head</div><div class="line">        while pAhead.next != None:</div><div class="line">            pAhead = pAhead.next</div><div class="line">            pBehind = pBehind.next</div><div class="line">        return pBehind</div></pre></td></tr></table></figure><h2 id="16-反转链表（链表）"><a href="#16-反转链表（链表）" class="headerlink" title="16. 反转链表（链表）"></a>16. 反转链表（链表）</h2><p>定义一个函数，输入一个链表的头结点，反转该链表并输出反转后的头结点。链表结点定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class ListNode &#123;</div><div class="line">    int val;</div><div class="line">    ListNode next = null;</div><div class="line"></div><div class="line">    ListNode(int val) &#123;</div><div class="line">        this.val = val;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>解决与链表相关的问题总是有大量的指针操作，而指针操作的代码总是容易出错的。</p><p>为了正确地反转一个链表，需要调整链表中指针的方向。为了将调整指针这个复杂的过程分析清楚，可以借助图形来直观分析。在下图所示的链表中，h、i、j是3个相邻的结点。假设经过若干操作，我们已经把结点h之前的指针调整完毕，这些结点的next指向h，此时链表的结果如下所示：</p><p><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-24 下午11.13.37.png" alt="屏幕快照 2017-07-24 下午11.13.37"></p><p>其中（a）为一个链表，（b）把i之前的所有结点的next都指向前一个结点，导致链表在结点i、j之间断裂。</p><p>不难注意到，由于结点i的next指向了它的前一个结点，导致我们无法再链表中遍历到结点j。为了避免链表在结点i处断开，我们需要在调整结点i的next之前把结点j保存下来。</p><p>也就是说我们在调整结点i的next指针时，除了需要知道结点i本身之外，还需要前一个结点h，因为我们需要把结点i的next指向结点h。同时，我们还事先需要保存i的一个结点j，以防止链表断开。因此相应地我们需要定义3个指针，分别指向当前遍历到的结点、它的前一个结点及后一个结点。</p><p>最后我们试着找到反转后链表的头结点。不难分析出反转后链表的头结点是原始链表的尾结点。什么结点是尾结点？自然是next为null的结点。</p><script type="math/tex; mode=display">pre\rightarrow head \rightarrow next</script><p>先保存next，即$next = head.next$再反转head的指针$head.next=pre $，链表结构变成</p><script type="math/tex; mode=display">pre\leftarrow head \ \ \ next</script><p>接着向后移动结点$pre=head,head=next$</p><p>实现代码如下：</p><blockquote><p>java版本</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">       </div><div class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        <span class="comment">//head为当前节点，如果当前节点为空的话，那就什么也不做，直接返回null；</span></div><div class="line">        ListNode pre = <span class="keyword">null</span>;</div><div class="line">        ListNode next = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">//当前节点是head，pre为当前节点的前一节点，next为当前节点的下一节点</span></div><div class="line">        <span class="comment">//需要pre和next的目的是让当前节点从pre-&gt;head-&gt;next1-&gt;next2变成pre&lt;-head next1-&gt;next2</span></div><div class="line">        <span class="comment">//即pre让节点可以反转所指方向，但反转之后如果不用next节点保存next1节点的话，此单链表就此断开了</span></div><div class="line">        <span class="comment">//所以需要用到pre和next两个节点</span></div><div class="line">        <span class="comment">//1-&gt;2-&gt;3-&gt;4-&gt;5</span></div><div class="line">        <span class="comment">//1&lt;-2&lt;-3 4-&gt;5</span></div><div class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</div><div class="line">            <span class="comment">//做循环，如果当前节点不为空的话，始终执行此循环，此循环的目的就是让当前节点从指向next到指向pre</span></div><div class="line">            <span class="comment">//如此就可以做到反转链表的效果</span></div><div class="line">            <span class="comment">//先用next保存head的下一个节点的信息，保证单链表不会因为失去head节点的原next节点而就此断裂</span></div><div class="line">            next = head.next;</div><div class="line">            <span class="comment">//保存完next，就可以让head从指向next变成指向pre了，代码如下</span></div><div class="line">            head.next = pre;</div><div class="line">            <span class="comment">//head指向pre后，就继续依次反转下一个节点</span></div><div class="line">            <span class="comment">//让pre，head，next依次向后移动一个节点，继续下一次的指针反转</span></div><div class="line">            pre = head;</div><div class="line">            head = next;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果head为null的时候，pre就为最后一个节点了，但是链表已经反转完毕，pre就是反转后链表的第一个节点</span></div><div class="line">        <span class="comment">//直接输出pre就是我们想要得到的反转后的链表</span></div><div class="line">        <span class="keyword">return</span> pre;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>python版本</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class ListNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># 返回ListNode</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseList</span><span class="params">(self, pHead)</span>:</span></div><div class="line">        <span class="comment"># write code here</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead <span class="keyword">or</span> <span class="keyword">not</span> pHead.next:</div><div class="line">            <span class="keyword">return</span> pHead          </div><div class="line">        pre = <span class="keyword">None</span>        </div><div class="line">        <span class="keyword">while</span> pHead:</div><div class="line">            next1 = pHead.next</div><div class="line">            pHead.next = pre</div><div class="line">            pre = pHead</div><div class="line">            pHead = next1</div><div class="line">        <span class="keyword">return</span> pre</div></pre></td></tr></table></figure><h2 id="17-合并两个排序的链表（链表）"><a href="#17-合并两个排序的链表（链表）" class="headerlink" title="17. 合并两个排序的链表（链表）"></a>17. 合并两个排序的链表（链表）</h2><p>输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。例如下图中的链表1和链表2，则合并之后的升序链表3如下所示：<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-25 上午9.26.52.png" alt="屏幕快照 2017-07-25 上午9.26.52"></p><p>这是一个经常被各公司采用的面试题。在面试过程中，最容易犯两种错误：一是在写代码之前没有对合并的过程想清楚，最终合并出来的链表要么中间断开了，要么并没有做到递增排序；二是代码在鲁棒性方面存在问题，程序一旦有特殊的输入（如空链表）就会奔溃。<br>首先分析合并两个链表的过程。从合并两个链表的头结点开始。链表1的头结点的值小于链表2的头结点的值，因此链表1的头结点将是合并后链表的头结点。</p><p>继续合并剩余的结点。在两个链表中剩下的结点依然是排序的，因此合并这两个链表的步骤和前面的步骤是一样的。依旧比较两个头结点的值。此时链表2的头结点值小于链表1的头结点的值，因此链表2的头结点的值将是合并剩余结点得到的链表的头结点。把这个结点和前面合并链表时得到的链表的尾结点链接起来。</p><p>当我们得到两个链表中值较小的头结点并把它链接到已经合并的链表之后，两个链表剩余的结点依然是排序的，因此合并的步骤和之前的步骤是一样的。这是典型的递归过程，我们可以定义递归函数完成这一合并过程。（解决这个问题需要大量的指针操作，如没有透彻地分析问题形成清晰的思路，很难写出正确的代码）</p><p><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-25 上午9.39.51.png" alt="屏幕快照 2017-07-25 上午9.39.51"></p><p>接下来解决鲁棒性问题，每当代码试图访问空指针指向的内存时程序就会奔溃，从而导致鲁棒性问题。本题中一旦输入空的链表就会引入空的指针，因此我们要对空链表单独处理。当第一个链表是空链表，也就是它的头结点是一个空指针时，和第二个链表合并的结果就是第二个链表。同样，当输入的第二个链表的头结点是空指针的时候，和第一个链表合并得到的结果就是第一个链表。如果两个链表都为空，合并得到的是一个空链表。（由于有大量的指针操作，如果稍有不慎就会在代码中遗留很多与鲁棒性相关的隐患。建议应聘者在写代码之前全面分析哪些情况会引入空指针，并考虑清楚怎么处理这些空指针。）</p><p>代码如下：</p><blockquote><p>java版本</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">public class ListNode &#123;</div><div class="line">    int val;</div><div class="line">    ListNode next = null;</div><div class="line"></div><div class="line">    ListNode(int val) &#123;</div><div class="line">        this.val = val;</div><div class="line">    &#125;</div><div class="line">&#125;*/</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (list1==<span class="keyword">null</span>) <span class="keyword">return</span> list2;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (list2==<span class="keyword">null</span>) <span class="keyword">return</span> list1;</div><div class="line">        ListNode MergeHead = <span class="keyword">null</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (listval&lt;=list2.val)&#123;</div><div class="line">            MergeHead = list1;</div><div class="line">            MergeHead.next = Merge(listnext,list2);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> </div><div class="line">        &#123;MergeHead = list2;</div><div class="line">             MergeHead.next = Merge(list1,list2.next);</div><div class="line">             &#125;</div><div class="line">        <span class="keyword">return</span> MergeHead;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>python版本</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class ListNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># 返回合并后列表</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Merge</span><span class="params">(self, pHead1, pHead2)</span>:</span></div><div class="line">        <span class="comment"># write code here</span></div><div class="line">        <span class="keyword">if</span> pHead1== <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> pHead2</div><div class="line">        <span class="keyword">if</span> pHead2== <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> pHead1</div><div class="line">        MergeHead = <span class="keyword">None</span>        </div><div class="line">        <span class="keyword">if</span> pHeadval &lt; pHead2.val:</div><div class="line">            MergeHead = pHead1</div><div class="line">            MergeHead.next = self.Merge(pHeadnext,pHead2)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            MergeHead = pHead2</div><div class="line">            MergeHead.next = self.Merge(pHead1,pHead2.next)</div><div class="line">        <span class="keyword">return</span> MergeHead</div></pre></td></tr></table></figure><h2 id="18-树的子结构（二叉树）"><a href="#18-树的子结构（二叉树）" class="headerlink" title="18. 树的子结构（二叉树）"></a>18. 树的子结构（二叉树）</h2><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><p>要查找树A中是否存在和树B结构一样的子树，我们可以分成两步：第一步在树A中找到和B的根结点的值一样的结点R，第二步再判断树A以R为根结点的子树是不是包含和树B一样的结构。</p><p>第一步在树A中查找与根结点的值一样的结点，实际上就是树的遍历。对二叉树这种数据结构熟悉的读者自然知道可以用递归的方法去遍历，也可以用循环的方法去遍历。由于递归的代码实现比较简洁，面试时如果没有特别要求，通常会采用递归的方式。参考代码如下：</p><blockquote><p>java第一步</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</div><div class="line">        <span class="comment">//一定要注意边界条件的检查，即检查空指针。否则程序容易奔溃，面试时尤其要注意。这里当Tree1和Tree2都不为零的时候，才进行比较。否则直接返回false</span></div><div class="line">        <span class="keyword">if</span>(root1!=<span class="keyword">null</span>&amp;&amp;root2!=<span class="keyword">null</span>)&#123;</div><div class="line">        <span class="comment">////如果找到了对应Tree2的根节点的点</span></div><div class="line">            <span class="keyword">if</span>(root1.val==root2.val)&#123;</div><div class="line">            <span class="comment">//以这个根节点为为起点判断是否包含Tree2</span></div><div class="line">                result = DoesTree1HaveTree2(root1,root2);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//如果找不到，那么就再去root的左儿子当作起点，去判断是否包含Tree2</span></div><div class="line">            <span class="keyword">if</span>(!result)&#123;</div><div class="line">                result=HasSubtree(root1.left,root2);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//如果还找不到，那么就再去root的右儿子当作起点，去判断是否包含Tree2</span></div><div class="line">            <span class="keyword">if</span>(!result)&#123;</div><div class="line">                result=HasSubtree(root1.right,root2);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">        </div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>第二步是判断树A中以R为根结点的子树是不是和树B具有相同的结构。同样，我们也可以用递归的思路来考虑：如果结点R的值和树B的根结点不同，则以R为根结点的子树和树B一定不具有相同的结点；如果他们的值相同，则递归地判断它们各自的左右结点的值是不是相同。递归的终止条件是我们达到了树A或者树B的叶结点。</p><p>代码如下：</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">DoesTree1HaveTree2</span><span class="params">(TreeNode root1,TreeNode root2)</span></span>&#123;</div><div class="line">       <span class="comment">//如果Tree2已经遍历完了都能对应的上，返回true</span></div><div class="line">        <span class="keyword">if</span>(root2==<span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果Tree2还没有遍历完，Tree1却遍历完了。返回false</span></div><div class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">         <span class="comment">//如果其中有一个点没有对应上，返回false</span></div><div class="line">        <span class="keyword">if</span>(root1.val!=root2.val)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果根节点对应的上，那么就分别去左右子节点里面匹配</span></div><div class="line">        <span class="keyword">return</span> DoesTree1HaveTree2(root1.left,root2.left)&amp;&amp;DoesTree1HaveTree2(root1.right,root2.right);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-01 下午2.54.39.png" alt="屏幕快照 2017-08-01 下午2.54.39"></p><p>二叉树相关的代码有大量的指针操作，每一次使用指针的时候，我们都要问自己这个指针有没有可能是NULL，如果是NULL该怎么处理。</p><h2 id="19-二叉树的镜像（二叉树）"><a href="#19-二叉树的镜像（二叉树）" class="headerlink" title="19. 二叉树的镜像（二叉树）"></a>19. 二叉树的镜像（二叉树）</h2><p>操作给定的二叉树，将其变换为源二叉树的镜像。<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-01 下午3.06.35.png" alt="屏幕快照 2017-08-01 下午3.06.35"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="comment">//边界</span></div><div class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="comment">//交换左右子树</span></div><div class="line">        TreeNode temp = root.left;</div><div class="line">        root.left=root.right;</div><div class="line">        root.right=temp;</div><div class="line">        <span class="comment">//递归</span></div><div class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)&#123;</div><div class="line">            Mirror(root.left);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)&#123;</div><div class="line">            Mirror(root.right);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="20-顺时针打印矩阵（数组）"><a href="#20-顺时针打印矩阵（数组）" class="headerlink" title="20. 顺时针打印矩阵（数组）"></a>20. 顺时针打印矩阵（数组）</h2><p>输入一个矩阵，按照从外向里以顺时针依次打印出每一个数字。例如，输入如下矩阵：<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-01 下午3.15.07.png" alt="屏幕快照 2017-08-01 下午3.15.07"></p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> row = matrix.length;</div><div class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;        </div><div class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt; ();</div><div class="line">        <span class="comment">// 输入的二维数组非法，返回空的数组</span></div><div class="line">        <span class="keyword">if</span>(row==<span class="number">0</span>&amp;&amp;col==<span class="number">0</span>)<span class="keyword">return</span> result;</div><div class="line">        <span class="comment">// 定义四个关键变量，表示左上和右下的打印范围</span></div><div class="line">        <span class="keyword">int</span> left =<span class="number">0</span>,top=<span class="number">0</span>,right=col-<span class="number">1</span>,bottom=row-<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(left&lt;=right&amp;&amp;top&lt;=bottom)&#123;</div><div class="line">             <span class="comment">// left to right</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;i++)&#123;result.add(matrix[top][i]);&#125;</div><div class="line">            <span class="comment">// top to bottom</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=top+<span class="number">1</span>;i&lt;=bottom;i++)&#123;result.add(matrix[i][right]);&#125;</div><div class="line">            <span class="comment">// right to left</span></div><div class="line">            <span class="keyword">if</span>(top!=bottom)&#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=right-<span class="number">1</span>;i&gt;=left;i--)&#123;result.add(matrix[bottom][i]);&#125;&#125;</div><div class="line">            <span class="comment">// bottom to top</span></div><div class="line">            <span class="keyword">if</span>(left!=right)&#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=bottom-<span class="number">1</span>;i&gt;=top+<span class="number">1</span>;i--)&#123;result.add(matrix[i][left]);&#125;&#125;</div><div class="line">            left++;right--;top++;bottom--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">       </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="21-包含min函数的栈（栈）"><a href="#21-包含min函数的栈（栈）" class="headerlink" title="21.包含min函数的栈（栈）"></a>21.包含min函数的栈（栈）</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。在该栈中，调用min、push及pop的时间复杂度都是O(1)。</p><p>可以利用一个辅助栈来存放最小值<br>  <img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-01 下午10.53.41.png" alt="屏幕快照 2017-08-01 下午10.53.41"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-01 下午10.53.48.png" alt="屏幕快照 2017-08-01 下午10.53.48"></p><p>  每入栈一次，就与辅助栈顶比较大小，如果小就入栈，如果大就入栈当前的辅助栈顶 。<br>  当出栈时，辅助栈也要出栈<br>  这种做法可以保证辅助栈顶一定都是最小元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">import java.util.Stack;</div><div class="line"></div><div class="line">public class Solution &#123;</div><div class="line">    Stack&lt;Integer&gt; data = new Stack&lt;Integer&gt;();</div><div class="line">    Stack&lt;Integer&gt; min = new Stack&lt;Integer&gt;();</div><div class="line">    </div><div class="line">    public void push(int node) &#123;</div><div class="line">        data.push(node);</div><div class="line">        if(min.empty())&#123;min.push(data.peek());&#125;</div><div class="line">        else if(data.peek()&lt;min.peek())&#123;min.push(data.peek());&#125;</div><div class="line">        else min.push(min.peek());</div><div class="line">        &#125;  </div><div class="line">    public void pop() &#123;</div><div class="line">        data.pop();</div><div class="line">        min.pop();      </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public int top() &#123;</div><div class="line">        return data.peek();</div><div class="line">        </div><div class="line">    &#125;    </div><div class="line">    public int min() &#123;</div><div class="line">        return min.peek();        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="22-栈的压入、弹出序列（栈）"><a href="#22-栈的压入、弹出序列（栈）" class="headerlink" title="22. 栈的压入、弹出序列（栈）"></a>22. 栈的压入、弹出序列（栈）</h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5，3，2，1是该压栈序列对应的一个弹出序列，但4，3，5，1，2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><p>借用一个辅助的栈，遍历压栈顺序，先讲第一个放入栈中，这里是1，然后判断栈顶元素是不是出栈顺序的第一个元素，这里是4，很显然1≠4，所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。<br>举例：<br>入栈1,2,3,4,5<br>出栈4,5,3,2,1<br>首先1入辅助栈，此时栈顶1≠4，继续入栈2<br>此时栈顶2≠4，继续入栈3<br>此时栈顶3≠4，继续入栈4<br>此时栈顶4＝4，出栈4，弹出序列向后一位，此时为5，,辅助栈里面是1,2,3<br>此时栈顶3≠5，继续入栈5<br>此时栈顶5=5，出栈5,弹出序列向后一位，此时为3，,辅助栈里面是1,2,3<br>….<br>依次执行，最后辅助栈为空。如果不为空说明弹出序列不是该栈的弹出顺序。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.Stack;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(pushA.length==<span class="number">0</span>||popA.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        Stack&lt;Integer&gt; S=<span class="keyword">new</span> Stack&lt;Integer&gt;();</div><div class="line">        <span class="keyword">int</span> popIndex = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pushA.length;i++)&#123;</div><div class="line">            S.push(pushA[i]);</div><div class="line">            <span class="keyword">while</span>(!S.empty()&amp;&amp;popA[popIndex]==S.peek())&#123;</div><div class="line">                S.pop();</div><div class="line">                popIndex++;</div><div class="line">            &#125;            </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> S.empty();      </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="23-从上往下打印二叉树（二叉树）"><a href="#23-从上往下打印二叉树（二叉树）" class="headerlink" title="23. 从上往下打印二叉树（二叉树）"></a>23. 从上往下打印二叉树（二叉树）</h2><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-02 上午12.17.30.png" alt="屏幕快照 2017-08-02 上午12.17.30"></p><p>每次打印一个结点时，如果该结点有子结点，则把该结点的子结点放到队列的末尾。接下来到队列的头部取出最早进入队列的结点，重复前面的打印操作。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.LinkedList;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        ArrayList&lt;Integer&gt; List=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;<span class="keyword">return</span> List;&#125;</div><div class="line">        </div><div class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</div><div class="line">        queue.add(root);<span class="comment">//先把根结点加入队列q</span></div><div class="line">        </div><div class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;<span class="comment">//队列非空时</span></div><div class="line">            TreeNode treenode=queue.remove();<span class="comment">//取出队列头结点</span></div><div class="line">            <span class="keyword">if</span>(treenode.left!=<span class="keyword">null</span>)&#123;queue.add(treenode.left);&#125;<span class="comment">//向队列加入左孩子（若有）</span></div><div class="line">            <span class="keyword">if</span>(treenode.right!=<span class="keyword">null</span>)&#123;queue.add(treenode.right);&#125;<span class="comment">//向队列加入右孩子（若有）</span></div><div class="line">            List.add(treenode.val);<span class="comment">//加到打印列表中</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> List;        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="24-二叉搜索树的后序遍历序列（二叉树）"><a href="#24-二叉搜索树的后序遍历序列（二叉树）" class="headerlink" title="24. 二叉搜索树的后序遍历序列（二叉树）"></a>24. 二叉搜索树的后序遍历序列（二叉树）</h2><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-02 上午9.50.37.png" alt="屏幕快照 2017-08-02 上午9.50.37"><br>在后序遍历得到的序列中，最后一个数字是树的根结点的值。数组中前面的数字可以分成两部分：第一部分是左子树结点的值，它们都比根结点小；第二部分是右子树结点的值，它们都比根结点大。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> length = sequence.length;</div><div class="line">        <span class="keyword">if</span>(sequence==<span class="keyword">null</span>||length==<span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;</div><div class="line">        <span class="keyword">int</span> root = sequence[length-<span class="number">1</span>];<span class="comment">//根结点</span></div><div class="line">        <span class="keyword">int</span> i=<span class="number">0</span>; <span class="comment">//外部初始化     </span></div><div class="line">        <span class="comment">//找到左子树的最后一个结点位置</span></div><div class="line">        <span class="keyword">for</span>(;i&lt;length-<span class="number">1</span>;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(sequence[i]&gt;root)&#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;    </div><div class="line">        <span class="comment">//如果右子树的结点值小于根结点的值，则返回false</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;length-<span class="number">1</span>;j++)&#123;</div><div class="line">            <span class="keyword">if</span>(sequence[j]&lt;root)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;    </div><div class="line">        <span class="comment">//初始化</span></div><div class="line">        <span class="keyword">boolean</span> left=<span class="keyword">true</span>;</div><div class="line">        <span class="keyword">boolean</span> right=<span class="keyword">true</span>;</div><div class="line">        <span class="comment">//递归左右子树</span></div><div class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</div><div class="line">            left = VerifySquenceOfBST(Arrays.copyOfRange(sequence,<span class="number">0</span>,i));<span class="comment">//Arrays的copyOfRange方法</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(i&lt;length-<span class="number">1</span>)&#123;</div><div class="line">            right = VerifySquenceOfBST(Arrays.copyOfRange(sequence,i,length-<span class="number">1</span>));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> left&amp;&amp;right;                </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="25-二叉树中和为某一值的路径（二叉树）"><a href="#25-二叉树中和为某一值的路径（二叉树）" class="headerlink" title="25. 二叉树中和为某一值的路径（二叉树）"></a>25. 二叉树中和为某一值的路径（二叉树）</h2><p>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</div><div class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> listAll;</div><div class="line">        list.add(root.val);</div><div class="line">        target -= root.val;<span class="comment">//每次减去结点的值</span></div><div class="line">        <span class="comment">//如果target等于0，则说明这条路径和为target，添加到listAll中</span></div><div class="line">        <span class="keyword">if</span>(target == <span class="number">0</span> &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</div><div class="line">            listAll.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(list));<span class="comment">//因为add添加的是引用，如果不new一个的话，后面的操作会更改listAll中list的值</span></div><div class="line">        <span class="comment">//向左孩子递归</span></div><div class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)FindPath(root.left, target);</div><div class="line">        <span class="comment">//向右孩子递归</span></div><div class="line">        <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)FindPath(root.right, target);</div><div class="line">        <span class="comment">//如果不满足条件，则回到父节点；</span></div><div class="line">        list.remove(list.size()-<span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> listAll;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="26-复杂链表的复制（链表）"><a href="#26-复杂链表的复制（链表）" class="headerlink" title="26. 复杂链表的复制（链表）"></a>26. 复杂链表的复制（链表）</h2><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p><p><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-04 下午7.51.53.png" alt="屏幕快照 2017-08-04 下午7.51.53"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-04 下午7.52.01.png" alt="屏幕快照 2017-08-04 下午7.52.01"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-04 下午7.52.07.png" alt="屏幕快照 2017-08-04 下午7.52.07"></p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (pHead == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">         <span class="comment">//复制next 如原来是A-&gt;B-&gt;C 变成A-&gt;A'-&gt;B-&gt;B'-&gt;C-&gt;C'</span></div><div class="line">        RandomListNode pCur = pHead;</div><div class="line">        <span class="keyword">while</span> (pCur != <span class="keyword">null</span>)</div><div class="line">        &#123;</div><div class="line">            RandomListNode node = <span class="keyword">new</span> RandomListNode(pCur.label);</div><div class="line">            node.next = pCur.next;</div><div class="line">            pCur.next = node;</div><div class="line">            pCur = node.next;</div><div class="line">        &#125;</div><div class="line">         <span class="comment">//复制random pCur是原来链表的结点 pCur.next是复制pCur的结点</span></div><div class="line">        pCur = pHead;</div><div class="line">        <span class="keyword">while</span> (pCur!=<span class="keyword">null</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (pCur.random!=<span class="keyword">null</span>)</div><div class="line">                pCur.next.random = pCur.random.next;</div><div class="line">            pCur = pCur.next.next;</div><div class="line">        &#125;</div><div class="line">         <span class="comment">//拆分链表</span></div><div class="line">        RandomListNode head = pHead.next;</div><div class="line">        RandomListNode tmp = head;</div><div class="line">        pCur = pHead;</div><div class="line">        <span class="keyword">while</span>(pCur.next!=<span class="keyword">null</span>)</div><div class="line">        &#123;</div><div class="line">            tmp = pCur.next;</div><div class="line">            pCur.next = tmp.next;</div><div class="line">            pCur = tmp;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> head;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="27-二叉搜素树与双向链表（二叉树）"><a href="#27-二叉搜素树与双向链表（二叉树）" class="headerlink" title="27. 二叉搜素树与双向链表（二叉树）"></a>27. 二叉搜素树与双向链表（二叉树）</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    TreeNode head = <span class="keyword">null</span>;</div><div class="line">    TreeNode realHead = <span class="keyword">null</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</div><div class="line">        ConvertSub(pRootOfTree);</div><div class="line">        <span class="keyword">return</span> realHead<span class="comment">//realHead是每个子树排序后的第一个结点，head是排序后的最后一个结点;</span></div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ConvertSub</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</div><div class="line">        <span class="comment">//递归中序遍历</span></div><div class="line">        <span class="keyword">if</span>(pRootOfTree==<span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line">        ConvertSub(pRootOfTree.left);</div><div class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//初始处</span></div><div class="line">            head = pRootOfTree;</div><div class="line">            realHead = pRootOfTree;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//前两句实现双向，第三句跳到下一个节点。</span></div><div class="line">            head.right = pRootOfTree;</div><div class="line">            pRootOfTree.left = head;</div><div class="line">            head = pRootOfTree;</div><div class="line">        &#125;</div><div class="line">        ConvertSub(pRootOfTree.right);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="28-字符串的排列（字符串）"><a href="#28-字符串的排列（字符串）" class="headerlink" title="28. 字符串的排列（字符串）"></a>28. 字符串的排列（字符串）</h2><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p><p>首先我要打印abc的全排列，就是第一步把a 和bc交换（得到bac,cab），这需要一个for循环，循环里面有一个swap，交换之后就相当于不管第一步了，进入下一步递归，所以跟一个递归函数， 完成递归之后把交换的换回来，变成原来的字串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">abc 为例子：</div><div class="line">1. 固定a, 求后面bc的全排列： abc, acb。 求完后，a 和 b交换； 得到bac,开始第二轮</div><div class="line">2. 固定b, 求后面ac的全排列： bac, bca。 求完后，b 和 c交换； 得到cab,开始第三轮</div><div class="line">3. 固定c, 求后面ba的全排列： cab, cba</div><div class="line"> 即递归树： </div><div class="line">　　　　　str:　　 a    　　　　 b 　　　　　　  c</div><div class="line">　　　　　　 　　ab ac     　　ba bc  　　　     ca cb</div><div class="line">　   　result:     abc acb    　 bac bca　     　   cab cba</div></pre></td></tr></table></figure><p><img src="http://omu7tit09.bkt.clouddn.com/15016515510574.jpg" alt=""></p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">if</span>(str.length()==<span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> list;</div><div class="line">        <span class="keyword">char</span>[] array = str.toCharArray();</div><div class="line">        permutation(array,<span class="number">0</span>,list);</div><div class="line">        Collections.sort(list);</div><div class="line">        <span class="keyword">return</span> list;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">permutation</span><span class="params">(<span class="keyword">char</span>[] array,<span class="keyword">int</span> begin,ArrayList&lt;String&gt; list)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(begin == array.length-<span class="number">1</span>) &#123;</div><div class="line">            list.add(String.valueOf(array));</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=begin;i&lt;array.length;++i) &#123;</div><div class="line">                <span class="keyword">if</span>(i==begin || array[i]!=array[begin]) &#123;</div><div class="line">                    swap(array,begin,i);</div><div class="line">                    permutation(array,begin+<span class="number">1</span>,list);</div><div class="line">                    swap(array,begin,i);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] array,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">        <span class="keyword">char</span> temp = array[i];</div><div class="line">        array[i] = array[j];</div><div class="line">        array[j] = temp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="29-数组中出现次数超过一半的数字（数组）"><a href="#29-数组中出现次数超过一半的数字（数组）" class="headerlink" title="29. 数组中出现次数超过一半的数字（数组）"></a>29. 数组中出现次数超过一半的数字（数组）</h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p><p>数组中有一个数字出现的次数超过数组长度的一半，也就是说它出现的次数比其他所有数字出现的次数的和还要多。因此我们可以考虑在遍历数组的时候保存两个值：一个是数组的一个数字，一个是次数。当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1；如果不同，则次数减1；如果次数为0，则保存下一个数字，并把次数设为1。</p><p>还要判断这个数字是否超过数组长度的一半，如果不存在输出0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(array==<span class="keyword">null</span>||array.length==<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> result=array[<span class="number">0</span>];</div><div class="line">        <span class="keyword">int</span> count=<span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;array.length;i++)&#123;</div><div class="line">           <span class="keyword">if</span>(result==array[i])&#123;</div><div class="line">               count++; &#125;</div><div class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(result!=array[i])&#123;</div><div class="line">               count--; &#125;</div><div class="line">           <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</div><div class="line">               result=array[i];</div><div class="line">               count=<span class="number">1</span>;</div><div class="line">           &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> times=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(array[i]==result)&#123;</div><div class="line">                times++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(times*<span class="number">2</span>&lt;=array.length)&#123;</div><div class="line">            System.out.println(times);</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> </div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="30-最小的K个数（数组）"><a href="#30-最小的K个数（数组）" class="headerlink" title="30. 最小的K个数（数组）"></a>30. 最小的K个数（数组）</h2><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p><p>第一种方法，借用partition函数</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList; </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; </div><div class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span>[] input, <span class="keyword">int</span> k)</span> </span>&#123; </div><div class="line">        ArrayList&lt;Integer&gt; output = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(); </div><div class="line">        <span class="keyword">int</span> length = input.length; </div><div class="line">        <span class="keyword">if</span> (input == <span class="keyword">null</span> || length &lt;= <span class="number">0</span> || length &lt; k || k&lt;= <span class="number">0</span>) &#123; </div><div class="line">            <span class="keyword">return</span> output; </div><div class="line">        &#125; </div><div class="line">        <span class="keyword">int</span> left = <span class="number">0</span>; </div><div class="line">        <span class="keyword">int</span> right = length - <span class="number">1</span>; </div><div class="line">        <span class="keyword">int</span> index = partition(input,left,right); </div><div class="line">        <span class="keyword">while</span>(index != k -<span class="number">1</span>) &#123; </div><div class="line">            <span class="keyword">if</span>(index &lt; k - <span class="number">1</span>) &#123; </div><div class="line">                left = index + <span class="number">1</span>; <span class="comment">//不够的话往右边走走</span></div><div class="line">                index = partition(input,left,right); </div><div class="line">            &#125; </div><div class="line">            <span class="keyword">else</span> &#123; </div><div class="line">                right = index - <span class="number">1</span>; <span class="comment">//太多的话往左边走走</span></div><div class="line">                index = partition(input,left,right); </div><div class="line">            &#125; </div><div class="line">        &#125; </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123; </div><div class="line">            output.add(input[i]); </div><div class="line">        &#125; </div><div class="line">        <span class="keyword">return</span> (ArrayList&lt;Integer&gt;) output; </div><div class="line">    &#125;</div><div class="line">   <span class="comment">//基准左右分区 </span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] input,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>&#123; </div><div class="line">        <span class="keyword">int</span> pivot = input[left]; </div><div class="line">        <span class="keyword">while</span>(left &lt; right) &#123; </div><div class="line">            <span class="keyword">while</span>(input[right] &gt;= pivot &amp;&amp; left &lt; right)</div><div class="line">            &#123; </div><div class="line">                right--; </div><div class="line">            &#125; </div><div class="line">            input[left] = input[right]; </div><div class="line">            <span class="keyword">while</span>(input[left] &lt;= pivot &amp;&amp; left &lt;right) &#123; </div><div class="line">                left++; </div><div class="line">            &#125; </div><div class="line">            input[right] = input[left]; </div><div class="line">        &#125; </div><div class="line">        input[left] = pivot; </div><div class="line">        <span class="keyword">return</span> left; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>第二种方法</p><p>用最大堆保存这k个数，每次只和堆顶比，如果比堆顶小，删除堆顶，新数入堆。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.PriorityQueue;</div><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span>[] input, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">       ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">       <span class="keyword">int</span> length = input.length;</div><div class="line">       <span class="keyword">if</span>(k &gt; length || k == <span class="number">0</span>)&#123;</div><div class="line">           <span class="keyword">return</span> result;</div><div class="line">       &#125;</div><div class="line">        PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(k, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</div><div class="line"> </div><div class="line">            <span class="meta">@Override</span><span class="comment">//PriorityQueue默认是小顶堆，实现大顶堆，需要反转默认排序器</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> o2.compareTo(o1);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</div><div class="line">            <span class="comment">//如果最大堆中已有的数字少于k个，直接读入</span></div><div class="line">            <span class="keyword">if</span> (maxHeap.size() != k) &#123;</div><div class="line">                maxHeap.offer(input[i]);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//如果最大堆中已有k个数字了，即容器已满，且大顶堆顶大于待插入数字，将待插入数字替换进大顶堆</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (maxHeap.peek() &gt; input[i]) &#123;</div><div class="line">                Integer temp = maxHeap.poll();</div><div class="line">                temp = <span class="keyword">null</span>;</div><div class="line">                maxHeap.offer(input[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">       <span class="comment">//输出大顶堆中的数</span></div><div class="line">        <span class="keyword">for</span> (Integer integer : maxHeap) &#123;</div><div class="line">            result.add(integer);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="31-连续子数组的最大和（数组）"><a href="#31-连续子数组的最大和（数组）" class="headerlink" title="31. 连续子数组的最大和（数组）"></a>31. 连续子数组的最大和（数组）</h2><p>输入一个整型数组，数组中有正数也有负数。数组中一个或连续的多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)</p><p>第一种方法</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(array.length==<span class="number">0</span>||array==<span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> cSum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> result = array[<span class="number">0</span>];<span class="comment">// result存储最大和，不能初始为0，存在负数</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(cSum&lt;<span class="number">0</span>)&#123;</div><div class="line">                cSum=array[i];<span class="comment">// 当前和&lt;0，抛弃不要</span></div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                cSum += array[i];<span class="comment">//否则累加上去</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(cSum&gt;result)&#123;</div><div class="line">                result = cSum;<span class="comment">// 存储当前的最大结果</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;                    </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>第二种方法：动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">F（i）：以array[i]为末尾元素的子数组的和的最大值，子数组的元素的相对位置不变  </div><div class="line">     F（i）=max（F（i-<span class="number">1</span>）+array[i] ， array[i]）  </div><div class="line">     res：所有子数组的和的最大值  </div><div class="line">     res=max（res，F（i））  </div><div class="line"></div><div class="line">     如数组[<span class="number">6</span>, -<span class="number">3</span>, -<span class="number">2</span>, <span class="number">7</span>, -<span class="number">15</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>]  </div><div class="line">     初始状态：  </div><div class="line">         F（<span class="number">0</span>）=<span class="number">6</span>  </div><div class="line">         res=<span class="number">6</span>  </div><div class="line">     i=<span class="number">1</span>：  </div><div class="line">         F（<span class="number">1</span>）=max（F（<span class="number">0</span>）-<span class="number">3</span>，-<span class="number">3</span>）=max（<span class="number">6</span>-<span class="number">3</span>，<span class="number">3</span>）=<span class="number">3</span>  </div><div class="line">         res=max（F（<span class="number">1</span>），res）=max（<span class="number">3</span>，<span class="number">6</span>）=<span class="number">6</span>  </div><div class="line">     i=<span class="number">2</span>：  </div><div class="line">         F（<span class="number">2</span>）=max（F（<span class="number">1</span>）-<span class="number">2</span>，-<span class="number">2</span>）=max（<span class="number">3</span>-<span class="number">2</span>，-<span class="number">2</span>）=<span class="number">1</span>  </div><div class="line">         res=max（F（<span class="number">2</span>），res）=max（<span class="number">1</span>，<span class="number">6</span>）=<span class="number">6</span>  </div><div class="line">     i=<span class="number">3</span>：  </div><div class="line">         F（<span class="number">3</span>）=max（F（<span class="number">2</span>）+<span class="number">7</span>，<span class="number">7</span>）=max（<span class="number">1</span>+<span class="number">7</span>，<span class="number">7</span>）=<span class="number">8</span>  </div><div class="line">         res=max（F（<span class="number">2</span>），res）=max（<span class="number">8</span>，<span class="number">6</span>）=<span class="number">8</span>  </div><div class="line">     i=<span class="number">4</span>：  </div><div class="line">         F（<span class="number">4</span>）=max（F（<span class="number">3</span>）-<span class="number">15</span>，-<span class="number">15</span>）=max（<span class="number">8</span>-<span class="number">15</span>，-<span class="number">15</span>）=-<span class="number">7</span>  </div><div class="line">         res=max（F（<span class="number">4</span>），res）=max（-<span class="number">7</span>，<span class="number">8</span>）=<span class="number">8</span>  </div><div class="line">     以此类推  </div><div class="line">     最终res的值为<span class="number">8</span></div></pre></td></tr></table></figure><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> res = array[<span class="number">0</span>];</div><div class="line">        <span class="keyword">int</span> max = array[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;array.length;i++)&#123;</div><div class="line">            max=Math.max(max+array[i],array[i]);</div><div class="line">            res = Math.max(max,res);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="32-从1到n整数中1出现的次数（数组）"><a href="#32-从1到n整数中1出现的次数（数组）" class="headerlink" title="32.从1到n整数中1出现的次数（数组）"></a>32.从1到n整数中1出现的次数（数组）</h2><p>输入一个整数n，求1到n这n个整数的十进制表示中1出现的次数。例如输入12，从1到12这些整数中包含1的数字有1、10、11、12，1一共出现了5次。</p><p>一、1的数目</p><p>编程之美上给出的规律：</p><ol><li>如果第i位（自右至左，从1开始标号）上的数字为0，则第i位可能出现1的次数由更高位决定（若没有高位，视高位为0），等于更高位数字X当前位数的权重$10^{i-1}$。</li><li>如果第i位上的数字为1，则第i位上可能出现1的次数不仅受更高位影响，还受低位影响（若没有低位，视低位为0），等于更高位数字X当前位数的权重$10^{i-1}+$（低位数字+1）。</li><li>如果第i位上的数字大于1，则第i位上可能出现1的次数仅由更高位决定（若没有高位，视高位为0），等于（更高位数字+1）X当前位数的权重$10^{i-1}$。</li></ol><p>二、X的数目<br>这里的  X∈[1,9] ，因为  X=0  不符合下列规律，需要单独计算。<br>首先要知道以下的规律：</p><ul><li>从 1 至 10，在它们的个位数中，任意的 X 都出现了 1 次。</li><li>从 1 至 100，在它们的十位数中，任意的 X 都出现了 10 次。</li><li>从 1 至 1000，在它们的百位数中，任意的 X 都出现了 100 次。</li></ul><p>依此类推，从 1 至  $10^i$ ，在它们的左数第二位（右数第  i  位）中，任意的 X 都出现了  $10^{i−1}$  次。</p><p>这个规律很容易验证，这里不再多做说明。</p><p>接下来以  n=2593,X=5  为例来解释如何得到数学公式。从 1 至 2593 中，数字 5 总计出现了 813 次，其中有 259 次出现在个位，260 次出现在十位，294 次出现在百位，0 次出现在千位。</p><p>现在依次分析这些数据，首先是个位。从 1 至 2590 中，包含了 259 个 10，因此任意的 X 都出现了 259 次。最后剩余的三个数 2591, 2592 和 2593，因为它们最大的个位数字 3 &lt; X，因此不会包含任何 5。（也可以这么看，3&lt;X，则个位上可能出现的X的次数仅由更高位决定，等于更高位数字$（259）\times 10^{1-1}=259$）。</p><p>然后是十位。从 1 至 2500 中，包含了 25 个 100，因此任意的 X 都出现了  25×10=250  次。剩下的数字是从 2501 至 2593，它们最大的十位数字9&gt;X，因此会包含全部10个5。最后总计250 + 10 = 260。（也可以这么看，9&gt;X，则十位上可能出现的X的次数仅由更高位决定，等于更高位数字$（25+1）\times 10^{2-1}=260$）。</p><p>接下来是百位。从 1 至 2000 中，包含了 2 个 1000，因此任意的 X 都出现了  2×100=200  次。剩下的数字是从 2001 至 2593，它们最大的百位数字 5 == X，这时情况就略微复杂，它们的百位肯定是包含 5 的，但不会包含全部 100 个。如果把百位是 5 的数字列出来，是从 2500 至 2593，数字的个数与百位和十位数字相关，是 93+1 = 94。最后总计 200 + 94 = 294。（也可以这么看，5==X，则百位上可能出现X的次数不仅受更高位影响，还受低位影响，等于更高位数字$（2）\times 10^{3-1}+（93+1）=294$）。</p><p>最后是千位。现在已经没有更高位，因此直接看最大的千位数字 2 &lt; X，所以不会包含任何 5。（也可以这么看，2&lt;X，则千位上可能出现的X的次数仅由更高位决定，等于更高位数字$（0）\times 10^{4-1}=0$）。</p><p>到此为止，已经计算出全部数字 5 的出现次数。<br>总结一下以上的算法，可以看到，当计算右数第  i  位包含的 X 的个数时：</p><ul><li>取第  i  位左边（高位）的数字，乘以$10^{i−1}$ ，得到基础值a 。</li><li>取第  i  位数字，计算修正值：<ul><li>如果大于 X，则结果为  $a+ 10^{i−1}$ 。 </li><li>如果小于 X，则结果为  a 。</li><li>如果等 X，则取第  i  位右边（低位）数字，设为  b ，最后结果为  a+b+1 。</li></ul></li></ul><p>相应的代码非常简单，效率也非常高，时间复杂度只有 $ O( log_ {10} n) $。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOfXBetween1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>||x&lt;<span class="number">1</span>||x&gt;<span class="number">9</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> high,low,curr,tmp,i = <span class="number">1</span>;</div><div class="line">    high = n;</div><div class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(high!=<span class="number">0</span>)&#123;</div><div class="line">        high = n/(<span class="keyword">int</span>)Math.pow(<span class="number">10</span>, i);<span class="comment">// 获取第i位的高位</span></div><div class="line">        tmp = n%(<span class="keyword">int</span>)Math.pow(<span class="number">10</span>, i);</div><div class="line">        curr = tmp/(<span class="keyword">int</span>)Math.pow(<span class="number">10</span>, i-<span class="number">1</span>);<span class="comment">// 获取第i位</span></div><div class="line">        low = tmp%(<span class="keyword">int</span>)Math.pow(<span class="number">10</span>, i-<span class="number">1</span>);<span class="comment">// 获取第i位的低位</span></div><div class="line">        <span class="keyword">if</span>(curr==x)&#123;</div><div class="line">            total+= high*(<span class="keyword">int</span>)Math.pow(<span class="number">10</span>, i-<span class="number">1</span>)+low+<span class="number">1</span>;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curr&lt;x)&#123;</div><div class="line">            total+=high*(<span class="keyword">int</span>)Math.pow(<span class="number">10</span>, i-<span class="number">1</span>);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            total+=(high+<span class="number">1</span>)*(<span class="keyword">int</span>)Math.pow(<span class="number">10</span>, i-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        i++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> total;        </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="33-把数组排成最小的数-数组"><a href="#33-把数组排成最小的数-数组" class="headerlink" title="33. 把数组排成最小的数(数组)"></a>33. 把数组排成最小的数(数组)</h2><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.Collections;</div><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n;</div><div class="line">        String s=<span class="string">""</span>;</div><div class="line">        ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        n=numbers.length;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</div><div class="line">            list.add(numbers[i]);<span class="comment">//将数组放入arrayList中</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//实现了Comparator接口的compare方法，将集合元素按照compare方法的规则进行排序</span></div><div class="line">        Collections.sort(list,<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;         </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer str1, Integer str2)</span> </span>&#123;</div><div class="line">                <span class="comment">// TODO Auto-generated method stub         </span></div><div class="line">                    String s1=str1+<span class="string">""</span>+str2;</div><div class="line">                    String s2=str2+<span class="string">""</span>+str1;</div><div class="line">                     </div><div class="line">                    <span class="keyword">return</span> s1.compareTo(s2);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j:list)&#123;</div><div class="line">            s+=j;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> s;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="34-丑数（数组）"><a href="#34-丑数（数组）" class="headerlink" title="34. 丑数（数组）"></a>34. 丑数（数组）</h2><p>把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(index&lt;<span class="number">7</span>)<span class="keyword">return</span> index;</div><div class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[index];</div><div class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> t2 = <span class="number">0</span>, t3 = <span class="number">0</span>, t5 = <span class="number">0</span>, i;</div><div class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;index;i++)&#123;</div><div class="line">            res[i] = min(res[t2]*<span class="number">2</span>,min(res[t3]*<span class="number">3</span>,res[t5]*<span class="number">5</span>));</div><div class="line">            <span class="keyword">if</span>(res[i] == res[t2]*<span class="number">2</span>)t2++;</div><div class="line">            <span class="keyword">if</span>(res[i] == res[t3]*<span class="number">3</span>)t3++;</div><div class="line">            <span class="keyword">if</span>(res[i] == res[t5]*<span class="number">5</span>)t5++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res[index-<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> (a&gt;b)? b:a;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="35-第一次只出现一次的字符（字符串）"><a href="#35-第一次只出现一次的字符（字符串）" class="headerlink" title="35. 第一次只出现一次的字符（字符串）"></a>35. 第一次只出现一次的字符（字符串）</h2><p>在一个字符串(1&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置.</p><p>我们可以使用一个容器来存放每个字符的出现次数。在这个数据容器中可以根据字符来查找出现的次数，也就是这个容器的作用是把一个字符映射成一个数字。在常用的数据容器中，哈希表正是这个用途。</p><p>为了解决这个问题，我们可以定义哈希表的键值（Key）是字符，而值（Value）是该字符出现的次数。同时我们还需要从头开始扫描字符串两次。第一次扫面字符串时，每扫到一个字符就在哈希表的对应项把次数加1.接下来第二次扫描时，每扫描到一个字符就能在哈希表中得到该字符出现的次数，这样第一个只出现一次的字符就是符合要求的输出。</p><p>需要涉及到Java中HashMap工作原理及实现，<a href="http://yikun.github.io/2015/04/01/Java-HashMap工作原理及实现/" target="_blank" rel="noopener">资料链接</a></p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">        HashMap&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character,Integer&gt;();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</div><div class="line">            <span class="keyword">char</span> c = str.charAt(i);<span class="comment">//charAt方法，获得位置i的串</span></div><div class="line">                <span class="keyword">if</span>(map.containsKey(c))&#123;<span class="comment">//HashMap的containKey方法；</span></div><div class="line">                    <span class="keyword">int</span> time = map.get(c);<span class="comment">//HashMap的get方法，得到Key c的Value；</span></div><div class="line">                    time++;</div><div class="line">                    map.put(c,time);<span class="comment">//HashMap的put方法，将Key c的Value置为time；</span></div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    map.put(c,<span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</div><div class="line">            <span class="keyword">char</span> c = str.charAt(i);</div><div class="line">            <span class="keyword">if</span>(map.get(c)==<span class="number">1</span>)&#123;</div><div class="line">                <span class="keyword">return</span> i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="36-数组中的逆序对（数组）"><a href="#36-数组中的逆序对（数组）" class="headerlink" title="36. 数组中的逆序对（数组）"></a>36. 数组中的逆序对（数组）</h2><p>在数组中的两个数字如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。例如在数组{7，5，6，4}中，一共存在5个逆序对，分别是（7，6）、（7，5）、（7，4）、（5，4）和（6，4）。</p><p>可以按照归并排序的思路，先把数组分隔成子数组，先统计出子数组内部的逆序对的数目，然后再统计出两个相邻子数组之间的逆序对的数目。在统计逆序对的过程中，还需要对数组进行排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    int cnt;</div><div class="line"> </div><div class="line">    public int InversePairs(int[] array) &#123;</div><div class="line">        cnt = 0;</div><div class="line">        if (array != null)</div><div class="line">            mergeSortUp2Down(array, 0, array.length - 1);</div><div class="line">        return cnt;</div><div class="line">    &#125; </div><div class="line">    /*</div><div class="line">     * 归并排序(从上往下)</div><div class="line">     */</div><div class="line">    public void mergeSortUp2Down(int[] a, int start, int end) &#123;</div><div class="line">        if (start &gt;= end)</div><div class="line">            return;</div><div class="line">        int mid = (start + end) &gt;&gt; 1;</div><div class="line"> </div><div class="line">        mergeSortUp2Down(a, start, mid);</div><div class="line">        mergeSortUp2Down(a, mid + 1, end);</div><div class="line"> </div><div class="line">        merge(a, start, mid, end);</div><div class="line">    &#125; </div><div class="line">    /*</div><div class="line">     * 将一个数组中的两个相邻有序区间合并成一个</div><div class="line">     */</div><div class="line">    public void merge(int[] a, int start, int mid, int end) &#123;</div><div class="line">        int[] tmp = new int[end - start + 1];</div><div class="line"> </div><div class="line">        int i = start, j = mid + 1, k = 0;</div><div class="line">        while (i &lt;= mid &amp;&amp; j &lt;= end) &#123;</div><div class="line">            if (a[i] &lt;= a[j])</div><div class="line">                tmp[k++] = a[i++];</div><div class="line">            else &#123;</div><div class="line">                tmp[k++] = a[j++];</div><div class="line">                cnt += mid - i + 1;  //关键的一步，统计逆序对..........</div><div class="line">                cnt%=1000000007;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        while (i &lt;= mid)</div><div class="line">            tmp[k++] = a[i++];</div><div class="line">        while (j &lt;= end)</div><div class="line">            tmp[k++] = a[j++];</div><div class="line">        for (k = 0; k &lt; tmp.length; k++)</div><div class="line">            a[start + k] = tmp[k];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="37-两个链表的第一个公共结点（链表）"><a href="#37-两个链表的第一个公共结点（链表）" class="headerlink" title="37. 两个链表的第一个公共结点（链表）"></a>37. 两个链表的第一个公共结点（链表）</h2><p>输入两个链表找出他们的第一个公共结点。</p><p>面试的时候碰到这道题，很多应聘者的第一个想法就是蛮力法：在第一个链表上顺序遍历每个结点，每遍历到一个结点的时候，在第二个链表上顺序遍历每个结点。若第二个链表上有一个结点和第一个链表上的结点一样，说明两个链表在这个结点上重合，于是就找到了它们的公共结点。如果第一个链表的长度为m，第二个链表的长度为n，显然该方法的时间复杂度是O(mn)。</p><p>通常蛮力法不会是最好的办法，我们接下来试着分析有公共结点的两个链表有哪些特点。从链表结构的定义看出，这两个链表是单向链表。如果他们有公共的结点，那么这两个链表从某一结点开始，他们的next指向同一个结点。但由于是单向链表的结点，每个结点只有一个next，因此从第一个公共结点开始，之后的结点都是重合的，不可能再出现分叉。所以两个有公共结点而部分重合的链表，拓扑形状看起来像一个Y，而不是X。<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-25 下午2.59.56.png" alt="屏幕快照 2017-07-25 下午2.59.56"></p><p>经过我们的分析发现，若两个链表有公共结点，那么公共结点出现在两个链表的尾部。如果我们从两个链表的尾部开始往前比较，最后一个相同的结点就是我们要找的结点。我们想到用栈的特点来解决这个问题：分别把两个链表的结点放入两个栈中，这样两个链表的尾结点就位于两个栈的栈顶，接下来比较两个栈顶的结点是否相同。若果相同，则把栈顶弹出接着比较下一个栈顶，直到找到最后一个相同的结点。</p><p>上面需要用到两个辅助栈。若链表的长度分别为m和n，那么空间复杂度是O(m+n)。这种思路的时间复杂度也是O(m+n)。和最开始的蛮力法相比，时间效率得到了提升，相当于是用空间换取时间效率。</p><p>之所以需要用到栈，是因为我们想同时遍历到达两个栈的尾结点。当两个链表的长度不相同时，如果我们从头开始遍历到达尾结点的时间就不一致。其实解决这个问题还有一个更简单的办法：首先遍历两个链表得到他们的长度，就能知道哪个链表比较长，以及长的链表比短的链表多几个结点。在第二次遍历的时候，在较长的链表上先走若干步，接着再同时在两个链表上遍历，找到的第一个相同的结点就是他们的第一个公共结点。</p><p>第三种思路和第二种思路相比，时间复杂度都是O(m+n)，但我们不再需要辅助的栈，因此提高了空间效率。实现代码如下：</p><blockquote><p>java版本</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">public class ListNode &#123;</div><div class="line">    int val;</div><div class="line">    ListNode next = null;</div><div class="line"></div><div class="line">    ListNode(int val) &#123;</div><div class="line">        this.val = val;</div><div class="line">    &#125;</div><div class="line">&#125;*/</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</div><div class="line">        ListNode current1 = pHead1;<span class="comment">//链表1</span></div><div class="line">        ListNode current2 = pHead2;<span class="comment">//链表2</span></div><div class="line">        <span class="keyword">if</span>(pHead1 ==<span class="keyword">null</span>||pHead2==<span class="keyword">null</span>)&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;<span class="comment">//</span></div><div class="line">        </div><div class="line">        <span class="keyword">int</span> len1 = getlistlength(pHead1);<span class="comment">//链表1的长度</span></div><div class="line">        <span class="keyword">int</span> len2 = getlistlength(pHead2);<span class="comment">//链表2的长度</span></div><div class="line">        </div><div class="line">        <span class="comment">//若链表1长度大于链表2</span></div><div class="line">        <span class="keyword">if</span>(len1&gt;=len2)&#123;</div><div class="line">            <span class="keyword">int</span> len=len1-len2;</div><div class="line">            <span class="comment">//遍历链表1，遍历长度为两链表长度差</span></div><div class="line">            <span class="keyword">while</span> (len&gt;<span class="number">0</span>)&#123;</div><div class="line">                current1 = currentnext;</div><div class="line">                len--;</div><div class="line">                  </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//若链表2长度大于链表1</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(len1&lt;len2)&#123;</div><div class="line">            <span class="keyword">int</span> len=len2-len1;</div><div class="line">            <span class="comment">//遍历链表2，遍历长度为两链表长度差</span></div><div class="line">            <span class="keyword">while</span> (len&gt;<span class="number">0</span>)&#123;</div><div class="line">                current2=current2.next;</div><div class="line">                len--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//开始齐头并进，直到找到第一个公共结点</span></div><div class="line">        <span class="keyword">while</span>(current1!=current2)&#123;</div><div class="line">            current1 = currentnext;</div><div class="line">            current2 = current2.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> current1;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//求指定链表的长度</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getlistlength</span><span class="params">(ListNode pHead)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</div><div class="line">        ListNode current = pHead;</div><div class="line">        <span class="keyword">while</span>(current!=<span class="keyword">null</span>)&#123;</div><div class="line">            length++;</div><div class="line">            current = current.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> length;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>python版本</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class ListNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindFirstCommonNode</span><span class="params">(self, pHead1, pHead2)</span>:</span></div><div class="line">        <span class="comment"># write code here</span></div><div class="line">        current1=pHead1</div><div class="line">        current2=pHead2</div><div class="line">        len1 = self.getlistlength(current1)</div><div class="line">        len2 = self.getlistlength(current2)        </div><div class="line">        <span class="keyword">if</span> len1&gt;=len2:            </div><div class="line">            length = len1-len2</div><div class="line">            <span class="keyword">while</span> length&gt;<span class="number">0</span>:</div><div class="line">                current1 = currentnext</div><div class="line">                length=length<span class="number">-1</span>                </div><div class="line">        <span class="keyword">elif</span> len1&lt;len2:</div><div class="line">            length = len2-len1</div><div class="line">            <span class="keyword">while</span> length&gt;<span class="number">0</span>:</div><div class="line">                current2 = current2.next</div><div class="line">                length=length<span class="number">-1</span>               </div><div class="line">        <span class="keyword">while</span> current1!=current2:</div><div class="line">            current1=currentnext</div><div class="line">            current2=current2.next</div><div class="line">        <span class="keyword">return</span> current1</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getlistlength</span><span class="params">(self,pHead)</span>:</span></div><div class="line">        length =<span class="number">0</span></div><div class="line">        current =pHead</div><div class="line">        <span class="keyword">while</span> current!=<span class="keyword">None</span>:</div><div class="line">            length=length+<span class="number">1</span></div><div class="line">            current = current.next</div><div class="line">        <span class="keyword">return</span> length</div></pre></td></tr></table></figure><h2 id="38-数字在排序数组中出现的次数（数组）"><a href="#38-数字在排序数组中出现的次数（数组）" class="headerlink" title="38. 数字在排序数组中出现的次数（数组）"></a>38. 数字在排序数组中出现的次数（数组）</h2><p>统计一个数字在排序数组中出现的次数。</p><p>利用二分查找直接找到第一个K和最后一个K。以下代码使用递归方法找到第一个K，使用循环方法最后一个K。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> length = array.length;</div><div class="line">        <span class="keyword">if</span>(length == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> firstK = getFirstK(array, k, <span class="number">0</span>, length-<span class="number">1</span>);</div><div class="line">        <span class="keyword">int</span> lastK = getLastK(array, k, <span class="number">0</span>, length-<span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span>(firstK != -<span class="number">1</span> &amp;&amp; lastK != -<span class="number">1</span>)&#123;</div><div class="line">             <span class="keyword">return</span> lastK - firstK + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//递归写法</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getFirstK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> mid = (start + end) &gt;&gt; <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(array[mid] &gt; k)&#123;</div><div class="line">            <span class="keyword">return</span> getFirstK(array, k, start, mid-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (array[mid] &lt; k)&#123;</div><div class="line">            <span class="keyword">return</span> getFirstK(array, k, mid+<span class="number">1</span>, end);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(mid-<span class="number">1</span> &gt;=<span class="number">0</span> &amp;&amp; array[mid-<span class="number">1</span>] == k)&#123;</div><div class="line">            <span class="keyword">return</span> getFirstK(array, k, start, mid-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> mid;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//循环写法</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getLastK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> length = array.length;</div><div class="line">        <span class="keyword">int</span> mid = (start + end) &gt;&gt; <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(start &lt;= end)&#123;</div><div class="line">            <span class="keyword">if</span>(array[mid] &gt; k)&#123;</div><div class="line">                end = mid-<span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[mid] &lt; k)&#123;</div><div class="line">                start = mid+<span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mid+<span class="number">1</span> &lt;= length-<span class="number">1</span> &amp;&amp; array[mid+<span class="number">1</span>] == k)&#123;</div><div class="line">                start = mid+<span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">return</span> mid;</div><div class="line">                &#125;</div><div class="line">            mid = (start + end) &gt;&gt; <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="39-二叉树的深度（二叉树）"><a href="#39-二叉树的深度（二叉树）" class="headerlink" title="39. 二叉树的深度（二叉树）"></a>39. 二叉树的深度（二叉树）</h2><h3 id="39-1-二叉树的深度"><a href="#39-1-二叉树的深度" class="headerlink" title="39.1 二叉树的深度"></a>39.1 二叉树的深度</h3><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p><p>Java 经典的求二叉树深度 递归写法</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> nleft = TreeDepth(root.left);</div><div class="line">        <span class="keyword">int</span> nright = TreeDepth(root.right);</div><div class="line">        <span class="keyword">return</span> nleft&gt;nright?(nleft+<span class="number">1</span>):(nright+<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="39-2-平衡二叉树"><a href="#39-2-平衡二叉树" class="headerlink" title="39.2 平衡二叉树"></a>39.2 平衡二叉树</h3><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p><p>有了求二叉树的深度的经验之后，我们就很容易想到一个思路：在遍历树的每个结点的时候，调用函数TreeDepth得到它的左右子树的深度。如果每个结点的左右子树的深度相差都不超过1，按照定义它就是一颗平衡的二叉树。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">int</span> left = TreeDepth(root.left);</div><div class="line">        <span class="keyword">int</span> right = TreeDepth(root.right);</div><div class="line">        <span class="keyword">int</span> diff = left-right;</div><div class="line">        <span class="keyword">if</span>(diff&gt;<span class="number">1</span>||diff&lt;-<span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">return</span> IsBalanced_Solution(root.left)&amp;&amp;IsBalanced_Solution(root.right);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> nleft = TreeDepth(root.left);</div><div class="line">        <span class="keyword">int</span> nright = TreeDepth(root.right);</div><div class="line">        <span class="keyword">return</span> nleft&gt;nright?(nleft+<span class="number">1</span>):(nright+<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="40-数组中只出现一次的数字（数组）"><a href="#40-数组中只出现一次的数字（数组）" class="headerlink" title="40. 数组中只出现一次的数字（数组）"></a>40. 数组中只出现一次的数字（数组）</h2><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是$O(n)$，空间复杂度是$O(1)$。</p><p>首先我们考虑这个问题的一个简单版本：一个数组里除了一个数字之外，其他的数字都出现了两次。请写程序找出这个只出现一次的数字。</p><p>这个题目的突破口在哪里？题目为什么要强调有一个数字出现一次，其他的出现两次？我们想到了异或运算的性质：任何一个数字异或它自己都等于0 。也就是说，如果我们从头到尾依次异或数组中的每一个数字，那么最终的结果刚好是那个只出现一次的数字，因为那些出现两次的数字全部在异或中抵消掉了。</p><p>有了上面简单问题的解决方案之后，我们回到原始的问题。如果能够把原数组分为两个子数组。在每个子数组中，包含一个只出现一次的数字，而其它数字都出现两次。如果能够这样拆分原数组，按照前面的办法就是分别求出这两个只出现一次的数字了。<br> 我们还是从头到尾依次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次的数字的异或结果。因为其它数字都出现了两次，在异或中全部抵消掉了。由于这两个数字肯定不一样，那么这个异或结果肯定不为0 ，也就是说在这个结果数字的二进制表示中至少就有一位为1 。我们在结果数字中找到第一个为1 的位的位置，记为第N 位。现在我们以第N 位是不是1 为标准把原数组中的数字分成两个子数组，第一个子数组中每个数字的第N 位都为1 ，而第二个子数组的每个数字的第N 位都为0 。<br> 现在我们已经把原数组分成了两个子数组，每个子数组都包含一个只出现一次的数字，而其它数字都出现了两次。因此到此为止，所有的问题我们都已经解决。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//num1,num2分别为长度为1的数组。传出参数</span></div><div class="line"><span class="comment">//将num1[0],num2[0]设置为返回结果</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> num1[] , <span class="keyword">int</span> num2[])</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span>(array==<span class="keyword">null</span> ||array.length&lt;<span class="number">2</span>)</div><div class="line">           <span class="keyword">return</span> ;</div><div class="line">       <span class="keyword">int</span> temp = <span class="number">0</span>;</div><div class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)</div><div class="line">           temp ^= array[i];</div><div class="line">        </div><div class="line">       <span class="keyword">int</span> indexOf1 = findFirstBitIs(temp);</div><div class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</div><div class="line">           <span class="keyword">if</span>(isBit(array[i], indexOf1))</div><div class="line">               num1[<span class="number">0</span>]^=array[i];</div><div class="line">           <span class="keyword">else</span></div><div class="line">               num2[<span class="number">0</span>]^=array[i];</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">    <span class="comment">//在正数num的二进制表示中找到最右边是1的位</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findFirstBitIs</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</div><div class="line">       <span class="keyword">int</span> indexBit = <span class="number">0</span>;</div><div class="line">       <span class="keyword">while</span>(((num &amp; <span class="number">1</span>)==<span class="number">0</span>) &amp;&amp; (indexBit)&lt;<span class="number">8</span>*<span class="number">4</span>)&#123;</div><div class="line">           num = num &gt;&gt; <span class="number">1</span>;</div><div class="line">           ++indexBit;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> indexBit;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">//判断在num的二进制表示中从右边数起的indexBit位是不是1.</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBit</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> indexBit)</span></span>&#123;</div><div class="line">       num = num &gt;&gt; indexBit;</div><div class="line">       <span class="keyword">return</span> (num &amp; <span class="number">1</span>) == <span class="number">1</span>;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="41-和为S的两个数字VS和为s的连续正数序列（数组）"><a href="#41-和为S的两个数字VS和为s的连续正数序列（数组）" class="headerlink" title="41.和为S的两个数字VS和为s的连续正数序列（数组）"></a>41.和为S的两个数字VS和为s的连续正数序列（数组）</h2><h3 id="41-1-和为s的两个数字"><a href="#41-1-和为s的两个数字" class="headerlink" title="41.1 和为s的两个数字"></a>41.1 和为s的两个数字</h3><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p><p>数列满足递增，设两个头尾两个指针i和j， </p><ul><li>若ai + aj == sum，就是答案（相差越远乘积越小） </li><li>若ai + aj &gt; sum，aj肯定不是答案之一（前面已得出 i 前面的数已是不可能），j -= 1 </li><li>若ai + aj &lt; sum，ai肯定不是答案之一（前面已得出 j 后面的数已是不可能），i += 1 </li></ul><p>时间复杂度为O(n)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">public class Solution &#123;</div><div class="line">    public ArrayList&lt;Integer&gt; FindNumbersWithSum(int [] array,int sum) &#123;</div><div class="line">        ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</div><div class="line">        if(array==null||array.length&lt;2)&#123;</div><div class="line">            return list;</div><div class="line">        &#125;</div><div class="line">        int i=0,j=array.length-1;</div><div class="line">        while(i&lt;j)&#123;</div><div class="line">            if(array[i]+array[j]==sum)&#123;</div><div class="line">                list.add(array[i]);</div><div class="line">                list.add(array[j]);</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            else if(array[i]+array[j]&gt;sum)&#123;</div><div class="line">                j--;</div><div class="line">            &#125;</div><div class="line">            else</div><div class="line">                i++;</div><div class="line">        &#125;</div><div class="line">        return list;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="41-2-和为s的连续正数序列"><a href="#41-2-和为s的连续正数序列" class="headerlink" title="41.2 和为s的连续正数序列"></a>41.2 和为s的连续正数序列</h3><p>输入一个正数s，打印出所有和为s的连续正数序列（至少含有两个数）。例如输入15，由于1+2+3+4+5=4+5+6=7+8=15，所以结果打印出三个连续序列1~5、4~6和7~8。</p><p>考虑用两个数small和big分别表示序列的最小值和最大值。首先把small初始化为1，big初始化为2，如果从small到big的序列和大于s，我们可以从序列中去掉较小的值，也就是增大small的值。如果从small到big的序列和小于s，我们可以增大big，让这个序列包含更多的数字。因为这个序列至少要有两个数字，我们一直增加small到（1+s）/2为止。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="comment">/*</span></div><div class="line">*初始化small=1，big=2;</div><div class="line">*small到big序列和小于sum，big++;大于sum，small++;</div><div class="line">*当small增加到(1+sum)/2是停止</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</div><div class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; lists=<span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</div><div class="line">        <span class="keyword">if</span>(sum&lt;=<span class="number">1</span>)&#123;<span class="keyword">return</span> lists;&#125;</div><div class="line">        <span class="keyword">int</span> small=<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> big=<span class="number">2</span>;</div><div class="line">        <span class="keyword">while</span>(small!=(<span class="number">1</span>+sum)/<span class="number">2</span>)&#123;          <span class="comment">//当small==(1+sum)/2的时候停止</span></div><div class="line">            <span class="keyword">int</span> curSum=sumOfList(small,big);</div><div class="line">            <span class="keyword">if</span>(curSum==sum)&#123;</div><div class="line">                ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=small;i&lt;=big;i++)&#123;</div><div class="line">                    list.add(i);</div><div class="line">                &#125;</div><div class="line">                lists.add(list);</div><div class="line">                small++;big++;</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curSum&lt;sum)&#123;</div><div class="line">                big++;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                small++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> lists;</div><div class="line">    &#125;     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfList</span><span class="params">(<span class="keyword">int</span> head,<span class="keyword">int</span> leap)</span></span>&#123;        <span class="comment">//计算当前序列的和</span></div><div class="line">        <span class="keyword">int</span> sum=head;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head+<span class="number">1</span>;i&lt;=leap;i++)&#123;</div><div class="line">            sum+=i;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="42-翻转单词顺序VS左旋转字符串（字符串）"><a href="#42-翻转单词顺序VS左旋转字符串（字符串）" class="headerlink" title="42. 翻转单词顺序VS左旋转字符串（字符串）"></a>42. 翻转单词顺序VS左旋转字符串（字符串）</h2><h3 id="42-1-翻转单词顺序"><a href="#42-1-翻转单词顺序" class="headerlink" title="42.1 翻转单词顺序"></a>42.1 翻转单词顺序</h3><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串“I am a student”，则输出“student. a am I”。<br>可以先翻转整个句子，然后，依次翻转每个单词。依据空格来确定单词的起始和终止位置</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</div><div class="line">        reverse(chars,<span class="number">0</span>,chars.length-<span class="number">1</span>);</div><div class="line">        <span class="keyword">int</span> blank = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;chars.length-<span class="number">1</span>;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(chars[i]==<span class="string">' '</span>)&#123;</div><div class="line">                <span class="keyword">int</span> nextblank = i;</div><div class="line">                reverse(chars,blank+<span class="number">1</span>,nextblank-<span class="number">1</span>);</div><div class="line">                blank = nextblank;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        reverse(chars,blank+<span class="number">1</span>,chars.length-<span class="number">1</span>);<span class="comment">//单独翻转最后一个单词</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] chars,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">        <span class="keyword">while</span>(low&lt;high)&#123;</div><div class="line">            <span class="keyword">char</span> temp = chars[low];</div><div class="line">            chars[low]=chars[high];</div><div class="line">            chars[high]=temp;</div><div class="line">            low++;</div><div class="line">            high--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="42-2-左旋转字符串"><a href="#42-2-左旋转字符串" class="headerlink" title="42.2 左旋转字符串"></a>42.2 左旋转字符串</h3><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。</p><p>以“abcdefg”为例，我们可以把它分为两部分。由于想把它的前两个字符移到后面，我们就把钱两个字符分到第一部分，把后面的所有字符都分到第二部分。然后先翻转这两部分，于是就得到“bagfedc”。接下来在翻转整个字符串，得到的”cdefgab”刚好就是把原始字符串左旋转2位的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public String LeftRotateString(String str,int n) &#123;</div><div class="line">        char[] chars = str.toCharArray();        </div><div class="line">        if(chars.length &lt; n) return &quot;&quot;; </div><div class="line">        reverse(chars, 0, n-1);</div><div class="line">        reverse(chars, n, chars.length-1);</div><div class="line">        reverse(chars, 0, chars.length-1);</div><div class="line">        return new String(chars);</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public void reverse(char[] chars,int low,int high)&#123;</div><div class="line">        char temp;</div><div class="line">        while(low&lt;high)&#123;</div><div class="line">            temp = chars[low];</div><div class="line">            chars[low] = chars[high];</div><div class="line">            chars[high] = temp;</div><div class="line">            low++;</div><div class="line">            high--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="43-N个骰子的点数（null）"><a href="#43-N个骰子的点数（null）" class="headerlink" title="43. N个骰子的点数（null）"></a>43. N个骰子的点数（null）</h2><h2 id="44-扑克牌的顺子（数组）"><a href="#44-扑克牌的顺子（数组）" class="headerlink" title="44. 扑克牌的顺子（数组）"></a>44. 扑克牌的顺子（数组）</h2><p>从扑克牌中随机抽5张牌，判断是不是顺子，即这5张牌是不是连续的。2~10为数字本身，A为1，J为11，Q为12，K为13，而大小王可以看做是任意数字，这里定为0.</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContinuous</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> length = numbers.length;</div><div class="line">        <span class="keyword">if</span>(numbers==<span class="keyword">null</span>||length==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//特殊情况</span></div><div class="line">        Arrays.sort(numbers);<span class="comment">//排序</span></div><div class="line">        <span class="comment">//统计数组中0的个数</span></div><div class="line">        <span class="keyword">int</span> numberOfZero = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;length&amp;&amp;numbers[i]==<span class="number">0</span>;i++)&#123;</div><div class="line">            ++numberOfZero;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> numberOfGap = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> small = numberOfZero;</div><div class="line">        <span class="keyword">int</span> big = small+<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(big&lt;length)&#123;</div><div class="line">            <span class="comment">//含有对子，不可能是顺子</span></div><div class="line">            <span class="keyword">if</span>(numbers[small]==numbers[big])&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//统计数组中的间隔数目</span></div><div class="line">            numberOfGap += numbers[big]-numbers[small]-<span class="number">1</span>;</div><div class="line">            small=big;</div><div class="line">            big++;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果间隔数小于等于零的数量则可以组成顺子，否则不行。</span></div><div class="line">        <span class="keyword">if</span>(numberOfGap&lt;=numberOfZero)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="45-圆圈中最后剩下的数字（链表）"><a href="#45-圆圈中最后剩下的数字（链表）" class="headerlink" title="45. 圆圈中最后剩下的数字（链表）"></a>45. 圆圈中最后剩下的数字（链表）</h2><p>0、…..，n-1这n个数字排成一个圆圈，从数字0开始每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。<br>约瑟夫环问题，用环形链表模拟圆圈的经典解法，</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(m&lt;=<span class="number">0</span>||n&lt;=<span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        <span class="comment">//先构造循环链表</span></div><div class="line">        ListNode head= <span class="keyword">new</span> ListNode(<span class="number">0</span>);<span class="comment">//头结点, 值为0</span></div><div class="line">        ListNode pre = head;</div><div class="line">        ListNode temp = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</div><div class="line">            temp = <span class="keyword">new</span> ListNode(i);</div><div class="line">            pre.next = temp;</div><div class="line">            pre = temp;</div><div class="line">        &#125;</div><div class="line">        temp.next = head;<span class="comment">//将第n-1个结点(也就是尾结点)指向头结点</span></div><div class="line">        ListNode temp2 = <span class="keyword">null</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">while</span>(n&gt;=<span class="number">1</span>)&#123;</div><div class="line">            <span class="comment">//每次都当前头结点找到第m个结点的前驱</span></div><div class="line">            temp2=head;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;m-<span class="number">1</span>;i++)&#123;</div><div class="line">                temp2 = temp2.next;</div><div class="line">            &#125;</div><div class="line">            temp2.next = temp2.next.next;</div><div class="line">            head = temp2.next;<span class="comment">//设置当前头结点</span></div><div class="line">            n--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> head.val;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>||m==<span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> last=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</div><div class="line">        &#123;</div><div class="line">            last=(last+m)%i;</div><div class="line">        &#125;   </div><div class="line">       <span class="keyword">return</span> last ;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="46-求1-2-…-n（逻辑）"><a href="#46-求1-2-…-n（逻辑）" class="headerlink" title="46. 求1+2+…..+n（逻辑）"></a>46. 求1+2+…..+n（逻辑）</h2><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><ol><li>需利用逻辑与的短路特性实现递归终止。 </li><li>当n==0时，(n&gt;0)&amp;&amp;((sum+=Sum_Solution(n-1))&gt;0)只执行前面的判断，为false，然后直接返回0；</li><li>当n&gt;0时，执行sum+=Sum_Solution(n-1)，实现递归计算Sum_Solution(n)。</li></ol><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> sum=n;</div><div class="line">        <span class="keyword">boolean</span> ans = (n&gt;<span class="number">0</span>)&amp;&amp;((sum+=Sum_Solution(n-<span class="number">1</span>))&gt;<span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="47-不用加减乘除做加法（位运算）"><a href="#47-不用加减乘除做加法（位运算）" class="headerlink" title="47. 不用加减乘除做加法（位运算）"></a>47. 不用加减乘除做加法（位运算）</h2><p>首先看十进制是如何做的： 5+7=12，三步走</p><ol><li>第一步：相加各位的值，不算进位，得到2。</li><li>第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。</li><li>第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。</li></ol><p>同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111 </p><ol><li>第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。</li><li>第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。</li><li>第三步重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;1010)&lt;&lt;1。继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (num2!=<span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">int</span> temp = num1^num2;</div><div class="line">            num2 = (num1&amp;num2)&lt;&lt;<span class="number">1</span>;</div><div class="line">            num1 = temp;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> num1;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="49-把字符串转换成整数（字符串）"><a href="#49-把字符串转换成整数（字符串）" class="headerlink" title="49. 把字符串转换成整数（字符串）"></a>49. 把字符串转换成整数（字符串）</h2><p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。<br>问题不难，但是要把很多特殊情况都考虑进去，却并不容易。需要考虑的特殊情况有以下几个：</p><ol><li>空指针null</li><li>字符串为空</li><li>正负号</li><li>上下溢出 Integer.MAX_VALUE (2^31-1)  Integer.MIN_VALUE(-2^31)</li></ol><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span>||str.length()==<span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">//空指针或空字符串</span></div><div class="line">        <span class="keyword">char</span>[] c = str.toCharArray();</div><div class="line">        <span class="keyword">boolean</span> minus=<span class="keyword">false</span>;</div><div class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</div><div class="line">        <span class="comment">//正负号</span></div><div class="line">        <span class="keyword">if</span>(c[i]==<span class="string">'+'</span>)&#123;</div><div class="line">            i++;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c[i]==<span class="string">'-'</span>)&#123;</div><div class="line">            i++;</div><div class="line">            minus=<span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(i&lt;c.length)&#123;</div><div class="line">            num = StrToIntCore(c,minus,i);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> num;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> num;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">StrToIntCore</span><span class="params">(<span class="keyword">char</span>[] str,<span class="keyword">boolean</span> minus,<span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;str.length;j++)&#123;</div><div class="line">            <span class="keyword">if</span>(str[j]&gt;=<span class="string">'0'</span>&amp;&amp;str[j]&lt;=<span class="string">'9'</span>)&#123;</div><div class="line">                <span class="keyword">int</span> flag = minus?-<span class="number">1</span>:<span class="number">1</span>;</div><div class="line">                num = num*<span class="number">10</span>+flag*(str[j]-<span class="string">'0'</span>);</div><div class="line">                <span class="keyword">if</span>((!minus&amp;&amp;num&gt;Integer.MAX_VALUE)||minus&amp;&amp;num&lt;Integer.MIN_VALUE)&#123;<span class="comment">//上下溢出</span></div><div class="line">                    num=<span class="number">0</span>;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//非法数值</span></div><div class="line">                num=<span class="number">0</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">           </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> num;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="50-树中两个结点的最低公共祖先（二叉树）"><a href="#50-树中两个结点的最低公共祖先（二叉树）" class="headerlink" title="50.树中两个结点的最低公共祖先（二叉树）"></a>50.树中两个结点的最低公共祖先（二叉树）</h2><h3 id="50-1-二叉搜索树的最低公共祖先"><a href="#50-1-二叉搜索树的最低公共祖先" class="headerlink" title="50.1  二叉搜索树的最低公共祖先"></a>50.1  二叉搜索树的最低公共祖先</h3><p>二叉搜索树是经过排序的，位于左子树的节点都比父节点小，位于右子树的节点都比父节点大。既然要找最低的公共祖先节点，我们可以从根节点开始进行比较。若当前节点的值比两个节点的值都大，那么最低的祖先节点一定在当前节点的左子树中，则遍历当前节点的左子节点；反之，若当前节点的值比两个节点的值都小，那么最低的祖先节点一定在当前节点的右子树中，则遍历当前节点的右子节点；这样，直到找到一个节点，位于两个节点值的中间，则找到了最低的公共祖先节点。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>||root==q||root==p)<span class="keyword">return</span> root;</div><div class="line">        <span class="keyword">if</span>(root.val&gt;p.val&amp;&amp;root.val&gt;q.val)&#123;</div><div class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left,p,q);</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val&lt;p.val&amp;&amp;root.val&lt;q.val)&#123;</div><div class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right,p,q);</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> root;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="50-2-普通二叉树的最低公共祖先"><a href="#50-2-普通二叉树的最低公共祖先" class="headerlink" title="50.2 普通二叉树的最低公共祖先"></a>50.2 普通二叉树的最低公共祖先</h3><p>一种简单的方法是DFS分别寻找到两个节点p和q的路径，然后对比路径，查看他们的第一个分岔口，则为LCA。<br>这个思路比较简单，代码写起来不如下面这种方法优雅：</p><p>我们仍然可以用递归来解决，递归寻找两个带查询LCA的节点p和q，当找到后，返回给它们的父亲。如果某个节点的左右子树分别包括这两个节点，那么这个节点必然是所求的解，返回该节点。否则，返回左或者右子树（哪个包含p或者q的就返回哪个）。复杂度O(n)</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>||root==p||root==q)&#123;<span class="keyword">return</span> root;&#125;</div><div class="line">        TreeNode left = lowestCommonAncestor(root.left,p,q);</div><div class="line">        TreeNode right = lowestCommonAncestor(root.right,p,q);</div><div class="line">        <span class="keyword">if</span>(left!=<span class="keyword">null</span>&amp;&amp;right!=<span class="keyword">null</span>)<span class="keyword">return</span> root;</div><div class="line">        <span class="keyword">return</span> left!=<span class="keyword">null</span>? left:right;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="51-数组中重复的数字（数组）"><a href="#51-数组中重复的数字（数组）" class="headerlink" title="51. 数组中重复的数字（数组）"></a>51. 数组中重复的数字（数组）</h2><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是重复的数字2或者3。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(numbers==<span class="keyword">null</span>||length==<span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;<span class="comment">//空指针或空数组</span></div><div class="line">        <span class="comment">// 判断数组是否合法,即每个数都在0~n-1之间</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(numbers[i]&gt;length-<span class="number">1</span>||numbers[i]&lt;<span class="number">0</span>)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//若数值与下标不同，则调换位置；</span></div><div class="line">        <span class="comment">//比较位置下标为数值(numbers[i])的数值(numbers[numbers[i]])与该数值(numbers[i])是否一致，若一致，则说明有重复数字</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</div><div class="line">            <span class="keyword">while</span>(numbers[i]!=i)&#123;</div><div class="line">                <span class="keyword">if</span>(numbers[i]==numbers[numbers[i]])&#123;</div><div class="line">                    duplication[<span class="number">0</span>] = numbers[i];</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">int</span> temp=numbers[i];</div><div class="line">                numbers[i]=numbers[temp];</div><div class="line">                numbers[temp]=temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="52-构建乘积数组（数组）"><a href="#52-构建乘积数组（数组）" class="headerlink" title="52. 构建乘积数组（数组）"></a>52. 构建乘积数组（数组）</h2><p>给定一个数组A[0,1,…,n-1],请构建一个数组$B[0,1,…,n-1]$,其中B中的元素$B[i]=A[0]<em>A[1]</em>…<em>A[i-1]</em>A[i+1]<em>…</em>A[n-1]$。不能使用除法。</p><p><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-02 下午7.43.57.png" alt="屏幕快照 2017-08-02 下午7.43.57"></p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] A) &#123;</div><div class="line">        <span class="keyword">int</span> length = A.length;</div><div class="line">        <span class="keyword">int</span>[] B = <span class="keyword">new</span> <span class="keyword">int</span>[length];</div><div class="line">        <span class="keyword">if</span>(length!=<span class="number">0</span>)&#123;</div><div class="line">            B[<span class="number">0</span>]=<span class="number">1</span>;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length;i++)&#123;</div><div class="line">                B[i]=B[i-<span class="number">1</span>]*A[i-<span class="number">1</span>];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">int</span> temp=<span class="number">1</span>;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=length-<span class="number">2</span>;j&gt;=<span class="number">0</span>;j--)&#123;                </div><div class="line">                temp = temp*A[j+<span class="number">1</span>];</div><div class="line">                B[j]=temp*B[j];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> B;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="53-正则表达式匹配（字符串）"><a href="#53-正则表达式匹配（字符串）" class="headerlink" title="53. 正则表达式匹配（字符串）"></a>53. 正则表达式匹配（字符串）</h2><p>当模式中的第二个字符不是“*”时：</p><ol><li>如果字符串第一个字符和模式中的第一个字符相匹配，那么字符串和模式都后移一个字符，然后匹配剩余的。 </li><li>如果字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。</li></ol><p>而当模式中的第二个字符是“*”时：</p><p>如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配。如果字符串第一个字符跟模式第一个字符匹配，可以有3种匹配方式： </p><ol><li>模式后移2字符，相当于$x*$被忽略； </li><li>字符串后移1字符，模式后移2字符； </li><li>字符串后移1字符，模式不变，即继续匹配字符下一位，因为*可以匹配多位；</li></ol><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">char</span>[] pattern)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || pattern == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> strIndex = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> patternIndex = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> matchCore(str, strIndex, pattern, patternIndex);</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matchCore</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> strIndex, <span class="keyword">char</span>[] pattern, <span class="keyword">int</span> patternIndex)</span> </span>&#123;</div><div class="line">    <span class="comment">//有效性检验：str到尾，pattern到尾，匹配成功</span></div><div class="line">    <span class="keyword">if</span> (strIndex == str.length &amp;&amp; patternIndex == pattern.length) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//pattern先到尾，匹配失败</span></div><div class="line">    <span class="keyword">if</span> (strIndex != str.length &amp;&amp; patternIndex == pattern.length) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//模式第2个是*，且字符串第1个跟模式第1个匹配,分3种匹配模式；如不匹配，模式后移2位</span></div><div class="line">    <span class="keyword">if</span> (patternIndex + <span class="number">1</span> &lt; pattern.length &amp;&amp; pattern[patternIndex + <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</div><div class="line">        <span class="keyword">if</span> ((strIndex != str.length &amp;&amp; pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == <span class="string">'.'</span> &amp;&amp; strIndex != str.length)) &#123;</div><div class="line">            <span class="keyword">return</span> matchCore(str, strIndex, pattern, patternIndex + <span class="number">2</span>)<span class="comment">//模式后移2，视为x*匹配0个字符</span></div><div class="line">                    || matchCore(str, strIndex + <span class="number">1</span>, pattern, patternIndex + <span class="number">2</span>)<span class="comment">//视为模式匹配1个字符</span></div><div class="line">                    || matchCore(str, strIndex + <span class="number">1</span>, pattern, patternIndex);<span class="comment">//*匹配1个，再匹配str中的下一个</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> matchCore(str, strIndex, pattern, patternIndex + <span class="number">2</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//模式第2个不是*，且字符串第1个跟模式第1个匹配，则都后移1位，否则直接返回false</span></div><div class="line">    <span class="keyword">if</span> ((strIndex != str.length &amp;&amp; pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == <span class="string">'.'</span> &amp;&amp; strIndex != str.length)) &#123;</div><div class="line">        <span class="keyword">return</span> matchCore(str, strIndex + <span class="number">1</span>, pattern, patternIndex + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="54-表示数值的字符串（字符串）"><a href="#54-表示数值的字符串（字符串）" class="headerlink" title="54. 表示数值的字符串（字符串）"></a>54. 表示数值的字符串（字符串）</h2><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(s.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">if</span>((s.length==<span class="number">1</span>)&amp;&amp;(s[<span class="number">0</span>]&lt;<span class="string">'0'</span>||s[<span class="number">0</span>]&gt;<span class="string">'9'</span>)) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'+'</span>||s[<span class="number">0</span>]==<span class="string">'-'</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(s.length==<span class="number">2</span>&amp;&amp;(s[<span class="number">1</span>]==<span class="string">'.'</span>)) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>((s[<span class="number">0</span>]&lt;<span class="string">'0'</span>||s[<span class="number">0</span>]&gt;<span class="string">'9'</span>)&amp;&amp;s[<span class="number">0</span>]!=<span class="string">'.'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//首位既不是符号也不是数字还不是小数点，当然是false</span></div><div class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>((i&lt;s.length)&amp;&amp;(s[i]&gt;=<span class="string">'0'</span>&amp;&amp;s[i]&lt;=<span class="string">'9'</span>)) i++;</div><div class="line">        <span class="keyword">if</span>(i&lt;s.length&amp;&amp;s[i]==<span class="string">'.'</span>)&#123;</div><div class="line">            i++;</div><div class="line">            <span class="comment">//if(i&gt;=s.length) return false;</span></div><div class="line">            <span class="keyword">while</span>((i&lt;s.length)&amp;&amp;(s[i]&gt;=<span class="string">'0'</span>&amp;&amp;s[i]&lt;=<span class="string">'9'</span>)) i++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(i&lt;s.length&amp;&amp;(s[i]==<span class="string">'e'</span>||s[i]==<span class="string">'E'</span>))&#123;</div><div class="line">            i++;</div><div class="line">            <span class="keyword">if</span>((i&lt;s.length)&amp;&amp;(s[i]==<span class="string">'+'</span>||s[i]==<span class="string">'-'</span>))&#123;</div><div class="line">                i++;</div><div class="line">                <span class="keyword">if</span>(i&lt;s.length) <span class="keyword">while</span>((i&lt;s.length)&amp;&amp;(s[i]&gt;=<span class="string">'0'</span>&amp;&amp;s[i]&lt;=<span class="string">'9'</span>)) i++;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i&lt;s.length)&#123;</div><div class="line">                <span class="keyword">while</span>((i&lt;s.length)&amp;&amp;(s[i]&gt;=<span class="string">'0'</span>&amp;&amp;s[i]&lt;=<span class="string">'9'</span>)) i++;</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(i&lt;s.length) <span class="keyword">return</span> <span class="keyword">false</span>;            </div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="55-字符流中第一个不重复的数组（字符串）"><a href="#55-字符流中第一个不重复的数组（字符串）" class="headerlink" title="55. 字符流中第一个不重复的数组（字符串）"></a>55. 字符流中第一个不重复的数组（字符串）</h2><p>使用一个HashMap来统计字符出现的次数，同时用一个ArrayList来记录输入流，每次返回第一个出现一次的字符都是在这个ArrayList（输入流）中的字符作为key去map中查找。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">//HashMap来统计字符出现的次数</span></div><div class="line">    HashMap&lt;Character, Integer&gt; map=<span class="keyword">new</span> HashMap();</div><div class="line">    <span class="comment">//ArrayList来记录输入流</span></div><div class="line">    ArrayList&lt;Character&gt; list=<span class="keyword">new</span> ArrayList&lt;Character&gt;();</div><div class="line">    <span class="comment">//Insert one char from stringstream</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(map.containsKey(ch))&#123;</div><div class="line">            <span class="keyword">int</span> time = map.get(ch);</div><div class="line">            time++;</div><div class="line">            map.put(ch,time);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            map.put(ch,<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">         </div><div class="line">        list.add(ch);</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="comment">//return the first appearence once char in current stringstream</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></div><div class="line">    &#123;   <span class="keyword">char</span> ch=<span class="string">'#'</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> k : list)&#123;<span class="comment">//list迭代</span></div><div class="line">            <span class="keyword">if</span>(map.get(k)==<span class="number">1</span>)&#123;</div><div class="line">                ch=k;</div><div class="line">                <span class="keyword">break</span>;<span class="comment">//得到第一个结果即可break</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> ch;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="56-链表中环的入口结点（链表）"><a href="#56-链表中环的入口结点（链表）" class="headerlink" title="56. 链表中环的入口结点（链表）"></a>56. 链表中环的入口结点（链表）</h2><p>一个链表中包含环，如何找到环的入口结点？例如在下图的链表中，环的入口结点是结点3。<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-25 下午3.41.20.png" alt="屏幕快照 2017-07-25 下午3.41.20"></p><p>以3为例分析两个指针的移动规律。指针$P_1$和$P_2$在初始化时都指向链表的头结点。由于环中有4个结点，指针$P_1$先在链表上向前移动4步。接下来两个指针以相同的速度在链表上向前移动，直到它们相遇。它们相遇的结点正好是还的入口结点。<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-25 下午3.46.08.png" alt="屏幕快照 2017-07-25 下午3.46.08"></p><p>剩下的问题就是如何得到环中结点的数目。我们可以使用一快一慢两个指针。若两个指针相遇，说明链表中有环。两个指针相遇的结点一定是在环中的。可以从这个结点出发，一边继续向前移动一边计数，当再次回到这个结点时，就可以得到环中结点数了<br>实现代码如下：</p><blockquote><p>java版本</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> public class ListNode &#123;</div><div class="line">    int val;</div><div class="line">    ListNode next = null;</div><div class="line"></div><div class="line">    ListNode(int val) &#123;</div><div class="line">        this.val = val;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line"><span class="comment">//找到一快一满指针相遇处的节点，相遇的节点一定是在环中</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">meetingNode</span><span class="params">(ListNode pHead)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(pHead == <span class="keyword">null</span>)&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;<span class="comment">//空链表处理</span></div><div class="line">        ListNode pslow = pHead.next;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span>(pslow == <span class="keyword">null</span>)&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;<span class="comment">//无环链表处理</span></div><div class="line">        </div><div class="line">        ListNode pfast = pslow.next;</div><div class="line">        <span class="keyword">while</span>(pfast!=<span class="keyword">null</span> &amp;&amp; pslow!=<span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(pslow==pfast)&#123;<span class="keyword">return</span> pfast;&#125;</div><div class="line">            </div><div class="line">            pslow = pslow.next;<span class="comment">//慢指针</span></div><div class="line">            </div><div class="line">            pfast = pfast.next;</div><div class="line">            <span class="keyword">if</span>(pfast!=<span class="keyword">null</span>)&#123;</div><div class="line">                pfast = pfast.next;</div><div class="line">            &#125;<span class="comment">//块指针</span></div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span></span>&#123;</div><div class="line">        ListNode meetingNode=meetingNode(pHead);<span class="comment">//相遇结点</span></div><div class="line">        <span class="comment">//环的结点个数</span></div><div class="line">        <span class="keyword">if</span>(meetingNode==<span class="keyword">null</span>)&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;<span class="comment">//是否有环</span></div><div class="line">        <span class="keyword">int</span> nodesInLoop = <span class="number">1</span>;        </div><div class="line">        ListNode p1=meetingNode;</div><div class="line">        <span class="keyword">while</span>(pnext!=meetingNode)&#123;</div><div class="line">            p1=pnext;</div><div class="line">            ++nodesInLoop;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//p1慢指针,先往前走</span></div><div class="line">        p1=pHead;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nodesInLoop;i++)&#123;</div><div class="line">            p1=pnext;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//p1,p2同步走，相遇的地方即为环入口</span></div><div class="line">        ListNode p2=pHead;</div><div class="line">        <span class="keyword">while</span>(p1!=p2)&#123;</div><div class="line">            p1=pnext;</div><div class="line">            p2=p2.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> p1;</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>python 版本</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line"># class ListNode:</div><div class="line">#     def __init__(self, x):</div><div class="line">#         self.val = x</div><div class="line">#         self.next = None</div><div class="line">class Solution:</div><div class="line">    def meetingNode(self,pHead):</div><div class="line">        if not pHead:</div><div class="line">            return None</div><div class="line">        pslow =pHead.next        </div><div class="line">        if not pslow:</div><div class="line">            return None</div><div class="line">        pfast = pslow.next</div><div class="line">        while pfast and pslow:</div><div class="line">            if pslow==pfast:</div><div class="line">                return pfast</div><div class="line">            pslow = pslow.next</div><div class="line">            </div><div class="line">            pfast = pfast.next</div><div class="line">            if pfast:</div><div class="line">                pfast=pfast.next</div><div class="line">        return None </div><div class="line">    def EntryNodeOfLoop(self, pHead):</div><div class="line">        meetingNode = self.meetingNode(pHead)</div><div class="line">        if not meetingNode:</div><div class="line">            return None</div><div class="line">        nodesInLoop = 1</div><div class="line">        p1 = meetingNode</div><div class="line">        while pnext!=meetingNode:</div><div class="line">            p1=pnext</div><div class="line">            nodesInLoop +=1</div><div class="line">        p1 = pHead</div><div class="line">        for i in xrange(0,nodesInLoop):</div><div class="line">            p1=pnext</div><div class="line">        p2=pHead</div><div class="line">        while p1!=p2:</div><div class="line">            p1=pnext</div><div class="line">            p2=p2.next</div><div class="line">        return p1</div></pre></td></tr></table></figure><h2 id="57-删除链表中重复的结点（链表）"><a href="#57-删除链表中重复的结点（链表）" class="headerlink" title="57. 删除链表中重复的结点（链表）"></a>57. 删除链表中重复的结点（链表）</h2><p>在一个排序的链表中，如何删除重复的结点？如在下图中重复结点被删除之后，链表如下图所示：<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-25 下午5.43.23.png" alt="屏幕快照 2017-07-25 下午5.43.23"></p><p>从头遍历整个链表。如果当前结点的值与下一个节点的值相同，那么它们就是重复的结点，都可以被删除。为了保证删除之后的链表仍然是相连的而没有中间断开，我们要把当前结点的前一个结点preNode和后面值比当前结点的值要大的结点相连。要确保preNode要始终与下一个没有重复的结点连接在一起。</p><p>实现代码如下：</p><blockquote><p>java递归版</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> public class ListNode &#123;</div><div class="line">    int val;</div><div class="line">    ListNode next = null;</div><div class="line"></div><div class="line">    ListNode(int val) &#123;</div><div class="line">        this.val = val;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (pHead == <span class="keyword">null</span> || pHead.next == <span class="keyword">null</span>) &#123; <span class="comment">// 只有0个或1个结点，则返回</span></div><div class="line">            <span class="keyword">return</span> pHead;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (pHead.val == pHead.next.val) &#123; <span class="comment">// 当前结点是重复结点</span></div><div class="line">            ListNode pNode = pHead.next;</div><div class="line">            <span class="keyword">while</span> (pNode != <span class="keyword">null</span> &amp;&amp; pNode.val == pHead.val) &#123;</div><div class="line">                <span class="comment">// 跳过值与当前结点相同的全部结点,找到第一个与当前结点不同的结点</span></div><div class="line">                pNode = pNode.next;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> deleteDuplication(pNode); <span class="comment">// 从第一个与当前结点不同的结点开始递归</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当前结点不是重复结点</span></div><div class="line">            pHead.next = deleteDuplication(pHead.next); <span class="comment">// 保留当前结点，从下一个结点开始递归</span></div><div class="line">            <span class="keyword">return</span> pHead;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>python版本</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class ListNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplication</span><span class="params">(self, pHead)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead <span class="keyword">or</span> <span class="keyword">not</span> pHead.next:</div><div class="line">            <span class="keyword">return</span> pHead</div><div class="line">        <span class="keyword">if</span> pHead.val==pHead.next.val:</div><div class="line">            pNode = pHead.next</div><div class="line">            <span class="keyword">while</span> pNode <span class="keyword">and</span> pNode.val == pHead.val:</div><div class="line">                 pNode = pNode.next</div><div class="line">            <span class="keyword">return</span> self.deleteDuplication(pNode)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            pHead.next = self.deleteDuplication(pHead.next)</div><div class="line">            <span class="keyword">return</span> pHead</div></pre></td></tr></table></figure><blockquote><p>java非递归</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> public class ListNode &#123;</div><div class="line">    int val;</div><div class="line">    ListNode next = null;</div><div class="line"></div><div class="line">    ListNode(int val) &#123;</div><div class="line">        this.val = val;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(pHead==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;         </div><div class="line">        ListNode preNode = <span class="keyword">null</span>;</div><div class="line">        ListNode node = pHead;</div><div class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</div><div class="line">            ListNode nextNode = node.next;</div><div class="line">            <span class="keyword">boolean</span> needDelete = <span class="keyword">false</span>;</div><div class="line">            <span class="comment">//需要删除重复节点的情况</span></div><div class="line">            <span class="keyword">if</span>(nextNode!=<span class="keyword">null</span>&amp;&amp;nextNode.val==node.val)&#123;</div><div class="line">                needDelete = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//不重复结点不删除</span></div><div class="line">            <span class="keyword">if</span>(!needDelete)&#123;</div><div class="line">                preNode = node;</div><div class="line">                node = node.next;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//重复节点删除</span></div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">int</span> value = node.val;</div><div class="line">                ListNode toBeDel = node;</div><div class="line">                <span class="comment">//连续重复结点</span></div><div class="line">                <span class="keyword">while</span>(toBeDel != <span class="keyword">null</span> &amp;&amp; toBeDel.val == value)&#123;</div><div class="line">                    nextNode = toBeDel.next;</div><div class="line">                    toBeDel = nextNode;</div><div class="line">                    <span class="keyword">if</span>(preNode==<span class="keyword">null</span>)</div><div class="line">                        pHead = nextNode;</div><div class="line">                    <span class="keyword">else</span></div><div class="line">                        preNode.next = nextNode;</div><div class="line">                    node = nextNode;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> pHead;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="58-二叉树的下一个结点（二叉树）"><a href="#58-二叉树的下一个结点（二叉树）" class="headerlink" title="58. 二叉树的下一个结点（二叉树）"></a>58. 二叉树的下一个结点（二叉树）</h2><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。<br>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。<br><img src="http://omu7tit09.bkt.clouddn.com/15017653485586.jpg" alt=""><br>我们可发现分成两大类：</p><ol><li>有右子树的，那么下个结点就是右子树最左边的点；（eg：D，B，E，A，F，C，G）</li><li>没有右子树的，也可以分成两类，a)是父节点左孩子（eg：N，I，L） ，那么父节点就是下一个节点 ； b)是父节点的右孩子（eg：H，J，K，M）找他的父节点的父节点的父节点…直到当前结点是其父节点的左孩子位置。如果没有eg：M，那么他就是尾节点。<blockquote><p>java</p></blockquote></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(pNode==<span class="keyword">null</span>)&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</div><div class="line">        <span class="keyword">if</span>(pNode.right!=<span class="keyword">null</span>)&#123;</div><div class="line">            pNode = pNode.right;</div><div class="line">            <span class="keyword">while</span>(pNode.left!=<span class="keyword">null</span>)&#123;</div><div class="line">                pNode = pNode.left;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> pNode;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(pNode.next!=<span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(pNode.next.left==pNode)<span class="keyword">return</span> pNode.next;</div><div class="line">            pNode = pNode.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;             </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="59-对称的二叉树（二叉树）"><a href="#59-对称的二叉树（二叉树）" class="headerlink" title="59. 对称的二叉树（二叉树）"></a>59. 对称的二叉树（二叉树）</h2><p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p><p>如果先序遍历的顺序分为两种先左后右和先右后左两种顺序遍历，如果两者相等说明二叉树是对称的二叉树</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> isSymmetrical(pRoot,pRoot);        </div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot1,TreeNode pRoot2)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(pRoot1==<span class="keyword">null</span>&amp;&amp;pRoot2==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span>(pRoot1==<span class="keyword">null</span>||pRoot2==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">if</span>(pRoot1.val==pRoot2.val)&#123;<span class="keyword">return</span></div><div class="line">            isSymmetrical(pRoot1.left,pRoot2.right)&amp;&amp;isSymmetrical(pRoot1.right,pRoot2.left);</div><div class="line">        &#125;<span class="keyword">else</span> </div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="60-把二叉树打印成多行（二叉树）"><a href="#60-把二叉树打印成多行（二叉树）" class="headerlink" title="60. 把二叉树打印成多行（二叉树）"></a>60. 把二叉树打印成多行（二叉树）</h2><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。<br>用end记录每层结点数目，start记录每层已经打印的数目，当start=end，重新建立list，开始下一层打印。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</div><div class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</div><div class="line">        <span class="keyword">if</span>(pRoot==<span class="keyword">null</span>)&#123;<span class="keyword">return</span> result;&#125;</div><div class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</div><div class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        queue.add(pRoot);</div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>,end = <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">            TreeNode treenode = queue.remove();</div><div class="line">            list.add(treenode.val);</div><div class="line">            start++;</div><div class="line">            <span class="keyword">if</span>(treenode.left!=<span class="keyword">null</span>)&#123;queue.add(treenode.left);&#125;</div><div class="line">            <span class="keyword">if</span>(treenode.right!=<span class="keyword">null</span>)&#123;queue.add(treenode.right);&#125; </div><div class="line">            <span class="keyword">if</span>(start==end)&#123;</div><div class="line">                end = queue.size();</div><div class="line">                start = <span class="number">0</span>;</div><div class="line">                result.add(list);</div><div class="line">                list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="61-按S型打印二叉树（二叉树）"><a href="#61-按S型打印二叉树（二叉树）" class="headerlink" title="61. 按S型打印二叉树（二叉树）"></a>61. 按S型打印二叉树（二叉树）</h2><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-03 上午9.29.00.png" alt="屏幕快照 2017-08-03 上午9.29.00"></p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.Stack;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</div><div class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; alist =<span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</div><div class="line">        <span class="keyword">if</span>(pRoot==<span class="keyword">null</span>)<span class="keyword">return</span> alist;</div><div class="line">        Stack&lt;TreeNode&gt; stack1 = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</div><div class="line">        stack1.add(pRoot);</div><div class="line">        Stack&lt;TreeNode&gt; stack2 = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</div><div class="line">        </div><div class="line">        <span class="keyword">while</span>(!stack1.isEmpty()||!stack2.isEmpty())&#123;</div><div class="line">            <span class="keyword">if</span>(!stack1.isEmpty())&#123;</div><div class="line">                ArrayList&lt;Integer&gt; alist2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();           </div><div class="line">                <span class="keyword">while</span>(!stack1.isEmpty())&#123;</div><div class="line">                    TreeNode treenode=stack1.pop();</div><div class="line">                    alist2.add(treenode.val);</div><div class="line">                    <span class="keyword">if</span>(treenode.left!=<span class="keyword">null</span>)&#123;</div><div class="line">                        stack2.add(treenode.left);</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span>(treenode.right!=<span class="keyword">null</span>)&#123;</div><div class="line">                        stack2.add(treenode.right);</div><div class="line">                    &#125;                </div><div class="line">                &#125;</div><div class="line">                alist.add(alist2);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                ArrayList&lt;Integer&gt; alist2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">                <span class="keyword">while</span>(!stack2.isEmpty())&#123;</div><div class="line">                    TreeNode treenode = stack2.pop();</div><div class="line">                    alist2.add(treenode.val);</div><div class="line">                    <span class="keyword">if</span>(treenode.right!=<span class="keyword">null</span>)&#123;</div><div class="line">                        stack1.add(treenode.right);                        </div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span>(treenode.left!=<span class="keyword">null</span>)&#123;</div><div class="line">                        stack1.add(treenode.left);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                alist.add(alist2);</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> alist;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="62-序列化与反序列化二叉树（二叉树）"><a href="#62-序列化与反序列化二叉树（二叉树）" class="headerlink" title="62. 序列化与反序列化二叉树（二叉树）"></a>62. 序列化与反序列化二叉树（二叉树）</h2><p>请实现两个函数，分别用来序列化和反序列化二叉树<br>算法思想：根据前序遍历规则完成序列化与反序列化。所谓序列化指的是遍历二叉树为字符串；所谓反序列化指的是依据字符串重新构造成二叉树。</p><p>依据前序遍历序列来序列化二叉树，因为前序遍历序列是从根结点开始的。当在遍历二叉树时碰到Null指针时，这些Null指针被序列化为一个特殊的字符“#”。另外，结点之间的数值用逗号隔开。</p><p><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-03 上午9.39.38.png" alt="屏幕快照 2017-08-03 上午9.39.38"></p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> index = -<span class="number">1</span>;   <span class="comment">//计数变量</span></div><div class="line">  </div><div class="line">    <span class="function">String <span class="title">Serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();<span class="comment">//新建字符串</span></div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            sb.append(<span class="string">"#,"</span>);</div><div class="line">            <span class="keyword">return</span> sb.toString();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//递归</span></div><div class="line">        sb.append(root.val + <span class="string">","</span>);</div><div class="line">        sb.append(Serialize(root.left));</div><div class="line">        sb.append(Serialize(root.right));</div><div class="line">        <span class="keyword">return</span> sb.toString();</div><div class="line">  &#125;</div><div class="line">    <span class="function">TreeNode <span class="title">Deserialize</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">        index++;</div><div class="line">        <span class="comment">//int len = str.length();</span></div><div class="line">        <span class="comment">//if(index &gt;= len)&#123;</span></div><div class="line">        <span class="comment">//    return null;</span></div><div class="line">       <span class="comment">// &#125;</span></div><div class="line">        String[] strr = str.split(<span class="string">","</span>);</div><div class="line">        TreeNode node = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span>(!strr[index].equals(<span class="string">"#"</span>))&#123;</div><div class="line">            node = <span class="keyword">new</span> TreeNode(Integer.valueOf(strr[index]));</div><div class="line">            node.left = Deserialize(str);</div><div class="line">            node.right = Deserialize(str);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> node;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="63-二叉搜索树的第K个结点（二叉树）"><a href="#63-二叉搜索树的第K个结点（二叉树）" class="headerlink" title="63. 二叉搜索树的第K个结点（二叉树）"></a>63. 二叉搜索树的第K个结点（二叉树）</h2><p>给定一颗二叉搜索树，请找出其中的第k大的结点。例如在下图二叉搜索树里，按结点数值大小顺序第三个结点的值是4.<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-03 上午9.44.34.png" alt="屏幕快照 2017-08-03 上午9.44.34"><br>如果按照中序遍历的顺序遍历一颗二叉搜索树，遍历序列的数值是递增排序的，只需要用中序遍历算法遍历一颗二叉搜索树，就很容易找出它的第K大的结点。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> index = <span class="number">0</span>; <span class="comment">//计数器</span></div><div class="line">    <span class="function">TreeNode <span class="title">KthNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123; <span class="comment">//中序遍历寻找第k个</span></div><div class="line">            TreeNode node = KthNode(root.left,k);</div><div class="line">            <span class="keyword">if</span>(node != <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">return</span> node;</div><div class="line">            index ++;</div><div class="line">            <span class="keyword">if</span>(index == k)</div><div class="line">                <span class="keyword">return</span> root;</div><div class="line">            node = KthNode(root.right,k);</div><div class="line">            <span class="keyword">if</span>(node != <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">return</span> node;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="64-数据流中的中位数（二叉树）"><a href="#64-数据流中的中位数（二叉树）" class="headerlink" title="64. 数据流中的中位数（二叉树）"></a>64. 数据流中的中位数（二叉树）</h2><p>Java的PriorityQueue是从JDK1.5开始提供的新的数据结构接口，默认内部是自然排序，结果为小顶堆，也可以自定义排序器，比如下面反转比较，完成大顶堆。</p><p>为了保证插入新数据和取中位数的时间效率都高效，这里使用大顶堆+小顶堆的容器，并且满足：</p><ol><li>两个堆中的数据数目差不能超过1，这样可以使中位数只会出现在两个堆的交接处；</li><li>大顶堆的所有数据都小于小顶堆，这样就满足了排序要求。</li></ol><p><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-03 上午10.55.51.png" alt="屏幕快照 2017-08-03 上午10.55.51"></p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"><span class="keyword">import</span> java.util.PriorityQueue;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</div><div class="line">    PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</div><div class="line">    PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(<span class="number">11</span>, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</div><div class="line">            <span class="comment">//PriorityQueue默认是小顶堆，实现大顶堆，需要反转默认排序器</span></div><div class="line">            <span class="keyword">return</span> o2.compareTo(o1); </div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (count %<span class="number">2</span> == <span class="number">0</span>) &#123;<span class="comment">//当数据总数为偶数时，新加入的元素，应当进入小根堆</span></div><div class="line">        <span class="comment">//（注意不是直接进入小根堆，而是经大根堆筛选后取大根堆中最大元素进入小根堆）</span></div><div class="line">        <span class="comment">//1.新加入的元素先入到大根堆，由大根堆筛选出堆中最大的元素</span></div><div class="line">        maxHeap.offer(num);</div><div class="line">        <span class="keyword">int</span> filteredMaxNum = maxHeap.poll();</div><div class="line">        <span class="comment">//2.筛选后的【大根堆中的最大元素】进入小根堆</span></div><div class="line">        minHeap.offer(filteredMaxNum);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//当数据总数为奇数时，新加入的元素，应当进入大根堆</span></div><div class="line">        <span class="comment">//（注意不是直接进入大根堆，而是经小根堆筛选后取小根堆中最大元素进入大根堆）</span></div><div class="line">        <span class="comment">//1.新加入的元素先入到小根堆，由小根堆筛选出堆中最小的元素</span></div><div class="line">        minHeap.offer(num);</div><div class="line">        <span class="keyword">int</span> filteredMinNum = minHeap.poll();</div><div class="line">        <span class="comment">//2.筛选后的【小根堆中的最小元素】进入大根堆</span></div><div class="line">        maxHeap.offer(filteredMinNum);</div><div class="line">    &#125;</div><div class="line">    count++;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (count %<span class="number">2</span> == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Double((minHeap.peek() + maxHeap.peek())) / <span class="number">2</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Double(minHeap.peek());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="65-滑动窗口的最大值（数组）"><a href="#65-滑动窗口的最大值（数组）" class="headerlink" title="65. 滑动窗口的最大值（数组）"></a>65. 滑动窗口的最大值（数组）</h2><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p><p><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-03 下午1.37.31.png" alt="屏幕快照 2017-08-03 下午1.37.31"></p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.LinkedList;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)</span></span></div><div class="line">    &#123;</div><div class="line">        ArrayList&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">if</span> (num == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> ret;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (num.length &lt; size || size &lt; <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> ret;</div><div class="line">        &#125;</div><div class="line">         </div><div class="line">        LinkedList&lt;Integer&gt; indexDeque = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="comment">//前size-1个中，前面比num[i]小的，对应下标从下标队列移除；</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (!indexDeque.isEmpty() &amp;&amp; num[i] &gt; num[indexDeque.getLast()]) &#123;</div><div class="line">                indexDeque.removeLast();</div><div class="line">            &#125;</div><div class="line">            indexDeque.addLast(i);</div><div class="line">        &#125;        </div><div class="line">        <span class="comment">//从第size-1个开始；前面比num[i]小的，对应下标从下标队列移除；</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &lt; num.length; i++) &#123;</div><div class="line">            <span class="keyword">while</span>(!indexDeque.isEmpty() &amp;&amp; num[i] &gt; num[indexDeque.getLast()]) &#123;</div><div class="line">                indexDeque.removeLast();</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//把下一个下标加入队列中</span></div><div class="line">            indexDeque.addLast(i);</div><div class="line">            <span class="comment">//当第一个数字的下标与当前处理的数字的下标之差大于或者等于滑动窗口的大小时，这个数字已经从窗口划出，可以移除了；</span></div><div class="line">            <span class="keyword">if</span> (i - indexDeque.getFirst() + <span class="number">1</span> &gt; size) &#123;</div><div class="line">                indexDeque.removeFirst();</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//下标队列的第一个是滑动窗口最大值对应的下标；</span></div><div class="line">            ret.add(num[indexDeque.getFirst()]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ret;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="66-矩阵中的路径（数组）"><a href="#66-矩阵中的路径（数组）" class="headerlink" title="66. 矩阵中的路径（数组）"></a>66. 矩阵中的路径（数组）</h2><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如下面的矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-03 下午1.43.55.png" alt="屏幕快照 2017-08-03 下午1.43.55"></p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">boolean</span>[] visited=<span class="keyword">new</span> <span class="keyword">boolean</span>[rows*cols];</div><div class="line">        <span class="keyword">return</span> movingCountCore(threshold, rows, cols, <span class="number">0</span>,<span class="number">0</span>,visited);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">movingCountCore</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols,</span></span></div><div class="line">            <span class="keyword">int</span> row,<span class="keyword">int</span> col,<span class="keyword">boolean</span>[] visited) &#123;</div><div class="line">        <span class="keyword">if</span>(row&lt;<span class="number">0</span>||row&gt;=rows||col&lt;<span class="number">0</span>||col&gt;=cols) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> i=row*cols+col;</div><div class="line">        <span class="keyword">if</span>(visited[i]||!checkSum(threshold,row,col)) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        visited[i]=<span class="keyword">true</span>;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>+movingCountCore(threshold, rows, cols,row,col+<span class="number">1</span>,visited)</div><div class="line">                +movingCountCore(threshold, rows, cols,row,col-<span class="number">1</span>,visited)</div><div class="line">                +movingCountCore(threshold, rows, cols,row+<span class="number">1</span>,col,visited)</div><div class="line">                +movingCountCore(threshold, rows, cols,row-<span class="number">1</span>,col,visited);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkSum</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(row!=<span class="number">0</span>)&#123;</div><div class="line">            sum+=row%<span class="number">10</span>;</div><div class="line">            row=row/<span class="number">10</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(col!=<span class="number">0</span>)&#123;</div><div class="line">            sum+=col%<span class="number">10</span>;</div><div class="line">            col=col/<span class="number">10</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(sum&gt;threshold) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer编程题java实现整理。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法题解（4）：二叉树题解</title>
    <link href="http://yoursite.com/2017/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%EF%BC%884%EF%BC%89%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/08/04/数据结构与算法题解（4）：二叉树题解/</id>
    <published>2017-08-04T15:20:45.000Z</published>
    <updated>2017-09-01T07:02:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>二叉树相关题解java实现。</p><a id="more"></a><h2 id="一、重建二叉树（剑6）"><a href="#一、重建二叉树（剑6）" class="headerlink" title="一、重建二叉树（剑6）"></a>一、重建二叉树（剑6）</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p>例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><p><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-28 上午10.49.39.png" alt="屏幕快照 2017-07-28 上午10.49.39"></p><ol><li>根据前序遍历的特点，我们知道根结点为1</li><li>观察中序遍历。其中root节点G左侧的472必然是root的左子树，G右侧的5386必然是root的右子树。</li><li>观察左子树472，左子树的中的根节点必然是大树的root的leftchild。在前序遍历中，大树的root的leftchild位于root之后，所以左子树的根节点为2。</li><li>同样的道理，root的右子树节点5386中的根节点也可以通过前序遍历求得。在前序遍历中，一定是先把root和root的所有左子树节点遍历完之后才会遍历右子树，并且遍历的左子树的第一个节点就是左子树的根节点。同理，遍历的右子树的第一个节点就是右子树的根节点。</li><li>观察发现，上面的过程是递归的。先找到当前树的根节点，然后划分为左子树，右子树，然后进入左子树重复上面的过程，然后进入右子树重复上面的过程。最后就可以还原一棵树了。</li></ol><p>该步递归的过程可以简洁表达如下：</p><ol><li>确定根,确定左子树，确定右子树。</li><li>在左子树中递归。</li><li>在右子树中递归。</li><li>打印当前根。</li></ol><p><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-28 上午10.51.43.png" alt="屏幕快照 2017-07-28 上午10.51.43"></p><p>递归代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; </div><div class="line">        return reConBTree(pre,0,pre.length-1,in,0,in.length-1);</div><div class="line">    &#125;</div><div class="line">    public TreeNode reConBTree(int [] pre,int preleft,int preright,int [] in,int inleft,int inright)&#123;</div><div class="line">        if(preleft &gt; preright || inleft&gt; inright)//当到达边界条件时候返回null</div><div class="line">            return null;</div><div class="line">        //新建一个TreeNode</div><div class="line">        TreeNode root = new TreeNode(pre[preleft]);</div><div class="line">        //对中序数组进行输入边界的遍历</div><div class="line">        for(int i = inleft; i&lt;= inright; i++)&#123;</div><div class="line">            if(pre[preleft] == in[i])&#123;</div><div class="line">                //重构左子树，注意边界条件</div><div class="line">                root.left = reConBTree(pre,preleft+1,preleft+i-inleft,in,inleft,i-1);</div><div class="line">                //重构右子树，注意边界条件</div><div class="line">                root.right = reConBTree(pre,preleft+i+1-inleft,preright,in,i+1,inright);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return root;      </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">``` </div><div class="line"></div><div class="line"></div><div class="line">## 二、树的子结构（剑18）</div><div class="line">输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</div><div class="line"></div><div class="line">要查找树A中是否存在和树B结构一样的子树，我们可以分成两步：第一步在树A中找到和B的根结点的值一样的结点R，第二步再判断树A以R为根结点的子树是不是包含和树B一样的结构。</div><div class="line"></div><div class="line">第一步在树A中查找与根结点的值一样的结点，实际上就是树的遍历。对二叉树这种数据结构熟悉的读者自然知道可以用递归的方法去遍历，也可以用循环的方法去遍历。由于递归的代码实现比较简洁，面试时如果没有特别要求，通常会采用递归的方式。参考代码如下：</div><div class="line">&gt;java第一步</div><div class="line"></div><div class="line">```java</div><div class="line">public boolean HasSubtree(TreeNode root1,TreeNode root2) &#123;</div><div class="line">        boolean result = false;</div><div class="line">        //一定要注意边界条件的检查，即检查空指针。否则程序容易奔溃，面试时尤其要注意。这里当Tree1和Tree2都不为零的时候，才进行比较。否则直接返回false</div><div class="line">        if(root1!=null&amp;&amp;root2!=null)&#123;</div><div class="line">        ////如果找到了对应Tree2的根节点的点</div><div class="line">            if(root1.val==root2.val)&#123;</div><div class="line">            //以这个根节点为为起点判断是否包含Tree2</div><div class="line">                result = DoesTree1HaveTree2(root1,root2);</div><div class="line">            &#125;</div><div class="line">            //如果找不到，那么就再去root的左儿子当作起点，去判断是否包含Tree2</div><div class="line">            if(!result)&#123;</div><div class="line">                result=HasSubtree(root1.left,root2);</div><div class="line">            &#125;</div><div class="line">            //如果还找不到，那么就再去root的右儿子当作起点，去判断是否包含Tree2</div><div class="line">            if(!result)&#123;</div><div class="line">                result=HasSubtree(root1.right,root2);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">        </div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>第二步是判断树A中以R为根结点的子树是不是和树B具有相同的结构。同样，我们也可以用递归的思路来考虑：如果结点R的值和树B的根结点不同，则以R为根结点的子树和树B一定不具有相同的结点；如果他们的值相同，则递归地判断它们各自的左右结点的值是不是相同。递归的终止条件是我们达到了树A或者树B的叶结点。</p><p>代码如下：</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">DoesTree1HaveTree2</span><span class="params">(TreeNode root1,TreeNode root2)</span></span>&#123;</div><div class="line">       <span class="comment">//如果Tree2已经遍历完了都能对应的上，返回true</span></div><div class="line">        <span class="keyword">if</span>(root2==<span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果Tree2还没有遍历完，Tree1却遍历完了。返回false</span></div><div class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">         <span class="comment">//如果其中有一个点没有对应上，返回false</span></div><div class="line">        <span class="keyword">if</span>(root1.val!=root2.val)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果根节点对应的上，那么就分别去左右子节点里面匹配</span></div><div class="line">        <span class="keyword">return</span> DoesTree1HaveTree2(root1.left,root2.left)&amp;&amp;DoesTree1HaveTree2(root1.right,root2.right);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-01 下午2.54.39.png" alt="屏幕快照 2017-08-01 下午2.54.39"></p><p>二叉树相关的代码有大量的指针操作，每一次使用指针的时候，我们都要问自己这个指针有没有可能是NULL，如果是NULL该怎么处理。</p><h2 id="三、二叉树的镜像（剑19）"><a href="#三、二叉树的镜像（剑19）" class="headerlink" title="三、二叉树的镜像（剑19）"></a>三、二叉树的镜像（剑19）</h2><p>操作给定的二叉树，将其变换为源二叉树的镜像。<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-01 下午3.06.35.png" alt="屏幕快照 2017-08-01 下午3.06.35"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="comment">//边界</span></div><div class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="comment">//交换左右子树</span></div><div class="line">        TreeNode temp = root.left;</div><div class="line">        root.left=root.right;</div><div class="line">        root.right=temp;</div><div class="line">        <span class="comment">//递归</span></div><div class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)&#123;</div><div class="line">            Mirror(root.left);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)&#123;</div><div class="line">            Mirror(root.right);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="四、从上往下打印二叉树（剑23）"><a href="#四、从上往下打印二叉树（剑23）" class="headerlink" title="四、从上往下打印二叉树（剑23）"></a>四、从上往下打印二叉树（剑23）</h2><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-02 上午12.17.30.png" alt="屏幕快照 2017-08-02 上午12.17.30"></p><p>每次打印一个结点时，如果该结点有子结点，则把该结点的子结点放到队列的末尾。接下来到队列的头部取出最早进入队列的结点，重复前面的打印操作。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.LinkedList;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        ArrayList&lt;Integer&gt; List=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;<span class="keyword">return</span> List;&#125;</div><div class="line">        </div><div class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</div><div class="line">        queue.add(root);<span class="comment">//先把根结点加入队列q</span></div><div class="line">        </div><div class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;<span class="comment">//队列非空时</span></div><div class="line">            TreeNode treenode=queue.remove();<span class="comment">//取出队列头结点</span></div><div class="line">            <span class="keyword">if</span>(treenode.left!=<span class="keyword">null</span>)&#123;queue.add(treenode.left);&#125;<span class="comment">//向队列加入左孩子（若有）</span></div><div class="line">            <span class="keyword">if</span>(treenode.right!=<span class="keyword">null</span>)&#123;queue.add(treenode.right);&#125;<span class="comment">//向队列加入右孩子（若有）</span></div><div class="line">            List.add(treenode.val);<span class="comment">//加到打印列表中</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> List;        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="五、二叉搜索树的后序遍历序列（剑24）"><a href="#五、二叉搜索树的后序遍历序列（剑24）" class="headerlink" title="五、二叉搜索树的后序遍历序列（剑24）"></a>五、二叉搜索树的后序遍历序列（剑24）</h2><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-02 上午9.50.37.png" alt="屏幕快照 2017-08-02 上午9.50.37"><br>在后序遍历得到的序列中，最后一个数字是树的根结点的值。数组中前面的数字可以分成两部分：第一部分是左子树结点的值，它们都比根结点小；第二部分是右子树结点的值，它们都比根结点大。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> length = sequence.length;</div><div class="line">        <span class="keyword">if</span>(sequence==<span class="keyword">null</span>||length==<span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;</div><div class="line">        <span class="keyword">int</span> root = sequence[length-<span class="number">1</span>];<span class="comment">//根结点</span></div><div class="line">        <span class="keyword">int</span> i=<span class="number">0</span>; <span class="comment">//外部初始化     </span></div><div class="line">        <span class="comment">//找到左子树的最后一个结点位置</span></div><div class="line">        <span class="keyword">for</span>(;i&lt;length-<span class="number">1</span>;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(sequence[i]&gt;root)&#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;    </div><div class="line">        <span class="comment">//如果右子树的结点值小于根结点的值，则返回false</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;length-<span class="number">1</span>;j++)&#123;</div><div class="line">            <span class="keyword">if</span>(sequence[j]&lt;root)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;    </div><div class="line">        <span class="comment">//初始化</span></div><div class="line">        <span class="keyword">boolean</span> left=<span class="keyword">true</span>;</div><div class="line">        <span class="keyword">boolean</span> right=<span class="keyword">true</span>;</div><div class="line">        <span class="comment">//递归左右子树</span></div><div class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</div><div class="line">            left = VerifySquenceOfBST(Arrays.copyOfRange(sequence,<span class="number">0</span>,i));<span class="comment">//Arrays的copyOfRange方法</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(i&lt;length-<span class="number">1</span>)&#123;</div><div class="line">            right = VerifySquenceOfBST(Arrays.copyOfRange(sequence,i,length-<span class="number">1</span>));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> left&amp;&amp;right;                </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="六、二叉树中和为某一值的路径（剑25）"><a href="#六、二叉树中和为某一值的路径（剑25）" class="headerlink" title="六、二叉树中和为某一值的路径（剑25）"></a>六、二叉树中和为某一值的路径（剑25）</h2><p>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</div><div class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> listAll;</div><div class="line">        list.add(root.val);</div><div class="line">        target -= root.val;<span class="comment">//每次减去结点的值</span></div><div class="line">        <span class="comment">//如果target等于0，则说明这条路径和为target，添加到listAll中</span></div><div class="line">        <span class="keyword">if</span>(target == <span class="number">0</span> &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</div><div class="line">            listAll.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(list));<span class="comment">//因为add添加的是引用，如果不new一个的话，后面的操作会更改listAll中list的值</span></div><div class="line">        <span class="comment">//向左孩子递归</span></div><div class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)FindPath(root.left, target);</div><div class="line">        <span class="comment">//向右孩子递归</span></div><div class="line">        <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)FindPath(root.right, target);</div><div class="line">        <span class="comment">//如果不满足条件，则回到父节点；</span></div><div class="line">        list.remove(list.size()-<span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> listAll;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="七、二叉搜索树与双向链表（剑27）"><a href="#七、二叉搜索树与双向链表（剑27）" class="headerlink" title="七、二叉搜索树与双向链表（剑27）"></a>七、二叉搜索树与双向链表（剑27）</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    TreeNode head = <span class="keyword">null</span>;</div><div class="line">    TreeNode realHead = <span class="keyword">null</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</div><div class="line">        ConvertSub(pRootOfTree);</div><div class="line">        <span class="keyword">return</span> realHead<span class="comment">//realHead是每个子树排序后的第一个结点，head是排序后的最后一个结点;</span></div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ConvertSub</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</div><div class="line">        <span class="comment">//递归中序遍历</span></div><div class="line">        <span class="keyword">if</span>(pRootOfTree==<span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line">        ConvertSub(pRootOfTree.left);</div><div class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//初始处</span></div><div class="line">            head = pRootOfTree;</div><div class="line">            realHead = pRootOfTree;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//前两句实现双向，第三句跳到下一个节点。</span></div><div class="line">            head.right = pRootOfTree;</div><div class="line">            pRootOfTree.left = head;</div><div class="line">            head = pRootOfTree;</div><div class="line">        &#125;</div><div class="line">        ConvertSub(pRootOfTree.right);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="八、二叉树的深度（剑39-1）"><a href="#八、二叉树的深度（剑39-1）" class="headerlink" title="八、二叉树的深度（剑39.1）"></a>八、二叉树的深度（剑39.1）</h2><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p><p>Java 经典的求二叉树深度 递归写法</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> nleft = TreeDepth(root.left);</div><div class="line">        <span class="keyword">int</span> nright = TreeDepth(root.right);</div><div class="line">        <span class="keyword">return</span> nleft&gt;nright?(nleft+<span class="number">1</span>):(nright+<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="九、平衡二叉树（剑39-2）"><a href="#九、平衡二叉树（剑39-2）" class="headerlink" title="九、平衡二叉树（剑39.2）"></a>九、平衡二叉树（剑39.2）</h2><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p><p>有了求二叉树的深度的经验之后，我们就很容易想到一个思路：在遍历树的每个结点的时候，调用函数TreeDepth得到它的左右子树的深度。如果每个结点的左右子树的深度相差都不超过1，按照定义它就是一颗平衡的二叉树。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">int</span> left = TreeDepth(root.left);</div><div class="line">        <span class="keyword">int</span> right = TreeDepth(root.right);</div><div class="line">        <span class="keyword">int</span> diff = left-right;</div><div class="line">        <span class="keyword">if</span>(diff&gt;<span class="number">1</span>||diff&lt;-<span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">return</span> IsBalanced_Solution(root.left)&amp;&amp;IsBalanced_Solution(root.right);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> nleft = TreeDepth(root.left);</div><div class="line">        <span class="keyword">int</span> nright = TreeDepth(root.right);</div><div class="line">        <span class="keyword">return</span> nleft&gt;nright?(nleft+<span class="number">1</span>):(nright+<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="十、二叉搜索树的最低公共祖先（剑50-1）"><a href="#十、二叉搜索树的最低公共祖先（剑50-1）" class="headerlink" title="十、二叉搜索树的最低公共祖先（剑50.1）"></a>十、二叉搜索树的最低公共祖先（剑50.1）</h2><p>二叉搜索树是经过排序的，位于左子树的节点都比父节点小，位于右子树的节点都比父节点大。既然要找最低的公共祖先节点，我们可以从根节点开始进行比较。若当前节点的值比两个节点的值都大，那么最低的祖先节点一定在当前节点的左子树中，则遍历当前节点的左子节点；反之，若当前节点的值比两个节点的值都小，那么最低的祖先节点一定在当前节点的右子树中，则遍历当前节点的右子节点；这样，直到找到一个节点，位于两个节点值的中间，则找到了最低的公共祖先节点。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>||root==q||root==p)<span class="keyword">return</span> root;</div><div class="line">        <span class="keyword">if</span>(root.val&gt;p.val&amp;&amp;root.val&gt;q.val)&#123;</div><div class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left,p,q);</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val&lt;p.val&amp;&amp;root.val&lt;q.val)&#123;</div><div class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right,p,q);</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> root;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="十一、普通二叉树的最低公共祖先（剑50-2）"><a href="#十一、普通二叉树的最低公共祖先（剑50-2）" class="headerlink" title="十一、普通二叉树的最低公共祖先（剑50.2）"></a>十一、普通二叉树的最低公共祖先（剑50.2）</h2><p>一种简单的方法是DFS分别寻找到两个节点p和q的路径，然后对比路径，查看他们的第一个分岔口，则为LCA。<br>这个思路比较简单，代码写起来不如下面这种方法优雅：</p><p>我们仍然可以用递归来解决，递归寻找两个带查询LCA的节点p和q，当找到后，返回给它们的父亲。如果某个节点的左右子树分别包括这两个节点，那么这个节点必然是所求的解，返回该节点。否则，返回左或者右子树（哪个包含p或者q的就返回哪个）。复杂度O(n)</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>||root==p||root==q)&#123;<span class="keyword">return</span> root;&#125;</div><div class="line">        TreeNode left = lowestCommonAncestor(root.left,p,q);</div><div class="line">        TreeNode right = lowestCommonAncestor(root.right,p,q);</div><div class="line">        <span class="keyword">if</span>(left!=<span class="keyword">null</span>&amp;&amp;right!=<span class="keyword">null</span>)<span class="keyword">return</span> root;</div><div class="line">        <span class="keyword">return</span> left!=<span class="keyword">null</span>? left:right;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="十二、二叉树的下一个结点（剑58）"><a href="#十二、二叉树的下一个结点（剑58）" class="headerlink" title="十二、二叉树的下一个结点（剑58）"></a>十二、二叉树的下一个结点（剑58）</h2><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。<br><img src="http://omu7tit09.bkt.clouddn.com/15017653485586.jpg" alt=""><br>我们可发现分成两大类：</p><ol><li>有右子树的，那么下个结点就是右子树最左边的点；（eg：D，B，E，A，F，C，G）</li><li>没有右子树的，也可以分成两类，a)是父节点左孩子（eg：N，I，L） ，那么父节点就是下一个节点 ； b)是父节点的右孩子（eg：H，J，K，M）找他的父节点的父节点的父节点…直到当前结点是其父节点的左孩子位置。如果没有eg：M，那么他就是尾节点。<blockquote><p>java</p></blockquote></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(pNode==<span class="keyword">null</span>)&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</div><div class="line">        <span class="keyword">if</span>(pNode.right!=<span class="keyword">null</span>)&#123;</div><div class="line">            pNode = pNode.right;</div><div class="line">            <span class="keyword">while</span>(pNode.left!=<span class="keyword">null</span>)&#123;</div><div class="line">                pNode = pNode.left;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> pNode;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(pNode.next!=<span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(pNode.next.left==pNode)<span class="keyword">return</span> pNode.next;</div><div class="line">            pNode = pNode.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;             </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="十三、对称的二叉树（剑59）"><a href="#十三、对称的二叉树（剑59）" class="headerlink" title="十三、对称的二叉树（剑59）"></a>十三、对称的二叉树（剑59）</h2><p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p><p>如果先序遍历的顺序分为两种先左后右和先右后左两种顺序遍历，如果两者相等说明二叉树是对称的二叉树</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> isSymmetrical(pRoot,pRoot);        </div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot1,TreeNode pRoot2)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(pRoot1==<span class="keyword">null</span>&amp;&amp;pRoot2==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span>(pRoot1==<span class="keyword">null</span>||pRoot2==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">if</span>(pRoot1.val==pRoot2.val)&#123;<span class="keyword">return</span></div><div class="line">            isSymmetrical(pRoot1.left,pRoot2.right)&amp;&amp;isSymmetrical(pRoot1.right,pRoot2.left);</div><div class="line">        &#125;<span class="keyword">else</span> </div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="十四、把二叉树打印成多行（剑60）"><a href="#十四、把二叉树打印成多行（剑60）" class="headerlink" title="十四、把二叉树打印成多行（剑60）"></a>十四、把二叉树打印成多行（剑60）</h2><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。<br>用end记录每层结点数目，start记录每层已经打印的数目，当start=end，重新建立list，开始下一层打印。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</div><div class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</div><div class="line">        <span class="keyword">if</span>(pRoot==<span class="keyword">null</span>)&#123;<span class="keyword">return</span> result;&#125;</div><div class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</div><div class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        queue.add(pRoot);</div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>,end = <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">            TreeNode treenode = queue.remove();</div><div class="line">            list.add(treenode.val);</div><div class="line">            start++;</div><div class="line">            <span class="keyword">if</span>(treenode.left!=<span class="keyword">null</span>)&#123;queue.add(treenode.left);&#125;</div><div class="line">            <span class="keyword">if</span>(treenode.right!=<span class="keyword">null</span>)&#123;queue.add(treenode.right);&#125; </div><div class="line">            <span class="keyword">if</span>(start==end)&#123;</div><div class="line">                end = queue.size();</div><div class="line">                start = <span class="number">0</span>;</div><div class="line">                result.add(list);</div><div class="line">                list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="十五、按S型打印二叉树（剑61）"><a href="#十五、按S型打印二叉树（剑61）" class="headerlink" title="十五、按S型打印二叉树（剑61）"></a>十五、按S型打印二叉树（剑61）</h2><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-03 上午9.29.00.png" alt="屏幕快照 2017-08-03 上午9.29.00"></p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.Stack;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</div><div class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; alist =<span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</div><div class="line">        <span class="keyword">if</span>(pRoot==<span class="keyword">null</span>)<span class="keyword">return</span> alist;</div><div class="line">        Stack&lt;TreeNode&gt; stack1 = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</div><div class="line">        stack1.add(pRoot);</div><div class="line">        Stack&lt;TreeNode&gt; stack2 = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</div><div class="line">        </div><div class="line">        <span class="keyword">while</span>(!stack1.isEmpty()||!stack2.isEmpty())&#123;</div><div class="line">            <span class="keyword">if</span>(!stack1.isEmpty())&#123;</div><div class="line">                ArrayList&lt;Integer&gt; alist2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();           </div><div class="line">                <span class="keyword">while</span>(!stack1.isEmpty())&#123;</div><div class="line">                    TreeNode treenode=stack1.pop();</div><div class="line">                    alist2.add(treenode.val);</div><div class="line">                    <span class="keyword">if</span>(treenode.left!=<span class="keyword">null</span>)&#123;</div><div class="line">                        stack2.add(treenode.left);</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span>(treenode.right!=<span class="keyword">null</span>)&#123;</div><div class="line">                        stack2.add(treenode.right);</div><div class="line">                    &#125;                </div><div class="line">                &#125;</div><div class="line">                alist.add(alist2);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                ArrayList&lt;Integer&gt; alist2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">                <span class="keyword">while</span>(!stack2.isEmpty())&#123;</div><div class="line">                    TreeNode treenode = stack2.pop();</div><div class="line">                    alist2.add(treenode.val);</div><div class="line">                    <span class="keyword">if</span>(treenode.right!=<span class="keyword">null</span>)&#123;</div><div class="line">                        stack1.add(treenode.right);                        </div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span>(treenode.left!=<span class="keyword">null</span>)&#123;</div><div class="line">                        stack1.add(treenode.left);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                alist.add(alist2);</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> alist;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="十六、序列化与反序列化二叉树（剑62）"><a href="#十六、序列化与反序列化二叉树（剑62）" class="headerlink" title="十六、序列化与反序列化二叉树（剑62）"></a>十六、序列化与反序列化二叉树（剑62）</h2><p>请实现两个函数，分别用来序列化和反序列化二叉树<br>算法思想：根据前序遍历规则完成序列化与反序列化。所谓序列化指的是遍历二叉树为字符串；所谓反序列化指的是依据字符串重新构造成二叉树。</p><p>依据前序遍历序列来序列化二叉树，因为前序遍历序列是从根结点开始的。当在遍历二叉树时碰到Null指针时，这些Null指针被序列化为一个特殊的字符“#”。另外，结点之间的数值用逗号隔开。</p><p><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-03 上午9.39.38.png" alt="屏幕快照 2017-08-03 上午9.39.38"></p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> index = -<span class="number">1</span>;   <span class="comment">//计数变量</span></div><div class="line">  </div><div class="line">    <span class="function">String <span class="title">Serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();<span class="comment">//新建字符串</span></div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            sb.append(<span class="string">"#,"</span>);</div><div class="line">            <span class="keyword">return</span> sb.toString();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//递归</span></div><div class="line">        sb.append(root.val + <span class="string">","</span>);</div><div class="line">        sb.append(Serialize(root.left));</div><div class="line">        sb.append(Serialize(root.right));</div><div class="line">        <span class="keyword">return</span> sb.toString();</div><div class="line">  &#125;</div><div class="line">    <span class="function">TreeNode <span class="title">Deserialize</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">        index++;</div><div class="line">        <span class="comment">//int len = str.length();</span></div><div class="line">        <span class="comment">//if(index &gt;= len)&#123;</span></div><div class="line">        <span class="comment">//    return null;</span></div><div class="line">       <span class="comment">// &#125;</span></div><div class="line">        String[] strr = str.split(<span class="string">","</span>);</div><div class="line">        TreeNode node = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span>(!strr[index].equals(<span class="string">"#"</span>))&#123;</div><div class="line">            node = <span class="keyword">new</span> TreeNode(Integer.valueOf(strr[index]));</div><div class="line">            node.left = Deserialize(str);</div><div class="line">            node.right = Deserialize(str);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> node;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="十七、二叉搜索树的第K个结点（剑63）"><a href="#十七、二叉搜索树的第K个结点（剑63）" class="headerlink" title="十七、二叉搜索树的第K个结点（剑63）"></a>十七、二叉搜索树的第K个结点（剑63）</h2><p>给定一颗二叉搜索树，请找出其中的第k大的结点。例如在下图二叉搜索树里，按结点数值大小顺序第三个结点的值是4.<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-03 上午9.44.34.png" alt="屏幕快照 2017-08-03 上午9.44.34"><br>如果按照中序遍历的顺序遍历一颗二叉搜索树，遍历序列的数值是递增排序的，只需要用中序遍历算法遍历一颗二叉搜索树，就很容易找出它的第K大的结点。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> index = <span class="number">0</span>; <span class="comment">//计数器</span></div><div class="line">    <span class="function">TreeNode <span class="title">KthNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123; <span class="comment">//中序遍历寻找第k个</span></div><div class="line">            TreeNode node = KthNode(root.left,k);</div><div class="line">            <span class="keyword">if</span>(node != <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">return</span> node;</div><div class="line">            index ++;</div><div class="line">            <span class="keyword">if</span>(index == k)</div><div class="line">                <span class="keyword">return</span> root;</div><div class="line">            node = KthNode(root.right,k);</div><div class="line">            <span class="keyword">if</span>(node != <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">return</span> node;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="十八、数据流中的中位数（剑64）"><a href="#十八、数据流中的中位数（剑64）" class="headerlink" title="十八、数据流中的中位数（剑64）"></a>十八、数据流中的中位数（剑64）</h2><p>Java的PriorityQueue是从JDK1.5开始提供的新的数据结构接口，默认内部是自然排序，结果为小顶堆，也可以自定义排序器，比如下面反转比较，完成大顶堆。</p><p>为了保证插入新数据和取中位数的时间效率都高效，这里使用大顶堆+小顶堆的容器，并且满足：</p><ol><li>两个堆中的数据数目差不能超过1，这样可以使中位数只会出现在两个堆的交接处；</li><li>大顶堆的所有数据都小于小顶堆，这样就满足了排序要求。</li></ol><p><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-03 上午10.55.51.png" alt="屏幕快照 2017-08-03 上午10.55.51"></p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"><span class="keyword">import</span> java.util.PriorityQueue;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</div><div class="line">    PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</div><div class="line">    PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(<span class="number">11</span>, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</div><div class="line">            <span class="comment">//PriorityQueue默认是小顶堆，实现大顶堆，需要反转默认排序器</span></div><div class="line">            <span class="keyword">return</span> o2.compareTo(o1); </div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (count %<span class="number">2</span> == <span class="number">0</span>) &#123;<span class="comment">//当数据总数为偶数时，新加入的元素，应当进入小根堆</span></div><div class="line">        <span class="comment">//（注意不是直接进入小根堆，而是经大根堆筛选后取大根堆中最大元素进入小根堆）</span></div><div class="line">        <span class="comment">//1.新加入的元素先入到大根堆，由大根堆筛选出堆中最大的元素</span></div><div class="line">        maxHeap.offer(num);</div><div class="line">        <span class="keyword">int</span> filteredMaxNum = maxHeap.poll();</div><div class="line">        <span class="comment">//2.筛选后的【大根堆中的最大元素】进入小根堆</span></div><div class="line">        minHeap.offer(filteredMaxNum);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//当数据总数为奇数时，新加入的元素，应当进入大根堆</span></div><div class="line">        <span class="comment">//（注意不是直接进入大根堆，而是经小根堆筛选后取小根堆中最大元素进入大根堆）</span></div><div class="line">        <span class="comment">//1.新加入的元素先入到小根堆，由小根堆筛选出堆中最小的元素</span></div><div class="line">        minHeap.offer(num);</div><div class="line">        <span class="keyword">int</span> filteredMinNum = minHeap.poll();</div><div class="line">        <span class="comment">//2.筛选后的【小根堆中的最小元素】进入大根堆</span></div><div class="line">        maxHeap.offer(filteredMinNum);</div><div class="line">    &#125;</div><div class="line">    count++;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (count %<span class="number">2</span> == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Double((minHeap.peek() + maxHeap.peek())) / <span class="number">2</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Double(minHeap.peek());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="十九、-二叉树最大路径和（leetcode-124）"><a href="#十九、-二叉树最大路径和（leetcode-124）" class="headerlink" title="十九、 二叉树最大路径和（leetcode 124）"></a>十九、 二叉树最大路径和（leetcode 124）</h2><p>一个很有意思的问题，一个社区，所有的房子构成一棵二叉树，每个房子里有一定价值的财物，这棵二叉树有一个根节点root。如果相邻的两座房子同时被进入，就会触发警报。一个小偷，最初只能访问root节点，并可以通过二叉树的边访问房子（注：访问不意味着进入），请问不触发警报的前提下他能偷到的财物的最大价值是多少？ </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">以下面这棵二叉树为例，最多能偷走3+3+1=7的财物    </div><div class="line">     3 </div><div class="line">    / \ </div><div class="line">   2   3 </div><div class="line">    \     \ </div><div class="line">     3     1</div></pre></td></tr></table></figure><p>分析：<br>这个问题乍一看上去可能没什么思路，但是如果是用递归，可以很优雅的解决这个问题，这需要读者对递归有比较深刻的理解。下面给出解决这个问题的java代码： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">import java.util.HashMap;</div><div class="line">import java.util.Map;</div><div class="line">import common.TreeNode;</div><div class="line"></div><div class="line">public class Solution &#123;</div><div class="line">//使用一个cache 缓存以每个节点为根节点的rob方法返回值，减少计算量</div><div class="line">    Map&lt;TreeNode, Integer&gt; cache = new HashMap&lt;TreeNode, Integer&gt;();</div><div class="line">    public int rob(TreeNode root) &#123;</div><div class="line">    //如果当前节点为空 直接返回0</div><div class="line">        if(null == root)&#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">        //首先查看缓存中有没有这个节点的rob方法返回值</div><div class="line">        if(null != cache.get(root))&#123;</div><div class="line">            return cache.get(root);</div><div class="line">        &#125;</div><div class="line">        //计算当前节点左孩子的rob方法返回值</div><div class="line">        int maxLeft = rob(root.left);</div><div class="line">        //计算当前节点右孩子的rob方法返回值</div><div class="line">        int maxRight = rob(root.right);</div><div class="line">        int maxLeftLeft = 0;</div><div class="line">        int maxLeftRight = 0;</div><div class="line">        //如果当前节点有左孩子</div><div class="line">        if(null != root.left)&#123;</div><div class="line">        //计算其左孩子的左孩子的rob值</div><div class="line">            maxLeftLeft = rob(root.left.left);</div><div class="line">            //计算其左孩子的右孩子的rob值</div><div class="line">            maxLeftRight = rob(root.left.right);</div><div class="line">        &#125;</div><div class="line">        int maxRightLeft = 0;</div><div class="line">        int maxRightRight = 0;</div><div class="line">        //如果当前节点有右孩子</div><div class="line">        if(null != root.right)&#123;</div><div class="line">        //计算其右孩子的左孩子的rob值</div><div class="line">            maxRightLeft = rob(root.right.left);</div><div class="line">            //计算其右孩子的右孩子的rob值</div><div class="line">            maxRightRight = rob(root.right.right);</div><div class="line">        &#125;</div><div class="line">        //不偷当前节点能偷到的财物的最大值</div><div class="line">        int notIncludeCurrentNodeMax = maxLeft + maxRight;</div><div class="line">        //偷当前节点能偷到的财物的最大值</div><div class="line">        int includeCurrentNodeMax = maxLeftLeft + maxLeftRight + maxRightLeft + maxRightRight + root.val;</div><div class="line">        //以其中的较大值作为当前节点的rob方法返回值</div><div class="line">        int res = notIncludeCurrentNodeMax &gt; includeCurrentNodeMax ? notIncludeCurrentNodeMax : includeCurrentNodeMax;</div><div class="line">        //缓存当前节点的rob方法返回值</div><div class="line">        cache.put(root, res);</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="面经中出现过的二叉树题："><a href="#面经中出现过的二叉树题：" class="headerlink" title="面经中出现过的二叉树题："></a>面经中出现过的二叉树题：</h2><h3 id="已整理"><a href="#已整理" class="headerlink" title="已整理"></a>已整理</h3><ul><li>一、给定二叉树的先序跟后序遍历，能不能将二叉树重建（不能，因为先序：父节点-左节点-右节点，后序：左节点-右节点-父节点，两者的拓扑序列是一样的，所以无法建立），如果给出一个二叉搜索树的后续能不能建立（可以，因为只要将遍历结果排序就可以得到中序结果）。</li><li>二、判断一棵树是否是另一棵的子树。</li><li>三、 翻转二叉树 </li><li>四、二叉树打印路径</li><li>六、输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。二叉树路径和等于某个值的所有路径输出。</li><li>七、排序二叉树转双向链表</li><li>十、输入根节点和两个子节点，找到最小公共父节点，2叉树只有孩子节点；查找二叉树某两个节点的最近公共祖先</li><li>十二、输入二叉树节点 P, 找到二叉树中序遍历 P 的下一个节点。</li><li>十四、把二叉树打印成多行；中序遍历二叉树，利用O(1)空间统计遍历的每个节点的层次</li><li>十五、手写S型遍历二叉树，如何优化，最后说了个空间优化的方法 </li><li>十九、leetcode 124 二叉树最大路径和</li></ul><h3 id="未整理"><a href="#未整理" class="headerlink" title="未整理"></a>未整理</h3><p>求完全二叉树的节点个数，要求最优解法，我写的是递归，复杂度O(logn*logn)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二叉树相关题解java实现。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法题解（3）：字符串题解</title>
    <link href="http://yoursite.com/2017/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%EF%BC%883%EF%BC%89%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A2%98%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/08/04/数据结构与算法题解（3）：字符串题解/</id>
    <published>2017-08-04T14:20:45.000Z</published>
    <updated>2017-09-01T07:02:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>字符串相关题解java实现</p><a id="more"></a><h2 id="一、替换空格（剑4）"><a href="#一、替换空格（剑4）" class="headerlink" title="一、替换空格（剑4）"></a>一、替换空格（剑4）</h2><p>请实现一个函数，把字符串中的每个空格替换成”%20”。例如输入“We are happy.”，则输出“We%20are%20happy”</p><p>网络编程中，要把特殊符号转换成服务器可识别的字符。转换的规则是在“%”后面跟上ASCII码的两位十六进制的表示。比如空格的ASCII码是32，即十六进制的0X20，因此空格被替换成“%20”。</p><p>问题1：替换字符串，是在原来的字符串上做替换，还是新开辟一个字符串做替换！<br>问题2：在当前字符串替换，怎么替换才更有效率（不考虑java里现有的replace方法）。从前往后替换，后面的字符要不断往后移动，要多次移动，所以效率低下；从后往前，先计算需要多少空间，然后从后往前移动，则每个字符只为移动一次，这样效率更高一点。<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-28 上午9.44.36.png" alt="屏幕快照 2017-07-28 上午9.44.36"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> spacenum = <span class="number">0</span>;<span class="comment">//spacenum为计算空格数</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(str.charAt(i)==<span class="string">' '</span>)</div><div class="line">                spacenum++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> indexold = str.length()-<span class="number">1</span>;<span class="comment">//indexold为为替换前的str下标</span></div><div class="line">        <span class="keyword">int</span> newlength = str.length()+<span class="number">2</span>*spacenum;<span class="comment">//计算空格转换成%20之后的str长度</span></div><div class="line">        <span class="keyword">int</span> indexnew = newlength-<span class="number">1</span>;<span class="comment">//indexold为为把空格替换为%20后的str下标</span></div><div class="line">        str.setLength(newlength);<span class="comment">//使str的长度扩大到转换成%20之后的长度,防止下标越界,setLength方法</span></div><div class="line">        <span class="keyword">for</span>(;indexold&gt;=<span class="number">0</span>&amp;&amp;indexold&lt;newlength;--indexold)&#123;</div><div class="line">            <span class="keyword">if</span>(str.charAt(indexold)==<span class="string">' '</span>)&#123;<span class="comment">//charAt方法</span></div><div class="line">                str.setCharAt(indexnew--,<span class="string">'0'</span>);</div><div class="line">                str.setCharAt(indexnew--,<span class="string">'2'</span>);</div><div class="line">                str.setCharAt(indexnew--,<span class="string">'%'</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                str.setCharAt(indexnew--,str.charAt(indexold));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> str.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="二、字符串的排列（剑28）"><a href="#二、字符串的排列（剑28）" class="headerlink" title="二、字符串的排列（剑28）"></a>二、字符串的排列（剑28）</h2><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p><p>首先我要打印abc的全排列，就是第一步把a 和bc交换（得到bac,cab），这需要一个for循环，循环里面有一个swap，交换之后就相当于不管第一步了，进入下一步递归，所以跟一个递归函数， 完成递归之后把交换的换回来，变成原来的字串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">abc 为例子：</div><div class="line">1. 固定a, 求后面bc的全排列： abc, acb。 求完后，a 和 b交换； 得到bac,开始第二轮</div><div class="line">2. 固定b, 求后面ac的全排列： bac, bca。 求完后，b 和 c交换； 得到cab,开始第三轮</div><div class="line">3. 固定c, 求后面ba的全排列： cab, cba</div><div class="line"> 即递归树： </div><div class="line">　　　　　str:　　 a    　　　　 b 　　　　　　  c</div><div class="line">　　　　　　 　　ab ac     　　ba bc  　　　     ca cb</div><div class="line">　   　result:     abc acb    　 bac bca　     　   cab cba</div></pre></td></tr></table></figure><p><img src="http://omu7tit09.bkt.clouddn.com/15016515510574.jpg" alt=""></p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">if</span>(str.length()==<span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> list;</div><div class="line">        <span class="keyword">char</span>[] array = str.toCharArray();</div><div class="line">        permutation(array,<span class="number">0</span>,list);</div><div class="line">        Collections.sort(list);</div><div class="line">        <span class="keyword">return</span> list;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">permutation</span><span class="params">(<span class="keyword">char</span>[] array,<span class="keyword">int</span> begin,ArrayList&lt;String&gt; list)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(begin == array.length-<span class="number">1</span>) &#123;</div><div class="line">            list.add(String.valueOf(array));</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=begin;i&lt;array.length;++i) &#123;</div><div class="line">                <span class="keyword">if</span>(i==begin || array[i]!=array[begin]) &#123;</div><div class="line">                    swap(array,begin,i);</div><div class="line">                    permutation(array,begin+<span class="number">1</span>,list);</div><div class="line">                    swap(array,begin,i);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] array,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">        <span class="keyword">char</span> temp = array[i];</div><div class="line">        array[i] = array[j];</div><div class="line">        array[j] = temp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="三、第一次只出现一次的字符（字符串）"><a href="#三、第一次只出现一次的字符（字符串）" class="headerlink" title="三、第一次只出现一次的字符（字符串）"></a>三、第一次只出现一次的字符（字符串）</h2><p>在一个字符串(1&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置.</p><p>我们可以使用一个容器来存放每个字符的出现次数。在这个数据容器中可以根据字符来查找出现的次数，也就是这个容器的作用是把一个字符映射成一个数字。在常用的数据容器中，哈希表正是这个用途。</p><p>为了解决这个问题，我们可以定义哈希表的键值（Key）是字符，而值（Value）是该字符出现的次数。同时我们还需要从头开始扫描字符串两次。第一次扫面字符串时，每扫到一个字符就在哈希表的对应项把次数加1.接下来第二次扫描时，每扫描到一个字符就能在哈希表中得到该字符出现的次数，这样第一个只出现一次的字符就是符合要求的输出。</p><p>需要涉及到Java中HashMap工作原理及实现，<a href="http://yikun.github.io/2015/04/01/Java-HashMap工作原理及实现/" target="_blank" rel="noopener">资料链接</a></p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">        HashMap&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character,Integer&gt;();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</div><div class="line">            <span class="keyword">char</span> c = str.charAt(i);<span class="comment">//charAt方法，获得位置i的串</span></div><div class="line">                <span class="keyword">if</span>(map.containsKey(c))&#123;<span class="comment">//HashMap的containKey方法；</span></div><div class="line">                    <span class="keyword">int</span> time = map.get(c);<span class="comment">//HashMap的get方法，得到Key c的Value；</span></div><div class="line">                    time++;</div><div class="line">                    map.put(c,time);<span class="comment">//HashMap的put方法，将Key c的Value置为time；</span></div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    map.put(c,<span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</div><div class="line">            <span class="keyword">char</span> c = str.charAt(i);</div><div class="line">            <span class="keyword">if</span>(map.get(c)==<span class="number">1</span>)&#123;</div><div class="line">                <span class="keyword">return</span> i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="四、翻转单词顺序（剑42-1）"><a href="#四、翻转单词顺序（剑42-1）" class="headerlink" title="四、翻转单词顺序（剑42.1）"></a>四、翻转单词顺序（剑42.1）</h2><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串“I am a student.”，则输出“student. a am I”。<br>可以先翻转整个句子，然后，依次翻转每个单词。依据空格来确定单词的起始和终止位置</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</div><div class="line">        reverse(chars,<span class="number">0</span>,chars.length-<span class="number">1</span>);</div><div class="line">        <span class="keyword">int</span> blank = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;chars.length-<span class="number">1</span>;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(chars[i]==<span class="string">' '</span>)&#123;</div><div class="line">                <span class="keyword">int</span> nextblank = i;</div><div class="line">                reverse(chars,blank+<span class="number">1</span>,nextblank-<span class="number">1</span>);</div><div class="line">                blank = nextblank;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        reverse(chars,blank+<span class="number">1</span>,chars.length-<span class="number">1</span>);<span class="comment">//单独翻转最后一个单词</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] chars,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">        <span class="keyword">while</span>(low&lt;high)&#123;</div><div class="line">            <span class="keyword">char</span> temp = chars[low];</div><div class="line">            chars[low]=chars[high];</div><div class="line">            chars[high]=temp;</div><div class="line">            low++;</div><div class="line">            high--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="五、左旋转字符串（剑42-2）"><a href="#五、左旋转字符串（剑42-2）" class="headerlink" title="五、左旋转字符串（剑42.2）"></a>五、左旋转字符串（剑42.2）</h2><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。</p><p>以“abcdefg”为例，我们可以把它分为两部分。由于想把它的前两个字符移到后面，我们就把钱两个字符分到第一部分，把后面的所有字符都分到第二部分。然后先翻转这两部分，于是就得到“bagfedc”。接下来在翻转整个字符串，得到的”cdefgab”刚好就是把原始字符串左旋转2位的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public String LeftRotateString(String str,int n) &#123;</div><div class="line">        char[] chars = str.toCharArray();        </div><div class="line">        if(chars.length &lt; n) return &quot;&quot;; </div><div class="line">        reverse(chars, 0, n-1);</div><div class="line">        reverse(chars, n, chars.length-1);</div><div class="line">        reverse(chars, 0, chars.length-1);</div><div class="line">        return new String(chars);</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public void reverse(char[] chars,int low,int high)&#123;</div><div class="line">        char temp;</div><div class="line">        while(low&lt;high)&#123;</div><div class="line">            temp = chars[low];</div><div class="line">            chars[low] = chars[high];</div><div class="line">            chars[high] = temp;</div><div class="line">            low++;</div><div class="line">            high--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="六、-把字符串转换成整数（剑49）"><a href="#六、-把字符串转换成整数（剑49）" class="headerlink" title="六、 把字符串转换成整数（剑49）"></a>六、 把字符串转换成整数（剑49）</h2><p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。<br>问题不难，但是要把很多特殊情况都考虑进去，却并不容易。需要考虑的特殊情况有以下几个：</p><ol><li>空指针null</li><li>字符串为空</li><li>正负号</li><li>上下溢出 Integer.MAX_VALUE (2^31-1)  Integer.MIN_VALUE(-2^31)</li></ol><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span>||str.length()==<span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">//空指针或空字符串</span></div><div class="line">        <span class="keyword">char</span>[] c = str.toCharArray();</div><div class="line">        <span class="keyword">boolean</span> minus=<span class="keyword">false</span>;</div><div class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</div><div class="line">        <span class="comment">//正负号</span></div><div class="line">        <span class="keyword">if</span>(c[i]==<span class="string">'+'</span>)&#123;</div><div class="line">            i++;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c[i]==<span class="string">'-'</span>)&#123;</div><div class="line">            i++;</div><div class="line">            minus=<span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(i&lt;c.length)&#123;</div><div class="line">            num = StrToIntCore(c,minus,i);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> num;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> num;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">StrToIntCore</span><span class="params">(<span class="keyword">char</span>[] str,<span class="keyword">boolean</span> minus,<span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;str.length;j++)&#123;</div><div class="line">            <span class="keyword">if</span>(str[j]&gt;=<span class="string">'0'</span>&amp;&amp;str[j]&lt;=<span class="string">'9'</span>)&#123;</div><div class="line">                <span class="keyword">int</span> flag = minus?-<span class="number">1</span>:<span class="number">1</span>;</div><div class="line">                num = num*<span class="number">10</span>+flag*(str[j]-<span class="string">'0'</span>);</div><div class="line">                <span class="keyword">if</span>((!minus&amp;&amp;num&gt;Integer.MAX_VALUE)||minus&amp;&amp;num&lt;Integer.MIN_VALUE)&#123;<span class="comment">//上下溢出</span></div><div class="line">                    num=<span class="number">0</span>;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//非法数值</span></div><div class="line">                num=<span class="number">0</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">           </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> num;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="七、正则表达式匹配（剑53）"><a href="#七、正则表达式匹配（剑53）" class="headerlink" title="七、正则表达式匹配（剑53）"></a>七、正则表达式匹配（剑53）</h2><p>当模式中的第二个字符不是“*”时：</p><ol><li>如果字符串第一个字符和模式中的第一个字符相匹配，那么字符串和模式都后移一个字符，然后匹配剩余的。 </li><li>如果字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。</li></ol><p>而当模式中的第二个字符是“*”时：</p><p>如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配。如果字符串第一个字符跟模式第一个字符匹配，可以有3种匹配方式： </p><ol><li>模式后移2字符，相当于$x*$被忽略； </li><li>字符串后移1字符，模式后移2字符； </li><li>字符串后移1字符，模式不变，即继续匹配字符下一位，因为*可以匹配多位；</li></ol><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">char</span>[] pattern)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || pattern == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> strIndex = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> patternIndex = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> matchCore(str, strIndex, pattern, patternIndex);</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matchCore</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> strIndex, <span class="keyword">char</span>[] pattern, <span class="keyword">int</span> patternIndex)</span> </span>&#123;</div><div class="line">    <span class="comment">//有效性检验：str到尾，pattern到尾，匹配成功</span></div><div class="line">    <span class="keyword">if</span> (strIndex == str.length &amp;&amp; patternIndex == pattern.length) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//pattern先到尾，匹配失败</span></div><div class="line">    <span class="keyword">if</span> (strIndex != str.length &amp;&amp; patternIndex == pattern.length) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//模式第2个是*，且字符串第1个跟模式第1个匹配,分3种匹配模式；如不匹配，模式后移2位</span></div><div class="line">    <span class="keyword">if</span> (patternIndex + <span class="number">1</span> &lt; pattern.length &amp;&amp; pattern[patternIndex + <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</div><div class="line">        <span class="keyword">if</span> ((strIndex != str.length &amp;&amp; pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == <span class="string">'.'</span> &amp;&amp; strIndex != str.length)) &#123;</div><div class="line">            <span class="keyword">return</span> matchCore(str, strIndex, pattern, patternIndex + <span class="number">2</span>)<span class="comment">//模式后移2，视为x*匹配0个字符</span></div><div class="line">                    || matchCore(str, strIndex + <span class="number">1</span>, pattern, patternIndex + <span class="number">2</span>)<span class="comment">//视为模式匹配1个字符</span></div><div class="line">                    || matchCore(str, strIndex + <span class="number">1</span>, pattern, patternIndex);<span class="comment">//*匹配1个，再匹配str中的下一个</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> matchCore(str, strIndex, pattern, patternIndex + <span class="number">2</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//模式第2个不是*，且字符串第1个跟模式第1个匹配，则都后移1位，否则直接返回false</span></div><div class="line">    <span class="keyword">if</span> ((strIndex != str.length &amp;&amp; pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == <span class="string">'.'</span> &amp;&amp; strIndex != str.length)) &#123;</div><div class="line">        <span class="keyword">return</span> matchCore(str, strIndex + <span class="number">1</span>, pattern, patternIndex + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="八、表示数值的字符串（剑54）"><a href="#八、表示数值的字符串（剑54）" class="headerlink" title="八、表示数值的字符串（剑54）"></a>八、表示数值的字符串（剑54）</h2><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(s.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">if</span>((s.length==<span class="number">1</span>)&amp;&amp;(s[<span class="number">0</span>]&lt;<span class="string">'0'</span>||s[<span class="number">0</span>]&gt;<span class="string">'9'</span>)) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'+'</span>||s[<span class="number">0</span>]==<span class="string">'-'</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(s.length==<span class="number">2</span>&amp;&amp;(s[<span class="number">1</span>]==<span class="string">'.'</span>)) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>((s[<span class="number">0</span>]&lt;<span class="string">'0'</span>||s[<span class="number">0</span>]&gt;<span class="string">'9'</span>)&amp;&amp;s[<span class="number">0</span>]!=<span class="string">'.'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//首位既不是符号也不是数字还不是小数点，当然是false</span></div><div class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>((i&lt;s.length)&amp;&amp;(s[i]&gt;=<span class="string">'0'</span>&amp;&amp;s[i]&lt;=<span class="string">'9'</span>)) i++;</div><div class="line">        <span class="keyword">if</span>(i&lt;s.length&amp;&amp;s[i]==<span class="string">'.'</span>)&#123;</div><div class="line">            i++;</div><div class="line">            <span class="comment">//if(i&gt;=s.length) return false;</span></div><div class="line">            <span class="keyword">while</span>((i&lt;s.length)&amp;&amp;(s[i]&gt;=<span class="string">'0'</span>&amp;&amp;s[i]&lt;=<span class="string">'9'</span>)) i++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(i&lt;s.length&amp;&amp;(s[i]==<span class="string">'e'</span>||s[i]==<span class="string">'E'</span>))&#123;</div><div class="line">            i++;</div><div class="line">            <span class="keyword">if</span>((i&lt;s.length)&amp;&amp;(s[i]==<span class="string">'+'</span>||s[i]==<span class="string">'-'</span>))&#123;</div><div class="line">                i++;</div><div class="line">                <span class="keyword">if</span>(i&lt;s.length) <span class="keyword">while</span>((i&lt;s.length)&amp;&amp;(s[i]&gt;=<span class="string">'0'</span>&amp;&amp;s[i]&lt;=<span class="string">'9'</span>)) i++;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i&lt;s.length)&#123;</div><div class="line">                <span class="keyword">while</span>((i&lt;s.length)&amp;&amp;(s[i]&gt;=<span class="string">'0'</span>&amp;&amp;s[i]&lt;=<span class="string">'9'</span>)) i++;</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(i&lt;s.length) <span class="keyword">return</span> <span class="keyword">false</span>;            </div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="九、字符流中第一个不重复的数组（剑55）"><a href="#九、字符流中第一个不重复的数组（剑55）" class="headerlink" title="九、字符流中第一个不重复的数组（剑55）"></a>九、字符流中第一个不重复的数组（剑55）</h2><p>使用一个HashMap来统计字符出现的次数，同时用一个ArrayList来记录输入流，每次返回第一个出现一次的字符都是在这个ArrayList（输入流）中的字符作为key去map中查找。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">//HashMap来统计字符出现的次数</span></div><div class="line">    HashMap&lt;Character, Integer&gt; map=<span class="keyword">new</span> HashMap();</div><div class="line">    <span class="comment">//ArrayList来记录输入流</span></div><div class="line">    ArrayList&lt;Character&gt; list=<span class="keyword">new</span> ArrayList&lt;Character&gt;();</div><div class="line">    <span class="comment">//Insert one char from stringstream</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(map.containsKey(ch))&#123;</div><div class="line">            <span class="keyword">int</span> time = map.get(ch);</div><div class="line">            time++;</div><div class="line">            map.put(ch,time);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            map.put(ch,<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">         </div><div class="line">        list.add(ch);</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="comment">//return the first appearence once char in current stringstream</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></div><div class="line">    &#123;   <span class="keyword">char</span> ch=<span class="string">'#'</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> k : list)&#123;<span class="comment">//list迭代</span></div><div class="line">            <span class="keyword">if</span>(map.get(k)==<span class="number">1</span>)&#123;</div><div class="line">                ch=k;</div><div class="line">                <span class="keyword">break</span>;<span class="comment">//得到第一个结果即可break</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> ch;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="十、最长无重复字符子串"><a href="#十、最长无重复字符子串" class="headerlink" title="十、最长无重复字符子串"></a>十、最长无重复字符子串</h2><p>给定一个字符串，找字符中的最大非重复子串 。</p><p>基本思路是维护一个窗口，每次关注窗口中的字符串，在每次判断中，左窗口和右窗口选择其一向前移动。同样是维护一个HashSet, 正常情况下移动右窗口，如果没有出现重复则继续移动右窗口，如果发现重复字符，则说明当前窗口中的串已经不满足要求，继续移动有窗口不可能得到更好的结果，此时移动左窗口，直到不再有重复字符为止，中间跳过的这些串中不会有更好的结果，因为他们不是重复就是更短。因为左窗口和右窗口都只向前，所以两个窗口都对每个元素访问不超过一遍，因此时间复杂度为O(2*n)=O(n),是线性算法。空间复杂度为HashSet的size,也是O(n). 用start记录当前处理的开始位置历遍字符串，当当前字符从开始位置start开始已经出现过的时候，子串开始位置+1，否则更新map中的hash值为当前位置 。代码如下：</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</div><div class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> lens=s.length();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, start=<span class="number">0</span>; i&lt;lens; ++i)&#123;</div><div class="line">            <span class="keyword">char</span> ch = s.charAt(i);</div><div class="line">            <span class="keyword">if</span> (map.containsKey(ch))&#123;</div><div class="line">                start = Math.max(start,map.get(ch)+<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">            map.put(ch,i);</div><div class="line">            max = Math.max(max,i-start+<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="十一、最长回文字符串"><a href="#十一、最长回文字符串" class="headerlink" title="十一、最长回文字符串"></a>十一、最长回文字符串</h2><p>已整理</p><h2 id="十二、KMP算法"><a href="#十二、KMP算法" class="headerlink" title="十二、KMP算法"></a>十二、KMP算法</h2><p>已整理</p><h2 id="面试出现的字符串题"><a href="#面试出现的字符串题" class="headerlink" title="面试出现的字符串题"></a>面试出现的字符串题</h2><h3 id="已整理"><a href="#已整理" class="headerlink" title="已整理"></a>已整理</h3><ul><li>三、寻找字符串中第一个只出现一次的字符；寻找一个字符串中第一个只出现一次的字符</li><li>五、左旋转字符串；手写算法:字符串反转；翻转一个英文字符串中的单词位置，单词间以空格分隔，但不改变每个单词本身的顺序。如输入“Ha Mo”，输出“Mo Ha”；字符串反转；请实现一个函数将“I am a student”转为“student a am I”。</li><li>六、实现atoi函数，即字符串转整型；就是那个字符串转换成整数，题目不难，但考虑的细节特别多。。。没写出来；写程序 str2Int</li><li>七、写 find 函数，在目标串中匹配模式串（要考虑中文字符的情况）。</li><li>十一、最长回文子串：判断一个数字是否为回文数（此处需注意，面试官一直问我有没有更优的方法，我当时已经说出了2-3个方法，囧），</li><li>十二、KMP算法</li></ul><h3 id="未整理"><a href="#未整理" class="headerlink" title="未整理"></a>未整理</h3><p>字符串由大小写字母组成，要求去重，只允许使用几个int临时变量，要求时间复杂度尽可能少。<br>左右括号组成的字符串，去除最少使得剩余的字符串是合法的<br>统计一个字符串中英文字母、空格、数字的个数，考察代码风格是否规范<br>然后要求手写纯C字符串拼接，当时笔者想到了三个细节（1：const char* str 2: 空串判断 3：返回新串还是原有串），写完代码之后面试就结束了。在出门的那一刹那，我想起了代码中一个问题，空间申请啊，内心是崩溃的。。。<br>字符串分割<br>字符串排序<br>字符串中字符替换<br>两个字符串的复制（除了字符串地址重叠的情况，也要注意判断字符串本身的空间足够不足够，对于异常情况要考虑全面）<br>写code去除字符串S1中的字符使得最终的字符串S2不包含’ab’和’c’</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;字符串相关题解java实现&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法题解（2）：数组题解</title>
    <link href="http://yoursite.com/2017/08/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%EF%BC%882%EF%BC%89%EF%BC%9A%E6%95%B0%E7%BB%84%E9%A2%98%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/08/03/数据结构与算法题解（2）：数组题解/</id>
    <published>2017-08-03T14:20:45.000Z</published>
    <updated>2017-09-08T23:49:13.000Z</updated>
    
    <content type="html"><![CDATA[<p> 数组相关题解java实现。</p><a id="more"></a><h2 id="一、二维数组中的查找（剑3）"><a href="#一、二维数组中的查找（剑3）" class="headerlink" title="一、二维数组中的查找（剑3）"></a>一、二维数组中的查找（剑3）</h2><p>在一个二维数组中，每一行都按照从左到右的递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一维数组和一个整数，判断数组中是否含有该整数。</p><p>首先选取数组中右上角的数字，如果该数字等于我们要查找的数组，查找过程结束；如果该数字大于要查找的数组，剔除这个数字所在的列；如果该数字小于要查找的数组，剔除这个数字所在的行。也就是说如果要查找的数字不再数组的右上角，则每一次都在数组的查找范围中剔除一行或者一列，这样每一步都可以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-28 上午12.21.28.png" alt="屏幕快照 2017-07-28 上午12.21.28"></p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> col = array[<span class="number">0</span>].length - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(row&lt;=array.length-<span class="number">1</span>&amp;&amp;col&gt;=<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(target == array[row][col])&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target&gt;array[row][col])&#123;</div><div class="line">                row++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                col--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>python</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">class Solution:</div><div class="line">    # array 二维列表</div><div class="line">    def Find(self, target, array):</div><div class="line">        # write code here</div><div class="line">        row = 0</div><div class="line">        col = len(array[0])-1</div><div class="line">        while row&lt;=len(array)-1 and col&gt;=0:</div><div class="line">            if target==array[row][col]:</div><div class="line">                return True</div><div class="line">            elif target&gt;array[row][col]:</div><div class="line">                row+=1</div><div class="line">            else:</div><div class="line">                col-=1</div><div class="line">        return False</div></pre></td></tr></table></figure><p>也可以把每一行看做是一个递增的序列，利用二分查找。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</div><div class="line">            <span class="keyword">int</span> low =<span class="number">0</span>;</div><div class="line">            <span class="keyword">int</span> high = array[i].length-<span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span>(low&lt;=high)&#123;</div><div class="line">                <span class="keyword">int</span> mid = (low+high)/<span class="number">2</span>;</div><div class="line">                <span class="keyword">if</span>(array[i][mid]==target)</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(array[i][mid]&gt;target)</div><div class="line">                    high =mid-<span class="number">1</span>;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    low=mid+<span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="二、用两个栈实现队列（剑7）"><a href="#二、用两个栈实现队列（剑7）" class="headerlink" title="二、用两个栈实现队列（剑7）"></a>二、用两个栈实现队列（剑7）</h2><p>栈是一个非常常见的数据结构，它在计算机领域中被广泛应用，比如操作系统会给每个线程创建一个栈来存储函数调用时各个函数的参数、返回地址及临时变量等。栈的特点是后进先出，即最后被压入（push）栈的元素会第一个被弹出（pop）。</p><p>队列是另外一种很重要的数据结构。和栈不同的是，队列的特点是先进先出，即第一个进入队列的元素将会第一个出来。</p><p>栈和队列虽然是针锋相对的两个数据结构，但有意思的是他们却相互联系。</p><p>通过一个具体的例子来分析往队列插入和删除元素的过程。首先插入一个元素a，不妨先把它插入到stack1，此时stack1中的元素有{a}，stack2为空，再向stack1压入b和c，此时stack1中的元素有{a,b,c}，其中c处于栈顶，而stack2仍然是空的。</p><p>因为a是最先进的，最先被删除的元素应该是a，但a位于栈低。我们可以把stack1中的元素逐个弹出并压入stack2，元素在stack2的顺序正好和原来在stack1的顺序相反因此经过三次弹出stack1和压入stack2操作之后，stack1为空，而stack2的元素是{c,b,a}，这时就可以弹出stack2的栈顶a了，随后弹出stack2中的b和c，而这个过程中stack1始终为空.</p><p>从上面的分析我们可以总结出删除一个元素的步骤：<strong>当stack2中不为空时，在stack2的栈顶元素是最先进入队列的元素，可以弹出。如果stack2为空时，我们把stack1中的元素逐个弹出并压入stack2。由于先进入队列的元素被压到stack1的底端，经过弹出和压入之后就处于stack2的顶端了，又可以直接弹出。</strong><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-28 上午10.58.44.png" alt="屏幕快照 2017-07-28 上午10.58.44"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">import java.util.Stack;</div><div class="line">public class Solution &#123;</div><div class="line">    Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;();</div><div class="line">    Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;();</div><div class="line">    </div><div class="line">    public void push(int node) &#123;</div><div class="line">        stack1.push(node);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public int pop() &#123;</div><div class="line">        while(!stack2.isEmpty())&#123;</div><div class="line">            return stack2.pop();</div><div class="line">        &#125;</div><div class="line">        while(!stack1.isEmpty())&#123;</div><div class="line">            stack2.push(stack1.pop());</div><div class="line">        &#125;</div><div class="line">        return stack2.pop();</div><div class="line">    </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="三、旋转数组的最小数字（剑8）"><a href="#三、旋转数组的最小数字（剑8）" class="headerlink" title="三、旋转数组的最小数字（剑8）"></a>三、旋转数组的最小数字（剑8）</h2><p>在准备面试的时候，我们应该重点掌握二分查找、归并排序和快速排序，做到能随时正确、完整地写出它们的代码。</p><p>若面试题是要求在排序的数组（或部分排序的数组）中查找一个数字或者统计某个数字出现的次数，我们都可以尝试用二分查找算法。</p><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。</p><p>可以采用二分法解答这个问题， mid = low + (high - low)/2 ，需要考虑三种情况： </p><ol><li>array[mid] &gt; array[high]:<br>出现这种情况的array类似[3,4,5,6,0,1,2]，此时最小数字一定在mid的右边。<br>low = mid + 1 <ol><li>array[mid] == array[high]: 出现这种情况的array类似 [1,0,1,1,1]   或者[1,1,1,0,1]，此时最小数字不好判断在mid左边，还是右边,这时只好一个一个试，low = low + 1 或者 high = high - 1 </li><li>array[mid] &lt; array[high]: 出现这种情况的array类似[2,2,3,4,5,6,6],此时最小数字一定就是array[mid]或者在mid的左边。因为右边必然都是递增的。   high = mid。注意这里有个坑：如果待查询的范围最后只剩两个数，那么mid一定会指向下标靠前的数字，比如 array = [4,6]，array[low] = 4 ;array[mid] = 4 ; array[high] = 6 ; 如果high = mid - 1，就会产生错误， 因此high = mid，但情形(1)中low = mid + 1就不会错误。</li></ol></li></ol><p>代码如下：</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> high = array.length-<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(low&lt;high)&#123;</div><div class="line">            <span class="keyword">int</span> mid = low+(high-low)/<span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>(array[mid]&gt;array[high])&#123;</div><div class="line">                low=mid+<span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[mid]==array[high])&#123;</div><div class="line">                high=high-<span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                high = mid;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> array[low];</div><div class="line">    </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="四、斐波那契数列（剑9）"><a href="#四、斐波那契数列（剑9）" class="headerlink" title="四、斐波那契数列（剑9）"></a>四、斐波那契数列（剑9）</h2><h3 id="4-1-斐波那契数列"><a href="#4-1-斐波那契数列" class="headerlink" title="4.1 斐波那契数列"></a>4.1 斐波那契数列</h3><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。n&lt;=39。<br>这个题可以说是迭代（Iteration） VS 递归（Recursion），f(n) = f(n-1) + f(n-2)，第一眼看就是递归啊，简直完美的递归环境，递归肯定很爽，这样想着关键代码两三行就搞定了，注意这题的n是从0开始的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> n;</div><div class="line"><span class="keyword">else</span> <span class="keyword">return</span> Fibonacci(n-<span class="number">1</span>)+Fibonacci(n-<span class="number">2</span>);</div></pre></td></tr></table></figure><p>然而并没有什么用，测试用例里肯定准备着一个超大的n来让Stack Overflow，为什么会溢出？因为重复计算，而且重复的情况还很严重，举个小点的例子，n=4，看看程序怎么跑的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Fibonacci(4) = Fibonacci(3) + Fibonacci(2);</div><div class="line">                    = Fibonacci(2) + Fibonacci(1) + Fibonacci(1) + Fibonacci(0);</div><div class="line">                    = Fibonacci(1) + Fibonacci(0) + Fibonacci(1) + Fibonacci(1) + Fibonacci(0);</div></pre></td></tr></table></figure><p>由于我们的代码并没有记录Fibonacci(1)和Fibonacci(0)的结果，对于程序来说它每次递归都是未知的，因此光是n=4时f(1)就重复计算了3次之多。</p><p>更简单的办法是从下往上计算，首先根据f(0)和f(1)算出f(2)，再根据f(1)和f(2)算出f(3)……依此类推就可以算出第n项了。很容易理解，这种思路的时间复杂度是O(n)。实现代码如下：</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> num1 = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> num2 = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> fibN=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</div><div class="line">            fibN=num1+num2;</div><div class="line">            num1=num2;</div><div class="line">            num2=fibN;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> fibN;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="4-2-跳台阶"><a href="#4-2-跳台阶" class="headerlink" title="4.2 跳台阶"></a>4.2 跳台阶</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级台阶总共有多少种跳法。</p><p>我们把n级台阶的跳法看成是n的函数，记为f(n)。当n&gt;2时，第一次跳的时候就有两种不同的选择：一是第一次只跳1级，此时跳法数目等于后面剩下的n-1级台阶的跳法数目，即为f(n-1)；另外一种选择是第一次跳2级，此时跳法数目等于后面剩下的n-2级台阶的跳法数目，即为f(n-2)，因此n级台阶的不同跳法的总数f(n)=f(n-1)+f(n-2)。分析到这里，我们不难看出这实际上是斐波那契数列了。<br>代码如下：</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(target == <span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(target == <span class="number">2</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">        <span class="keyword">int</span> num1 = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> num2 = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> jump = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;target;i++)&#123;</div><div class="line">            jump = num1+num2;</div><div class="line">            num1=num2;</div><div class="line">            num2=jump;                </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> jump;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="4-3-变态跳台阶"><a href="#4-3-变态跳台阶" class="headerlink" title="4.3  变态跳台阶"></a>4.3  变态跳台阶</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><p>因为n级台阶，第一步有n种跳法：跳1级、跳2级、到跳n级。跳1级，剩下n-1级，则剩下跳法是f(n-1)，跳2级，剩下n-2级，则剩下跳法是f(n-2)。所以f(n)=f(n-1)+f(n-2)+…+f(1)，因为f(n-1)=f(n-2)+f(n-3)+…+f(1)，所以f(n)=2*f(n-1)</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(target==<span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">2</span>*JumpFloorII(target-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="4-4-矩形覆盖"><a href="#4-4-矩形覆盖" class="headerlink" title="4.4 矩形覆盖"></a>4.4 矩形覆盖</h3><p>我们可以用$2<em>1$的小矩形横着或者竖着去覆盖更大的矩形。请问用n个$2</em>1$的小矩形无重叠地覆盖一个$2*n$的大矩形，总共有多少种方法？</p><p>把$2<em>8$的覆盖方法记为f(8)。用一个$1</em>2$小矩形去覆盖大矩形的最左边有两个选择。竖着放或者横着放。当竖着放时，右边剩下$2<em>7$的区域，记为f(7)。横着放时，当$1</em>2$的小矩阵横着放在左上角的时候，左下角必须横着放一个$1<em>2$的小矩阵，剩下$2</em>6$，记为f(6)，因此f(8)=f(7)+f(6)。此时可以看出，仍然是斐波那契数列。</p><p>代码如下：</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(target==<span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> num1=<span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> num2=<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> cover =<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;target;i++)&#123;</div><div class="line">            cover = num1+num2;</div><div class="line">            num1=num2;</div><div class="line">            num2=cover; </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> cover;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="五、调整数组顺序使奇数位于偶数前面（剑14）"><a href="#五、调整数组顺序使奇数位于偶数前面（剑14）" class="headerlink" title="五、调整数组顺序使奇数位于偶数前面（剑14）"></a>五、调整数组顺序使奇数位于偶数前面（剑14）</h2><p><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-28 下午6.04.43.png" alt="屏幕快照 2017-07-28 下午6.04.43"></p><p>书上的方法类似于快排，但快排是不稳定的，即其相对位置会发生变化。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> length = array.length;</div><div class="line">        <span class="keyword">if</span>(array==<span class="keyword">null</span>||length==<span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> right = length-<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</div><div class="line">            <span class="keyword">while</span>(left&lt;right&amp;&amp;array[left]%<span class="number">2</span>==<span class="number">1</span>)&#123;</div><div class="line">                left++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">while</span>(left&lt;right&amp;&amp;array[right]%<span class="number">2</span>==<span class="number">0</span>)&#123;</div><div class="line">                right--;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">int</span> temp =array[right];</div><div class="line">            array[right]=array[left];</div><div class="line">            array[left]=temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里要保证奇数和奇数，偶数和偶数之间的相对位置不变。可以使用插入排序的思想</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> length = array.length;</div><div class="line">        <span class="keyword">if</span>(array==<span class="keyword">null</span>||length==<span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(array[i]%<span class="number">2</span>==<span class="number">1</span>)&#123;</div><div class="line">                <span class="keyword">int</span> curr = array[i];</div><div class="line">                <span class="keyword">int</span> j=i-<span class="number">1</span>;</div><div class="line">                <span class="keyword">while</span>(j&gt;=<span class="number">0</span>&amp;&amp;array[j]%<span class="number">2</span>==<span class="number">0</span>)&#123;</div><div class="line">                    array[j+<span class="number">1</span>]=array[j];</div><div class="line">                    j--;</div><div class="line">                &#125;</div><div class="line">                array[j+<span class="number">1</span>]=curr;</div><div class="line">            &#125;    </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="六、顺时针打印矩阵（剑20）"><a href="#六、顺时针打印矩阵（剑20）" class="headerlink" title="六、顺时针打印矩阵（剑20）"></a>六、顺时针打印矩阵（剑20）</h2><p>输入一个矩阵，按照从外向里以顺时针依次打印出每一个数字。例如，输入如下矩阵：<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-01 下午3.15.07.png" alt="屏幕快照 2017-08-01 下午3.15.07"></p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> row = matrix.length;</div><div class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;        </div><div class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt; ();</div><div class="line">        <span class="comment">// 输入的二维数组非法，返回空的数组</span></div><div class="line">        <span class="keyword">if</span>(row==<span class="number">0</span>&amp;&amp;col==<span class="number">0</span>)<span class="keyword">return</span> result;</div><div class="line">        <span class="comment">// 定义四个关键变量，表示左上和右下的打印范围</span></div><div class="line">        <span class="keyword">int</span> left =<span class="number">0</span>,top=<span class="number">0</span>,right=col-<span class="number">1</span>,bottom=row-<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(left&lt;=right&amp;&amp;top&lt;=bottom)&#123;</div><div class="line">             <span class="comment">// left to right</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;i++)&#123;result.add(matrix[top][i]);&#125;</div><div class="line">            <span class="comment">// top to bottom</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=top+<span class="number">1</span>;i&lt;=bottom;i++)&#123;result.add(matrix[i][right]);&#125;</div><div class="line">            <span class="comment">// right to left</span></div><div class="line">            <span class="keyword">if</span>(top!=bottom)&#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=right-<span class="number">1</span>;i&gt;=left;i--)&#123;result.add(matrix[bottom][i]);&#125;&#125;</div><div class="line">            <span class="comment">// bottom to top</span></div><div class="line">            <span class="keyword">if</span>(left!=right)&#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=bottom-<span class="number">1</span>;i&gt;=top+<span class="number">1</span>;i--)&#123;result.add(matrix[i][left]);&#125;&#125;</div><div class="line">            left++;right--;top++;bottom--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">       </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="七、包含min函数的栈（剑21）"><a href="#七、包含min函数的栈（剑21）" class="headerlink" title="七、包含min函数的栈（剑21）"></a>七、包含min函数的栈（剑21）</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。在该栈中，调用min、push及pop的时间复杂度都是O(1)。</p><p>可以利用一个辅助栈来存放最小值<br>  <img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-01 下午10.53.41.png" alt="屏幕快照 2017-08-01 下午10.53.41"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-01 下午10.53.48.png" alt="屏幕快照 2017-08-01 下午10.53.48"></p><p>  每入栈一次，就与辅助栈顶比较大小，如果小就入栈，如果大就入栈当前的辅助栈顶 。<br>  当出栈时，辅助栈也要出栈<br>  这种做法可以保证辅助栈顶一定都是最小元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">import java.util.Stack;</div><div class="line"></div><div class="line">public class Solution &#123;</div><div class="line">    Stack&lt;Integer&gt; data = new Stack&lt;Integer&gt;();</div><div class="line">    Stack&lt;Integer&gt; min = new Stack&lt;Integer&gt;();</div><div class="line">    </div><div class="line">    public void push(int node) &#123;</div><div class="line">        data.push(node);</div><div class="line">        if(min.empty())&#123;min.push(data.peek());&#125;</div><div class="line">        else if(data.peek()&lt;min.peek())&#123;min.push(data.peek());&#125;</div><div class="line">        else min.push(min.peek());</div><div class="line">        &#125;  </div><div class="line">    public void pop() &#123;</div><div class="line">        data.pop();</div><div class="line">        min.pop();      </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public int top() &#123;</div><div class="line">        return data.peek();</div><div class="line">        </div><div class="line">    &#125;    </div><div class="line">    public int min() &#123;</div><div class="line">        return min.peek();        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="八、栈的压入、弹出序列（剑22）"><a href="#八、栈的压入、弹出序列（剑22）" class="headerlink" title="八、栈的压入、弹出序列（剑22）"></a>八、栈的压入、弹出序列（剑22）</h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5，3，2，1是该压栈序列对应的一个弹出序列，但4，3，5，1，2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><p>借用一个辅助的栈，遍历压栈顺序，先讲第一个放入栈中，这里是1，然后判断栈顶元素是不是出栈顺序的第一个元素，这里是4，很显然1≠4，所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。<br>举例：<br>入栈1,2,3,4,5<br>出栈4,5,3,2,1<br>首先1入辅助栈，此时栈顶1≠4，继续入栈2<br>此时栈顶2≠4，继续入栈3<br>此时栈顶3≠4，继续入栈4<br>此时栈顶4＝4，出栈4，弹出序列向后一位，此时为5，,辅助栈里面是1,2,3<br>此时栈顶3≠5，继续入栈5<br>此时栈顶5=5，出栈5,弹出序列向后一位，此时为3，,辅助栈里面是1,2,3<br>….<br>依次执行，最后辅助栈为空。如果不为空说明弹出序列不是该栈的弹出顺序。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.Stack;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(pushA.length==<span class="number">0</span>||popA.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        Stack&lt;Integer&gt; S=<span class="keyword">new</span> Stack&lt;Integer&gt;();</div><div class="line">        <span class="keyword">int</span> popIndex = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pushA.length;i++)&#123;</div><div class="line">            S.push(pushA[i]);</div><div class="line">            <span class="keyword">while</span>(!S.empty()&amp;&amp;popA[popIndex]==S.peek())&#123;</div><div class="line">                S.pop();</div><div class="line">                popIndex++;</div><div class="line">            &#125;            </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> S.empty();      </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="九、数组中出现次数超过一半的数字（剑29）"><a href="#九、数组中出现次数超过一半的数字（剑29）" class="headerlink" title="九、数组中出现次数超过一半的数字（剑29）"></a>九、数组中出现次数超过一半的数字（剑29）</h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p><p>数组中有一个数字出现的次数超过数组长度的一半，也就是说它出现的次数比其他所有数字出现的次数的和还要多。因此我们可以考虑在遍历数组的时候保存两个值：一个是数组的一个数字，一个是次数。当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1；如果不同，则次数减1；如果次数为0，则保存下一个数字，并把次数设为1。</p><p>还要判断这个数字是否超过数组长度的一半，如果不存在输出0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(array==<span class="keyword">null</span>||array.length==<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> result=array[<span class="number">0</span>];</div><div class="line">        <span class="keyword">int</span> count=<span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;array.length;i++)&#123;</div><div class="line">           <span class="keyword">if</span>(result==array[i])&#123;</div><div class="line">               count++; &#125;</div><div class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(result!=array[i])&#123;</div><div class="line">               count--; &#125;</div><div class="line">           <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</div><div class="line">               result=array[i];</div><div class="line">               count=<span class="number">1</span>;</div><div class="line">           &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> times=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(array[i]==result)&#123;</div><div class="line">                times++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(times*<span class="number">2</span>&lt;=array.length)&#123;</div><div class="line">            System.out.println(times);</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> </div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="十、最小的K个数（剑30）"><a href="#十、最小的K个数（剑30）" class="headerlink" title="十、最小的K个数（剑30）"></a>十、最小的K个数（剑30）</h2><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p><p>第一种方法，借用partition函数</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList; </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; </div><div class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span>[] input, <span class="keyword">int</span> k)</span> </span>&#123; </div><div class="line">        ArrayList&lt;Integer&gt; output = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();         </div><div class="line">        <span class="keyword">int</span> length = input.length; </div><div class="line">        <span class="keyword">if</span> (input == <span class="keyword">null</span> || length &lt;= <span class="number">0</span> || length &lt; k || k&lt;= <span class="number">0</span>) &#123; </div><div class="line">            <span class="keyword">return</span> output; </div><div class="line">        &#125; </div><div class="line">        <span class="keyword">int</span> low = <span class="number">0</span>; </div><div class="line">        <span class="keyword">int</span> high = length - <span class="number">1</span>; </div><div class="line">        <span class="keyword">while</span>(low&lt;high) &#123; </div><div class="line">            <span class="keyword">int</span> pivotloc = partition(input,low,high); </div><div class="line">            <span class="keyword">if</span>(pivotloc==k-<span class="number">1</span>)<span class="keyword">break</span>;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(pivotloc &lt; k - <span class="number">1</span>) &#123; </div><div class="line">                low = pivotloc + <span class="number">1</span>; <span class="comment">//在右边</span></div><div class="line">            &#125; </div><div class="line">            <span class="keyword">else</span> &#123; </div><div class="line">                high = pivotloc - <span class="number">1</span>; <span class="comment">//在左边             </span></div><div class="line">            &#125; </div><div class="line">        &#125; </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123; </div><div class="line">            output.add(input[i]); </div><div class="line">        &#125; </div><div class="line">        <span class="keyword">return</span> output; </div><div class="line">    &#125;</div><div class="line">   <span class="comment">//基准左右分区 </span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] input,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span> </span>&#123; </div><div class="line">        <span class="keyword">int</span> pivot = input[low]; </div><div class="line">        <span class="keyword">while</span>(low &lt; high) &#123; </div><div class="line">            <span class="keyword">while</span>(input[high] &gt;= pivot &amp;&amp; low &lt; high) high--; </div><div class="line">            input[low] = input[high]; </div><div class="line">            <span class="keyword">while</span>(input[low] &lt;= pivot &amp;&amp; low &lt;high) low++; </div><div class="line">            input[high] = input[low]; </div><div class="line">        &#125; </div><div class="line">        input[low] = pivot; </div><div class="line">        <span class="keyword">return</span> low; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>第二种方法</p><p>用最大堆保存这k个数，每次只和堆顶比，如果比堆顶小，删除堆顶，新数入堆。时间 $O(NlogK)$ 空间 $O(K)$</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.PriorityQueue;</div><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span>[] input, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">       ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">       <span class="keyword">int</span> length = input.length;</div><div class="line">       <span class="keyword">if</span>(k &gt; length || k == <span class="number">0</span>)&#123;</div><div class="line">           <span class="keyword">return</span> result;</div><div class="line">       &#125;</div><div class="line">        PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(k, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123; </div><div class="line">            <span class="meta">@Override</span><span class="comment">//PriorityQueue默认是小顶堆，实现大顶堆，需要反转默认排序器</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> o2.compareTo(o1);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        <span class="comment">//遍历数组时将数字加入优先队列（堆），一旦堆的大小大于k就将堆顶元素去除，确保堆的大小为k。遍历完后堆中的数就是最小的K个数。</span></div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i:input) &#123;</div><div class="line">            maxHeap.offer(i);</div><div class="line">            <span class="keyword">if</span>(maxHeap.size()&gt;k)</div><div class="line">                maxHeap.poll();           </div><div class="line">        &#125;</div><div class="line">       <span class="comment">//输出大顶堆中的数</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> integer : maxHeap) &#123;</div><div class="line">            result.add(integer);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="十一、连续子数组的最大和（剑31）"><a href="#十一、连续子数组的最大和（剑31）" class="headerlink" title="十一、连续子数组的最大和（剑31）"></a>十一、连续子数组的最大和（剑31）</h2><p>输入一个整型数组，数组中有正数也有负数。数组中一个或连续的多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)</p><p>第一种方法</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(array.length==<span class="number">0</span>||array==<span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> cSum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> result = array[<span class="number">0</span>];<span class="comment">// result存储最大和，不能初始为0，存在负数</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(cSum&lt;<span class="number">0</span>)&#123;</div><div class="line">                cSum=array[i];<span class="comment">// 当前和&lt;0，抛弃不要</span></div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                cSum += array[i];<span class="comment">//否则累加上去</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(cSum&gt;result)&#123;</div><div class="line">                result = cSum;<span class="comment">// 存储当前的最大结果</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;                    </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>第二种方法：动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">F（i）：以array[i]为末尾元素的子数组的和的最大值，子数组的元素的相对位置不变  </div><div class="line">     F（i）=max（F（i-<span class="number">1</span>）+array[i] ， array[i]）  </div><div class="line">     res：所有子数组的和的最大值  </div><div class="line">     res=max（res，F（i））  </div><div class="line"></div><div class="line">     如数组[<span class="number">6</span>, -<span class="number">3</span>, -<span class="number">2</span>, <span class="number">7</span>, -<span class="number">15</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>]  </div><div class="line">     初始状态：  </div><div class="line">         F（<span class="number">0</span>）=<span class="number">6</span>  </div><div class="line">         res=<span class="number">6</span>  </div><div class="line">     i=<span class="number">1</span>：  </div><div class="line">         F（<span class="number">1</span>）=max（F（<span class="number">0</span>）-<span class="number">3</span>，-<span class="number">3</span>）=max（<span class="number">6</span>-<span class="number">3</span>，<span class="number">3</span>）=<span class="number">3</span>  </div><div class="line">         res=max（F（<span class="number">1</span>），res）=max（<span class="number">3</span>，<span class="number">6</span>）=<span class="number">6</span>  </div><div class="line">     i=<span class="number">2</span>：  </div><div class="line">         F（<span class="number">2</span>）=max（F（<span class="number">1</span>）-<span class="number">2</span>，-<span class="number">2</span>）=max（<span class="number">3</span>-<span class="number">2</span>，-<span class="number">2</span>）=<span class="number">1</span>  </div><div class="line">         res=max（F（<span class="number">2</span>），res）=max（<span class="number">1</span>，<span class="number">6</span>）=<span class="number">6</span>  </div><div class="line">     i=<span class="number">3</span>：  </div><div class="line">         F（<span class="number">3</span>）=max（F（<span class="number">2</span>）+<span class="number">7</span>，<span class="number">7</span>）=max（<span class="number">1</span>+<span class="number">7</span>，<span class="number">7</span>）=<span class="number">8</span>  </div><div class="line">         res=max（F（<span class="number">2</span>），res）=max（<span class="number">8</span>，<span class="number">6</span>）=<span class="number">8</span>  </div><div class="line">     i=<span class="number">4</span>：  </div><div class="line">         F（<span class="number">4</span>）=max（F（<span class="number">3</span>）-<span class="number">15</span>，-<span class="number">15</span>）=max（<span class="number">8</span>-<span class="number">15</span>，-<span class="number">15</span>）=-<span class="number">7</span>  </div><div class="line">         res=max（F（<span class="number">4</span>），res）=max（-<span class="number">7</span>，<span class="number">8</span>）=<span class="number">8</span>  </div><div class="line">     以此类推  </div><div class="line">     最终res的值为<span class="number">8</span></div></pre></td></tr></table></figure><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> res = array[<span class="number">0</span>];</div><div class="line">        <span class="keyword">int</span> max = array[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;array.length;i++)&#123;</div><div class="line">            max=Math.max(max+array[i],array[i]);</div><div class="line">            res = Math.max(max,res);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="十二、从1到n整数中1出现的次数（剑32）"><a href="#十二、从1到n整数中1出现的次数（剑32）" class="headerlink" title="十二、从1到n整数中1出现的次数（剑32）"></a>十二、从1到n整数中1出现的次数（剑32）</h2><p>输入一个整数n，求1到n这n个整数的十进制表示中1出现的次数。例如输入12，从1到12这些整数中包含1的数字有1、10、11、12，1一共出现了5次。</p><p>一、1的数目</p><p>编程之美上给出的规律：</p><ol><li>如果第i位（自右至左，从1开始标号）上的数字为0，则第i位可能出现1的次数由更高位决定（若没有高位，视高位为0），等于更高位数字X当前位数的权重$10^{i-1}$。</li><li>如果第i位上的数字为1，则第i位上可能出现1的次数不仅受更高位影响，还受低位影响（若没有低位，视低位为0），等于更高位数字X当前位数的权重$10^{i-1}+$（低位数字+1）。</li><li>如果第i位上的数字大于1，则第i位上可能出现1的次数仅由更高位决定（若没有高位，视高位为0），等于（更高位数字+1）X当前位数的权重$10^{i-1}$。</li></ol><p>二、X的数目<br>这里的  X∈[1,9] ，因为  X=0  不符合下列规律，需要单独计算。<br>首先要知道以下的规律：</p><ul><li>从 1 至 10，在它们的个位数中，任意的 X 都出现了 1 次。</li><li>从 1 至 100，在它们的十位数中，任意的 X 都出现了 10 次。</li><li>从 1 至 1000，在它们的百位数中，任意的 X 都出现了 100 次。</li></ul><p>依此类推，从 1 至  $10^i$ ，在它们的左数第二位（右数第  i  位）中，任意的 X 都出现了  $10^{i−1}$  次。</p><p>这个规律很容易验证，这里不再多做说明。</p><p>接下来以  n=2593,X=5  为例来解释如何得到数学公式。从 1 至 2593 中，数字 5 总计出现了 813 次，其中有 259 次出现在个位，260 次出现在十位，294 次出现在百位，0 次出现在千位。</p><p>现在依次分析这些数据，首先是个位。从 1 至 2590 中，包含了 259 个 10，因此任意的 X 都出现了 259 次。最后剩余的三个数 2591, 2592 和 2593，因为它们最大的个位数字 3 &lt; X，因此不会包含任何 5。（也可以这么看，3&lt;X，则个位上可能出现的X的次数仅由更高位决定，等于更高位数字$（259）\times 10^{1-1}=259$）。</p><p>然后是十位。从 1 至 2500 中，包含了 25 个 100，因此任意的 X 都出现了  25×10=250  次。剩下的数字是从 2501 至 2593，它们最大的十位数字9&gt;X，因此会包含全部10个5。最后总计250 + 10 = 260。（也可以这么看，9&gt;X，则十位上可能出现的X的次数仅由更高位决定，等于更高位数字$（25+1）\times 10^{2-1}=260$）。</p><p>接下来是百位。从 1 至 2000 中，包含了 2 个 1000，因此任意的 X 都出现了  2×100=200  次。剩下的数字是从 2001 至 2593，它们最大的百位数字 5 == X，这时情况就略微复杂，它们的百位肯定是包含 5 的，但不会包含全部 100 个。如果把百位是 5 的数字列出来，是从 2500 至 2593，数字的个数与百位和十位数字相关，是 93+1 = 94。最后总计 200 + 94 = 294。（也可以这么看，5==X，则百位上可能出现X的次数不仅受更高位影响，还受低位影响，等于更高位数字$（2）\times 10^{3-1}+（93+1）=294$）。</p><p>最后是千位。现在已经没有更高位，因此直接看最大的千位数字 2 &lt; X，所以不会包含任何 5。（也可以这么看，2&lt;X，则千位上可能出现的X的次数仅由更高位决定，等于更高位数字$（0）\times 10^{4-1}=0$）。</p><p>到此为止，已经计算出全部数字 5 的出现次数。<br>总结一下以上的算法，可以看到，当计算右数第  i  位包含的 X 的个数时：</p><ul><li>取第  i  位左边（高位）的数字，乘以$10^{i−1}$ ，得到基础值a 。</li><li>取第  i  位数字，计算修正值：<ul><li>如果大于 X，则结果为  $a+ 10^{i−1}$ 。 </li><li>如果小于 X，则结果为  a 。</li><li>如果等 X，则取第  i  位右边（低位）数字，设为  b ，最后结果为  a+b+1 。</li></ul></li></ul><p>相应的代码非常简单，效率也非常高，时间复杂度只有 $ O( log_ {10} n) $。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> len = getLenOfNum(n);</div><div class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> tmp = (<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, len - <span class="number">1</span>);</div><div class="line">        <span class="keyword">int</span> first = n / tmp;</div><div class="line">        <span class="keyword">int</span> firstOneNum = first == <span class="number">1</span> ? n % tmp + <span class="number">1</span> : tmp;</div><div class="line">        <span class="keyword">int</span> otherOneNUm = first * (len - <span class="number">1</span>) * (tmp / <span class="number">10</span>);</div><div class="line">        <span class="keyword">return</span> firstOneNum + otherOneNUm + NumberOf1Between1AndN_Solution(n % tmp);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getLenOfNum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</div><div class="line">            len++;</div><div class="line">            n /= <span class="number">10</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> len;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="十三、把数组排成最小的数（剑33）"><a href="#十三、把数组排成最小的数（剑33）" class="headerlink" title="十三、把数组排成最小的数（剑33）"></a>十三、把数组排成最小的数（剑33）</h2><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.Collections;</div><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n;</div><div class="line">        String s=<span class="string">""</span>;</div><div class="line">        ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        n=numbers.length;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</div><div class="line">            list.add(numbers[i]);<span class="comment">//将数组放入arrayList中</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//实现了Comparator接口的compare方法，将集合元素按照compare方法的规则进行排序</span></div><div class="line">        Collections.sort(list,<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;         </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer str1, Integer str2)</span> </span>&#123;</div><div class="line">                <span class="comment">// TODO Auto-generated method stub         </span></div><div class="line">                    String s1=str1+<span class="string">""</span>+str2;</div><div class="line">                    String s2=str2+<span class="string">""</span>+str1;</div><div class="line">                     </div><div class="line">                    <span class="keyword">return</span> s1.compareTo(s2);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j:list)&#123;</div><div class="line">            s+=j;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> s;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="十四、丑数（剑34）"><a href="#十四、丑数（剑34）" class="headerlink" title="十四、丑数（剑34）"></a>十四、丑数（剑34）</h2><p>把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(index&lt;<span class="number">7</span>)<span class="keyword">return</span> index;</div><div class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[index];</div><div class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> t2 = <span class="number">0</span>, t3 = <span class="number">0</span>, t5 = <span class="number">0</span>, i;</div><div class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;index;i++)&#123;</div><div class="line">            res[i] = min(res[t2]*<span class="number">2</span>,min(res[t3]*<span class="number">3</span>,res[t5]*<span class="number">5</span>));</div><div class="line">            <span class="keyword">if</span>(res[i] == res[t2]*<span class="number">2</span>)t2++;</div><div class="line">            <span class="keyword">if</span>(res[i] == res[t3]*<span class="number">3</span>)t3++;</div><div class="line">            <span class="keyword">if</span>(res[i] == res[t5]*<span class="number">5</span>)t5++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res[index-<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> (a&gt;b)? b:a;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="十五、数组中的逆序对（剑36）"><a href="#十五、数组中的逆序对（剑36）" class="headerlink" title="十五、数组中的逆序对（剑36）"></a>十五、数组中的逆序对（剑36）</h2><p>在数组中的两个数字如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。例如在数组{7，5，6，4}中，一共存在5个逆序对，分别是（7，6）、（7，5）、（7，4）、（5，4）和（6，4）。</p><p>可以按照归并排序的思路，先把数组分隔成子数组，先统计出子数组内部的逆序对的数目，然后再统计出两个相邻子数组之间的逆序对的数目。在统计逆序对的过程中，还需要对数组进行排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    int cnt;</div><div class="line"> </div><div class="line">    public int InversePairs(int[] array) &#123;</div><div class="line">        cnt = 0;</div><div class="line">        if (array != null)</div><div class="line">            mergeSortUp2Down(array, 0, array.length - 1);</div><div class="line">        return cnt;</div><div class="line">    &#125; </div><div class="line">    /*</div><div class="line">     * 归并排序(从上往下)</div><div class="line">     */</div><div class="line">    public void mergeSortUp2Down(int[] a, int start, int end) &#123;</div><div class="line">        if (start &gt;= end)</div><div class="line">            return;</div><div class="line">        int mid = (start + end) &gt;&gt; 1;</div><div class="line"> </div><div class="line">        mergeSortUp2Down(a, start, mid);</div><div class="line">        mergeSortUp2Down(a, mid + 1, end);</div><div class="line"> </div><div class="line">        merge(a, start, mid, end);</div><div class="line">    &#125; </div><div class="line">    /*</div><div class="line">     * 将一个数组中的两个相邻有序区间合并成一个</div><div class="line">     */</div><div class="line">    public void merge(int[] a, int start, int mid, int end) &#123;</div><div class="line">        int[] tmp = new int[end - start + 1];</div><div class="line"> </div><div class="line">        int i = start, j = mid + 1, k = 0;</div><div class="line">        while (i &lt;= mid &amp;&amp; j &lt;= end) &#123;</div><div class="line">            if (a[i] &lt;= a[j])</div><div class="line">                tmp[k++] = a[i++];</div><div class="line">            else &#123;</div><div class="line">                tmp[k++] = a[j++];</div><div class="line">                cnt += mid - i + 1;  //关键的一步，统计逆序对..........</div><div class="line">                cnt%=1000000007;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        while (i &lt;= mid)</div><div class="line">            tmp[k++] = a[i++];</div><div class="line">        while (j &lt;= end)</div><div class="line">            tmp[k++] = a[j++];</div><div class="line">        for (k = 0; k &lt; tmp.length; k++)</div><div class="line">            a[start + k] = tmp[k];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="十六、数字在排序数组中出现的次数（剑38）"><a href="#十六、数字在排序数组中出现的次数（剑38）" class="headerlink" title="十六、数字在排序数组中出现的次数（剑38）"></a>十六、数字在排序数组中出现的次数（剑38）</h2><p>统计一个数字在排序数组中出现的次数。</p><p>利用二分查找直接找到第一个K和最后一个K。以下代码使用递归方法找到第一个K，使用循环方法最后一个K。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> length = array.length;</div><div class="line">        <span class="keyword">if</span>(length == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> firstK = getFirstK(array, k, <span class="number">0</span>, length-<span class="number">1</span>);</div><div class="line">        <span class="keyword">int</span> lastK = getLastK(array, k, <span class="number">0</span>, length-<span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span>(firstK != -<span class="number">1</span> &amp;&amp; lastK != -<span class="number">1</span>)&#123;</div><div class="line">             <span class="keyword">return</span> lastK - firstK + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//递归写法</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getFirstK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> mid = (start + end) &gt;&gt; <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(array[mid] &gt; k)&#123;</div><div class="line">            <span class="keyword">return</span> getFirstK(array, k, start, mid-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (array[mid] &lt; k)&#123;</div><div class="line">            <span class="keyword">return</span> getFirstK(array, k, mid+<span class="number">1</span>, end);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(mid-<span class="number">1</span> &gt;=<span class="number">0</span> &amp;&amp; array[mid-<span class="number">1</span>] == k)&#123;</div><div class="line">            <span class="keyword">return</span> getFirstK(array, k, start, mid-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> mid;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//循环写法</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getLastK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> length = array.length;</div><div class="line">        <span class="keyword">int</span> mid = (start + end) &gt;&gt; <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(start &lt;= end)&#123;</div><div class="line">            <span class="keyword">if</span>(array[mid] &gt; k)&#123;</div><div class="line">                end = mid-<span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[mid] &lt; k)&#123;</div><div class="line">                start = mid+<span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mid+<span class="number">1</span> &lt;= length-<span class="number">1</span> &amp;&amp; array[mid+<span class="number">1</span>] == k)&#123;</div><div class="line">                start = mid+<span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">return</span> mid;</div><div class="line">                &#125;</div><div class="line">            mid = (start + end) &gt;&gt; <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="十七、数组中只出现一次的数字（剑40）"><a href="#十七、数组中只出现一次的数字（剑40）" class="headerlink" title="十七、数组中只出现一次的数字（剑40）"></a>十七、数组中只出现一次的数字（剑40）</h2><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是$O(n)$，空间复杂度是$O(1)$。</p><p>首先我们考虑这个问题的一个简单版本：一个数组里除了一个数字之外，其他的数字都出现了两次。请写程序找出这个只出现一次的数字。</p><p>这个题目的突破口在哪里？题目为什么要强调有一个数字出现一次，其他的出现两次？我们想到了异或运算的性质：任何一个数字异或它自己都等于0 。也就是说，如果我们从头到尾依次异或数组中的每一个数字，那么最终的结果刚好是那个只出现一次的数字，因为那些出现两次的数字全部在异或中抵消掉了。</p><p>有了上面简单问题的解决方案之后，我们回到原始的问题。如果能够把原数组分为两个子数组。在每个子数组中，包含一个只出现一次的数字，而其它数字都出现两次。如果能够这样拆分原数组，按照前面的办法就是分别求出这两个只出现一次的数字了。<br> 我们还是从头到尾依次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次的数字的异或结果。因为其它数字都出现了两次，在异或中全部抵消掉了。由于这两个数字肯定不一样，那么这个异或结果肯定不为0 ，也就是说在这个结果数字的二进制表示中至少就有一位为1 。我们在结果数字中找到第一个为1 的位的位置，记为第N 位。现在我们以第N 位是不是1 为标准把原数组中的数字分成两个子数组，第一个子数组中每个数字的第N 位都为1 ，而第二个子数组的每个数字的第N 位都为0 。<br> 现在我们已经把原数组分成了两个子数组，每个子数组都包含一个只出现一次的数字，而其它数字都出现了两次。因此到此为止，所有的问题我们都已经解决。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//num1,num2分别为长度为1的数组。传出参数</span></div><div class="line"><span class="comment">//将num1[0],num2[0]设置为返回结果</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> num1[] , <span class="keyword">int</span> num2[])</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span>(array==<span class="keyword">null</span> ||array.length&lt;<span class="number">2</span>)</div><div class="line">           <span class="keyword">return</span> ;</div><div class="line">       <span class="keyword">int</span> temp = <span class="number">0</span>;</div><div class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)</div><div class="line">           temp ^= array[i];</div><div class="line">        </div><div class="line">       <span class="keyword">int</span> indexOf1 = findFirstBitIs(temp);</div><div class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</div><div class="line">           <span class="keyword">if</span>(isBit(array[i], indexOf1))</div><div class="line">               num1[<span class="number">0</span>]^=array[i];</div><div class="line">           <span class="keyword">else</span></div><div class="line">               num2[<span class="number">0</span>]^=array[i];</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">    <span class="comment">//在正数num的二进制表示中找到最右边是1的位</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findFirstBitIs</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</div><div class="line">       <span class="keyword">int</span> indexBit = <span class="number">0</span>;</div><div class="line">       <span class="keyword">while</span>(((num &amp; <span class="number">1</span>)==<span class="number">0</span>) &amp;&amp; (indexBit)&lt;<span class="number">8</span>*<span class="number">4</span>)&#123;</div><div class="line">           num = num &gt;&gt; <span class="number">1</span>;</div><div class="line">           ++indexBit;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> indexBit;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">//判断在num的二进制表示中从右边数起的indexBit位是不是1.</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBit</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> indexBit)</span></span>&#123;</div><div class="line">       num = num &gt;&gt; indexBit;</div><div class="line">       <span class="keyword">return</span> (num &amp; <span class="number">1</span>) == <span class="number">1</span>;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="十八、-和为s的两个数字（剑41-1）"><a href="#十八、-和为s的两个数字（剑41-1）" class="headerlink" title="十八、 和为s的两个数字（剑41.1）"></a>十八、 和为s的两个数字（剑41.1）</h2><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p><p>数列满足递增，设两个头尾两个指针i和j， </p><ul><li>若ai + aj == sum，就是答案（相差越远乘积越小） </li><li>若ai + aj &gt; sum，aj肯定不是答案之一（前面已得出 i 前面的数已是不可能），j -= 1 </li><li>若ai + aj &lt; sum，ai肯定不是答案之一（前面已得出 j 后面的数已是不可能），i += 1 </li></ul><p>时间复杂度为O(n)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">public class Solution &#123;</div><div class="line">    public ArrayList&lt;Integer&gt; FindNumbersWithSum(int [] array,int sum) &#123;</div><div class="line">        ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</div><div class="line">        if(array==null||array.length&lt;2)&#123;</div><div class="line">            return list;</div><div class="line">        &#125;</div><div class="line">        int i=0,j=array.length-1;</div><div class="line">        while(i&lt;j)&#123;</div><div class="line">            if(array[i]+array[j]==sum)&#123;</div><div class="line">                list.add(array[i]);</div><div class="line">                list.add(array[j]);</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            else if(array[i]+array[j]&gt;sum)&#123;</div><div class="line">                j--;</div><div class="line">            &#125;</div><div class="line">            else</div><div class="line">                i++;</div><div class="line">        &#125;</div><div class="line">        return list;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="十九、和为s的连续正数序列（剑41-2）"><a href="#十九、和为s的连续正数序列（剑41-2）" class="headerlink" title="十九、和为s的连续正数序列（剑41.2）"></a>十九、和为s的连续正数序列（剑41.2）</h2><p>输入一个正数s，打印出所有和为s的连续正数序列（至少含有两个数）。例如输入15，由于1+2+3+4+5=4+5+6=7+8=15，所以结果打印出三个连续序列1~5、4~6和7~8。</p><p>考虑用两个数small和big分别表示序列的最小值和最大值。首先把small初始化为1，big初始化为2，如果从small到big的序列和大于s，我们可以从序列中去掉较小的值，也就是增大small的值。如果从small到big的序列和小于s，我们可以增大big，让这个序列包含更多的数字。因为这个序列至少要有两个数字，我们一直增加small到（1+s）/2为止。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="comment">/*</span></div><div class="line">*初始化small=1，big=2;</div><div class="line">*small到big序列和小于sum，big++;大于sum，small++;</div><div class="line">*当small增加到(1+sum)/2是停止</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</div><div class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; lists=<span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</div><div class="line">        <span class="keyword">if</span>(sum&lt;=<span class="number">1</span>)&#123;<span class="keyword">return</span> lists;&#125;</div><div class="line">        <span class="keyword">int</span> small=<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> big=<span class="number">2</span>;</div><div class="line">        <span class="keyword">while</span>(small!=(<span class="number">1</span>+sum)/<span class="number">2</span>)&#123;          <span class="comment">//当small==(1+sum)/2的时候停止</span></div><div class="line">            <span class="keyword">int</span> curSum=sumOfList(small,big);</div><div class="line">            <span class="keyword">if</span>(curSum==sum)&#123;</div><div class="line">                ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=small;i&lt;=big;i++)&#123;</div><div class="line">                    list.add(i);</div><div class="line">                &#125;</div><div class="line">                lists.add(list);</div><div class="line">                small++;big++;</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curSum&lt;sum)&#123;</div><div class="line">                big++;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                small++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> lists;</div><div class="line">    &#125;     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfList</span><span class="params">(<span class="keyword">int</span> head,<span class="keyword">int</span> leap)</span></span>&#123;        <span class="comment">//计算当前序列的和</span></div><div class="line">        <span class="keyword">int</span> sum=head;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head+<span class="number">1</span>;i&lt;=leap;i++)&#123;</div><div class="line">            sum+=i;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="二十、扑克牌的顺子（剑44）"><a href="#二十、扑克牌的顺子（剑44）" class="headerlink" title="二十、扑克牌的顺子（剑44）"></a>二十、扑克牌的顺子（剑44）</h2><p>从扑克牌中随机抽5张牌，判断是不是顺子，即这5张牌是不是连续的。2~10为数字本身，A为1，J为11，Q为12，K为13，而大小王可以看做是任意数字，这里定为0.</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContinuous</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> length = numbers.length;</div><div class="line">        <span class="keyword">if</span>(numbers==<span class="keyword">null</span>||length==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//特殊情况</span></div><div class="line">        Arrays.sort(numbers);<span class="comment">//排序</span></div><div class="line">        <span class="comment">//统计数组中0的个数</span></div><div class="line">        <span class="keyword">int</span> numberOfZero = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;length&amp;&amp;numbers[i]==<span class="number">0</span>;i++)&#123;</div><div class="line">            ++numberOfZero;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> numberOfGap = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> small = numberOfZero;</div><div class="line">        <span class="keyword">int</span> big = small+<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(big&lt;length)&#123;</div><div class="line">            <span class="comment">//含有对子，不可能是顺子</span></div><div class="line">            <span class="keyword">if</span>(numbers[small]==numbers[big])&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//统计数组中的间隔数目</span></div><div class="line">            numberOfGap += numbers[big]-numbers[small]-<span class="number">1</span>;</div><div class="line">            small=big;</div><div class="line">            big++;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果间隔数小于等于零的数量则可以组成顺子，否则不行。</span></div><div class="line">        <span class="keyword">if</span>(numberOfGap&lt;=numberOfZero)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="二十一、求1-2-…-n（剑46）"><a href="#二十一、求1-2-…-n（剑46）" class="headerlink" title="二十一、求1+2+…..+n（剑46）"></a>二十一、求1+2+…..+n（剑46）</h2><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><ol><li>需利用逻辑与的短路特性实现递归终止。 </li><li>当n==0时，(n&gt;0)&amp;&amp;((sum+=Sum_Solution(n-1))&gt;0)只执行前面的判断，为false，然后直接返回0；</li><li>当n&gt;0时，执行sum+=Sum_Solution(n-1)，实现递归计算Sum_Solution(n)。</li></ol><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> sum=n;</div><div class="line">        <span class="keyword">boolean</span> ans = (n&gt;<span class="number">0</span>)&amp;&amp;((sum+=Sum_Solution(n-<span class="number">1</span>))&gt;<span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="二十二、数组中重复的数字（剑51）"><a href="#二十二、数组中重复的数字（剑51）" class="headerlink" title="二十二、数组中重复的数字（剑51）"></a>二十二、数组中重复的数字（剑51）</h2><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是重复的数字2或者3。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(numbers==<span class="keyword">null</span>||length==<span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;<span class="comment">//空指针或空数组</span></div><div class="line">        <span class="comment">// 判断数组是否合法,即每个数都在0~n-1之间</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(numbers[i]&gt;length-<span class="number">1</span>||numbers[i]&lt;<span class="number">0</span>)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//若数值与下标不同，则调换位置；</span></div><div class="line">        <span class="comment">//比较位置下标为数值(numbers[i])的数值(numbers[numbers[i]])与该数值(numbers[i])是否一致，若一致，则说明有重复数字</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</div><div class="line">            <span class="keyword">while</span>(numbers[i]!=i)&#123;</div><div class="line">                <span class="keyword">if</span>(numbers[i]==numbers[numbers[i]])&#123;</div><div class="line">                    duplication[<span class="number">0</span>] = numbers[i];</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">int</span> temp=numbers[i];</div><div class="line">                numbers[i]=numbers[temp];</div><div class="line">                numbers[temp]=temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="二十三、构建乘积数组（剑52）"><a href="#二十三、构建乘积数组（剑52）" class="headerlink" title="二十三、构建乘积数组（剑52）"></a>二十三、构建乘积数组（剑52）</h2><p> 给定一个数组A[0,1,…,n-1],请构建一个数组$B[0,1,…,n-1]$,其中B中的元素$B[i]=A[0]<em>A[1]</em>…<em>A[i-1]</em>A[i+1]<em>…</em>A[n-1]$。不能使用除法。</p><p><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-02 下午7.43.57.png" alt="屏幕快照 2017-08-02 下午7.43.57"></p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] A) &#123;</div><div class="line">        <span class="keyword">int</span> length = A.length;</div><div class="line">        <span class="keyword">int</span>[] B = <span class="keyword">new</span> <span class="keyword">int</span>[length];</div><div class="line">        <span class="keyword">if</span>(length!=<span class="number">0</span>)&#123;</div><div class="line">            B[<span class="number">0</span>]=<span class="number">1</span>;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length;i++)&#123;</div><div class="line">                B[i]=B[i-<span class="number">1</span>]*A[i-<span class="number">1</span>];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">int</span> temp=<span class="number">1</span>;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=length-<span class="number">2</span>;j&gt;=<span class="number">0</span>;j--)&#123;                </div><div class="line">                temp = temp*A[j+<span class="number">1</span>];</div><div class="line">                B[j]=temp*B[j];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> B;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="二十四、-滑动窗口的最大值（剑65）"><a href="#二十四、-滑动窗口的最大值（剑65）" class="headerlink" title="二十四、 滑动窗口的最大值（剑65）"></a>二十四、 滑动窗口的最大值（剑65）</h2><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p><p><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-03 下午1.37.31.png" alt="屏幕快照 2017-08-03 下午1.37.31"></p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.LinkedList;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)</span></span></div><div class="line">    &#123;</div><div class="line">        ArrayList&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">if</span> (num == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> ret;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (num.length &lt; size || size &lt; <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> ret;</div><div class="line">        &#125;</div><div class="line">         </div><div class="line">        LinkedList&lt;Integer&gt; indexDeque = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="comment">//前size-1个中，前面比num[i]小的，对应下标从下标队列移除；</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (!indexDeque.isEmpty() &amp;&amp; num[i] &gt; num[indexDeque.getLast()]) &#123;</div><div class="line">                indexDeque.removeLast();</div><div class="line">            &#125;</div><div class="line">            indexDeque.addLast(i);</div><div class="line">        &#125;        </div><div class="line">        <span class="comment">//从第size-1个开始；前面比num[i]小的，对应下标从下标队列移除；</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &lt; num.length; i++) &#123;</div><div class="line">            <span class="keyword">while</span>(!indexDeque.isEmpty() &amp;&amp; num[i] &gt; num[indexDeque.getLast()]) &#123;</div><div class="line">                indexDeque.removeLast();</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//把下一个下标加入队列中</span></div><div class="line">            indexDeque.addLast(i);</div><div class="line">            <span class="comment">//当第一个数字的下标与当前处理的数字的下标之差大于或者等于滑动窗口的大小时，这个数字已经从窗口划出，可以移除了；</span></div><div class="line">            <span class="keyword">if</span> (i - indexDeque.getFirst() + <span class="number">1</span> &gt; size) &#123;</div><div class="line">                indexDeque.removeFirst();</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//下标队列的第一个是滑动窗口最大值对应的下标；</span></div><div class="line">            ret.add(num[indexDeque.getFirst()]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ret;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="二十五、矩阵中的路径（剑66）"><a href="#二十五、矩阵中的路径（剑66）" class="headerlink" title="二十五、矩阵中的路径（剑66）"></a>二十五、矩阵中的路径（剑66）</h2><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如下面的矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-03 下午1.43.55.png" alt="屏幕快照 2017-08-03 下午1.43.55"></p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">boolean</span>[] visited=<span class="keyword">new</span> <span class="keyword">boolean</span>[rows*cols];</div><div class="line">        <span class="keyword">return</span> movingCountCore(threshold, rows, cols, <span class="number">0</span>,<span class="number">0</span>,visited);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">movingCountCore</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols,</span></span></div><div class="line">            <span class="keyword">int</span> row,<span class="keyword">int</span> col,<span class="keyword">boolean</span>[] visited) &#123;</div><div class="line">        <span class="keyword">if</span>(row&lt;<span class="number">0</span>||row&gt;=rows||col&lt;<span class="number">0</span>||col&gt;=cols) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> i=row*cols+col;</div><div class="line">        <span class="keyword">if</span>(visited[i]||!checkSum(threshold,row,col)) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        visited[i]=<span class="keyword">true</span>;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>+movingCountCore(threshold, rows, cols,row,col+<span class="number">1</span>,visited)</div><div class="line">                +movingCountCore(threshold, rows, cols,row,col-<span class="number">1</span>,visited)</div><div class="line">                +movingCountCore(threshold, rows, cols,row+<span class="number">1</span>,col,visited)</div><div class="line">                +movingCountCore(threshold, rows, cols,row-<span class="number">1</span>,col,visited);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkSum</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(row!=<span class="number">0</span>)&#123;</div><div class="line">            sum+=row%<span class="number">10</span>;</div><div class="line">            row=row/<span class="number">10</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(col!=<span class="number">0</span>)&#123;</div><div class="line">            sum+=col%<span class="number">10</span>;</div><div class="line">            col=col/<span class="number">10</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(sum&gt;threshold) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="二十六、寻找某个值的区间（leetcode-34-Search-for-a-Range）"><a href="#二十六、寻找某个值的区间（leetcode-34-Search-for-a-Range）" class="headerlink" title="二十六、寻找某个值的区间（leetcode 34 Search for a Range）"></a>二十六、寻找某个值的区间（leetcode 34 Search for a Range）</h2><p>主要考查二分查找，如果读者对二分查找不是很熟悉，这里推荐一篇博客：<a href="http://blog.csdn.net/int64ago/article/details/7425727/" target="_blank" rel="noopener">你真的会二分查找吗？</a>上面讲得非常详细。</p><p>这题要求在一个排好序可能有重复元素的数组里面找到包含某个值的区间范围。要求使用O(log n)的时间，所以我们采用两次二分查找。</p><p>主要实现两个方法：</p><ul><li>searchRightIndex：查找并返回target出现在nums数组最右边的index。注意一点，如果target比数组最小值还小，那么返回-1</li><li>searchLeftIndex：查找并返回target出现在nums数组最左边的index。如果target比数组最大值还大，那么返回nums.length</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public int[] searchRange(int[] nums, int target) &#123;  </div><div class="line">    int[] result = &#123;-1, -1&#125;;  </div><div class="line">    int index = searchRightIndex(nums, 0, nums.length - 1, target);  </div><div class="line">    if (index &lt; 0 || nums[index] != target)  </div><div class="line">        return result;  </div><div class="line">    result[0] = searchLeftIndex(nums, 0, index, target);  </div><div class="line">    result[1] = index;  </div><div class="line">    return result;  </div><div class="line">    &#125;  </div><div class="line">    //查找并返回target出现在nums数组最右边的index</div><div class="line">    public int searchRightIndex(int[] nums, int left, int right, int target) &#123;  </div><div class="line">        while (left &lt;= right) &#123;  </div><div class="line">            int mid = (left + right) / 2;  </div><div class="line">            if (nums[mid] &gt; target) right = mid - 1;  </div><div class="line">            else left = mid + 1;  </div><div class="line">        &#125;  </div><div class="line">        return right;  </div><div class="line">    &#125;  </div><div class="line">    //查找并返回target出现在nums数组最左边的index</div><div class="line">    public int searchLeftIndex(int[] nums, int left, int right, int target) &#123;  </div><div class="line">        while (left &lt;= right) &#123;  </div><div class="line">            int mid = (left + right) / 2;  </div><div class="line">            if (nums[mid] &lt; target) left = mid + 1;  </div><div class="line">            else right = mid - 1;  </div><div class="line">        &#125;  </div><div class="line">        return left;  </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="二十七、第K个数的问题"><a href="#二十七、第K个数的问题" class="headerlink" title="二十七、第K个数的问题"></a>二十七、第K个数的问题</h2><h3 id="27-1-无序数组寻找第K大的数"><a href="#27-1-无序数组寻找第K大的数" class="headerlink" title="27.1 无序数组寻找第K大的数"></a>27.1 无序数组寻找第K大的数</h3><p>这题是一道很好的面试题目，首先题目短小，很快就能说清题意而且有很多种解法。从简单到复杂的解法都有，梯度均匀。解决它不需要预先知道特殊领域知识。</p><p>这题有很多思路：</p><ol><li>按从大到小全排序，然后取第k个元素，时间复杂度O(nlogn)，空间复杂度O(1)</li><li>利用堆进行部分排序。维护一个大根堆，将数组元素全部压入堆，然后弹出k次，第k个就是答案。时间复杂度$O(klogn)$，空间复杂度$O(n)$</li><li>选择排序，第k次选择后即可得到第k大的数，时间复杂度O(nk)，空间复杂度O(1)</li></ol><p>以上三种方法时间复杂度太高。下面介绍两种更好的方法：</p><blockquote><p>第一种</p></blockquote><p>利用快速排序中的partition思想，从数组中随机选择一个基准pivot，把数组划分为左右两部分，左边部分元素小于pivot，右边部分元素大于或等于pivot。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        k = nums.length-k;<span class="comment">//找前K大的</span></div><div class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> high = nums.length-<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</div><div class="line">            <span class="keyword">int</span> pivotloc = partition(nums,low,high);</div><div class="line">            <span class="keyword">if</span>(pivotloc==k) </div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(k&lt;pivotloc)&#123;<span class="comment">//左边</span></div><div class="line">                high = pivotloc-<span class="number">1</span>;</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k&gt;pivotloc)&#123;</div><div class="line">                low = pivotloc+<span class="number">1</span>;<span class="comment">//在右边</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> nums[k];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</div><div class="line"><span class="keyword">int</span> pivot = nums[low];</div><div class="line"><span class="keyword">while</span>(low&lt;high)&#123;</div><div class="line"><span class="keyword">while</span>(low&lt;high &amp;&amp; nums[high]&gt;=pivot) high--;</div><div class="line">nums[low]=nums[high];</div><div class="line"><span class="keyword">while</span>(low&lt;high &amp;&amp; nums[low]&lt;=pivot) low++;</div><div class="line">nums[high] =nums[low];</div><div class="line">    &#125;</div><div class="line">nums[low]=pivot;</div><div class="line"><span class="keyword">return</span> low;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>第二种方法：</p></blockquote><p>遍历数组时将数字加入优先队列（堆），一旦堆的大小大于k就将堆顶元素去除，确保堆的大小为k。遍历完后堆顶就是返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        PriorityQueue&lt;Integer&gt; p = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length; i++)&#123;</div><div class="line">            p.add(nums[i]);</div><div class="line">            <span class="keyword">if</span>(p.size()&gt;k) p.poll();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> p.poll();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="27-2-两个有序数组的第K大的数"><a href="#27-2-两个有序数组的第K大的数" class="headerlink" title="27.2 两个有序数组的第K大的数"></a>27.2 两个有序数组的第K大的数</h3><p>两个有序数组，寻找归并排序后数组的中位数/第 k 大数字（与二分有关）；</p><h3 id="27-3-N个有序数组求最大的K个数"><a href="#27-3-N个有序数组求最大的K个数" class="headerlink" title="27.3 N个有序数组求最大的K个数"></a>27.3 N个有序数组求最大的K个数</h3><h3 id="27-4-求两个有序数组的中位数"><a href="#27-4-求两个有序数组的中位数" class="headerlink" title="27.4 求两个有序数组的中位数"></a>27.4 求两个有序数组的中位数</h3><h2 id="二十八、求根算法（-LeetCode-69）"><a href="#二十八、求根算法（-LeetCode-69）" class="headerlink" title="二十八、求根算法（ LeetCode 69）"></a>二十八、求根算法（ LeetCode 69）</h2><p>这道题要找x的平方根，x的平方根肯定小于x/2。要在[1,x/2]有序序列当中找一个数，用二分法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;  </div><div class="line">    <span class="keyword">long</span> high = (x / <span class="number">2</span>) + <span class="number">1</span>;  </div><div class="line">    <span class="keyword">long</span> low = <span class="number">0</span>;  </div><div class="line">    <span class="keyword">while</span> (high &gt;= low) &#123;  </div><div class="line">        <span class="keyword">long</span> mid = (high + low) / <span class="number">2</span>;  </div><div class="line">        <span class="keyword">if</span> (mid * mid == x)  </div><div class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)mid;  </div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mid * mid &gt; x)  </div><div class="line">            high = mid - <span class="number">1</span>;  </div><div class="line">        <span class="keyword">else</span>  </div><div class="line">            low = mid + <span class="number">1</span>;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)high;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>二分法在数值计算中非常常见，还是得熟练掌握。其实这个题目还有另一种方法，称为牛顿法。不过他更多的是一种数学方法，算法在这里没有太多体现，不过牛顿法是数值计算中非常重要的方法，所以我还是介绍一下。不太了解牛顿法基本思想的朋友，可以参考一下牛顿法-维基百科。一般牛顿法是用数值方法来解一个f(y)=0的方程（为什么变量在这里用y是因为我们要求的开方是x，避免歧义）。对于这个问题我们构造f(y)=y^2-x，其中x是我们要求平方根的数，那么当f(y)=0时，即y^2-x=0,所以y=sqrt(x),即是我们要求的平方根。f(y)的导数f’(y)=2*y，根据牛顿法的迭代公式我们可以得到y_(n+1)=y_n-f(n)/f’(n)=(y_n+x/y_n)/2。最后根据以上公式来迭代解以上方程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">    <span class="keyword">double</span> lastY = <span class="number">0</span>;  </div><div class="line">    <span class="keyword">double</span> y = <span class="number">1</span>;  </div><div class="line">    <span class="keyword">while</span> (y != lastY)  </div><div class="line">    &#123;  </div><div class="line">        lastY = y;  </div><div class="line">        y = (y + x / y) / <span class="number">2</span>;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(y);  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="面经中出现过的数组题"><a href="#面经中出现过的数组题" class="headerlink" title="面经中出现过的数组题"></a>面经中出现过的数组题</h2><h3 id="已整理"><a href="#已整理" class="headerlink" title="已整理"></a>已整理</h3><ul><li>一、二维数组，每行递增，每列递增,实现查找；二维数组，每行递增，每列递增，求第 k 大的数；</li><li>三、旋转数组的查找；有序数组 从中间某点隔开，右边的放到左边，然后问在这个数组中怎么进行二分查找。讲了思路后手写代码；一维有序数组，经过循环位移后，最小的数出现在数列中间，如果原数组严格递增，如何找这个最小数；如果原数组严格递增或递减，如何找这个最小数；如果原数组非严格递增或递减，如何找这个最小数；</li><li>五、调整数组顺序使奇数位于偶数前面；让一个数组中的所有奇数在前，偶数在后。</li><li>六、顺时针打印矩阵</li><li>九、数组中超过一半的数字；找出数组中出现次数超过一半的数，现在有一个数组，已知一个数出现的次数超过了一半，请用O(n)的复杂度的算法找出这个数我说了一个最简答的，直接遍历数组，用map存储《数，出现的次数》这个键-值对，然后找出超过一半的即可。继续优化，，，，没答上来</li><li>十、最小的K个数；数列中找第 k 大的数字（与快排或堆排序有关）；编程题最少时间复杂度求数组中第k大的数，</li><li>十一、连续子数组的最大和</li><li>十二、从1到n整数中1出现的次数；给你一个数N，问1-N这N个整数里面，每个位上一共出现多少次数字1. 这个是编程之美上的原题。当时看的时候觉得好复杂，最后我也没写出来，当然，面试的技巧就是，无论这道题你会还是不会，尽量把你的思考过程说出来，一方面防止冷场，另一方面可以让他知道你的思考过程。最后面试官让我不用最优的，我就写了个最笨的。</li><li>十五、数组中逆序对计算，打印逆序对儿，如输入数组[1,4,2,5,3]，输出(4,2),(4,3),(5,3)；统计数列中的逆序对（归并排序有关）；</li><li>十八、和为S的两个数字VS和为s的连续正数序列；有序数组寻找和为某数的一对数字；寻找和为定值的多个数；寻找和为定值的两个数</li><li>二十四、滑动窗口的最大值；coding：数组滑动窗口得到最大的窗口，O（n）复杂度、扩展：这个滑动窗口中必须有m个不同才可以，目标不变，如果改，并分析时间复杂度；</li><li>二十六、寻找某个值的区间（leetcode 34 Search for a Range）</li></ul><h3 id="未整理"><a href="#未整理" class="headerlink" title="未整理"></a>未整理</h3><p>数组中后面的数减前面的数的差的最大值，要求时间、空间复杂度尽可能底<br>多个有序数组的归并<br>多个有序数组求交集<br>两个有序数组求差集<br>两个数组，求差集<br>两个集合如何求并集，交集；</p><ul><li>leetcode 89 Gray Code<br>leetcode 42 trapping rain water <a href="http://www.cnblogs.com/fuzhe1989/p/3428553.html" target="_blank" rel="noopener">墙里能装多少水</a></li></ul><p>有一个数组，让找到两个不重复的连续子序列A,B ，求Max(Sum(A)-Sum(B)。 3分钟解出，10分钟写完代码</p><p>LeetCode原题： 有一个集合A包含了一些数，输入N，求元素个数最小的集合B，使得A并B后内的数组合相加能够组成1到N中的所有数</p><p>给定一个数组，长度已知为N（中等），求中位数，要求时间复杂度尽可能小：快排+丢弃长度小于N/2的部分</p><p>给定数组，要求以最小的时间复杂度求得最大最小值：维护一个小数组，只存放两个数，预定义为min和max，后将剩余N-2个数和它们依次比较，大于max的覆盖max，小于min的覆盖min，其余情形的不更新数组。时间复杂度o(n)。</p><p>然后考了个数据结构，给个数组如何建堆<a href="http://xfhnever.com/categories/算法与数据结构/page/2/" target="_blank" rel="noopener">http://xfhnever.com/categories/算法与数据结构/page/2/</a></p><p>一维数组，swap 其中的几对数字（每个数字只属于一次 swap 操作），实现查找（与二分有关）；<br>一个有序数组，其中一个数字发生变异，但不知道变异后会不会影响整体序，如何实现查找；<br>任意交换其中的两数，发现并恢复；</p><p>给定数组，寻找 next big（堆排序有关）；</p><p>数组可能是递增、递减、递减后递增、递增后递减四种情况，递增递减都是非严格的，如果有转折点，返回转折点的值，否则返回-1；</p><p>给出一个数组，返回数组中满足类似a &gt; b &lt; c ＞ｄ这种情况的连续子数组的最大长度。时间复杂度当然是Ｏ（ｎ），比较有意思的题目。</p><p>同样是一个数组，去掉其中一个数，得到与这个数相邻中比较小的那个数的值（如果是最左侧或者最右侧则返回０）。不断重复上面的操作，直到数组为空，返回累加的最大值。</p><p>已知一个数组，有n+2个不同的数，其中n个数出现了偶数次，2个数出现了奇数次，设计算法找出这2个数又只想出一个简单的，用栈，偶数的进出进出，最后在栈中没有了，奇数的进出进，最后会留在栈中。就找到了（这个空间复杂度为O（n）继续优化，，又没想出来。</p><p>写递推公式给定整数n和m，问能不能找出整数x，使得x以后的所有整数都可以由整数n和m组合而成</p><p>区间查询最大值，要求查询复杂度为O(1)，正解为st表，我敲的线段树，也过了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 数组相关题解java实现。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法题解（1）：链表题解</title>
    <link href="http://yoursite.com/2017/08/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%EF%BC%881%EF%BC%89%EF%BC%9A%E9%93%BE%E8%A1%A8%E9%A2%98%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/08/03/数据结构与算法题解（1）：链表题解/</id>
    <published>2017-08-03T11:20:45.000Z</published>
    <updated>2017-12-26T06:34:09.365Z</updated>
    
    <content type="html"><![CDATA[<p>链表相关题解java实现。</p><a id="more"></a><h2 id="一、从尾到头打印链表（剑5）"><a href="#一、从尾到头打印链表（剑5）" class="headerlink" title="一、从尾到头打印链表（剑5）"></a>一、从尾到头打印链表（剑5）</h2><p>输入一个链表的头结点，从尾到头反过来打印每个结点的值（注意不能改变链表的结构）。</p><p>解决这个问题肯定要遍历链表。遍历的顺序是从头到尾的顺序，可输出的顺序却是从尾到头。也就是说第一个遍历到的结点最后一个输出，而最后一个遍历到的结点第一个输出。这就是典型的“后进先出”，我们可以用栈实现这种顺序。没经过一个节点的时候，把该结点放到一个栈中。当遍历完整个链表后，再从栈顶开始逐个输出结点的值，此时输出的结点的顺序就翻转过来了。实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Stack;</div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</div><div class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        <span class="keyword">while</span> (listNode!=<span class="keyword">null</span>)&#123;</div><div class="line">            stack.push(listNode.val);</div><div class="line">            listNode = listNode.next;</div><div class="line">        &#125;</div><div class="line">        ArrayList&lt;Integer&gt; List = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</div><div class="line">            List.add(stack.pop());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> List;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>既然想到了用栈来实现这个函数，而递归在本质上就是一个栈结构，因此可用递归来实现。要实现反过来输出链表，我们每访问到一个节点的时候，先递归输出它后面的结点，再输出该结点自身，这样链表的输出结果就反过来了。实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</div><div class="line">        ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        </div><div class="line">        ListNode pNode=listNode;</div><div class="line">        <span class="keyword">if</span>(pNode!=<span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(pNode.next!=<span class="keyword">null</span>)&#123;</div><div class="line">                list=printListFromTailToHead(pNode.next);</div><div class="line">            &#125;</div><div class="line">            list.add(pNode.val);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> list;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="二、在O-1-时间删除链表结点（剑13）"><a href="#二、在O-1-时间删除链表结点（剑13）" class="headerlink" title="二、在O(1)时间删除链表结点（剑13）"></a>二、在O(1)时间删除链表结点（剑13）</h2><p>给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点。</p><p>我们要删除结点i，先把i的下一个结点i.next的内容复制到i，然后在把i的指针指向i.next结点的下一个结点即i.next.next，它的效果刚好是把结点i给删除了。</p><p>此外还要考虑删除的结点是头尾结点、链表中只有一个结点、链表为空这几种情况。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteNode</span> </span>&#123;  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 链表结点 </div><div class="line">     */  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;  </div><div class="line">        <span class="keyword">int</span> value; <span class="comment">// 保存链表的值  </span></div><div class="line">        ListNode next; <span class="comment">// 下一个结点  </span></div><div class="line">    &#125;  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 给定单向链表的头指针和一个结点指针，定义一个函数在0(1)时间删除该结点, </div><div class="line">     * 【注意1：这个方法和文本上的不一样，书上的没有返回值，这个因为JAVA引用传递的原因， </div><div class="line">     * 如果删除的结点是头结点，如果不采用返回值的方式，那么头结点永远删除不了】 </div><div class="line">     * 【注意2：输入的待删除结点必须是待链表中的结点，否则会引起错误，这个条件由用户进行保证】 </div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> head        链表表的头 </div><div class="line">     * <span class="doctag">@param</span> toBeDeleted 待删除的结点 </div><div class="line">     * <span class="doctag">@return</span> 删除后的头结点 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head, ListNode toBeDeleted)</span> </span>&#123;  </div><div class="line">        <span class="comment">// 如果输入参数有空值就返回表头结点  </span></div><div class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || toBeDeleted == <span class="keyword">null</span>) &#123;  </div><div class="line">            <span class="keyword">return</span> head;  </div><div class="line">        &#125;  </div><div class="line">        <span class="comment">// 如果删除的是头结点，直接返回头结点的下一个结点  </span></div><div class="line">        <span class="keyword">if</span> (head == toBeDeleted) &#123;  </div><div class="line">            <span class="keyword">return</span> head.next;  </div><div class="line">        &#125;  </div><div class="line">          <span class="comment">// 下面的情况链表至少有两个结点  </span></div><div class="line">        <span class="comment">// 在多个节点的情况下，如果删除的是最后一个元素  </span></div><div class="line">        <span class="keyword">if</span> (toBeDeleted.next == <span class="keyword">null</span>) &#123;  </div><div class="line">            <span class="comment">// 找待删除元素的前驱  </span></div><div class="line">            ListNode tmp = head;  </div><div class="line">            <span class="keyword">while</span> (tmp.next != toBeDeleted) &#123;  </div><div class="line">                tmp = tmp.next;  </div><div class="line">            &#125;  </div><div class="line">            <span class="comment">// 删除待结点  </span></div><div class="line">            tmp.next = <span class="keyword">null</span>;  </div><div class="line">        &#125;  </div><div class="line">        <span class="comment">// 在多个节点的情况下，如果删除的是某个中间结点  </span></div><div class="line">        <span class="keyword">else</span> &#123;  </div><div class="line">            <span class="comment">// 将下一个结点的值输入当前待删除的结点  </span></div><div class="line">            toBeDeleted.value = toBeDeleted.next.value;  </div><div class="line">            <span class="comment">// 待删除的结点的下一个指向原先待删除引号的下下个结点，即将待删除的下一个结点删除  </span></div><div class="line">            toBeDeleted.next = toBeDeleted.next.next;  </div><div class="line">        &#125;  </div><div class="line">        <span class="comment">// 返回删除节点后的链表头结点  </span></div><div class="line">        <span class="keyword">return</span> head;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure><h2 id="三、链表中倒数第K个结点（剑15）"><a href="#三、链表中倒数第K个结点（剑15）" class="headerlink" title="三、链表中倒数第K个结点（剑15）"></a>三、链表中倒数第K个结点（剑15）</h2><p>输入一个链表，输出该链表中倒数第k个结点。为了符合大多数人的习惯，本题从1 开始计数，即链表的尾结点是倒数第1个结点。例如一个链表有6个结点，从头结点开始它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个结点的值为4的结点。</p><p>很自然的想法是先走到链表尾端，再从尾端回溯k步。可是我们从链表结点的定义可以看出本题中的链表是单向链表，单向链表的结点只有从前向后的指针而没有从后往前的指针，这种思路行不通。</p><p>既然不能从尾结点开始遍历链表，我们还是把思路回到头结点上来。假设整个链表有n个结点，那么倒数第k个结点就是从头结点开始往后走n-k+1步就可以了。如何得到结点树n？只需要从头开始遍历链表，每经过一个结点，计数器加1就行了。</p><p>也就是说我们需要遍历链表两次，第一次统计出链表中的结点的个数，第二次就能找到倒数第k个结点。但是面试官期待的解法是只需要遍历链表一次。</p><p>为了实现只遍历链表一次就能找到倒数第k个结点，我们可以定义两个指针。第一个指针从链表的头指针开始遍历向前走k-1步，第二个指针保持不动；从第k步开始，第二个指针也开始从链表的头指针开始遍历。由于两个指针的距离保持在k-1，当第一个（走在前面的）指针到达链表的尾结点时，第二个指针（走在后边的）指针正好是倒数第k个结点。</p><p><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-25 上午11.06.17.png" alt="屏幕快照 2017-07-25 上午11.06.17"></p><p>但是这样写出来的代码不够鲁棒，面试官可以找出三种办法让这段代码崩溃：</p><ul><li>输入的ListHead为空指针。由于代码会试图访问空指针指向的内存，程序崩溃。</li><li><ol><li>输入的以ListHead为头结点的链表的结点总数少于k。由于在for循环中会在链表上向前走k-1步，仍然会由于空指针造成的程序奔溃。</li></ol></li><li><ol><li>输入的参数k为0.由于k是一个无符号整数，那么在for循环中k-1得到的将不是-1，而是4294967295（无符号的0xFFFFFFFFF），因此for循环执行的次数远远超过我们的预计，同样也会造成程序崩溃。</li></ol></li></ul><p>面试过程中写代码特别要注意鲁棒性，若写出的代码存在多处崩溃的风险，那我们很可能和offer失之交臂。针对前面三个问题，分别处理。若输入的链表头指针为null，那么整个链表为空，此时查找倒数第k个结点自然应该返回null。若输入的k为0，也就是试图查找倒数第0个结点，由于我们计数是从1开始的，因此输入0是没有实际意义，也可以返回null。若链表的结点数少于k，在for循环中遍历链表可能会出现指向null的next，因此我们在for循环中应该加一个if循环。</p><p>代码如下：</p><blockquote><p>java版本</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">public class ListNode &#123;</div><div class="line">    int val;</div><div class="line">    ListNode next = null;</div><div class="line"></div><div class="line">    ListNode(int val) &#123;</div><div class="line">        this.val = val;</div><div class="line">    &#125;</div><div class="line">&#125;*/</div><div class="line">public class Solution &#123;</div><div class="line">    public ListNode FindKthToTail(ListNode head,int k) &#123;</div><div class="line">        if(head==null||k &lt;=0)&#123;return null;&#125;</div><div class="line">        ListNode pAhead = head;</div><div class="line">        ListNode pBehind = head;</div><div class="line">        </div><div class="line">        for(int i=1;i&lt;k;i++)&#123;</div><div class="line">            if(pAhead.next != null)</div><div class="line">               &#123;pAhead = pAhead.next;&#125;</div><div class="line">            else</div><div class="line">                &#123;return null;&#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        </div><div class="line">        while(pAhead.next!=null)</div><div class="line">            &#123;</div><div class="line">            pAhead = pAhead.next;</div><div class="line">            pBehind = pBehind.next;        </div><div class="line">        &#125;</div><div class="line">        return pBehind;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>python版本</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line"># class ListNode:</div><div class="line">#     def __init__(self, x):</div><div class="line">#         self.val = x</div><div class="line">#         self.next = None</div><div class="line">class Solution:</div><div class="line">    def FindKthToTail(self, head, k):</div><div class="line">        # write code here</div><div class="line">        if not head or k == 0:</div><div class="line">            return None</div><div class="line">        pAhead = head</div><div class="line">        pBehind = None</div><div class="line">        for i in xrange(0,k-1):</div><div class="line">            if pAhead.next != None:                </div><div class="line">              pAhead = pAhead.next</div><div class="line">            else:</div><div class="line">                return None</div><div class="line">        pBehind = head</div><div class="line">        while pAhead.next != None:</div><div class="line">            pAhead = pAhead.next</div><div class="line">            pBehind = pBehind.next</div><div class="line">        return pBehind</div></pre></td></tr></table></figure><h2 id="四、反转链表（剑16）"><a href="#四、反转链表（剑16）" class="headerlink" title="四、反转链表（剑16）"></a>四、反转链表（剑16）</h2><p>定义一个函数，输入一个链表的头结点，反转该链表并输出反转后的头结点。链表结点定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class ListNode &#123;</div><div class="line">    int val;</div><div class="line">    ListNode next = null;</div><div class="line"></div><div class="line">    ListNode(int val) &#123;</div><div class="line">        this.val = val;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>解决与链表相关的问题总是有大量的指针操作，而指针操作的代码总是容易出错的。</p><p>为了正确地反转一个链表，需要调整链表中指针的方向。为了将调整指针这个复杂的过程分析清楚，可以借助图形来直观分析。在下图所示的链表中，h、i、j是3个相邻的结点。假设经过若干操作，我们已经把结点h之前的指针调整完毕，这些结点的next指向h，此时链表的结果如下所示：</p><p><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-24 下午11.13.37.png" alt="屏幕快照 2017-07-24 下午11.13.37"></p><p>其中（a）为一个链表，（b）把i之前的所有结点的next都指向前一个结点，导致链表在结点i、j之间断裂。</p><p>不难注意到，由于结点i的next指向了它的前一个结点，导致我们无法再链表中遍历到结点j。为了避免链表在结点i处断开，我们需要在调整结点i的next之前把结点j保存下来。</p><p>也就是说我们在调整结点i的next指针时，除了需要知道结点i本身之外，还需要前一个结点h，因为我们需要把结点i的next指向结点h。同时，我们还事先需要保存i的一个结点j，以防止链表断开。因此相应地我们需要定义3个指针，分别指向当前遍历到的结点、它的前一个结点及后一个结点。</p><p>最后我们试着找到反转后链表的头结点。不难分析出反转后链表的头结点是原始链表的尾结点。什么结点是尾结点？自然是next为null的结点。</p><script type="math/tex; mode=display">pre\rightarrow head \rightarrow next</script><p>先保存next，即$next = head.next$再反转head的指针$head.next=pre $，链表结构变成</p><script type="math/tex; mode=display">pre\leftarrow head \ \ \ next</script><p>接着向后移动结点$pre=head,head=next$</p><p>实现代码如下：</p><blockquote><p>java版本</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">       </div><div class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        <span class="comment">//head为当前节点，如果当前节点为空的话，那就什么也不做，直接返回null；</span></div><div class="line">        ListNode pre = <span class="keyword">null</span>;</div><div class="line">        ListNode next = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">//当前节点是head，pre为当前节点的前一节点，next为当前节点的下一节点</span></div><div class="line">        <span class="comment">//需要pre和next的目的是让当前节点从pre-&gt;head-&gt;next1-&gt;next2变成pre&lt;-head next1-&gt;next2</span></div><div class="line">        <span class="comment">//即pre让节点可以反转所指方向，但反转之后如果不用next节点保存next1节点的话，此单链表就此断开了</span></div><div class="line">        <span class="comment">//所以需要用到pre和next两个节点</span></div><div class="line">        <span class="comment">//1-&gt;2-&gt;3-&gt;4-&gt;5</span></div><div class="line">        <span class="comment">//1&lt;-2&lt;-3 4-&gt;5</span></div><div class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</div><div class="line">            <span class="comment">//做循环，如果当前节点不为空的话，始终执行此循环，此循环的目的就是让当前节点从指向next到指向pre</span></div><div class="line">            <span class="comment">//如此就可以做到反转链表的效果</span></div><div class="line">            <span class="comment">//先用next保存head的下一个节点的信息，保证单链表不会因为失去head节点的原next节点而就此断裂</span></div><div class="line">            next = head.next;</div><div class="line">            <span class="comment">//保存完next，就可以让head从指向next变成指向pre了，代码如下</span></div><div class="line">            head.next = pre;</div><div class="line">            <span class="comment">//head指向pre后，就继续依次反转下一个节点</span></div><div class="line">            <span class="comment">//让pre，head，next依次向后移动一个节点，继续下一次的指针反转</span></div><div class="line">            pre = head;</div><div class="line">            head = next;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果head为null的时候，pre就为最后一个节点了，但是链表已经反转完毕，pre就是反转后链表的第一个节点</span></div><div class="line">        <span class="comment">//直接输出pre就是我们想要得到的反转后的链表</span></div><div class="line">        <span class="keyword">return</span> pre;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>python版本</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class ListNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># 返回ListNode</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseList</span><span class="params">(self, pHead)</span>:</span></div><div class="line">        <span class="comment"># write code here</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead <span class="keyword">or</span> <span class="keyword">not</span> pHead.next:</div><div class="line">            <span class="keyword">return</span> pHead          </div><div class="line">        pre = <span class="keyword">None</span>        </div><div class="line">        <span class="keyword">while</span> pHead:</div><div class="line">            next1 = pHead.next</div><div class="line">            pHead.next = pre</div><div class="line">            pre = pHead</div><div class="line">            pHead = next1</div><div class="line">        <span class="keyword">return</span> pre</div></pre></td></tr></table></figure><h2 id="五、合并两个排序的链表（剑17）"><a href="#五、合并两个排序的链表（剑17）" class="headerlink" title="五、合并两个排序的链表（剑17）"></a>五、合并两个排序的链表（剑17）</h2><p>输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。例如下图中的链表1和链表2，则合并之后的升序链表3如下所示：<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-25 上午9.26.52.png" alt="屏幕快照 2017-07-25 上午9.26.52"></p><p>这是一个经常被各公司采用的面试题。在面试过程中，最容易犯两种错误：一是在写代码之前没有对合并的过程想清楚，最终合并出来的链表要么中间断开了，要么并没有做到递增排序；二是代码在鲁棒性方面存在问题，程序一旦有特殊的输入（如空链表）就会奔溃。<br>首先分析合并两个链表的过程。从合并两个链表的头结点开始。链表1的头结点的值小于链表2的头结点的值，因此链表1的头结点将是合并后链表的头结点。</p><p>继续合并剩余的结点。在两个链表中剩下的结点依然是排序的，因此合并这两个链表的步骤和前面的步骤是一样的。依旧比较两个头结点的值。此时链表2的头结点值小于链表1的头结点的值，因此链表2的头结点的值将是合并剩余结点得到的链表的头结点。把这个结点和前面合并链表时得到的链表的尾结点链接起来。</p><p>当我们得到两个链表中值较小的头结点并把它链接到已经合并的链表之后，两个链表剩余的结点依然是排序的，因此合并的步骤和之前的步骤是一样的。这是典型的递归过程，我们可以定义递归函数完成这一合并过程。（解决这个问题需要大量的指针操作，如没有透彻地分析问题形成清晰的思路，很难写出正确的代码）</p><p><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-25 上午9.39.51.png" alt="屏幕快照 2017-07-25 上午9.39.51"></p><p>接下来解决鲁棒性问题，每当代码试图访问空指针指向的内存时程序就会奔溃，从而导致鲁棒性问题。本题中一旦输入空的链表就会引入空的指针，因此我们要对空链表单独处理。当第一个链表是空链表<br>，也就是它的头结点是一个空指针时，和第二个链表合并的结果就是第二个链表。同样，当输入的第二个链表的头结点是空指针的时候，和第一个链表合并得到的结果就是第一个链表。如果两个链表都为空，合并得到的是一个空链表。（由于有大量的指针操作，如果稍有不慎就会在代码中遗留很多与鲁棒性相关的隐患。建议应聘者在写代码之前全面分析哪些情况会引入空指针，并考虑清楚怎么处理这些空指针。）</p><p>代码如下：</p><blockquote><p>java</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public ListNode Merge(ListNode list1,ListNode list2) &#123;</div><div class="line">        //新建一个头节点，用来存合并的链表。</div><div class="line">        ListNode head=new ListNode(-1);</div><div class="line">        head.next=null; </div><div class="line">        ListNode root=head;</div><div class="line">        while(list1!=null&amp;&amp;list2!=null)&#123;</div><div class="line">            if(list1.val&lt;list2.val)&#123;</div><div class="line">                head.next=list1;</div><div class="line">                list1=list1.next;</div><div class="line">            &#125;else&#123;</div><div class="line">                head.next=list2;</div><div class="line">                list2=list2.next;</div><div class="line">            &#125;</div><div class="line">            head = head.next;</div><div class="line">        &#125;</div><div class="line">        //把未结束的链表连接到合并后的链表尾部</div><div class="line">        if(list1!=null)&#123;</div><div class="line">            head.next=list1;</div><div class="line">        &#125;</div><div class="line">        if(list2!=null)&#123;</div><div class="line">            head.next=list2;</div><div class="line">        &#125;</div><div class="line">        return root.next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>java递归写法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (list1==<span class="keyword">null</span>) <span class="keyword">return</span> list2;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (list2==<span class="keyword">null</span>) <span class="keyword">return</span> list1;</div><div class="line">        ListNode MergeHead = <span class="keyword">null</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (list.val&lt;=list2.val)&#123;</div><div class="line">            MergeHead = list1;</div><div class="line">            MergeHead.next = Merge(list1.next,list2);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> </div><div class="line">        &#123;MergeHead = list2;</div><div class="line">             MergeHead.next = Merge(list1,list2.next);</div><div class="line">             &#125;</div><div class="line">        <span class="keyword">return</span> MergeHead;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="六、复杂链表的复制（剑26）"><a href="#六、复杂链表的复制（剑26）" class="headerlink" title="六、复杂链表的复制（剑26）"></a>六、复杂链表的复制（剑26）</h2><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p><p><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-04 下午7.51.53.png" alt="屏幕快照 2017-08-04 下午7.51.53"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-04 下午7.52.01.png" alt="屏幕快照 2017-08-04 下午7.52.01"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-04 下午7.52.07.png" alt="屏幕快照 2017-08-04 下午7.52.07"></p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (pHead == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">         <span class="comment">//复制next 如原来是A-&gt;B-&gt;C 变成A-&gt;A'-&gt;B-&gt;B'-&gt;C-&gt;C'</span></div><div class="line">        RandomListNode pCur = pHead;</div><div class="line">        <span class="keyword">while</span> (pCur != <span class="keyword">null</span>)</div><div class="line">        &#123;</div><div class="line">            RandomListNode node = <span class="keyword">new</span> RandomListNode(pCur.label);</div><div class="line">            node.next = pCur.next;</div><div class="line">            pCur.next = node;</div><div class="line">            pCur = node.next;</div><div class="line">        &#125;</div><div class="line">         <span class="comment">//复制random pCur是原来链表的结点 pCur.next是复制pCur的结点</span></div><div class="line">        pCur = pHead;</div><div class="line">        <span class="keyword">while</span> (pCur!=<span class="keyword">null</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (pCur.random!=<span class="keyword">null</span>)</div><div class="line">                pCur.next.random = pCur.random.next;</div><div class="line">            pCur = pCur.next.next;</div><div class="line">        &#125;</div><div class="line">         <span class="comment">//拆分链表</span></div><div class="line">        RandomListNode head = pHead.next;</div><div class="line">        RandomListNode tmp = head;</div><div class="line">        pCur = pHead;</div><div class="line">        <span class="keyword">while</span>(pCur.next!=<span class="keyword">null</span>)</div><div class="line">        &#123;</div><div class="line">            tmp = pCur.next;</div><div class="line">            pCur.next = tmp.next;</div><div class="line">            pCur = tmp;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> head;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="七、二叉搜索树与双向链表（剑27）"><a href="#七、二叉搜索树与双向链表（剑27）" class="headerlink" title="七、二叉搜索树与双向链表（剑27）"></a>七、二叉搜索树与双向链表（剑27）</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    TreeNode head = <span class="keyword">null</span>;</div><div class="line">    TreeNode realHead = <span class="keyword">null</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</div><div class="line">        ConvertSub(pRootOfTree);</div><div class="line">        <span class="keyword">return</span> realHead<span class="comment">//realHead是每个子树排序后的第一个结点，head是排序后的最后一个结点;</span></div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ConvertSub</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</div><div class="line">        <span class="comment">//递归中序遍历</span></div><div class="line">        <span class="keyword">if</span>(pRootOfTree==<span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line">        ConvertSub(pRootOfTree.left);</div><div class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//初始处</span></div><div class="line">            head = pRootOfTree;</div><div class="line">            realHead = pRootOfTree;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//前两句实现双向，第三句跳到下一个节点。</span></div><div class="line">            head.right = pRootOfTree;</div><div class="line">            pRootOfTree.left = head;</div><div class="line">            head = pRootOfTree;</div><div class="line">        &#125;</div><div class="line">        ConvertSub(pRootOfTree.right);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="八、两个链表的第一个公共结点（剑37）"><a href="#八、两个链表的第一个公共结点（剑37）" class="headerlink" title="八、两个链表的第一个公共结点（剑37）"></a>八、两个链表的第一个公共结点（剑37）</h2><p>输入两个链表找出他们的第一个公共结点。</p><p>面试的时候碰到这道题，很多应聘者的第一个想法就是蛮力法：在第一个链表上顺序遍历每个结点，每遍历到一个结点的时候，在第二个链表上顺序遍历每个结点。若第二个链表上有一个结点和第一个链表上的结点一样，说明两个链表在这个结点上重合，于是就找到了它们的公共结点。如果第一个链表的长度为m，第二个链表的长度为n，显然该方法的时间复杂度是O(mn)。</p><p>通常蛮力法不会是最好的办法，我们接下来试着分析有公共结点的两个链表有哪些特点。从链表结构的定义看出，这两个链表是单向链表。如果他们有公共的结点，那么这两个链表从某一结点开始，他们的next指向同一个结点。但由于是单向链表的结点，每个结点只有一个next，因此从第一个公共结点开始，之后的结点都是重合的，不可能再出现分叉。所以两个有公共结点而部分重合的链表，拓扑形状看起来像一个Y，而不是X。<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-25 下午2.59.56.png" alt="屏幕快照 2017-07-25 下午2.59.56"></p><p>经过我们的分析发现，若两个链表有公共结点，那么公共结点出现在两个链表的尾部。如果我们从两个链表的尾部开始往前比较，最后一个相同的结点就是我们要找的结点。我们想到用栈的特点来解决这个问题：分别把两个链表的结点放入两个栈中，这样两个链表的尾结点就位于两个栈的栈顶，接下来比较两个栈顶的结点是否相同。若果相同，则把栈顶弹出接着比较下一个栈顶，直到找到最后一个相同的结点。</p><p>上面需要用到两个辅助栈。若链表的长度分别为m和n，那么空间复杂度是O(m+n)。这种思路的时间复杂度也是O(m+n)。和最开始的蛮力法相比，时间效率得到了提升，相当于是用空间换取时间效率。</p><p>之所以需要用到栈，是因为我们想同时遍历到达两个栈的尾结点。当两个链表的长度不相同时，如果我们从头开始遍历到达尾结点的时间就不一致。其实解决这个问题还有一个更简单的办法：首先遍历两个链表得到他们的长度，就能知道哪个链表比较长，以及长的链表比短的链表多几个结点。在第二次遍历的时候，在较长的链表上先走若干步，接着再同时在两个链表上遍历，找到的第一个相同的结点就是他们的第一个公共结点。</p><p>第三种思路和第二种思路相比，时间复杂度都是O(m+n)，但我们不再需要辅助的栈，因此提高了空间效率。实现代码如下：</p><blockquote><p>java版本</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">public class ListNode &#123;</div><div class="line">    int val;</div><div class="line">    ListNode next = null;</div><div class="line"></div><div class="line">    ListNode(int val) &#123;</div><div class="line">        this.val = val;</div><div class="line">    &#125;</div><div class="line">&#125;*/</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</div><div class="line">        ListNode current1 = pHead1;<span class="comment">//链表1</span></div><div class="line">        ListNode current2 = pHead2;<span class="comment">//链表2</span></div><div class="line">        <span class="keyword">if</span>(pHead1 ==<span class="keyword">null</span>||pHead2==<span class="keyword">null</span>)&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;<span class="comment">//</span></div><div class="line">        </div><div class="line">        <span class="keyword">int</span> len1 = getlistlength(pHead1);<span class="comment">//链表1的长度</span></div><div class="line">        <span class="keyword">int</span> len2 = getlistlength(pHead2);<span class="comment">//链表2的长度</span></div><div class="line">        </div><div class="line">        <span class="comment">//若链表1长度大于链表2</span></div><div class="line">        <span class="keyword">if</span>(len1&gt;=len2)&#123;</div><div class="line">            <span class="keyword">int</span> len=len1-len2;</div><div class="line">            <span class="comment">//遍历链表1，遍历长度为两链表长度差</span></div><div class="line">            <span class="keyword">while</span> (len&gt;<span class="number">0</span>)&#123;</div><div class="line">                current1 = currentnext;</div><div class="line">                len--;</div><div class="line">                  </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//若链表2长度大于链表1</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(len1&lt;len2)&#123;</div><div class="line">            <span class="keyword">int</span> len=len2-len1;</div><div class="line">            <span class="comment">//遍历链表2，遍历长度为两链表长度差</span></div><div class="line">            <span class="keyword">while</span> (len&gt;<span class="number">0</span>)&#123;</div><div class="line">                current2=current2.next;</div><div class="line">                len--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//开始齐头并进，直到找到第一个公共结点</span></div><div class="line">        <span class="keyword">while</span>(current1!=current2)&#123;</div><div class="line">            current1 = currentnext;</div><div class="line">            current2 = current2.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> current1;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//求指定链表的长度</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getlistlength</span><span class="params">(ListNode pHead)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</div><div class="line">        ListNode current = pHead;</div><div class="line">        <span class="keyword">while</span>(current!=<span class="keyword">null</span>)&#123;</div><div class="line">            length++;</div><div class="line">            current = current.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> length;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>python版本</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class ListNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindFirstCommonNode</span><span class="params">(self, pHead1, pHead2)</span>:</span></div><div class="line">        <span class="comment"># write code here</span></div><div class="line">        current1=pHead1</div><div class="line">        current2=pHead2</div><div class="line">        len1 = self.getlistlength(current1)</div><div class="line">        len2 = self.getlistlength(current2)        </div><div class="line">        <span class="keyword">if</span> len1&gt;=len2:            </div><div class="line">            length = len1-len2</div><div class="line">            <span class="keyword">while</span> length&gt;<span class="number">0</span>:</div><div class="line">                current1 = currentnext</div><div class="line">                length=length<span class="number">-1</span>                </div><div class="line">        <span class="keyword">elif</span> len1&lt;len2:</div><div class="line">            length = len2-len1</div><div class="line">            <span class="keyword">while</span> length&gt;<span class="number">0</span>:</div><div class="line">                current2 = current2.next</div><div class="line">                length=length<span class="number">-1</span>               </div><div class="line">        <span class="keyword">while</span> current1!=current2:</div><div class="line">            current1=currentnext</div><div class="line">            current2=current2.next</div><div class="line">        <span class="keyword">return</span> current1</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getlistlength</span><span class="params">(self,pHead)</span>:</span></div><div class="line">        length =<span class="number">0</span></div><div class="line">        current =pHead</div><div class="line">        <span class="keyword">while</span> current!=<span class="keyword">None</span>:</div><div class="line">            length=length+<span class="number">1</span></div><div class="line">            current = current.next</div><div class="line">        <span class="keyword">return</span> length</div></pre></td></tr></table></figure><h2 id="九、圆圈中最后剩下的的数字（剑45）"><a href="#九、圆圈中最后剩下的的数字（剑45）" class="headerlink" title="九、圆圈中最后剩下的的数字（剑45）"></a>九、圆圈中最后剩下的的数字（剑45）</h2><p>0、…..，n-1这n个数字排成一个圆圈，从数字0开始每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。<br>约瑟夫环问题，用环形链表模拟圆圈的经典解法，</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(m&lt;=<span class="number">0</span>||n&lt;=<span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        <span class="comment">//先构造循环链表</span></div><div class="line">        ListNode head= <span class="keyword">new</span> ListNode(<span class="number">0</span>);<span class="comment">//头结点, 值为0</span></div><div class="line">        ListNode pre = head;</div><div class="line">        ListNode temp = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</div><div class="line">            temp = <span class="keyword">new</span> ListNode(i);</div><div class="line">            pre.next = temp;</div><div class="line">            pre = temp;</div><div class="line">        &#125;</div><div class="line">        temp.next = head;<span class="comment">//将第n-1个结点(也就是尾结点)指向头结点</span></div><div class="line">        ListNode temp2 = <span class="keyword">null</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">while</span>(n&gt;=<span class="number">1</span>)&#123;</div><div class="line">            <span class="comment">//每次都当前头结点找到第m个结点的前驱</span></div><div class="line">            temp2=head;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;m-<span class="number">1</span>;i++)&#123;</div><div class="line">                temp2 = temp2.next;</div><div class="line">            &#125;</div><div class="line">            temp2.next = temp2.next.next;</div><div class="line">            head = temp2.next;<span class="comment">//设置当前头结点</span></div><div class="line">            n--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> head.val;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>||m==<span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> last=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</div><div class="line">        &#123;</div><div class="line">            last=(last+m)%i;</div><div class="line">        &#125;   </div><div class="line">       <span class="keyword">return</span> last ;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="十、链表中环的入口结点（剑56）"><a href="#十、链表中环的入口结点（剑56）" class="headerlink" title="十、链表中环的入口结点（剑56）"></a>十、链表中环的入口结点（剑56）</h2><p>一个链表中包含环，如何找到环的入口结点？例如在下图的链表中，环的入口结点是结点3。</p><p><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-25 下午3.41.20.png" alt="屏幕快照 2017-07-25 下午3.41.20"></p><p>以3为例分析两个指针的移动规律。指针$P_1$和$P_2$在初始化时都指向链表的头结点。由于环中有4个结点，指针$P_1$先在链表上向前移动4步。接下来两个指针以相同的速度在链表上向前移动，直到它们相遇。它们相遇的结点正好是还的入口结点。<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-25 下午3.46.08.png" alt="屏幕快照 2017-07-25 下午3.46.08"></p><p>剩下的问题就是如何得到环中结点的数目。我们可以使用一快一慢两个指针。若两个指针相遇，说明链表中有环。两个指针相遇的结点一定是在环中的。可以从这个结点出发，一边继续向前移动一边计数，当再次回到这个结点时，就可以得到环中结点数了<br>实现代码如下：</p><blockquote><p>java版本</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> public class ListNode &#123;</div><div class="line">    int val;</div><div class="line">    ListNode next = null;</div><div class="line"></div><div class="line">    ListNode(int val) &#123;</div><div class="line">        this.val = val;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line"><span class="comment">//找到一快一满指针相遇处的节点，相遇的节点一定是在环中</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">meetingNode</span><span class="params">(ListNode pHead)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(pHead == <span class="keyword">null</span>)&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;<span class="comment">//空链表处理</span></div><div class="line">        ListNode pslow = pHead.next;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span>(pslow == <span class="keyword">null</span>)&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;<span class="comment">//无环链表处理</span></div><div class="line">        </div><div class="line">        ListNode pfast = pslow.next;</div><div class="line">        <span class="keyword">while</span>(pfast!=<span class="keyword">null</span> &amp;&amp; pslow!=<span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(pslow==pfast)&#123;<span class="keyword">return</span> pfast;&#125;</div><div class="line">            </div><div class="line">            pslow = pslow.next;<span class="comment">//慢指针</span></div><div class="line">            </div><div class="line">            pfast = pfast.next;</div><div class="line">            <span class="keyword">if</span>(pfast!=<span class="keyword">null</span>)&#123;</div><div class="line">                pfast = pfast.next;</div><div class="line">            &#125;<span class="comment">//块指针</span></div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span></span>&#123;</div><div class="line">        ListNode meetingNode=meetingNode(pHead);<span class="comment">//相遇结点</span></div><div class="line">        <span class="comment">//环的结点个数</span></div><div class="line">        <span class="keyword">if</span>(meetingNode==<span class="keyword">null</span>)&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;<span class="comment">//是否有环</span></div><div class="line">        <span class="keyword">int</span> nodesInLoop = <span class="number">1</span>;        </div><div class="line">        ListNode p1=meetingNode;</div><div class="line">        <span class="keyword">while</span>(pnext!=meetingNode)&#123;</div><div class="line">            p1=pnext;</div><div class="line">            ++nodesInLoop;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//p1慢指针,先往前走</span></div><div class="line">        p1=pHead;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nodesInLoop;i++)&#123;</div><div class="line">            p1=pnext;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//p1,p2同步走，相遇的地方即为环入口</span></div><div class="line">        ListNode p2=pHead;</div><div class="line">        <span class="keyword">while</span>(p1!=p2)&#123;</div><div class="line">            p1=pnext;</div><div class="line">            p2=p2.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> p1;</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>python 版本</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line"># class ListNode:</div><div class="line">#     def __init__(self, x):</div><div class="line">#         self.val = x</div><div class="line">#         self.next = None</div><div class="line">class Solution:</div><div class="line">    def meetingNode(self,pHead):</div><div class="line">        if not pHead:</div><div class="line">            return None</div><div class="line">        pslow =pHead.next        </div><div class="line">        if not pslow:</div><div class="line">            return None</div><div class="line">        pfast = pslow.next</div><div class="line">        while pfast and pslow:</div><div class="line">            if pslow==pfast:</div><div class="line">                return pfast</div><div class="line">            pslow = pslow.next</div><div class="line">            </div><div class="line">            pfast = pfast.next</div><div class="line">            if pfast:</div><div class="line">                pfast=pfast.next</div><div class="line">        return None </div><div class="line">    def EntryNodeOfLoop(self, pHead):</div><div class="line">        meetingNode = self.meetingNode(pHead)</div><div class="line">        if not meetingNode:</div><div class="line">            return None</div><div class="line">        nodesInLoop = 1</div><div class="line">        p1 = meetingNode</div><div class="line">        while pnext!=meetingNode:</div><div class="line">            p1=pnext</div><div class="line">            nodesInLoop +=1</div><div class="line">        p1 = pHead</div><div class="line">        for i in xrange(0,nodesInLoop):</div><div class="line">            p1=pnext</div><div class="line">        p2=pHead</div><div class="line">        while p1!=p2:</div><div class="line">            p1=pnext</div><div class="line">            p2=p2.next</div><div class="line">        return p1</div></pre></td></tr></table></figure><h2 id="十一、删除链表中重复的结点（剑57）"><a href="#十一、删除链表中重复的结点（剑57）" class="headerlink" title="十一、删除链表中重复的结点（剑57）"></a>十一、删除链表中重复的结点（剑57）</h2><p>在一个排序的链表中，如何删除重复的结点？如在下图中重复结点被删除之后，链表如下图所示：<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-25 下午5.43.23.png" alt="屏幕快照 2017-07-25 下午5.43.23"></p><p>从头遍历整个链表。如果当前结点的值与下一个节点的值相同，那么它们就是重复的结点，都可以被删除。为了保证删除之后的链表仍然是相连的而没有中间断开，我们要把当前结点的前一个结点preNode和后面值比当前结点的值要大的结点相连。要确保preNode要始终与下一个没有重复的结点连接在一起。</p><p>实现代码如下：</p><blockquote><p>java递归版</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> public class ListNode &#123;</div><div class="line">    int val;</div><div class="line">    ListNode next = null;</div><div class="line"></div><div class="line">    ListNode(int val) &#123;</div><div class="line">        this.val = val;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (pHead == <span class="keyword">null</span> || pHead.next == <span class="keyword">null</span>) &#123; <span class="comment">// 只有0个或1个结点，则返回</span></div><div class="line">            <span class="keyword">return</span> pHead;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (pHead.val == pHead.next.val) &#123; <span class="comment">// 当前结点是重复结点</span></div><div class="line">            ListNode pNode = pHead.next;</div><div class="line">            <span class="keyword">while</span> (pNode != <span class="keyword">null</span> &amp;&amp; pNode.val == pHead.val) &#123;</div><div class="line">                <span class="comment">// 跳过值与当前结点相同的全部结点,找到第一个与当前结点不同的结点</span></div><div class="line">                pNode = pNode.next;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> deleteDuplication(pNode); <span class="comment">// 从第一个与当前结点不同的结点开始递归</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当前结点不是重复结点</span></div><div class="line">            pHead.next = deleteDuplication(pHead.next); <span class="comment">// 保留当前结点，从下一个结点开始递归</span></div><div class="line">            <span class="keyword">return</span> pHead;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>python版本</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class ListNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.next = None</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplication</span><span class="params">(self, pHead)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead <span class="keyword">or</span> <span class="keyword">not</span> pHead.next:</div><div class="line">            <span class="keyword">return</span> pHead</div><div class="line">        <span class="keyword">if</span> pHead.val==pHead.next.val:</div><div class="line">            pNode = pHead.next</div><div class="line">            <span class="keyword">while</span> pNode <span class="keyword">and</span> pNode.val == pHead.val:</div><div class="line">                 pNode = pNode.next</div><div class="line">            <span class="keyword">return</span> self.deleteDuplication(pNode)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            pHead.next = self.deleteDuplication(pHead.next)</div><div class="line">            <span class="keyword">return</span> pHead</div></pre></td></tr></table></figure><blockquote><p>java非递归</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> public class ListNode &#123;</div><div class="line">    int val;</div><div class="line">    ListNode next = null;</div><div class="line"></div><div class="line">    ListNode(int val) &#123;</div><div class="line">        this.val = val;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(pHead==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;         </div><div class="line">        ListNode preNode = <span class="keyword">null</span>;</div><div class="line">        ListNode node = pHead;</div><div class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</div><div class="line">            ListNode nextNode = node.next;</div><div class="line">            <span class="keyword">boolean</span> needDelete = <span class="keyword">false</span>;</div><div class="line">            <span class="comment">//需要删除重复节点的情况</span></div><div class="line">            <span class="keyword">if</span>(nextNode!=<span class="keyword">null</span>&amp;&amp;nextNode.val==node.val)&#123;</div><div class="line">                needDelete = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//不重复结点不删除</span></div><div class="line">            <span class="keyword">if</span>(!needDelete)&#123;</div><div class="line">                preNode = node;</div><div class="line">                node = node.next;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//重复节点删除</span></div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">int</span> value = node.val;</div><div class="line">                ListNode toBeDel = node;</div><div class="line">                <span class="comment">//连续重复结点</span></div><div class="line">                <span class="keyword">while</span>(toBeDel != <span class="keyword">null</span> &amp;&amp; toBeDel.val == value)&#123;</div><div class="line">                    nextNode = toBeDel.next;</div><div class="line">                    toBeDel = nextNode;</div><div class="line">                    <span class="keyword">if</span>(preNode==<span class="keyword">null</span>)</div><div class="line">                        pHead = nextNode;</div><div class="line">                    <span class="keyword">else</span></div><div class="line">                        preNode.next = nextNode;</div><div class="line">                    node = nextNode;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> pHead;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="十二、翻转部分链表-leetcode-92-Reverse-Linked-List-II"><a href="#十二、翻转部分链表-leetcode-92-Reverse-Linked-List-II" class="headerlink" title="十二、翻转部分链表(leetcode 92 Reverse Linked List II)"></a>十二、翻转部分链表(leetcode 92 Reverse Linked List II)</h2><p>给了一个链表，第1个结点标号为1，把链表中标号在M到N区间的部分反转  （我写的很慢，面试官看不下去了，让我只说思路）</p><p>这道题是比较常见的链表反转操作，不过不是反转整个链表，而是从m到n的一部分。分为两个步骤，第一步是找到m结点所在位置，第二步就是进行反转直到n结点。反转的方法就是每读到一个结点，把它插入到m结点前面位置，然后m结点接到读到结点的下一个。总共只需要一次扫描，所以时间是O(n)，只需要几个辅助指针，空间是O(1)。代码如下：</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;  </div><div class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)  </div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);  </div><div class="line">        dummy.next = head;  </div><div class="line">        ListNode preNode = dummy;  </div><div class="line">        <span class="keyword">int</span> i=<span class="number">1</span>;  </div><div class="line">        <span class="keyword">while</span>(preNode.next!=<span class="keyword">null</span> &amp;&amp; i&lt;m)  </div><div class="line">        &#123;  </div><div class="line">            preNode = preNode.next;  </div><div class="line">            i++;  </div><div class="line">        &#125;  </div><div class="line">        ListNode mNode = preNode.next;  </div><div class="line">        ListNode cur = mNode.next;  </div><div class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span> &amp;&amp; i&lt;n)  </div><div class="line">        &#123;  </div><div class="line">            ListNode next = cur.next;  </div><div class="line">            cur.next = preNode.next;  </div><div class="line">            preNode.next = cur;  </div><div class="line">            mNode.next = next;  </div><div class="line">            cur = next;  </div><div class="line">            i++;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> dummy.next;  </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="十三、链表插入排序-leetcode-147-Insertion-Sort-List"><a href="#十三、链表插入排序-leetcode-147-Insertion-Sort-List" class="headerlink" title="十三、链表插入排序(leetcode 147 Insertion Sort List)"></a>十三、链表插入排序(leetcode 147 Insertion Sort List)</h2><p>这道题跟Sort List类似，要求在链表上实现一种排序算法，这道题是指定实现插入排序。插入排序是一种$O(n^2)$复杂度的算法，基本想法相信大家都比较了解，就是每次循环找到一个元素在当前排好的结果中相对应的位置，然后插进去，经过n次迭代之后就得到排好序的结果了。了解了思路之后就是链表的基本操作了，搜索并进行相应的插入。时间复杂度是排序算法的$O(n^2)$，空间复杂度是O(1)。代码如下： </p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">     <span class="function"><span class="keyword">public</span> ListNode <span class="title">insertionSortList</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span>( head == <span class="keyword">null</span> )&#123;</div><div class="line"><span class="keyword">return</span> head;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ListNode helper = <span class="keyword">new</span> ListNode(<span class="number">0</span>); <span class="comment">//new starter of the sorted list</span></div><div class="line">ListNode cur = head; <span class="comment">//the node will be inserted</span></div><div class="line">ListNode pre = helper; <span class="comment">//insert node between pre and pre.next</span></div><div class="line">ListNode next = <span class="keyword">null</span>; <span class="comment">//the next node will be inserted</span></div><div class="line"><span class="comment">//not the end of input list</span></div><div class="line"><span class="keyword">while</span>( cur != <span class="keyword">null</span> )&#123;</div><div class="line">next = cur.next;</div><div class="line"><span class="comment">//find the right place to insert</span></div><div class="line"><span class="keyword">while</span>( pre.next != <span class="keyword">null</span> &amp;&amp; pre.next.val &lt; cur.val )&#123;</div><div class="line">pre = pre.next;</div><div class="line">&#125;</div><div class="line"><span class="comment">//insert between pre and pre.next</span></div><div class="line">cur.next = pre.next;</div><div class="line">pre.next = cur;</div><div class="line">pre = helper;</div><div class="line">cur = next;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">return</span> helper.next;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="十四、链表归并排序-leetcode-148-Sort-List"><a href="#十四、链表归并排序-leetcode-148-Sort-List" class="headerlink" title="十四、链表归并排序(leetcode 148 Sort List)"></a>十四、链表归并排序(leetcode 148 Sort List)</h2><p>链表排序，不允许直接交换节点的值，敲的有点bug，指针初始化有问题</p><p>这道题跟Insertion Sort List类似，要求我们用O(nlogn)算法对链表进行排序，但是并没有要求用哪一种排序算法，我们可以使用归并排序，快速排序，堆排序等满足要求的方法来实现。对于这道题比较容易想到的是归并排序，因为我们已经做过Merge Two Sorted Lists，这是归并排序的一个subroutine。剩下我们需要做的就是每次找到中点，然后对于左右进行递归，最后用Merge Two Sorted Lists把他们合并起来。代码如下：</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</div><div class="line">      <span class="keyword">return</span> head;</div><div class="line">        </div><div class="line">    <span class="comment">// step 1. cut the list to two halves</span></div><div class="line">    ListNode prev = <span class="keyword">null</span>, slow = head, fast = head;</div><div class="line">    </div><div class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</div><div class="line">      prev = slow;</div><div class="line">      slow = slow.next;</div><div class="line">      fast = fast.next.next;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    prev.next = <span class="keyword">null</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// step 2. sort each half</span></div><div class="line">    ListNode l1 = sortList(head);</div><div class="line">    ListNode l2 = sortList(slow);</div><div class="line">    </div><div class="line">    <span class="comment">// step 3. merge l1 and l2</span></div><div class="line">    <span class="keyword">return</span> merge(l1, l2);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function">ListNode <span class="title">merge</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</div><div class="line">    ListNode l = <span class="keyword">new</span> ListNode(<span class="number">0</span>), p = l;</div><div class="line">    </div><div class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</div><div class="line">        p.next = l1;</div><div class="line">        l1 = l1.next;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        p.next = l2;</div><div class="line">        l2 = l2.next;</div><div class="line">      &#125;</div><div class="line">      p = p.next;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (l1 != <span class="keyword">null</span>)</div><div class="line">      p.next = l1;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (l2 != <span class="keyword">null</span>)</div><div class="line">      p.next = l2;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> l.next;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="十五、实现稀疏矩阵相乘"><a href="#十五、实现稀疏矩阵相乘" class="headerlink" title="十五、实现稀疏矩阵相乘"></a>十五、实现稀疏矩阵相乘</h2><p>给定两个稀疏矩阵A和B，求AB。A的列数和B的行数相等。</p><p>面经：（链表，即每行的非零值存进单链表里。从面试官表情判断，应该说对了）</p><p><a href="http://www.chongchonggou.com/g_5929864.html" target="_blank" rel="noopener">http://www.chongchonggou.com/g_5929864.html</a><br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">A = [</div><div class="line">  [ 1, 0, 0],</div><div class="line">  [-1, 0, 3]</div><div class="line">]</div><div class="line"></div><div class="line">B = [</div><div class="line">  [ 7, 0, 0 ],</div><div class="line">  [ 0, 0, 0 ],</div><div class="line">  [ 0, 0, 1 ]</div><div class="line">]</div><div class="line"></div><div class="line">     |  1 0 0 |   | 7 0 0 |   |  7 0 0 |</div><div class="line">AB = | -1 0 3 | x | 0 0 0 | = | -7 0 3 |</div><div class="line">                  | 0 0 1 |</div></pre></td></tr></table></figure><p>这道题让我们实现稀疏矩阵相乘，稀疏矩阵的特点是矩阵中绝大多数的元素为0，而相乘的结果是还应该是稀疏矩阵，即还是大多数元素为0，那么我们使用传统的矩阵相乘的算法肯定会处理大量的0乘0的无用功，所以我们需要适当的优化算法，使其可以顺利通过OJ，我们知道一个$ i x k$ 的矩阵A乘以一个 $k x j$ 的矩阵B会得到一个$i x j$ 大小的矩阵C，那么我们来看结果矩阵中的某个元素$C[i][j]$是怎么来的。起始是$A[i][0]<em>B[0][j] + A[i][1]</em>B[1][j] + … + A[i][k]<em>B[k][j]$，那么为了不重复计算0乘0，我们首先遍历A数组，要确保$A[i][k]$不为0，才继续计算，然后我们遍历B矩阵的第k行，如果$B[K][J]$不为0，我们累加结果矩阵$res[i][j] += A[i][k] </em> B[k][j]$; 这样我们就能高效的算出稀疏矩阵的乘法，参见代码如下：</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] multiply(<span class="keyword">int</span>[][] A, <span class="keyword">int</span>[][] B) &#123;</div><div class="line">    <span class="keyword">int</span> rowA = A.length;</div><div class="line">    <span class="keyword">int</span> colA = A[<span class="number">0</span>].length;</div><div class="line">    <span class="keyword">int</span> colB = B[<span class="number">0</span>].length;</div><div class="line">    <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[rowA][colB];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowA; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; colA; j++) &#123;    </div><div class="line">        <span class="keyword">if</span> (A[i][k] != <span class="number">0</span>) &#123;<span class="comment">// Check whether A[i][j]==0 to spare much time, because a sparse matrix has more than 95% zero elements </span></div><div class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt; colB; j++) &#123; </div><div class="line">                <span class="keyword">if</span> (B[k][j] != <span class="number">0</span>) res[i][j] += A[i][k] * B[k][j]; </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;   </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>再来看另一种方法，这种方法其实核心思想跟上面那种方法相同，稍有不同的是我们用一个链表来记录每一行中，各个位置中不为0的列数和其对应的值，这样就得到i个链表，然后我们遍历链表，取出每行中不为零的列数和值，然后遍历B中对应行进行累加相乘，参见代码如下：</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] multiply(<span class="keyword">int</span>[][] A, <span class="keyword">int</span>[][] B) &#123;</div><div class="line">    <span class="keyword">int</span> rowA = A.length;</div><div class="line">    colA = A[<span class="number">0</span>].length;</div><div class="line">    colB = B[<span class="number">0</span>].length;</div><div class="line">    <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[rowA][colB];</div><div class="line">    </div><div class="line">    LinkedList&lt;Point&gt;[] rowsA = <span class="keyword">new</span> LinkedList[rowA];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowA; i++) &#123;<span class="comment">// Create non-zero array for each row in A</span></div><div class="line">    rowsA[i] = <span class="keyword">new</span> LinkedList();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; colA; j++) &#123;   </div><div class="line">        <span class="keyword">if</span> (A[i][j] != <span class="number">0</span>) &#123;</div><div class="line">        rowsA[i].add(<span class="keyword">new</span> Point(j, A[i][j]));</div><div class="line">        &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowA; i++) &#123;<span class="comment">// Only deal with non-zero elements in the above arrays </span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; rowsA[i].size(); j++) &#123;</div><div class="line">        <span class="keyword">int</span> col = rowsA[i].get(j).x;</div><div class="line">        <span class="keyword">int</span> val = rowsA[i].get(j).y;</div><div class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; colB; k++) &#123; </div><div class="line">                res[i][k] += val * B[col][k]; </div><div class="line">        &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;   </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="十六、排序链表中找出和为给定值的一段链表"><a href="#十六、排序链表中找出和为给定值的一段链表" class="headerlink" title="十六、排序链表中找出和为给定值的一段链表"></a>十六、排序链表中找出和为给定值的一段链表</h2><p>排序链表中找出和为给定值的一段链表</p><h2 id="面经中出现过的链表题："><a href="#面经中出现过的链表题：" class="headerlink" title="面经中出现过的链表题："></a>面经中出现过的链表题：</h2><ul><li>二、如何在O(1)时间删除链表节点；</li><li>三、第一题是链表倒数第 k 节点；如何找链表倒数第K个结点（联系这个题目，两链表找交点的题就可以在O(1)空间解决了）；单链表如何判断有环；链表中倒数第K个结点</li><li>四、反转链表递归、非递归；链表反转；链表逆序。。正中我下怀~；写程序 翻转链表；给了个单链表逆置，写代码；用C/C++实现单链表的反转。</li><li>六、复杂链表的复制</li><li>七、二叉搜索树转换成一个排好序的双向链表；上网搜搜有怎样将二叉排序树变成双向链表</li><li>八、两个相交链表如何找交点（我说了用栈保存每个链表节点的方法，他问有没有O(1)空间解法，一时没想到）；判断两条链表是否交叉</li><li>十、确定链表中环的起始位置</li><li>十二、翻转部分链表(Reverse Linked List II)</li><li>十三、链表插入排序(Insertion Sort List)</li><li>十四、链表归并排序(Sort List)</li><li>十六、排序链表中找出和为给定值的一段链表</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链表相关题解java实现。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法（19）：海量数据处理</title>
    <link href="http://yoursite.com/2017/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8819%EF%BC%89%EF%BC%9A%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2017/08/02/数据结构与算法（19）：海量数据处理/</id>
    <published>2017-08-02T14:14:45.000Z</published>
    <updated>2017-09-01T06:38:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、何谓海量数据处理？"><a href="#一、何谓海量数据处理？" class="headerlink" title="一、何谓海量数据处理？"></a>一、何谓海量数据处理？</h2><p>所谓海量数据处理，其实很简单，海量，海量，何谓海量，就是数据量太大，所以导致要么是无法再较短时间内迅速解决，要么是数据太大，导致无法一次性装入内存。</p><a id="more"></a><p>那解决办法呢？针对时间，我们可以采用巧妙的算法搭配合适的数据结构，如Bloom Filter、Hash、Bit-map、堆、数据库或倒排索引、trie，针对空间，无非就一个办法：大而化小、分而治之、hash映射，你不是说规模太大嘛，那简单啊，就把规模大化为规模小的，各个击破不就完了嘛。</p><p>至于所谓的单机及集群问题，通俗点来讲，单机就是处理装载数据的机器有限（只要考虑CPU、内存、硬盘的数据交互），而集群，机器有多辆，适合分布式处理，并行计算（更多考虑节点和节点间的数据交互）。</p><p>再者，通过本blog内的有关海量数据处理的文章，我们已经大致知道，处理海量数据问题无非就是：</p><ol><li>分而治之、hash映射+hash统计+堆、快速、归并排序；</li><li>双层桶划分</li><li>Bloom Filter、bitmap</li><li>trie树、数据库、倒排索引；</li><li>外排序</li><li>分布式处理之Hadoop、Mapreduce</li></ol><p>下面，本文第一部分、从Set、Map谈到hashtable、hash_map、hash_set，简要介绍下Set、Map、Multiset、Multimap，及hash_set、hash_map、hash_multiset、hash_multimap之区别，而第二部分，则针对上述6种方法模式结合对应的海量数据处理面试题分别具体阐述。</p><h2 id="二、从Set、Map谈到hashtable、hash-map-hash-set"><a href="#二、从Set、Map谈到hashtable、hash-map-hash-set" class="headerlink" title="二、从Set、Map谈到hashtable、hash_map/hash_set"></a>二、从Set、Map谈到hashtable、hash_map/hash_set</h2><p>稍后本文第二部分将多次提到hash_map、hash_set，下面稍稍介绍下这些容器，以作为基础准备。一般来说，STL容器分为两种</p><ul><li>序列式容器：vector、list、deque、stack、queue、heap</li><li>关联式容器：关联式容器又分为set（集合）和map（映射表）两大类，以及这两大类的衍生体（多键集合）和multimap（多键映射表），这些容器均以RB-tree完成。此外，还有第三类关联容器，如hashtable（散列表），以及以hashtable为底层机制完成的hash_set（散列集合）、hash_map（散列映射表）、hash_multiset(散列多键集合)、hash_multimap（散列多键映射表）。也就是说，set、map、multiset、multimap都内含一个RB-tree，而hash_set、hash_map、hash_multiset、hash_multimap都内含一个hashtable。</li></ul><p>所谓关联式容器，类似关联式数据库，每笔数据或每个元素都有一个键值（key）和一个实值（value），即所谓的Key-Value（键-值对）。当元素被插入到关联式容器中时，容器内结构（RB-Tree、hashtable）便依照其键值大小，以某种特定规则将这个元素放置于适当位置。</p><p>包括在非关联式数据库中，比如，在MongoDB内，文档（document）是最基本的数据组织形式，每个文档也是以Key-Value(键-值对)的方式组织起来。一个文档可以有多个Key-Value组合，每个Value可以是不同的类型，比如String、Integer、List等等。${“name”:”July”,”Sex”:”male”,”age”:23}$</p><h3 id="2-1-关联式容器之集合：set-map-multimap-multimap"><a href="#2-1-关联式容器之集合：set-map-multimap-multimap" class="headerlink" title="2.1 关联式容器之集合：set/map/multimap/multimap"></a>2.1 关联式容器之集合：set/map/multimap/multimap</h3><p>set，同map一样，所有元素都会根据元素的键值自动被排序，因为set、map两者的所有操作，都是调用RB-tree的操作行为，不过，值得注意的是，两者都不允许两个元素有相同的键值。</p><p>不同的是，set的元素不像map那样可以同时拥有实值（value）和键值（key），set元素的键值就是实值，实值就是键值，而map的所有元素都是pair，同时拥有实值（value）和键值（key），pair的第一个元素被视为键值，第二个元素被视为实值。</p><p>至于multiset、multimap，他们的特性及用法和set、map完全相同，唯一的差别就在于它们允许键值重复，即所有的插入操作基于RB-tree的insert——equal()而非insert_unique()。</p><h3 id="2-2-关联式容器之映射表：hash-set-hash-map-hash-multiset-hash-multimap"><a href="#2-2-关联式容器之映射表：hash-set-hash-map-hash-multiset-hash-multimap" class="headerlink" title="2.2 关联式容器之映射表：hash_set/hash_map/hash_multiset/hash_multimap"></a>2.2 关联式容器之映射表：hash_set/hash_map/hash_multiset/hash_multimap</h3><p>hash_set/hash_map，两者的一切操作都是基于hashtable之上。hash_set同set一样，同时拥有实值和键值，且实质就是键值，键值就是实值，而hash_map同map一样，每一个元素同时拥有一个实值(value)和一个键值(key)，所以其使用方式，和上面的map基本相同。但由于hash_set/hash_map都是基于hashtable之上，所以不具备自动排序功能。为什么?因为hashtable没有自动排序功能。</p><p> 至于hash_multiset/hash_multimap的特性与上面的multiset/multimap完全相同，唯一的差别就是它们hash_multiset/hash_multimap的底层实现机制是hashtable（而multiset/multimap，上面说了，底层实现机制是RB-tree），所以它们的元素都不会被自动排序，不过也都允许键值重复。</p><p>所以，综上，说白了，什么样的结构决定其什么样的性质，因为set/map/multiset/multimap都是基于RB-tree之上，所以有自动排序功能，而hash_set/hash_map/hash_multiset/hash_multimap都是基于hashtable之上，所以不含有自动排序功能，至于加个前缀multi_无非就是允许键值重复而已。</p><h2 id="三、处理海量数据问题之六把密钥"><a href="#三、处理海量数据问题之六把密钥" class="headerlink" title="三、处理海量数据问题之六把密钥"></a>三、处理海量数据问题之六把密钥</h2><h3 id="密钥一：分而治之-Hash映射-Hash-map统计-堆-快-归并排序"><a href="#密钥一：分而治之-Hash映射-Hash-map统计-堆-快-归并排序" class="headerlink" title="密钥一：分而治之/Hash映射+Hash_map统计+堆/快/归并排序"></a>密钥一：分而治之/Hash映射+Hash_map统计+堆/快/归并排序</h3><p>这一部分介绍处理海量数据问题的第一把密钥：分而治之、哈希映射+Hash统计+堆、快速、归并排序</p><blockquote><p>（1）海量日志数据，提取出某日访问</p></blockquote><p>既然是海量数据处理，那么可想而知，给我们的数据那就一定是海量的。针对这个数据的海量，我们如何着手呢?对的，无非就是分而治之/hash映射 + hash统计 + 堆/快速/归并排序，说白了，就是先映射，而后统计，最后排序：</p><ol><li>分而治之/hash映射：针对数据太大，内存受限，只能是：把大文件化成(取模映射)小文件，即16字方针：大而化小，各个击破，缩小规模，逐个解决</li><li>hash统计：当大文件转化了小文件，那么我们便可以采用常规的Hashmap(ip，value)来进行频率统计。</li><li>堆/快速排序：统计完了之后，便进行排序(可采取堆排序)，得到次数最多的IP</li></ol><p>具体而论，“首先是这一天，并且是访问百度的日志的IP取出来，逐个写到一个大文件中。注意到IP是32位的，最多有个$2^{32}$个IP。同样可以采用映射的方法，比如%1000，把整个大文件映射为1000个小文件，再找出每个小文件中出现频率最大的IP（可以采用Hash_map对那1000个文件中的所以IP进行频率统计，然后依次找出各个文件中频率最大的那个IP）及相应的频率。然后再在这1000个最大的IP中，找出那个频率最大的IP，即为所求。”</p><p>关于本题，还有几个问题：</p><ol><li>Hash取模是一种等价映射，不会存在同一个元素分散到不同小文件中的情况，即这里采用的是mod1000算法，那么相同的IP在hash取模后，只可能落在同一个文件中，不可能被分散的。因为如果两个IP相等，那么经过Hash（IP）之后的哈希值是相同的，将此哈希值取模，必定仍然相等。</li><li>那到底什么是hash映射呢？简单来说，就是为了便于计算机在有限的内存中处理大数据，从而通过一种映射散列的方式让数据均匀分布在对应的内存位置（如大数据通过取余的方式映射城小数存放在内存中，或者大文件映射成多个小文件），而这个映射散列方式便是我们通常所说的hash函数，设计的好的hash函数能让数据均匀分布而减少冲突。尽管数据映射到了另外一些不同的位置，但数据还是原来的数据，只是代替和表示这些原始数据的形式发生了变化而已。</li></ol><blockquote><p>（2）寻找热门查询，300万个查询字符串中统计最热门的10个查询</p></blockquote><p>原题：搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1~255字节。假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门），请你统计最热门的10个查询串，要求使用的内存不能超过1G。</p><p>由上面那题可知，数据大则划分为小的，比如一亿个IP求Top10，可先%1000将IP分到1000个小文件中去，并保证一种IP只出现在一个文件中，再对每个小文件中的IP进行Hashmap计数统计并按数量排序，最后归并或者最小堆一次处理每个小文件的top10以得到最后的结。</p><p>但如果数据规模比较小，能一次性装入内存呢？比如这第二题，虽然有一千万个Query，但是由于重复度比较高，因此事实上只有300万的Query，每个Query255Byte，因此我们可以考虑把它们都放进内存中去（300万个字符串假设没有重复，都是最大长度，那么最多占用内存3M*1K/4=0.75G。所以可以将所有字符串都存放在内存中进行处理），而现在只需要一个合适的数据结构，在这里，HashTable绝对是我们优先的选择。</p><p>所以我们放弃分而治之、Hash映射的步骤，直接上Hash统计，然后排序。所以，针对此类典型的Top K问题，采取的对策往往是：Hashmap+堆。如下所示：</p><ol><li>Hash_map统计：先对这批海量数据预处理。具体方法是：维护一个Key为Query字符串，Value为该QUery出现次数的HashTable，即Hash_map(Query,Value)，每次读取一个Query，如果该字符串不在table内，则加入该字串，并且将Value值设为1；如果该字串在Table中，那么将该字串的计数加1即可。最终我们在O(N)的时间复杂度内用Hash表完成了统计。</li><li>堆排序：借助堆这个数据结构，找出Top K，时间复杂度为NlogK。即借助堆结构，我们可以在log量级的时间内查找和调整。因此，维护一个K（该题目中是10）大小的小根堆，然后遍历300万的Query，分别和根元素进行对比。所以，我们最终的时间复杂度是$O(N)+N·O(logK)$，（N为1000万，N’是300万）</li></ol><p>这篇文章中所述的堆排序思路：“维护k个元素的最小堆，即用容量为K的最小堆存储最先遍历到的k个数，并假设它们即是最大的k个数，建堆费时$O(k)$，并调整堆，费时$O(logk)$，这样我们就有$k_1&gt;k_2&gt;…k_{min}$（kmin设为小顶堆中最小元素）。继续遍历数列，每次遍历一个元素x，与堆顶元素比较，若$x&gt;k_{min}$，则更新堆（用时$log_k$），否则不更新堆。这样下来，总费时$O（k<em>logk+（n-k）</em>logk）=O（n*logk）$。此方法得益于在堆中，查找等各项操作时间复杂度均为logk。”</p><p>当然，你也可以采用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。</p><blockquote><p>（3）有一个1G大小的文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小时1M。返回频数最高的100个词。</p></blockquote><p>由上面那两个例题，分而治之 + hash统计 + 堆/快速排序这个套路，我们已经开始有了屡试不爽的感觉。下面，再拿几道再多多验证下。请看此第3题：又是文件很大，又是内存受限，咋办?还能怎么办呢?无非还是：</p><ol><li>分而治之/hash映射：顺序读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件（记为x0,x1,…x4999）中。这样每个文件大概是200k左右。如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。</li><li>hash统计：对每个小文件，采用trie树、hash——map等统计每个文件中出现的词以及相应的频率。</li><li>堆、归并排序：取出出现频率最大的100个词（可以用含100个结点的最小堆），并把100个词及相应的频率存入文件，这样又得到了5000个文件。最后就是把这5000个文件进行归并（类似于归并排序）的过程了。</li></ol><blockquote><p>（4）海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。</p></blockquote><p>如果每个数据元素只出现一次，而且只出现在某一台机器中，那么可以采取以下步骤统计出现次数TOP10的数据元素：</p><ol><li>堆排序：在每台电脑上求出TOP10，可以采用包含10个元素的堆完成（TOP10小，用最大堆，TOP10大，用最小堆，比如求TOP10大，我们首先取前10个元素调整成最小堆，如果发现，然后扫描后面的数据，并与堆顶元素比较，如果比堆顶元素大，那么用该元素替换堆顶，然后再调整为最小堆。最后堆中的元素就是TOP10大）。</li><li><p>求出每台电脑上的TOP10后，然后把这100台电脑上的TOP10组合起来，共1000个数据，再利用上面类似的方法求出TOP10就可以了。</p><p>但如果同一个元素重复出现在不同的电脑中呢，如下例子所述：就拿2台机器求top2的情况来说，第一台：a(50)、b(50)、c(49)、d(49)、e(0)、e(0)，第二台：a(0)、b(0)、c(49)、d(49)、e(50)、f(50)，这个时候，你可以有两种方法：</p><ol><li>遍历一遍所有数据，重新hash取摸，如此使得同一个元素只出现在单独的一台电脑中，然后采用上面所说的方法，统计每台电脑中各个元素的出现次数找出TOP10，继而组合100台电脑上的TOP10，找出最终的TOP10。</li><li>暴力求解：直接统计统计每台电脑中各个元素的出现次数，然后把同一个元素在不同机器中的出现次数相加，最终从所有数据中找出TOP10。</li></ol></li></ol><blockquote><p>（5）有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。</p></blockquote><ol><li>hash映射：顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件（记为）中。这样新生成的文件每个的大小大约也1G（假设hash函数是随机的）。</li><li>hash统计：找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。注：hash_map(query,query_count)是用来统计每个query的出现次数，不是存储他们的值，出现一次，则count+1。</li><li>堆/快速/归并排序：利用快速/堆/归并排序按照出现次数进行排序。将排序好的query和对应的query_cout输出到文件中。这样得到了10个排好序的文件。对这10个文件进行归并排序（内排序与外排序相结合）。</li></ol><p>除此之外，此题还有以下两个方法：</p><ol><li>一般query的总量是有限的，只是重复的次数比较多而已，可能对于所有的query，一次性就可以加入到内存了。这样，我们就可以采用trie树/hash_map等直接来统计每个query出现的次数，然后按出现次数做快速/堆/归并排序就可以了。</li><li>与方案1类似，但在做完hash，分成多个文件后，可以交给多个文件来处理，采用分布式的架构来处理（比如MapReduce），最后再进行合并。</li></ol><blockquote><p>（6）给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？</p></blockquote><p>可以估计每个文件的大小为5G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。</p><ol><li>分而治之/hash映射：遍历文件a，对每个url求取，然后根据所取得的值将url分别存储到1000个小文件（记为$a_0,a_1…..,a_{999}$）中。这样每个小文件的大约为300M。遍历文件b，采取和a相同的方式将url分别存储到1000小文件中（记为$b_0,b_1……,b_{999}$）。这样处理后，所有可能相同的url都在对应的小文件（$a_0vsb_0,a_1vsb_1……a_{999}vsb_{999}$）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。</li><li>hash_set统计：求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。</li></ol><blockquote><p>（7）怎么在海量数据中找出重复次数最多的一个？</p></blockquote><p>先做hash，然后求模映射为小文件，求出每个小文件中重复次数最多的一个，并记录重复次数。然后找出上一步求出的数据中重复次数最多的一个就是所求（具体参考前面的题）。</p><blockquote><p>（8）上千万或上亿数据（有重复），统计其中出现次数最多的前N个数据。</p></blockquote><p>上千万或上亿的数据，现在的机器的内存应该能存下。所以考虑采用hash_map/搜索二叉树/红黑树等来进行统计次数。然后利用堆取出前N个出现次数最多的数据。</p><blockquote><p>（9）一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。</p></blockquote><ul><li>方案1：如果文件比较大，无法一次性读入内存，可以采用hash取模的方法，将大文件分解为多个小文件，对于单个小文件利用hash_map统计出每个小文件中10个最常出现的词，然后再进行归并处理，找出最终的10个最常出现的词。</li><li>方案2：通过hash取模将大文件分解为多个小文件后，除了可以用hash_map统计出每个小文件中10个最常出现的词，也可以用trie树统计每个词出现的次数，时间复杂度是$O(n<em>le)$（le表示单词的平准长度），最终同样找出出现最频繁的前10个词（可用堆来实现），时间复杂度是$O(n</em>lg10)$。</li></ul><h3 id="密钥二：双层桶划分"><a href="#密钥二：双层桶划分" class="headerlink" title="密钥二：双层桶划分"></a>密钥二：双层桶划分</h3><p>双层桶划分，其实本质上还是分而治之的思想，重在“分”的技巧上！</p><p>适用范围：第k大，中位数，不重复或重复的数字 </p><p>基本原理及要点：因为元素范围很大，不能利用直接寻址表，所以通过多次划分，逐步确定范围，然后最后在一个可以接受的范围内进行。可以通过多次缩小，双层只是一个例子。</p><blockquote><p>（1）2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。 </p></blockquote><p>有点像鸽巢原理，整数个数为$2^{32}$,也就是，我们可以将这$2^{32}$个数，划分为$2^8$个区域(比如用单个文件代表一个区域)，然后将数据分离到不同的区域，然后不同的区域在利用bitmap就可以直接解决了。也就是说只要有足够的磁盘空间，就可以很方便的解决。</p><blockquote><p>（2）5亿个int找它们的中位数。 </p></blockquote><p>这个例子比上面那个更明显。首先我们将int划分为$2^{16}$个区域，然后读取数据统计落到各个区域里的数的个数，之后我们根据统计结果就可以判断中位数落到那个区域，同时知道这个区域中的第几大数刚好是中位数。然后第二次扫描我们只统计落在这个区域中的那些数就可以了。 </p><p>实际上，如果不是int是int64，我们可以经过3次这样的划分即可降低到可以接受的程度。即可以先将int64分成$2^{24}$个区域，然后确定区域的第几大数，在将该区域分成$2^{20}$个子区域，然后确定是子区域的第几大数，然后子区域里的数的个数只有$2^{20}$，就可以直接利用direct addr table进行统计了。</p><h3 id="密钥三：Bloom-filter-Bitmap"><a href="#密钥三：Bloom-filter-Bitmap" class="headerlink" title="密钥三：Bloom filter/Bitmap"></a>密钥三：Bloom filter/Bitmap</h3><blockquote><p>Bloom filter</p></blockquote><p><a href="http://blog.csdn.net/v_july_v/article/details/6685894" target="_blank" rel="noopener">海量数据处理之Bloom Filter详解</a></p><p>适用范围：可以用来实现数据字典，进行数据的判重，或者集合求交集</p><p>基本原理及要点： 对于原理来说很简单，位数组+k个独立hash函数。将hash函数对应的值的位数组置1，查找时如果发现所有hash函数对应位都是1说明存在，很明显这个过程并不保证查找的结果是100%正确的。同时也不支持删除一个已经插入的关键字，因为该关键字对应的位会牵动到其他的关键字。所以一个简单的改进就是 counting Bloom filter，用一个counter数组代替位数组，就可以支持删除了。 </p><p>还有一个比较重要的问题，如何根据输入元素个数n，确定位数组m的大小及hash函数个数。当hash函数个数$k=(ln2)<em>(m/n)$时错误率最小。在错误率不大于E的情况下，m至少要等于$n</em>lg(1/E)$才能表示任意n个元素的集合。但m还应该更大些，因为还要保证bit数组里至少一半为0，则$m&gt;=nlg(1/E)*lge$ 大概就是$nlg(1/E)1.44$倍(lg表示以2为底的对数)。 </p><p>举个例子我们假设错误率为0.01，则此时m应大概是n的13倍。这样k大概是8个。 注意这里m与n的单位不同，m是bit为单位，而n则是以元素个数为单位(准确的说是不同元素的个数)。通常单个元素的长度都是有很多bit的。所以使用bloom filter内存上通常都是节省的。</p><p>扩展：Bloom filter将集合中的元素映射到位数组中，用k（k为哈希函数个数）个映射位是否全1表示元素在不在这个集合中。Counting bloom filter（CBF）将位数组中的每一位扩展为一个counter，从而支持了元素的删除操作。Spectral Bloom Filter（SBF）将其与集合元素的出现次数关联。SBF采用counter中的最小值来近似表示元素的出现频率。 </p><p>问题实例：</p><blockquote><p>给你A,B两个文件，各存放50亿条URL，每条URL占用64字节，内存限制是4G，让你找出A,B文件共同的URL。如果是三个乃至n个文件呢？ </p></blockquote><p>根据这个问题我们来计算下内存的占用，$4G=2^{32}$大概是40亿*8大概是340亿，n=50亿，如果按出错率0.01算需要的大概是650亿个bit。现在可用的是340亿，相差并不多，这样可能会使出错率上升些。另外如果这些urlip是一一对应的，就可以转换成ip，则大大简单了。</p><p>同时，上文的第5题：给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？如果允许有一定的错误率，可以使用Bloom filter，4G内存大概可以表示340亿bit。将其中一个文件中的url使用Bloom filter映射为这340亿bit，然后挨个读取另外一个文件的url，检查是否与Bloom filter，如果是，那么该url应该是共同的url（注意会有一定的错误率）。</p><blockquote><p>Bitmap介绍</p></blockquote><p><a href="http://blog.csdn.net/v_july_v/article/details/6685962" target="_blank" rel="noopener">Bit-map详解</a></p><p>所谓的Bit-map就是用一个bit位来标记某个元素对应的Value， 而Key即是该元素。由于采用了Bit为单位来存储数据，因此在存储空间方面，可以大大节省。</p><p>如果说了这么多还没明白什么是Bit-map，那么我们来看一个具体的例子，假设我们要对0-7内的5个元素(4,7,2,5,3)排序（这里假设这些元素没有重复）。那么我们就可以采用Bit-map的方法来达到排序的目的。要表示8个数，我们就只需要8个Bit（1Bytes），首先我们开辟1Byte的空间，将这些空间的所有Bit位都置为0，如下图：<br><img src="http://omu7tit09.bkt.clouddn.com/15022535201076.jpg" alt=""></p><p>然后遍历这5个元素，首先第一个元素是4，那么就把4对应的位置为1（可以这样操作 p+(i/8)|(0×01&lt;&lt;(i%8)) 当然了这里的操作涉及到Big-ending和Little-ending的情况，这里默认为Big-ending）,因为是从零开始的，所以要把第五位置为一，如下图：<br><img src="http://omu7tit09.bkt.clouddn.com/15022535649356.jpg" alt=""></p><p>然后再处理第二个元素7，将第八位置为1,，接着再处理第三个元素，一直到最后处理完所有的元素，将相应的位置为1，这时候的内存的Bit位的状态如下：<br><img src="http://omu7tit09.bkt.clouddn.com/15022536293546.jpg" alt=""></p><p>然后我们现在遍历一遍Bit区域，将该位是一的位的编号输出（2，3，4，5，7），这样就达到了排序的目的。下面的代码给出了一个BitMap的用法：排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">//定义每个Byte中有8个Bit位  </div><div class="line">#include ＜memory.h＞  </div><div class="line">#define BYTESIZE 8  </div><div class="line">void SetBit(char *p, int posi)  </div><div class="line">&#123;  </div><div class="line">    for(int i=0; i ＜ (posi/BYTESIZE); i++)  </div><div class="line">    &#123;  </div><div class="line">        p++;  </div><div class="line">    &#125;    </div><div class="line">    *p = *p|(0x01＜＜(posi%BYTESIZE));//将该Bit位赋值1  </div><div class="line">    return;  </div><div class="line">&#125;  </div><div class="line">void BitMapSortDemo()  </div><div class="line">&#123;  </div><div class="line">    //为了简单起见，我们不考虑负数  </div><div class="line">    int num[] = &#123;3,5,2,10,6,12,8,14,9&#125;;    </div><div class="line">    //BufferLen这个值是根据待排序的数据中最大值确定的  </div><div class="line">    //待排序中的最大值是14，因此只需要2个Bytes(16个Bit)  </div><div class="line">    //就可以了。  </div><div class="line">    const int BufferLen = 2;  </div><div class="line">    char *pBuffer = new char[BufferLen];    </div><div class="line">    //要将所有的Bit位置为0，否则结果不可预知。  </div><div class="line">    memset(pBuffer,0,BufferLen);  </div><div class="line">    for(int i=0;i＜9;i++)  </div><div class="line">    &#123;  </div><div class="line">        //首先将相应Bit位上置为1  </div><div class="line">        SetBit(pBuffer,num[i]);  </div><div class="line">    &#125;    </div><div class="line">    //输出排序结果  </div><div class="line">    for(int i=0;i＜BufferLen;i++)//每次处理一个字节(Byte)  </div><div class="line">    &#123;  </div><div class="line">        for(int j=0;j＜BYTESIZE;j++)//处理该字节中的每个Bit位  </div><div class="line">        &#123;  </div><div class="line">            //判断该位上是否是1，进行输出，这里的判断比较笨。  </div><div class="line">            //首先得到该第j位的掩码（0x01＜＜j），将内存区中的  </div><div class="line">            //位和此掩码作与操作。最后判断掩码是否和处理后的  </div><div class="line">            //结果相同  </div><div class="line">            if((*pBuffer&amp;(0x01＜＜j)) == (0x01＜＜j))  </div><div class="line">            &#123;  </div><div class="line">                printf(&quot;%d &quot;,i*BYTESIZE + j);  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        pBuffer++;  </div><div class="line">    &#125;  </div><div class="line">&#125;    </div><div class="line">int _tmain(int argc, _TCHAR* argv[])  </div><div class="line">&#123;  </div><div class="line">    BitMapSortDemo();  </div><div class="line">    return 0;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可进行数据的快速查找，判重，删除，一般来说数据范围是int的10倍以下。<br>问题实例</p><blockquote><p>在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。</p></blockquote><ul><li>方案1：采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存2^32 * 2 bit=1 GB内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。</li><li>方案2：也可采用与第1题类似的方法，进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。”</li></ul><blockquote><p>给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？</p></blockquote><ul><li>方案1：用位图/Bitmap的方法，申请512M的内存，一个bit位代表一个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。</li></ul><h3 id="密匙四：Trie树-数据库-倒排索引"><a href="#密匙四：Trie树-数据库-倒排索引" class="headerlink" title="密匙四：Trie树/数据库/倒排索引"></a>密匙四：Trie树/数据库/倒排索引</h3><blockquote><p>Trie树</p></blockquote><ul><li>适用范围：数据量大，重复多，但是数据种类小，可以放入内存 </li><li>基本原理及要点：实现方式，节点孩子的表示方式 </li><li>扩展：压缩实现。</li></ul><p>问题实例</p><ol><li>密钥一（2）：寻找热门查询：查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个，每个不超过255字节。</li><li>密钥一（5）：有10个文件，每个文件1G，每个文件的每一行都存放的是用户的query，每个文件的query都可能重复。要你按照query的频度排序。</li><li>密钥一（8）：一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词。其解决方法是：用trie树统计每个词出现的次数，时间复杂度是O(n*le)（le表示单词的平准长度），然后是找出出现最频繁的前10个词。</li><li>1000万字符串，其中有些是相同的(重复),需要把重复的全部去掉，保留没有重复的字符串。请问怎么设计和实现？</li></ol><p>更多有关Trie树的介绍，请参见此文：<a href="http://blog.csdn.net/v_july_v/article/details/6897097" target="_blank" rel="noopener">从Trie树（字典树）谈到后缀树</a></p><blockquote><p>数据库索引</p></blockquote><ul><li>适用范围：大数据量的增删改查 </li><li>基本原理及要点：利用数据的设计实现方法，对海量数据的增删改查进行处理。</li></ul><p>关于数据库索引及其优化，更多可参见此文：<a href="http://www.cnblogs.com/pkuoliver/archive/2011/08/17/mass-data-topic-7-index-and-optimize.html" target="_blank" rel="noopener">海量数据处理专题（七）——数据库索引及优化</a>。同时，关于MySQL索引背后的数据结构及算法原理，这里还有一篇很好的文章：<a href="http://www.codinglabs.org/html/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a>。</p><blockquote><p>倒排索引(Inverted index)</p></blockquote><ul><li>适用范围：搜索引擎，关键字查询 </li><li>基本原理及要点：为何叫倒排索引？一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。</li></ul><p>以英文为例，下面是要被索引的文本： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">T0 = “it is what it is” </div><div class="line">T1 = “what is it” </div><div class="line">T2 = “it is a banana”</div></pre></td></tr></table></figure><p>我们就能得到下面的反向文件索引： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">“a”: &#123;2&#125; </div><div class="line">“banana”: &#123;2&#125; </div><div class="line">“is”: &#123;0, 1, 2&#125; </div><div class="line">“it”: &#123;0, 1, 2&#125; </div><div class="line">“what”: &#123;0, 1&#125;</div></pre></td></tr></table></figure><p>检索的条件”what”,”is”和”it”将对应集合的交集。</p><p>正向索引开发出来用来存储每个文档的单词的列表。正向索引的查询往往满足每个文档有序频繁的全文查询和每个单词在校验文档中的验证这样的查询。在正向索引中，文档占据了中心的位置，每个文档指向了一个它所包含的索引项的序列。也就是说文档指向了它包含的那些单词，而反向索引则是单词指向了包含它的文档，很容易看到这个反向的关系。 </p><p>问题实例：文档检索系统，查询那些文件包含了某单词，比如常见的学术论文的关键字搜索。</p><h3 id="密匙五：外排序"><a href="#密匙五：外排序" class="headerlink" title="密匙五：外排序"></a>密匙五：外排序</h3><p>适用范围：大数据的排序，去重<br>基本原理及要点：外排序的归并方法，置换选择败者树原理，最优归并树 </p><blockquote><p>（1）有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16个字节，内存限制大小是1M。返回频数最高的100个词。 </p></blockquote><p>这个数据具有很明显的特点，词的大小为16个字节，但是内存只有1m做hash有些不够，所以可以用来排序。内存可以当输入缓冲区使用。</p><p>关于多路归并算法及外排序的具体应用场景，请参见：<br><a href="http://blog.csdn.net/v_JULY_v/article/details/6451990" target="_blank" rel="noopener">如何给10000000个数据量的磁盘文件排序</a>。</p><h3 id="密匙六：分布式处理之Mapreduce"><a href="#密匙六：分布式处理之Mapreduce" class="headerlink" title="密匙六：分布式处理之Mapreduce"></a>密匙六：分布式处理之Mapreduce</h3><p>MapReduce是一种计算模型，简单的说就是将大批量的工作（数据）分解（MAP）执行，然后再将结果合并成最终结果（REDUCE）。这样做的好处是可以在任务被分解后，可以通过大量机器进行并行计算，减少整个操作的时间。但如果你要我再通俗点介绍，那么，说白了，Mapreduce的原理就是一个归并排序。</p><ul><li>适用范围：数据量大，但是数据种类小可以放入内存</li><li>基本原理及要点：将数据交给不同的机器去处理，数据划分，结果归约。</li></ul><p>问题实例</p><ul><li>The canonical example application of MapReduce is a process to count the appearances of each different word in a set of documents:</li><li>海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。</li><li>一共有N个机器，每个机器上有N个数。每个机器最多存O(N)个数并对它们操作。如何找到$N^2$个数的中位数(median)？</li></ul><p>更多具体阐述请参见：<br><a href="http://blog.csdn.net/v_july_v/article/details/6704077" target="_blank" rel="noopener">从Hadhoop框架与MapReduce模式中谈海量数据处理</a><br><a href="http://blog.csdn.net/v_july_v/article/details/6637014" target="_blank" rel="noopener"> MapReduce技术的初步了解与学习</a></p><h2 id="四、海量数据处理题库搜集"><a href="#四、海量数据处理题库搜集" class="headerlink" title="四、海量数据处理题库搜集"></a>四、海量数据处理题库搜集</h2><ol><li>如何在海量数据中查找给定部分数据最相似的top200向量，向量的维度也很高，因为之前了解过其他面蚂蚁金服的朋友，也有问到这个题目的，所以反应比较快，直接就说可以用KD树，聚类，hash，</li><li>如何在海量数据中查找给定部分数据最相似的top200向量，向量的维度也很高，实现一个分布式的topN算法</li><li>最后是一个海量数据处理题，给了个滴滴打车的背景，实质就是如何在海量数据中找到最大值。我按着分治思想说了一个解法，意思到了，他也就没往深处问。</li><li>要求手写海量数据topK的问题，手写个最小堆，之前没自己写过，幸亏ＴＴＦ同学临时指导了一下，都准备好了也没面到</li><li>海量数据问题，给定１０亿个数，统计出现次数最多的１００个数，如果把数换成字符串呢</li><li>给你1000个数，怎样随机抽取10个数</li><li>之后就是大数据题目，1KW句子算相似度（还是那套分块+hash/建索引，但是因为本人不是做这个的，文本处理根本说一片空白，所以就不误导大家了），之后就是一直围绕大数据的题目不断深化。</li><li>怎么在2G内存里找100TB数据的中位数</li><li>从大数据中找出topk</li><li>对大小在1-10000的1亿个数进行排序，你会怎么做？（友情提示，不要用基于比较的排序算法哦）</li><li>怎么在2G内存里找100TB数据的中位数，</li><li>10亿个整数，1G内存，O(n)算法，统计只出现一次的数。 </li><li>N个数找K大数那个题,堆解释了一遍,比较满意,问还能怎么优化O(Nlogk)的方法，并行方面想</li><li>给$10^{10}$个64位数,100M内存的空间排序,感谢队长刚好在去的前一天教过我一个求中位数的方法.用文件操作来做了,像快排一样,二分选个数统计大于那个数的数量和小于那个数的数量,如果能用100M的空间排序就把那些数排了,如果不能继续.直到能排为止.</li><li>第k大之类的套路题</li><li>如何从很多的query中找出一个query （我开始想到hash，后来经提示我想到了前缀树）若允许有错误，可以再怎么解决（不知道，面试官提示了布隆过滤器）</li><li>百度二面那个query找相似的系统设计题，我先后说了前缀树，kd树等解决方案，虽然不对，但面试至少知道我了解这些东西</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、何谓海量数据处理？&quot;&gt;&lt;a href=&quot;#一、何谓海量数据处理？&quot; class=&quot;headerlink&quot; title=&quot;一、何谓海量数据处理？&quot;&gt;&lt;/a&gt;一、何谓海量数据处理？&lt;/h2&gt;&lt;p&gt;所谓海量数据处理，其实很简单，海量，海量，何谓海量，就是数据量太大，所以导致要么是无法再较短时间内迅速解决，要么是数据太大，导致无法一次性装入内存。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法（18）：倒排索引</title>
    <link href="http://yoursite.com/2017/08/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8818%EF%BC%89%EF%BC%9A%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/"/>
    <id>http://yoursite.com/2017/08/01/数据结构与算法（18）：倒排索引/</id>
    <published>2017-08-01T15:20:45.000Z</published>
    <updated>2017-09-01T07:08:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、倒排索引"><a href="#一、倒排索引" class="headerlink" title="一、倒排索引"></a>一、倒排索引</h2><p>倒排索引（inverted index），也常被称为反向索引、置入档案或反向档案，是一种索引方法，被用来存储在全文搜索下某个单词在一个文档或一组文档中存储位置的映射。它是文档检索系统中最常用的数据结构。</p><a id="more"></a><p>有两种不同的倒排索引形式：</p><ul><li>一条记录的水平反向索引（或者反向档案索引）包含每个引用单词的文档的列表。</li><li>一个单词的水平反向索引（或者完全反向索引）又包含每个单词在一个文档中的位置。</li></ul><p>后者的形式提供了更多的兼容性（比如短语搜索），但是需要更多的时间和空间来创建。</p><p>以英文为例，下面是要被索引的文本：</p><ul><li>$T_0$=”it is what it is”</li><li>$T_1$=”what is it”</li><li>$T_2$=”it is a banana”</li></ul><p>我们就能得到下面的反向文件索引：</p><ul><li>“a”:      {2}</li><li>“banana”: {2}</li><li>“is”:     {0, 1, 2}</li><li>“it”:     {0, 1, 2}</li><li>“what”:   {0, 1}</li></ul><p>检索的条件”what”, “is” 和 “it” 将对应这个集合：${\displaystyle \{0,1\}\cap \{0,1,2\}\cap \{0,1,2\}=\{0,1}$</p><p>对相同的文字，我们得到后面这些完全反向索引，有文档数量和当前查询的单词结果组成的的成对数据。 同样，文档数量和当前查询的单词结果都从零开始。所以，”banana”: {(2, 3)} 就是说 “banana”在第三个文档里 $T_{2}$，而且在第三个文档的位置是第四个单词(地址为 3)。</p><ul><li>“a”:      {(2, 2)}</li><li>“banana”: {(2, 3)}</li><li>“is”:     {(0, 1), (0, 4), (1, 1), (2, 1)}</li><li>“it”:     {(0, 0), (0, 3), (1, 2), (2, 0)} </li><li>“what”:   {(0, 2), (1, 0)}</li></ul><p>如果我们执行短语搜索”what is it” 我们得到这个短语的全部单词各自的结果所在文档为文档0和文档1。但是这个短语检索的连续的条件仅仅在文档1得到。</p><p>有了这个索引系统，搜索引擎可以很方便地响应用户的查询，比如用户输入查询词“banana”，搜索系统查找倒排索引，从中可以读出包含这个单词的文档，这些文档就是提供给用户的搜索结果，而利用单词频率信息、文档频率信息即可以对这些候选搜索结果进行排序，计算文档和查询的相似性，按照相似性得分由高到低排序输出，此即为搜索系统的部分内部流程。</p><h2 id="二、单词词典"><a href="#二、单词词典" class="headerlink" title="二、单词词典"></a>二、单词词典</h2><p>单词词典是倒排索引中非常重要的组成部分，它用来维护文档集合中出现过的所有单词的相关信息，同时用来记载某个单词对应的倒排列表在倒排文件中的位置信息。在支持搜索时，根据用户的查询词，去单词词典里查询，就能够获得相应的倒排列表，并以此作为后续排序的基础。</p><p> 对于一个规模很大的文档集合来说，可能包含几十万甚至上百万的不同单词，能否快速定位某个单词，这直接影响搜索时的响应速度，所以需要高效的数据结构来对单词词典进行构建和查找，常用的数据结构包括哈希加链表结构和树形词典结构。</p><h3 id="2-1-哈希加链表"><a href="#2-1-哈希加链表" class="headerlink" title="2.1 哈希加链表"></a>2.1 哈希加链表</h3><p> 这种词典结构主要由两个部分构成：</p><p>主体部分是哈希每个哈希表项保存一个指针，指针指向冲突链表，在冲突链表里，相同哈希值的单词形成链表结构。之所以会有冲突链表，是因为两个不同单词获得相同的哈希值，如果是这样，在哈希方法里被称做是一次冲突，可以将相同哈希值的单词存储在链表里，以供后续查找。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15032803466774.jpg" alt=""></p><p>在建立索引的过程中，词典结构也会相应地被构建出来。比如在解析一个新文档的时候，对于某个在文档中出现的单词T，首先利用哈希函数获得其哈希值，之后根据哈希值对应的哈希表项读取其中保存的指针，就找到了对应的冲突链表。如果冲突链表里已经存在这个单词，说明单词在之前解析的文档里已经出现过。如果在冲突链表里没有发现这个单词，说明该单词是首次碰到，则将其加入冲突链表里。通过这种方式，当文档集合内所有文档解析完毕时，相应的词典结构也就建立起来了。</p><p>在响应用户查询请求时，其过程与建立词典类似，不同点在于即使词典里没出现过某个单词，也不会添加到词典内。以图1-7为例，假设用户输入的查询请求为单词3，对这个单词进行哈希，定位到哈希表内的2号槽，从其保留的指针可以获得冲突链表，依次将单词3和冲突链表内的单词比较，发现单词3在冲突链表内，于是找到这个单词，之后可以读出这个单词对应的倒排列表来进行后续的工作，如果没有找到这个单词，说明文档集合内没有任何文档包含单词，则搜索结果为空。</p><h3 id="2-2-树形结构"><a href="#2-2-树形结构" class="headerlink" title="2.2 树形结构"></a>2.2 树形结构</h3><p>B树（或者B+树）是另外一种高效查找结构，图1-8是一个 B树结构示意图。B树与哈希方式查找不同，需要字典项能够按照大小排序（数字或者字符序），而哈希方式则无须数据满足此项要求。</p><p>B树形成了层级查找结构，中间节点用于指出一定顺序范围的词典项目存储在哪个子树中，起到根据词典项比较大小进行导航的作用，最底层的叶子节点存储单词的地址信息，根据这个地址就可以提取出单词字符串。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15032807488216.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、倒排索引&quot;&gt;&lt;a href=&quot;#一、倒排索引&quot; class=&quot;headerlink&quot; title=&quot;一、倒排索引&quot;&gt;&lt;/a&gt;一、倒排索引&lt;/h2&gt;&lt;p&gt;倒排索引（inverted index），也常被称为反向索引、置入档案或反向档案，是一种索引方法，被用来存储在全文搜索下某个单词在一个文档或一组文档中存储位置的映射。它是文档检索系统中最常用的数据结构。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="倒排索引" scheme="http://yoursite.com/tags/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法（17）：simhash</title>
    <link href="http://yoursite.com/2017/08/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%EF%BC%9Asimhash/"/>
    <id>http://yoursite.com/2017/08/01/数据结构与算法（17）：simhash/</id>
    <published>2017-08-01T14:20:45.000Z</published>
    <updated>2017-09-01T07:08:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、引入"><a href="#一、引入" class="headerlink" title="一、引入"></a>一、引入</h2><p>随着信息爆炸时代的来临，互联网上充斥着着大量的近重复信息，有效地识别它们是一个很有意义的课题。例如，对于搜索引擎的爬虫系统来说，收录重复的网页是毫无意义的，只会造成存储和计算资源的浪费；同时，展示重复的信息对于用户来说也并不是最好的体验。造成网页近重复的可能原因主要包括： </p><a id="more"></a><ul><li>镜像网站</li><li>内容复制</li><li>嵌入广告</li><li>计数改变</li><li>少量修改</li></ul><p>一个简化的爬虫系统架构如下图所示：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15032777664354.jpg" alt=""></p><p>事实上，传统比较两个文本相似性的方法，大多是将文本分词之后，转化为特征向量距离的度量，比如常见的欧氏距离、海明距离或者余弦角度等等。两两比较固然能很好地适应，但这种方法的一个最大的缺点就是，无法将其扩展到海量数据。例如，试想像Google那种收录了数以几十亿互联网信息的大型搜索引擎，每天都会通过爬虫的方式为自己的索引库新增的数百万网页，如果待收录每一条数据都去和网页库里面的每条记录算一下余弦角度，其计算量是相当恐怖的。 </p><p>我们考虑采用为每一个web文档通过hash的方式生成一个指纹（fingerprint）。传统的加密式hash，比如md5，其设计的目的是为了让整个分布尽可能地均匀，输入内容哪怕只有轻微变化，hash就会发生很大地变化。我们理想当中的哈希函数，需要对几乎相同的输入内容，产生相同或者相近的hashcode，换句话说，hashcode的相似程度要能直接反映输入内容的相似程度。很明显，前面所说的md5等传统hash无法满足我们的需求。 </p><h2 id="二、simhash的原理"><a href="#二、simhash的原理" class="headerlink" title="二、simhash的原理"></a>二、simhash的原理</h2><p>simhash是locality sensitive hash（局部敏感哈希）的一种，最早由Moses Charikar在《similarity estimation techniques from rounding algorithms》一文中提出。Google就是基于此算法实现网页文件查重的。simhash算法的主要思想是降维，将高维的特征向量映射成一个f-bit的指纹(fingerprint)，通过比较两篇文章的f-bit指纹的Hamming Distance来确定文章是否重复或者高度近似。我们假设有以下三段文本：</p><ul><li>the cat sat on the mat</li><li>the cat sat on a mat</li><li>we all scream for ice cream</li></ul><p>使用传统hash可能会产生如下的结果： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">irb(main):006:0&gt; p1 = &apos;the cat sat on the mat&apos; </div><div class="line">irb(main):005:0&gt; p2 = &apos;the cat sat on a mat&apos; </div><div class="line">irb(main):007:0&gt; p3 = &apos;we all scream for ice cream&apos; </div><div class="line">irb(main):007:0&gt; p1.hash </div><div class="line">=&gt; 415542861 </div><div class="line">irb(main):007:0&gt; p2.hash </div><div class="line">=&gt; 668720516 </div><div class="line">irb(main):007:0&gt; p3.hash </div><div class="line">=&gt; 767429688</div></pre></td></tr></table></figure><p>使用simhash会应该产生类似如下的结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">irb(main):003:0&gt; p1.simhash </div><div class="line">=&gt; 851459198 </div><div class="line">00110010110000000011110001111110 </div><div class="line">irb(main):004:0&gt; p2.simhash </div><div class="line">=&gt; 847263864 </div><div class="line">00110010100000000011100001111000 </div><div class="line">irb(main):002:0&gt; p3.simhash </div><div class="line">=&gt; 984968088 </div><div class="line">00111010101101010110101110011000</div></pre></td></tr></table></figure><p>海明距离的定义，为两个二进制串中不同位的数量。上述三个文本的simhash结果，其两两之间的海明距离为(p1,p2)=4，(p1,p3)=16以及(p2,p3)=12。事实上，这正好符合文本之间的相似度，p1和p2间的相似度要远大于与p3的。 </p><p>如何实现这种hash算法呢？图解如下：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15032779655846.jpg" alt=""></p><p>算法过程大概如下：</p><ol><li>将Doc进行关键词抽取(其中包括分词和计算权重)，抽取出n个(关键词，权重)对， 即图中的<code>(feature, weight)</code>们。 记为 <code>feature_weight_pairs = [fw1, fw2 … fwn]</code>，其中 <code>fwn = (feature_n,weight_n</code>)。</li><li><code>hash_weight_pairs = [ (hash(feature), weight) for feature, weight in  feature_weight_pairs ]</code>生成图中的<code>(hash,weight)</code>们, 此时假设hash生成的位数bits_count = 6（如图）;</li><li>然后对<code>hash_weight_pairs</code>进行位的纵向累加，如果该位是1，则+weight,如果是0，则-weight，最后生成bits_count个数字，如图所示是[13, 108, -22, -5, -32, 55], 这里产生的值和hash函数所用的算法相关。</li><li><code>[13,108,-22,-5,-32,55] -&gt; 110001</code>这个就很简单啦，正1负0。</li></ol><h2 id="三、海明距离"><a href="#三、海明距离" class="headerlink" title="三、海明距离"></a>三、海明距离</h2><p>当我们算出所有doc的simhash值之后，需要计算doc A和doc B之间是否相似的条件是：A和B的海明距离是否小于等于n，这个n值根据经验一般取值为3,</p><p>那海明距离怎么计算呢？二进制串A 和 二进制串B 的海明距离 就是  A xor B 后二进制中1的个数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">举例如下：</div><div class="line">A = 100111;</div><div class="line">B = 101010;</div><div class="line">hamming_distance(A, B) = count_1(A xor B) = count_1(001101) = 3;</div></pre></td></tr></table></figure><p>simhash本质上是局部敏感性的hash，和md5之类的不一样。 正因为它的局部敏感性，所以我们可以使用海明距离来衡量simhash值的相似度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、引入&quot;&gt;&lt;a href=&quot;#一、引入&quot; class=&quot;headerlink&quot; title=&quot;一、引入&quot;&gt;&lt;/a&gt;一、引入&lt;/h2&gt;&lt;p&gt;随着信息爆炸时代的来临，互联网上充斥着着大量的近重复信息，有效地识别它们是一个很有意义的课题。例如，对于搜索引擎的爬虫系统来说，收录重复的网页是毫无意义的，只会造成存储和计算资源的浪费；同时，展示重复的信息对于用户来说也并不是最好的体验。造成网页近重复的可能原因主要包括： &lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="哈希" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C/"/>
    
      <category term="simhash" scheme="http://yoursite.com/tags/simhash/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法（16）：一致性哈希</title>
    <link href="http://yoursite.com/2017/07/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8816%EF%BC%89%EF%BC%9A%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/"/>
    <id>http://yoursite.com/2017/07/30/数据结构与算法（16）：一致性哈希/</id>
    <published>2017-07-30T14:20:45.000Z</published>
    <updated>2017-09-01T07:08:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>一致性哈希算法在1997年由麻省理工学院提出的一种分布式哈希（DHT）实现算法，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷和CARP十分类似。一致性哈希修正了CARP使用的简单哈希算法带来的问题，使得分布式哈希（DHT）可以在P2P环境中真正得到应用。 </p><a id="more"></a><h2 id="一、Hash算法"><a href="#一、Hash算法" class="headerlink" title="一、Hash算法"></a>一、Hash算法</h2><p>一致性hash算法提出了在动态变化的Cache环境中，判定哈希算法好坏的四个定义：</p><ol><li>平衡性(Balance)：平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。</li><li>单调性(Monotonicity)：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。 </li><li>分散性(Spread)：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。 </li><li>负载(Load)：负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同 的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。</li></ol><p>假设一个简单的场景：有4个cache服务器（后简称cache）组成的集群，当一个对象object传入集群时，这个对象应该存储在哪一个cache里呢？一种简单的方法是使用映射公式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hash(object) % 4</div></pre></td></tr></table></figure><p>这个算法就可以保证任何object都会尽可能随机落在其中一个cache中。一切运行正常。</p><p>然后考虑以下情况：</p><p>由于流量增大，需要增加一台cache，共5个cache。这时，映射公式就变成Hash(object) % 5。<br>有一个cache服务器down掉，变成3个cache。这时，映射公式就变成Hash(object) % 3。<br>可见，无论新增还是减少节点，都会改变映射公式，而由于映射公式改变，几乎所有的object都会被映射到新的cache中，这意味着一时间所有的缓存全部失效。 大量的数据请求落在app层甚至是db层上，这样严重的违反了单调性原则,这对服务器的影响当然是灾难性的。</p><p>接下来主要讲解一下一致性哈希算法是如何设计的：</p><h2 id="二、一致性Hash算法"><a href="#二、一致性Hash算法" class="headerlink" title="二、一致性Hash算法"></a>二、一致性Hash算法</h2><h3 id="2-1-环形Hash空间"><a href="#2-1-环形Hash空间" class="headerlink" title="2.1 环形Hash空间"></a>2.1 环形Hash空间</h3><p>按照常用的hash算法来将对应的key哈希到一个具有2^32次方个桶的空间中，即$0至 (2^{32})-1$的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形。如下图<br><img src="http://omu7tit09.bkt.clouddn.com/15032456506713.jpg" alt=""></p><h3 id="2-2-数据映射"><a href="#2-2-数据映射" class="headerlink" title="2.2 数据映射"></a>2.2 数据映射</h3><p>现在我们将object1、object2、object3、object4四个对象通过特定的Hash函数计算出对应的key值，然后散列到Hash环上。如下图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Hash(object1) = key1；</div><div class="line">Hash(object2) = key2；</div><div class="line">Hash(object3) = key3；</div><div class="line">Hash(object4) = key4；</div></pre></td></tr></table></figure><p><img src="http://omu7tit09.bkt.clouddn.com/15032457040230.jpg" alt=""></p><h3 id="2-3-机器映射"><a href="#2-3-机器映射" class="headerlink" title="2.3 机器映射"></a>2.3 机器映射</h3><p>在采用一致性哈希算法的分布式集群中将新的机器加入，其原理是通过使用与对象存储一样的Hash算法将机器也映射到环中（一般情况下对机器的hash计算是采用机器的IP或者机器唯一的别名作为输入值），然后以顺时针的方向计算，将所有对象存储到离自己最近的机器中。</p><p>假设现在有NODE1，NODE2，NODE3三台机器，通过Hash算法得到对应的KEY值，映射到环中，其示意图如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Hash(NODE1) = KEY1;</div><div class="line">Hash(NODE2) = KEY2;</div><div class="line">Hash(NODE3) = KEY3;</div></pre></td></tr></table></figure><p><img src="http://omu7tit09.bkt.clouddn.com/15032457583606.jpg" alt=""></p><p>通过上图可以看出对象与机器处于同一哈希空间中，这样按顺时针转动object1存储到了NODE1中，object3存储到了NODE2中，object2、object4存储到了NODE3中。在这样的部署环境中，hash环是不会变更的，因此，通过算出对象的hash值就能快速的定位到对应的机器中，这样就能找到对象真正的存储位置了。</p><h3 id="2-4-机器的删除与添加"><a href="#2-4-机器的删除与添加" class="headerlink" title="2.4 机器的删除与添加"></a>2.4 机器的删除与添加</h3><p>普通hash求余算法最为不妥的地方就是在有机器的添加或者删除之后会照成大量的对象存储位置失效，这样就大大的不满足单调性了。下面来分析一下一致性哈希算法是如何处理的。</p><h4 id="2-4-1-节点（机器）的删除"><a href="#2-4-1-节点（机器）的删除" class="headerlink" title="2.4.1 节点（机器）的删除"></a>2.4.1 节点（机器）的删除</h4><p>以上面的分布为例，如果NODE2出现故障被删除了，那么按照顺时针迁移的方法，object3将会被迁移到NODE3中，这样仅仅是object3的映射位置发生了变化，其它的对象没有任何的改动。如下图：<br><img src="http://omu7tit09.bkt.clouddn.com/15032458807559.jpg" alt=""></p><h4 id="2-4-2-节点（机器）的添加"><a href="#2-4-2-节点（机器）的添加" class="headerlink" title="2.4.2 节点（机器）的添加"></a>2.4.2 节点（机器）的添加</h4><p>如果往集群中添加一个新的节点NODE4，通过对应的哈希算法得到KEY4，并映射到环中，如下图：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15032459323158.jpg" alt=""></p><p>通过按顺时针迁移的规则，那么object2被迁移到了NODE4中，其它对象还保持这原有的存储位置。通过对节点的添加和删除的分析，一致性哈希算法在保持了单调性的同时，还是数据的迁移达到了最小，这样的算法对分布式集群来说是非常合适的，避免了大量数据迁移，减小了服务器的的压力。</p><h3 id="2-5-平衡性"><a href="#2-5-平衡性" class="headerlink" title="2.5 平衡性"></a>2.5 平衡性</h3><p>根据上面的图解分析，一致性哈希算法满足了单调性和负载均衡的特性以及一般hash算法的分散性，但这还并不能当做其被广泛应用的原由，因为还缺少了平衡性。下面将分析一致性哈希算法是如何满足平衡性的。hash算法是不保证平衡的，如上面只部署了NODE1和NODE3的情况（NODE2被删除的图），object1存储到了NODE1中，而object2、object3、object4都存储到了NODE3中，这样就照成了非常不平衡的状态。</p><h3 id="2-6-虚拟节点"><a href="#2-6-虚拟节点" class="headerlink" title="2.6 虚拟节点"></a>2.6 虚拟节点</h3><p>其实，理论上，只要cache足够多，每个cache在圆环上就会足够分散。但是在真实场景里，cache服务器只会有很少，所以，在一致性哈希算法中，为了尽可能的满足平衡性，其引入了虚拟节点的概念。</p><p>“虚拟节点”（ virtual node ）是实际节点（机器）在 hash 空间的复制品（ replica ），一实际个节点（机器）对应了若干个“虚拟节点”，这个对应个数也成为“复制个数”，“虚拟节点”在 hash 空间中以hash值排列。</p><p>以上面只部署了NODE1和NODE3的情况（NODE2被删除的图）为例，之前的对象在机器上的分布很不均衡，现在我们以2个副本（复制个数）为例，这样整个hash环中就存在了4个虚拟节点，最后对象映射的关系图如下：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15032460510317.jpg" alt=""></p><p>根据上图可知对象的映射关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">object1-&gt;NODE1-1，object2-&gt;NODE1-2，object3-&gt;NODE3-2，object4-&gt;NODE3-1</div></pre></td></tr></table></figure><p>通过虚拟节点的引入，对象的分布就比较均衡了。那么在实际操作中，正真的对象查询是如何工作的呢？对象从hash到虚拟节点到实际节点的转换如下图：<br><img src="http://omu7tit09.bkt.clouddn.com/15032461144759.jpg" alt=""></p><p>“虚拟节点”的hash计算可以采用对应节点的IP地址加数字后缀的方式。例如假设NODE1的IP地址为192.168.1.100。引入“虚拟节点”前，计算 cache A 的 hash 值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hash(“192.168.1.100”);</div></pre></td></tr></table></figure><p>引入“虚拟节点”后，计算“虚拟节”点NODE1-1和NODE1-2的hash值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Hash(“192.168.1.100#1”); // NODE1-1</div><div class="line">Hash(“192.168.1.100#2”); // NODE1-2</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一致性哈希算法在1997年由麻省理工学院提出的一种分布式哈希（DHT）实现算法，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷和CARP十分类似。一致性哈希修正了CARP使用的简单哈希算法带来的问题，使得分布式哈希（DHT）可以在P2P环境中真正得到应用。 &lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="哈希" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C/"/>
    
      <category term="一致性哈希" scheme="http://yoursite.com/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法（15）：布隆过滤器</title>
    <link href="http://yoursite.com/2017/07/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8815%EF%BC%89%EF%BC%9A%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>http://yoursite.com/2017/07/29/数据结构与算法（15）：布隆过滤器/</id>
    <published>2017-07-29T14:20:45.000Z</published>
    <updated>2017-09-01T07:08:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、引入"><a href="#一、引入" class="headerlink" title="一、引入"></a>一、引入</h2><p>什么情况下需要布隆过滤器？我们先来看几个比较常见的例子：</p><a id="more"></a><ul><li>字处理软件中，需要检查一个英语单词是否拼写正确</li><li>在 FBI，一个嫌疑人的名字是否已经在嫌疑名单上</li><li>在网络爬虫里，一个网址是否被访问过</li><li>yahoo, gmail等邮箱垃圾邮件过滤功能</li></ul><p>这几个例子有一个共同的特点： 如何判断一个元素是否存在一个集合中？</p><h2 id="二、常规思路与局限"><a href="#二、常规思路与局限" class="headerlink" title="二、常规思路与局限"></a>二、常规思路与局限</h2><p>如果想判断一个元素是不是在一个集合里，一般想到的是将集合中所有元素保存起来，然后通过比较确定。链表、树、散列表（又叫哈希表，Hash table）等等数据结构都是这种思路。但是随着集合中元素的增加，我们需要的存储空间越来越大。同时检索速度也越来越慢。</p><ul><li>数组</li><li>链表</li><li>树、平衡二叉树、Trie</li><li>Map (红黑树)</li><li>哈希表</li></ul><p>虽然上面描述的这几种数据结构配合常见的排序、二分搜索可以快速高效的处理绝大部分判断元素是否存在集合中的需求。但是当集合里面的元素数量足够大，如果有500万条记录甚至1亿条记录呢？这个时候常规的数据结构的问题就凸显出来了。</p><p>数组、链表、树等数据结构会存储元素的内容，一旦数据量过大，消耗的内存也会呈现线性增长，最终达到瓶颈。</p><p>有的同学可能会问，哈希表不是效率很高吗？查询效率可以达到O(1)。但是哈希表需要消耗的内存依然很高。使用哈希表存储一亿 个垃圾 email 地址的消耗？哈希表的做法：首先，哈希函数将一个email地址映射成8字节信息指纹；考虑到哈希表存储效率通常小于50%（哈希冲突）；因此消耗的内存：8 <em> 2 </em> 1亿 字节 = 1.6G 内存，普通计算机是无法提供如此大的内存。这个时候，布隆过滤器（Bloom Filter）就应运而生。在继续介绍布隆过滤器的原理时，先讲解下关于哈希函数的预备知识。</p><h3 id="三、哈希函数"><a href="#三、哈希函数" class="headerlink" title="三、哈希函数"></a>三、哈希函数</h3><p>哈希函数的概念是：将任意大小的数据转换成特定大小的数据的函数，转换后的数据称为哈希值或哈希编码。</p><p>一个应用是Hash table（散列表，也叫哈希表），是根据哈希值 (Key value) 而直接进行访问的数据结构。也就是说，它通过把哈希值映射到表中一个位置来访问记录，以加快查找的速度。下面是一个典型的 hash 函数 / 表示意图：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15032372861383.jpg" alt=""></p><p>可以明显的看到，原始数据经过哈希函数的映射后称为了一个个的哈希编码，数据得到压缩。哈希函数是实现哈希表和布隆过滤器的基础。</p><p>哈希函数有以下两个特点：</p><ul><li>如果两个散列值是不相同的（根据同一函数），那么这两个散列值的原始输入也是不相同的。</li><li>散列函数的输入和输出不是唯一对应关系的，如果两个散列值相同，两个输入值很可能是相同的。但也可能不同，这种情况称为 “散列碰撞”（或者 “散列冲突”）。</li></ul><p>缺点： 引用吴军博士的《数学之美》中所言，哈希表的空间效率还是不够高。如果用哈希表存储一亿个垃圾邮件地址，每个email地址 对应 8bytes, 而哈希表的存储效率一般只有50%，因此一个email地址需要占用16bytes. 因此一亿个email地址占用1.6GB，如果存储几十亿个email address则需要上百GB的内存。除非是超级计算机，一般的服务器是无法存储的。</p><p>所以要引入下面的 Bloom Filter。</p><h2 id="四、布隆过滤器（Bloom-Filter）"><a href="#四、布隆过滤器（Bloom-Filter）" class="headerlink" title="四、布隆过滤器（Bloom Filter）"></a>四、布隆过滤器（Bloom Filter）</h2><p>布隆过滤器（英语：Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p><h3 id="4-1-原理"><a href="#4-1-原理" class="headerlink" title="4.1 原理"></a>4.1 原理</h3><p>布隆过滤器（Bloom Filter）的核心实现是一个超大的位数组和几个哈希函数。假设位数组的长度为m，哈希函数的个数为k</p><p><img src="http://omu7tit09.bkt.clouddn.com/15032375523687.jpg" alt=""></p><p>以上图为例，具体的操作流程：假设集合里面有3个元素{x, y, z}，哈希函数的个数为3。首先将位数组进行初始化，将里面每个位都设置位0。</p><p>对于集合里面的每一个元素，将元素依次通过3个哈希函数进行映射，每次映射都会产生一个哈希值，这个值对应位数组上面的一个点，然后将位数组对应的位置标记为1。查询W元素是否存在集合中的时候，同样的方法将W通过哈希映射到位数组上的3个点。如果3个点的其中有一个点不为1，则可以判断该元素一定不存在集合中。反之，如果3个点都为1，则该元素可能存在集合中。</p><p>注意：此处不能判断该元素是否一定存在集合中，可能存在一定的误判率。可以从图中可以看到：假设某个元素通过映射对应下标为4，5，6这3个点。虽然这3个点都为1，但是很明显这3个点是不同元素经过哈希得到的位置，因此这种情况说明元素虽然不在集合中，也可能对应的都是1，这是误判率存在的原因。</p><h3 id="4-2-添加与查询"><a href="#4-2-添加与查询" class="headerlink" title="4.2 添加与查询"></a>4.2 添加与查询</h3><blockquote><p>布隆过滤器添加元素</p></blockquote><ul><li>将要添加的元素给k个哈希函数</li><li>得到对应于位数组上的k个位置</li><li>将这k个位置设为1</li></ul><blockquote><p>布隆过滤器查询元素</p></blockquote><ul><li>将要查询的元素给k个哈希函数</li><li>得到对应于位数组上的k个位置</li><li>如果k个位置有一个为0，则肯定不在集合中</li><li>如果k个位置全部为1，则可能在集合中</li></ul><h3 id="4-3-优点"><a href="#4-3-优点" class="headerlink" title="4.3 优点"></a>4.3 优点</h3><blockquote><p>It tells us that the element either definitely is not in the set or may be in the set.</p></blockquote><p>相比于其它的数据结构，布隆过滤器在空间和时间方面都有巨大的优势。布隆过滤器存储空间和插入/查询时间都是常数（O(k)）。另外，散列函数相互之间没有关系，方便由硬件并行实现。布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势。</p><p>布隆过滤器可以表示全集，其它任何数据结构都不能；</p><h3 id="4-4-缺点"><a href="#4-4-缺点" class="headerlink" title="4.4 缺点"></a>4.4 缺点</h3><p>但是布隆过滤器的缺点和优点一样明显。误算率是其中之一。随着存入的元素数量增加，误算率随之增加。但是如果元素数量太少，则使用散列表足矣。</p><p>误判补救方法是：再建立一个小的白名单，存储那些可能被误判的信息。</p><p>另外，一般情况下不能从布隆过滤器中删除元素. 我们很容易想到把位数组变成整数数组，每插入一个元素相应的计数器加 1, 这样删除元素时将计数器减掉就可以了。然而要保证安全地删除元素并非如此简单。首先我们必须保证删除的元素的确在布隆过滤器里面. 这一点单凭这个过滤器是无法保证的。另外计数器回绕也会造成问题。</p><h3 id="4-5-实例"><a href="#4-5-实例" class="headerlink" title="4.5 实例"></a>4.5 实例</h3><p>可以快速且空间效率高的判断一个元素是否属于一个集合；用来实现数据字典，或者集合求交集。</p><blockquote><p> Google chrome 浏览器使用bloom filter识别恶意链接（能够用较少的存储空间表示较大的数据集合，简单的想就是把每一个URL都可以映射成为一个bit）</p></blockquote><p>又如： 检测垃圾邮件</p><blockquote><p>假定我们存储一亿个电子邮件地址，我们先建立一个十六亿二进制（比特），即两亿字节的向量，然后将这十六亿个二进制全部设置为零。对于每一个电子邮件地址 X，我们用八个不同的随机数产生器（F1,F2, …,F8） 产生八个信息指纹（f1, f2, …, f8）。再用一个随机数产生器 G 把这八个信息指纹映射到 1 到十六亿中的八个自然数 g1, g2, …,g8。现在我们把这八个位置的二进制全部设置为一。当我们对这一亿个 email 地址都进行这样的处理后。一个针对这些 email 地址的布隆过滤器就建成了。</p></blockquote><p>再如:</p><blockquote><p>A,B 两个文件，各存放 50 亿条 URL，每条 URL 占用 64 字节，内存限制是 4G，让你找出 A,B 文件共同的 URL。如果是三个乃至 n 个文件呢？</p></blockquote><p>分析 ：如果允许有一定的错误率，可以使用 Bloom filter，4G 内存大概可以表示 340 亿 bit。将其中一个文件中的 url 使用 Bloom filter 映射为这 340 亿 bit，然后挨个读取另外一个文件的 url，检查是否与 Bloom filter，如果是，那么该 url 应该是共同的 url（注意会有一定的错误率）。”</p><h3 id="4-6-实现"><a href="#4-6-实现" class="headerlink" title="4.6 实现"></a>4.6 实现</h3><p>下面给出python的简单实现，使用murmurhash算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">import mmh3</div><div class="line">from bitarray import bitarray</div><div class="line"></div><div class="line"></div><div class="line"># zhihu_crawler.bloom_filter</div><div class="line"></div><div class="line"># Implement a simple bloom filter with murmurhash algorithm.</div><div class="line"># Bloom filter is used to check wether an element exists in a collection, and it has a good performance in big data situation.</div><div class="line"># It may has positive rate depend on hash functions and elements count.</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">BIT_SIZE = 5000000</div><div class="line"></div><div class="line">class BloomFilter:</div><div class="line">    </div><div class="line">    def __init__(self):</div><div class="line">        # Initialize bloom filter, set size and all bits to 0</div><div class="line">        bit_array = bitarray(BIT_SIZE)</div><div class="line">        bit_array.setall(0)</div><div class="line"></div><div class="line">        self.bit_array = bit_array</div><div class="line">        </div><div class="line">    def add(self, url):</div><div class="line">        # Add a url, and set points in bitarray to 1 (Points count is equal to hash funcs count.)</div><div class="line">        # Here use 7 hash functions.</div><div class="line">        point_list = self.get_postions(url)</div><div class="line"></div><div class="line">        for b in point_list:</div><div class="line">            self.bit_array[b] = 1</div><div class="line"></div><div class="line">    def contains(self, url):</div><div class="line">        # Check if a url is in a collection</div><div class="line">        point_list = self.get_postions(url)</div><div class="line"></div><div class="line">        result = True</div><div class="line">        for b in point_list:</div><div class="line">            result = result and self.bit_array[b]</div><div class="line">    </div><div class="line">        return result</div><div class="line"></div><div class="line">    def get_postions(self, url):</div><div class="line">        # Get points positions in bit vector.</div><div class="line">        point1 = mmh3.hash(url, 41) % BIT_SIZE</div><div class="line">        point2 = mmh3.hash(url, 42) % BIT_SIZE</div><div class="line">        point3 = mmh3.hash(url, 43) % BIT_SIZE</div><div class="line">        point4 = mmh3.hash(url, 44) % BIT_SIZE</div><div class="line">        point5 = mmh3.hash(url, 45) % BIT_SIZE</div><div class="line">        point6 = mmh3.hash(url, 46) % BIT_SIZE</div><div class="line">        point7 = mmh3.hash(url, 47) % BIT_SIZE</div><div class="line"></div><div class="line"></div><div class="line">        return [point1, point2, point3, point4, point5, point6, point7]</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、引入&quot;&gt;&lt;a href=&quot;#一、引入&quot; class=&quot;headerlink&quot; title=&quot;一、引入&quot;&gt;&lt;/a&gt;一、引入&lt;/h2&gt;&lt;p&gt;什么情况下需要布隆过滤器？我们先来看几个比较常见的例子：&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="哈希" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C/"/>
    
      <category term="布隆过滤器" scheme="http://yoursite.com/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法（14）：最短路算法</title>
    <link href="http://yoursite.com/2017/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8814%EF%BC%89%EF%BC%9A%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2017/07/28/数据结构与算法（14）：最短路算法/</id>
    <published>2017-07-28T14:20:45.000Z</published>
    <updated>2017-09-01T07:09:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>最短路径问题是图论研究中的一个经典算法问题，旨在寻找图（由结点和路径组成的）中两结点之间的最短路径。算法具体的形式包括：</p><a id="more"></a><ul><li>确定起点的最短路径问题 - 即已知起始结点，求最短路径的问题。适合使用Dijkstra算法。</li><li>确定终点的最短路径问题 - 与确定起点的问题相反，该问题是已知终结结点，求最短路径的问题。在无向图中该问题与确定起点的问题完全等同，在有向图中该问题等同于把所有路径方向反转的确定起点的问题。</li><li>确定起点终点的最短路径问题 - 即已知起点和终点，求两结点之间的最短路径。</li><li>全局最短路径问题 - 求图中所有的最短路径。适合使用Floyd-Warshall算法。</li></ul><h2 id="一、Dijkstra算法"><a href="#一、Dijkstra算法" class="headerlink" title="一、Dijkstra算法"></a>一、Dijkstra算法</h2><h3 id="1-1-算法思想"><a href="#1-1-算法思想" class="headerlink" title="1.1 算法思想"></a>1.1 算法思想</h3><p>Dijkstra(迪杰斯特拉)算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。Dijkstra算法是很有代表性的最短路径算法，在很多专业课程中都作为基本内容有详细的介绍，如数据结构，图论，运筹学等等。注意该算法要求图中不存在负权边。</p><blockquote><p>问题描述：</p></blockquote><p>在无向图 G=(V,E) 中，假设每条边 E[i] 的长度为 w[i]，找到由顶点 V0 到其余各点的最短路径。（单源最短路径）</p><blockquote><p>算法思想：</p></blockquote><p>设G=(V,E)是一个带权有向图，把图中顶点集合V分成两组，第一组为已求出最短路径的顶点集合（用S表示，初始时S中只有一个源点，以后每求得一条最短路径 , 就将加入到集合S中，直到全部顶点都加入到S中，算法就结束了），第二组为其余未确定最短路径的顶点集合（用U表示），按最短路径长度的递增次序依次把第二组的顶点加入S中。在加入的过程中，总保持从源点v到S中各顶点的最短路径长度不大于从源点v到U中任何顶点的最短路径长度。此外，每个顶点对应一个距离，S中的顶点的距离就是从v到此顶点的最短路径长度，U中的顶点的距离，是从v到此顶点只包括S中的顶点为中间顶点的当前最短路径长度。</p><blockquote><p>适用条件与限制</p></blockquote><ul><li>有向图和无向图都可以使用本算法，无向图中的每条边可以看成相反的两条边。</li><li>用来求最短路的图中不能存在负权边。(可以利用拓扑排序检测)</li></ul><h3 id="1-2-算法步骤"><a href="#1-2-算法步骤" class="headerlink" title="1.2 算法步骤"></a>1.2 算法步骤</h3><ol><li>初始时，S只包含源点，即S＝{v}，v的距离为0。U包含除v外的其他顶点，即:U={其余顶点}，若v与U中顶点u有边，则<u,v>正常有权值，若u不是v的出边邻接点，则<u,v>权值为∞。</u,v></u,v></li><li><p>从U中选取一个距离v最小的顶点k，把k，加入S中（该选定的距离就是v到k的最短路径长度）。</p></li><li><p>以k为新考虑的中间点，修改U中各顶点的距离；若从源点v到顶点u的距离（经过顶点k）比原来距离（不经过顶点k）短，则修改顶点u的距离值，修改后的距离值的顶点k的距离加上边上的权。</p></li><li>重复步骤b和c直到所有顶点都包含在S中。</li></ol><blockquote><p>步骤动画如下：</p></blockquote><p><img src="http://omu7tit09.bkt.clouddn.com/15034750643056.gif" alt=""></p><blockquote><p>实例如下</p></blockquote><p><img src="http://omu7tit09.bkt.clouddn.com/15034750948707.jpg" alt=""></p><p>用Dijkstra算法找出以A为起点的单源最短路径步骤如下</p><p><img src="http://omu7tit09.bkt.clouddn.com/15034751165686.jpg" alt=""></p><h3 id="1-3-代码实现"><a href="#1-3-代码实现" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h3><p>以”邻接矩阵”为例对迪杰斯特拉算法进行说明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class MatrixUDG &#123;</div><div class="line"></div><div class="line">    private int mEdgNum;        // 边的数量</div><div class="line">    private char[] mVexs;       // 顶点集合</div><div class="line">    private int[][] mMatrix;    // 邻接矩阵</div><div class="line">    private static final int INF = Integer.MAX_VALUE;   // 最大值</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>MatrixUDG是邻接矩阵对应的结构体。mVexs用于保存顶点，mEdgNum用于保存边数，mMatrix则是用于保存矩阵信息的二维数组。例如，mMatrix[i][j]=1，则表示”顶点i(即mVexs[i])”和”顶点j(即mVexs[j])”是邻接点；mMatrix[i][j]=0，则表示它们不是邻接点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * Dijkstra最短路径。</div><div class="line"> * 即，统计图中"顶点vs"到其它各个顶点的最短路径。</div><div class="line"> *</div><div class="line"> * 参数说明：</div><div class="line"> *       vs -- 起始顶点(start vertex)。即计算"顶点vs"到其它顶点的最短路径。</div><div class="line"> *     prev -- 前驱顶点数组。即，prev[i]的值是"顶点vs"到"顶点i"的最短路径所经历的全部顶点中，位于"顶点i"之前的那个顶点。</div><div class="line"> *     dist -- 长度数组。即，dist[i]是"顶点vs"到"顶点i"的最短路径的长度。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> vs, <span class="keyword">int</span>[] prev, <span class="keyword">int</span>[] dist)</span> </span>&#123;</div><div class="line">    <span class="comment">// flag[i]=true表示"顶点vs"到"顶点i"的最短路径已成功获取</span></div><div class="line">    <span class="keyword">boolean</span>[] flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[mVexs.length];</div><div class="line"></div><div class="line">    <span class="comment">// 初始化</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mVexs.length; i++) &#123;</div><div class="line">        flag[i] = <span class="keyword">false</span>;          <span class="comment">// 顶点i的最短路径还没获取到。</span></div><div class="line">        prev[i] = <span class="number">0</span>;              <span class="comment">// 顶点i的前驱顶点为0。</span></div><div class="line">        dist[i] = mMatrix[vs][i];  <span class="comment">// 顶点i的最短路径为"顶点vs"到"顶点i"的权。</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 对"顶点vs"自身进行初始化</span></div><div class="line">    flag[vs] = <span class="keyword">true</span>;</div><div class="line">    dist[vs] = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 遍历mVexs.length-1次；每次找出一个顶点的最短路径。</span></div><div class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; mVexs.length; i++) &#123;</div><div class="line">        <span class="comment">// 寻找当前最小的路径；</span></div><div class="line">        <span class="comment">// 即，在未获取最短路径的顶点中，找到离vs最近的顶点(k)。</span></div><div class="line">        <span class="keyword">int</span> min = INF;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mVexs.length; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (flag[j]==<span class="keyword">false</span> &amp;&amp; dist[j]&lt;min) &#123;</div><div class="line">                min = dist[j];</div><div class="line">                k = j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 标记"顶点k"为已经获取到最短路径</span></div><div class="line">        flag[k] = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 修正当前最短路径和前驱顶点</span></div><div class="line">        <span class="comment">// 即，当已经"顶点k的最短路径"之后，更新"未获取最短路径的顶点的最短路径和前驱顶点"。</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mVexs.length; j++) &#123;</div><div class="line">            <span class="keyword">int</span> tmp = (mMatrix[k][j]==INF ? INF : (min + mMatrix[k][j]));</div><div class="line">            <span class="keyword">if</span> (flag[j]==<span class="keyword">false</span> &amp;&amp; (tmp&lt;dist[j]) ) &#123;</div><div class="line">                dist[j] = tmp;</div><div class="line">                prev[j] = k;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 打印dijkstra最短路径的结果</span></div><div class="line">    System.out.printf(<span class="string">"dijkstra(%c): \n"</span>, mVexs[vs]);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; mVexs.length; i++)</div><div class="line">        System.out.printf(<span class="string">"  shortest(%c, %c)=%d\n"</span>, mVexs[vs], mVexs[i], dist[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="1-4-时间复杂度"><a href="#1-4-时间复杂度" class="headerlink" title="1.4 时间复杂度"></a>1.4 时间复杂度</h3><p>我们可以用大O符号将该算法的运行时间表示为边数m和顶点数n的函数。</p><p>对于基于顶点集Q的实现，算法的运行时间是$O(|E|\cdot dk_{Q}+|V|\cdot em_{Q})$，其中$dk_{Q}和em_{Q}$分别表示完成键的降序排列时间和从Q中提取最小键值的时间。</p><p>Dijkstra算法最简单的实现方法是用一个链表或者数组来存储所有顶点的集合Q，所以搜索Q中最小元素的运算（Extract-Min(Q)）只需要线性搜索 Q中的所有元素。这样的话算法的运行时间是$O(n^{2})$。</p><p>对于边数少于$n^{2}$的稀疏图来说，我们可以用邻接表来更有效的实现该算法。同时需要将一个二叉堆或者斐波纳契堆用作优先队列来寻找最小的顶点（Extract-Min）。当用到二叉堆的时候，算法所需的时间为${\displaystyle O((m+n)logn)}$，斐波纳契堆能稍微提高一些性能，让算法运行时间达到${\displaystyle O(m+nlogn)}$。然而，使用斐波纳契堆进行编程，常常会由于算法常数过大而导致速度没有显著提高。</p><h2 id="二、Floyd算法"><a href="#二、Floyd算法" class="headerlink" title="二、Floyd算法"></a>二、Floyd算法</h2><p>Dijkstra很优秀，但是使用Dijkstra有一个最大的限制，就是不能有负权边。而Bellman-Ford适用于权值可以为负、无权值为负的回路的图。这比Dijkstra算法的使用范围要广。</p><h3 id="2-1-算法思想"><a href="#2-1-算法思想" class="headerlink" title="2.1 算法思想"></a>2.1 算法思想</h3><p>Floyd算法是一个经典的动态规划算法。用通俗的语言来描述的话，首先我们的目标是寻找从点i到点j的最短路径。从动态规划的角度看问题，我们需要为这个目标重新做一个诠释（这个诠释正是动态规划最富创造力的精华所在）</p><p> 从任意节点i到任意节点j的最短路径不外乎2种可能，1是直接从i到j，2是从i经过若干个节点k到j。所以，我们假设Dis(i,j)为节点u到节点v的最短路径的距离，对于每一个节点k，我们检查Dis(i,k) + Dis(k,j) &lt; Dis(i,j)是否成立，如果成立，证明从i到k再到j的路径比i直接到j的路径短，我们便设置Dis(i,j) = Dis(i,k) + Dis(k,j)，这样一来，当我们遍历完所有节点k，Dis(i,j)中记录的便是i到j的最短路径的距离。</p><h3 id="2-2-算法步骤"><a href="#2-2-算法步骤" class="headerlink" title="2.2 算法步骤"></a>2.2 算法步骤</h3><p><img src="http://omu7tit09.bkt.clouddn.com/15034778818372.jpg" alt=""><br>初始状态：S是记录各个顶点间最短路径的矩阵。 </p><ol><li><p>初始化S：矩阵S中顶点a[i][j]的距离为顶点i到顶点j的权值；如果i和j不相邻，则a[i][j]=∞。实际上，就是将图的原始矩阵复制到S中。<br> 注:a[i][j]表示矩阵S中顶点i(第i个顶点)到顶点j(第j个顶点)的距离。</p></li><li><p>以顶点A(第1个顶点)为中介点，若$a[i][j] &gt; a[i][0]+a[0][j]$，则设置$a[i][j]=a[i][0]+a[0][j]$。 以顶点$a[1]$，上一步操作之后，$a[1][6]=∞$；而将A作为中介点时，(B,A)=12，(A,G)=14，因此B和G之间的距离可以更新为26。</p></li><li>同理，依次将顶点B,C,D,E,F,G作为中介点，并更新a[i][j]的大小。</li></ol><h3 id="2-3-代码实现"><a href="#2-3-代码实现" class="headerlink" title="2.3 代码实现"></a>2.3 代码实现</h3><p>以”邻接矩阵”为例对弗洛伊德算法进行说明，对于”邻接表”实现的图在后面会给出相应的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MatrixUDG</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mEdgNum;        <span class="comment">// 边的数量</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] mVexs;       <span class="comment">// 顶点集合</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] mMatrix;    <span class="comment">// 邻接矩阵</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INF = Integer.MAX_VALUE;   <span class="comment">// 最大值</span></div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>MatrixUDG是邻接矩阵对应的结构体。mVexs用于保存顶点，mEdgNum用于保存边数，mMatrix则是用于保存矩阵信息的二维数组。例如，mMatrix[i][j]=1，则表示”顶点i(即mVexs[i])”和”顶点j(即mVexs[j])”是邻接点；mMatrix[i][j]=0，则表示它们不是邻接点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * floyd最短路径。</div><div class="line"> * 即，统计图中各个顶点间的最短路径。</div><div class="line"> *</div><div class="line"> * 参数说明：</div><div class="line"> *     path -- 路径。path[i][j]=k表示，"顶点i"到"顶点j"的最短路径会经过顶点k。</div><div class="line"> *     dist -- 长度数组。即，dist[i][j]=sum表示，"顶点i"到"顶点j"的最短路径的长度是sum。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">floyd</span><span class="params">(<span class="keyword">int</span>[][] path, <span class="keyword">int</span>[][] dist)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 初始化</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mVexs.length; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mVexs.length; j++) &#123;</div><div class="line">            dist[i][j] = mMatrix[i][j];    <span class="comment">// "顶点i"到"顶点j"的路径长度为"i到j的权值"。</span></div><div class="line">            path[i][j] = j;                <span class="comment">// "顶点i"到"顶点j"的最短路径是经过顶点j。</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 计算最短路径</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mVexs.length; k++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mVexs.length; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mVexs.length; j++) &#123;</div><div class="line"></div><div class="line">                <span class="comment">// 如果经过下标为k顶点路径比原两点间路径更短，则更新dist[i][j]和path[i][j]</span></div><div class="line">                <span class="keyword">int</span> tmp = (dist[i][k]==INF || dist[k][j]==INF) ? INF : (dist[i][k] + dist[k][j]);</div><div class="line">                <span class="keyword">if</span> (dist[i][j] &gt; tmp) &#123;</div><div class="line">                    <span class="comment">// "i到j最短路径"对应的值设，为更小的一个(即经过k)</span></div><div class="line">                    dist[i][j] = tmp;</div><div class="line">                    <span class="comment">// "i到j最短路径"对应的路径，经过k</span></div><div class="line">                    path[i][j] = path[i][k];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 打印floyd最短路径的结果</span></div><div class="line">    System.out.printf(<span class="string">"floyd: \n"</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mVexs.length; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mVexs.length; j++)</div><div class="line">            System.out.printf(<span class="string">"%2d  "</span>, dist[i][j]);</div><div class="line">        System.out.printf(<span class="string">"\n"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-4-时间复杂度"><a href="#2-4-时间复杂度" class="headerlink" title="2.4 时间复杂度"></a>2.4 时间复杂度</h3><p>Floyd-Warshall算法的时间复杂度为$O(N^{3})$，空间复杂度为$O(N^{2})$。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最短路径问题是图论研究中的一个经典算法问题，旨在寻找图（由结点和路径组成的）中两结点之间的最短路径。算法具体的形式包括：&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Dijkstra算法" scheme="http://yoursite.com/tags/Dijkstra%E7%AE%97%E6%B3%95/"/>
    
      <category term="Floyd算法" scheme="http://yoursite.com/tags/Floyd%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>机器学习算法系列（32）：MapReduce执行流程详解</title>
    <link href="http://yoursite.com/2017/07/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%8832%EF%BC%89%EF%BC%9AMapReduce%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/07/27/机器学习算法系列（32）：MapReduce执行流程详解/</id>
    <published>2017-07-27T15:14:45.000Z</published>
    <updated>2017-12-26T08:04:21.224Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、简述"><a href="#一、简述" class="headerlink" title="一、简述"></a>一、简述</h2><p>MapReduce最早是由Google提出的分布式数据处理模型，随后受到了业内的广泛关注，并被大量应用到各种商业场景中。比如：</p><a id="more"></a><ul><li>搜索：网页爬取、倒排索引、PageRank。</li><li>Web访问日志分析：分析和挖掘用户在web上的访问、购物行为特征，实现个性化推荐；分析用户访问行为。</li><li>文本统计分析：比如莫言小说的WordCount、词频TFIDF分析；学术论文、专利文献的引用分析和统计；维基百科数据分析等。</li><li>海量数据挖掘：非结构化数据、时空数据、图像数据的挖掘。</li><li>机器学习：监督学习、无监督学习、分类算法如决策树、SVM等。</li><li>自然语言处理：基于大数据的训练和预测；基于语料库构建单词同现矩阵，频繁项集数据挖掘、重复文档检测等。</li><li>广告推荐：用户点击（CTR)和购买行为（CVR）预测。</li></ul><p>一个Map/Reduce作业（job）通常会把输入的数据（input file）且分为若干个独立的数据块（splits），然后由map任务（task）以完全并行的方式处理它们。Map/Reduce框架会对map的输出做一个Shuffle操作，Suffle操作后的结果会输入给reduce任务。整个Map/Reduce框架负责任务的调度和监控，以及重新执行已经失败的任务。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15032152319495.png" alt=""></p><p>Map/Reduce计算集群由一个单独的JobTracker（master）和每个集群节点一个TaskTracker（slave）共同组成。JobTracker负责调度构成一个作业的所有任务，这些任务会被分派到不同的TaskTracker上去执行，JobTRacker会去监控它们的执行、重新执行已经失败的任务。而TaskTracker仅负责执行由JobTracker指派的任务。<br><img src="http://omu7tit09.bkt.clouddn.com/15032154071740.png" alt=""></p><p>本文将按照map/reduce执行流程中各个任务的时间顺序详细叙述map/reduce的各个任务模块，包括：输入分片（input split）、map阶段、combiner阶段、shuffle阶段和reduce阶段。下图是一个不错的执行流程图：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15032154926693.jpg" alt=""></p><h2 id="二、作业的提交与监控"><a href="#二、作业的提交与监控" class="headerlink" title="二、作业的提交与监控"></a>二、作业的提交与监控</h2><p>JobClient是用户提交的作业与JobTracker交互的主要接口。<br><img src="http://omu7tit09.bkt.clouddn.com/15032157622568.jpg" alt=""></p><p>JobClient提交作业的过程如下：</p><ol><li>map/reduce程序通过runJob()方法新建一个JobClient实例;</li><li>向JobTracker请求一个新jobID，通过JobTracker的getNewJobId()获取；</li><li>检查作业输入输出说明。如果没有指定输出目录或者输出目录已经存在，作业将不会被提交，map/reduce程序； 输入作业划分split，如果划分无法计算（如：输入路径不存在），作业将不会被提交，错误返回给map/reduce程序。</li><li>将运行作业所需要的资源（作业的jar文件、配置文件、计算所得的输入划分）复制到一个以作业ID命名的目录中；</li><li>通过调用JobTracker的submitJob()方法，告诉JobTracker作业准备提交；</li><li>JobTracker将提交的作业放到一个内部队列中，交由作业调度器进行调度，并对其进行初始化。</li><li>创建Map任务、Reduce任务：一个split对应一个map，有多少split就有多少map; Reduce任务的数量由JobConf的mapred.reduce.tasks属性决定</li><li>TaskTracker执行一个简单的循环，定期发送心跳（heartbeat）给JobTracker</li></ol><h2 id="三、执行流程"><a href="#三、执行流程" class="headerlink" title="三、执行流程"></a>三、执行流程</h2><h3 id="3-1-Input-file"><a href="#3-1-Input-file" class="headerlink" title="3.1 Input file"></a>3.1 Input file</h3><p>Input file是map/reduce任务的原始数据，一般存储在HDFS上。应用程序至少应该指明输入/输出的位置（路径），并通过实现合适的接口或抽象类提供map和reduce函数。再加上其他作业的参数，就构成了作业配置（job configuration）。然后，Hadoop的 job client提交作业（jar包/可执行程序等）和配置信息给JobTracker，后者负责分发这些软件和配置信息给slave、调度任务并监控它们的执行，同时提供状态和诊断信息给job-client。</p><h4 id="3-1-1-InputFormat"><a href="#3-1-1-InputFormat" class="headerlink" title="3.1.1 InputFormat"></a>3.1.1 InputFormat</h4><p>InputFormat为Map/Reduce作业输入的细节规范。Map/Reduce框架根据作业的InputFormat来：</p><ol><li>检查作业输入的正确性，如格式等。</li><li>把输入文件切分成多个逻辑InputSplit实例， 一个InputSplit将会被分配给一个独立的Map任务。</li><li>提供RecordReader实现，这个RecordReader从逻辑InputSplit中获得输入记录（”K-V对”），这些记录将由Map任务处理。</li></ol><p>InputFormat有如下几种:<br><img src="http://omu7tit09.bkt.clouddn.com/15032163887568.png" alt=""></p><blockquote><p>TextInputFormat:</p></blockquote><p>TextInputFormat是默认的INputFormat，输入文件中的每一行就是一个记录，Key是这一行的byte offset，而value是这一行的内容。如果一个作业的Inputformat是TextInputFormat，并且框架检测到输入文件的后缀是 .gz 和 .lzo，就会使用对应的CompressionCodec自动解压缩这些文件。但是需要注意，上述带后缀的压缩文件不会被切分，并且整个压缩文件会分给一个mapper来处理。</p><blockquote><p>KeyValueTextInputFormat</p></blockquote><p>输入文件中每一行就是一个记录，第一个分隔符字符切分每行。在分隔符字符之前的内容为Key，在之后的为Value。分隔符变量通过key.value.separator.in.input.line变量设置，默认为(\t)字符。</p><blockquote><p>NLineInputFormat</p></blockquote><p>与TextInputFormat一样，但每个数据块必须保证有且只有Ｎ行，mapred.line.input.format.linespermap属性，默认为1。</p><blockquote><p>SequenceFileInputFormat</p></blockquote><p>一个用来读取字符流数据的InputFormat，为用户自定义的。字符流数据是Hadoop自定义的压缩的二进制数据格式。它用来优化从一个MapReduce任务的输出到另一个MapReduce任务的输入之间的数据传输过程。</p><h3 id="3-2-输入分片（Input-files）"><a href="#3-2-输入分片（Input-files）" class="headerlink" title="3.2 输入分片（Input files）"></a>3.2 输入分片（Input files）</h3><p>InputSplit是一个单独的Map任务需要处理的数据块。一般的InputSplit是字节样式输入，然后由RecordReader处理并转化成记录样式。通常一个split就是一个block，这样做的好处是使得Map任务可以在存储有当前数据的节点上运行本地的任务，而不需要通过网络进行跨节点的任务调度。</p><p>可以通过设置mapred.min.split.size， mapred.max.split.size, block.size来控制拆分的大小。如果mapred.min.split.size大于block size，则会将两个block合成到一个split，这样有部分block数据需要通过网络读取；如果mapred.max.split.size小于block size，则会将一个block拆成多个split，增加了Map任务数。</p><p>在进行map计算之前，mapreduce会根据输入文件计算输入分片（input split），每个输入分片（input split）针对一个map任务，输入分片（input split）存储的并非数据本身，而是一个分片长度和一个记录数据的位置的数组，输入分片（input split）往往和hdfs的block（块）关系很密切，假如我们设定hdfs的块的大小是64mb，如果我们输入有三个文件，大小分别是3mb、65mb和127mb，那么mapreduce会把3mb文件分为一个输入分片（input split），65mb则是两个输入分片（input split）而127mb也是两个输入分片（input split），换句话说我们如果在map计算前做输入分片调整，例如合并小文件，那么就会有5个map任务将执行，而且每个map执行的数据大小不均，这个也是mapreduce优化计算的一个关键点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入文件大小                10M     65M     127M</div><div class="line">分割后的InputSplit大小      10M     64M,1M     64M，63M</div></pre></td></tr></table></figure><p>在Map任务开始前，会先获取文件在HDFS上的路径和block信息，然后根据splitSize对文件进行切分（splitSize = computeSplitSize(blockSize, minSize, maxSize) ），默认splitSize 就等于blockSize的默认值（64m）。</p><p>假设现在我们有两个文本文件，作为我们例子的输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">File 1 内容：</div><div class="line">My name is Tony</div><div class="line">My company is pivotal</div><div class="line"></div><div class="line">File 2 内容：</div><div class="line">My name is Lisa</div><div class="line">My company is EMC</div></pre></td></tr></table></figure><h3 id="3-2-Map阶段"><a href="#3-2-Map阶段" class="headerlink" title="3.2 Map阶段"></a>3.2 Map阶段</h3><p>Map是一类将输入记录集转换为中间格式记录集的独立任务，主要是读取InputSplit的每一个Key,Value对并进行处理。</p><p>首先我们的输入就是两个文件， 默认情况下就是两个split, 对应前面图中的split 0, split 1</p><p>两个split 默认会分给两个Mapper来处理， WordCount例子相当地暴力， 这一步里面就是直接把文件内容分解为单词和 1 （注意， 不是具体数量， 就是数字1）其中的单词就是我们的主健，也称为Key, 后面的数字就是对应的值，也称为value.</p><p>那么对应两个Mapper的输出就是：</p><blockquote><p>split 0</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">My       1</div><div class="line">name    1</div><div class="line">is         1</div><div class="line">Tony     1</div><div class="line">My          1</div><div class="line">company     1</div><div class="line">is       1</div><div class="line">Pivotal   1</div></pre></td></tr></table></figure><blockquote><p>split 1</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">My       1</div><div class="line">name    1</div><div class="line">is       1</div><div class="line">Lisa     1</div><div class="line">My       1</div><div class="line">company  1</div><div class="line">is       1</div><div class="line">EMC   　　1</div></pre></td></tr></table></figure><h3 id="3-3-Shuffle阶段"><a href="#3-3-Shuffle阶段" class="headerlink" title="3.3 Shuffle阶段"></a>3.3 Shuffle阶段</h3><p>将map的输出作为reduce的输入的过程就是shuffle了，这个是mapreduce优化的重点地方。这里我不讲怎么优化shuffle阶段，讲讲shuffle阶段的原理，因为大部分的书籍里都没讲清楚shuffle阶段。Shuffle一开始就是map阶段做输出操作，一般mapreduce计算的都是海量数据，map输出时候不可能把所有文件都放到内存操作，因此map写入磁盘的过程十分的复杂，更何况map输出时候要对结果进行排序，内存开销是很大的，map在做输出时候会在内存里开启一个环形内存缓冲区，这个缓冲区专门用来输出的，默认大小是100mb，并且在配置文件里为这个缓冲区设定了一个阀值，默认是0.80（这个大小和阀值都是可以在配置文件里进行配置的），同时map还会为输出操作启动一个守护线程，如果缓冲区的内存达到了阀值的80%时候，这个守护线程就会把内容写到磁盘上，这个过程叫spill，另外的20%内存可以继续写入要写进磁盘的数据，写入磁盘和写入内存操作是互不干扰的，如果缓存区被撑满了，那么map就会阻塞写入内存的操作，让写入磁盘操作完成后再继续执行写入内存操作，前面我讲到写入磁盘前会有个排序操作，这个是在写入磁盘操作时候进行，不是在写入内存时候进行的，如果我们定义了combiner函数，那么排序前还会执行combiner操作。每次spill操作也就是写入磁盘操作时候就会写一个溢出文件，也就是说在做map输出有几次spill就会产生多少个溢出文件，等map输出全部做完后，map会合并这些输出文件。这个过程里还会有一个Partitioner操作，对于这个操作很多人都很迷糊，其实Partitioner操作和map阶段的输入分片（Input split）很像，一个Partitioner对应一个reduce作业，如果我们mapreduce操作只有一个reduce操作，那么Partitioner就只有一个，如果我们有多个reduce操作，那么Partitioner对应的就会有多个，Partitioner因此就是reduce的输入分片，这个程序员可以编程控制，主要是根据实际key和value的值，根据实际业务类型或者为了更好的reduce负载均衡要求进行，这是提高reduce效率的一个关键所在。到了reduce阶段就是合并map输出文件了，Partitioner会找到对应的map输出文件，然后进行复制操作，复制操作时reduce会开启几个复制线程，这些线程默认个数是5个，程序员也可以在配置文件更改复制线程的个数，这个复制过程和map写入磁盘过程类似，也有阀值和内存大小，阀值一样可以在配置文件里配置，而内存大小是直接使用reduce的tasktracker的内存大小，复制时候reduce还会进行排序操作和合并文件操作，这些操作完了就会进行reduce计算了。</p><h4 id="3-3-1-Partition"><a href="#3-3-1-Partition" class="headerlink" title="3.3.1 Partition"></a>3.3.1 Partition</h4><p>Partition 是什么？ Partition 就是分区。</p><p>为什么要分区？ 因为有时候会有多个Reducer, Partition就是提前对输入进行处理， 根据将来的Reducer进行分区. 到时候Reducer处理的时候， 只需要处理分给自己的数据就可以了。 </p><p>如何分区？ 主要的分区方法就是按照Key 的不同，把数据分开，其中很重要的一点就是要保证Key的唯一性， 因为将来做Reduce的时候有可能是在不同的节点上做的， 如果一个Key同时存在于两个节点上， Reduce的结果就会出问题， 所以很常见的Partition方法就是哈希。</p><p>结合我们的例子， 我们这里假设有两个Reducer, 前面两个split 做完Partition的结果就会如下：</p><blockquote><p>split 0</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Partition 1:</div><div class="line">company　1</div><div class="line">is     　1</div><div class="line">is　　　　1</div><div class="line"></div><div class="line">Partition 2:</div><div class="line">My　　   1</div><div class="line">My　　　　1</div><div class="line">name　　1</div><div class="line">Pivotal   1</div><div class="line">Tony　　  1</div></pre></td></tr></table></figure><blockquote><p>split 1</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Partition 1:</div><div class="line">company 1</div><div class="line">is 　　　1</div><div class="line">is      1</div><div class="line">EMC　　　1</div><div class="line"></div><div class="line">Partition 2:</div><div class="line">My　　   1</div><div class="line">My       1</div><div class="line">name　　 1</div><div class="line">Lisa     1</div></pre></td></tr></table></figure><p>其中Partition 1 将来是准备给Reducer 1 处理的， Partition 2 是给Reducer 2 的</p><p>这里我们可以看到， Partition 只是把所有的条目按照Key 分了一下区， 没有其他任何处理， 每个区里面的Key 都不会出现在另外一个区里面。</p><h4 id="3-3-2-Sort"><a href="#3-3-2-Sort" class="headerlink" title="3.3.2 Sort"></a>3.3.2 Sort</h4><p>Sort 就是排序喽， 其实这个过程在我来看并不是必须的， 完全可以交给客户自己的程序来处理。 那为什么还要排序呢？ 可能是写MapReduce的大牛们想，“大部分reduce 程序应该都希望输入的是已经按Key排序好的数据， 如果是这样， 那我们就干脆顺手帮你做掉啦， 请叫我雷锋！”  ……好吧， 你是雷锋.</p><p>那么我们假设对前面的数据再进行排序， 结果如下：</p><blockquote><p>split 0</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Partition 1:</div><div class="line">company　1</div><div class="line">is     　1</div><div class="line">is　　　　1</div><div class="line"></div><div class="line">Partition 2:</div><div class="line">My　　   1</div><div class="line">My　　　　1</div><div class="line">name　　1</div><div class="line">Pivotal   1</div><div class="line">Tony　　  1</div></pre></td></tr></table></figure><blockquote><p>split 1</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Partition 1:</div><div class="line">company 1</div><div class="line">EMC　　 1</div><div class="line">is 　　　1</div><div class="line">is      1</div><div class="line"></div><div class="line">Partition 2:</div><div class="line">Lisa　　 1</div><div class="line">My　　   1</div><div class="line">My       1</div><div class="line">name　　 1</div></pre></td></tr></table></figure><p>这里可以看到， 每个partition里面的条目都按照Key的顺序做了排序</p><h4 id="3-3-3-Combine"><a href="#3-3-3-Combine" class="headerlink" title="3.3.3 Combine"></a>3.3.3 Combine</h4><p>什么是Combine呢？ Combine 其实可以理解为一个mini Reduce 过程， 它发生在前面Map的输出结果之后， 目的就是在结果送到Reducer之前先对其进行一次计算， 以减少文件的大小， 方便后面的传输。 但这步也不是必须的。</p><p>按照前面的输出， 执行Combine:</p><blockquote><p>split 0</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Partition 1:</div><div class="line">company　1</div><div class="line">is     　2</div><div class="line"></div><div class="line">Partition 2:</div><div class="line">My　　   2</div><div class="line">name　　1</div><div class="line">Pivotal   1</div><div class="line">Tony　　  1</div></pre></td></tr></table></figure><blockquote><p>split 1</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Partition 1:</div><div class="line">company 1</div><div class="line">EMC　　 1</div><div class="line">is 　　　2</div><div class="line"></div><div class="line">Partition 2:</div><div class="line">Lisa　　 1</div><div class="line">My　　   2</div><div class="line">name　　 1</div></pre></td></tr></table></figure><p>我们可以看到， 针对前面的输出结果， 我们已经局部地统计了is 和My的出现频率， 减少了输出文件的大小。</p><h4 id="3-3-4-copy"><a href="#3-3-4-copy" class="headerlink" title="3.3.4 copy"></a>3.3.4 copy</h4><p>下面就要准备把输出结果传送给Reducer了。 这个阶段被称为Copy, 但事实上雷子认为叫他Download更为合适， 因为实现的时候， 是通过http的方式， 由Reducer节点向各个mapper节点下载属于自己分区的数据。</p><p>那么根据前面的Partition, 下载完的结果如下：</p><p>Reducer 节点 1 共包含两个文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Partition 1:</div><div class="line">company　1</div><div class="line">is     　2</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Partition 1:</div><div class="line">company　　1</div><div class="line">EMC　　　　1</div><div class="line">is　　　　2</div></pre></td></tr></table></figure><p>Reducer 节点 2 也是两个文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> Partition 2:</div><div class="line">My　　   2</div><div class="line">name　　1</div><div class="line">Pivotal   1</div><div class="line">Tony　　  1</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Partition 2:</div><div class="line">Lisa　　 1</div><div class="line">My　　   2</div><div class="line">name　　 1</div></pre></td></tr></table></figure><p>这里可以看到， 通过Copy, 相同Partition 的数据落到了同一个节点上。</p><h4 id="3-3-5-merge"><a href="#3-3-5-merge" class="headerlink" title="3.3.5 merge"></a>3.3.5 merge</h4><p>如上一步所示， 此时Reducer得到的文件是从不同Mapper那里下载到的， 需要对他们进行合并为一个文件， 所以下面这一步就是Merge, 结果如下：</p><blockquote><p>Reducer 节点 1</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">company　1</div><div class="line">company  1</div><div class="line">EMC　　  1</div><div class="line">is     　2</div><div class="line">is　　　　2</div></pre></td></tr></table></figure><blockquote><p>Reducer 节点 2</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Lisa　　1</div><div class="line">My　　   2</div><div class="line">My　　　　2</div><div class="line">name　　1</div><div class="line">name　　1</div><div class="line">Pivotal   1</div><div class="line">Tony　　  1</div></pre></td></tr></table></figure><h3 id="3-4-Redeuce阶段"><a href="#3-4-Redeuce阶段" class="headerlink" title="3.4 Redeuce阶段"></a>3.4 Redeuce阶段</h3><p>reduce阶段对数据进行归约处理。键相等的键值对会调用一次reduce方法。经过这一阶段，数据量会减少。归约后的数据输出到本地文件中。本阶段默认是没有的，需要用户自己增加这一阶段的代码。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15032285242095.jpg" alt=""></p><h2 id="四、实例说明"><a href="#四、实例说明" class="headerlink" title="四、实例说明"></a>四、实例说明</h2><p>下面将以WordCount为例，解释MapReduce各个阶段的概念。 假设存在一个文本a.txt，文本内每行是一个数字，我们要统计每个数字出现的次数。文本内的数字称为Word，数字出现的次数称为Count。如果MaxCompute Mapreduce完成这一功能，需要经历下图描述的几个步骤：<br><img src="http://omu7tit09.bkt.clouddn.com/15032286457705.jpg" alt=""></p><ol><li>首先对文本进行分片，将每片内的数据作为单个Map Worker的输入；</li><li>Map处理输入，每获取一个数字，将数字的Count设置为1，并将此<word, count="">对输出，此时以Word作为输出数据的Key；<br>在Shuffle阶段前期，首先对每个Map Worker的输出，按照Key值，即Word值排序。排序后进行Combine操作，即将Key值(Word值)相同的Count累加，构成一个新的<word, count="">对。此过程被称为合并排序；</word,></word,></li><li>在Shuffle阶段后期，数据被发送到Reduce端。Reduce Worker收到数据后依赖Key值再次对数据排序；</li><li>每个Reduce Worker对数据进行处理时，采用与Combiner相同的逻辑，将Key值(Word值)相同的Count累加，得到输出结果；</li></ol><p>分布式相关<br>mr 方案解决矩阵相乘的代码；<br>hadoop原理，shuffle如何排序，map如何切割数据，如何处理数据倾斜，join的mr代码</p><p>MR的shuffle过程？内存不够时涉及大文件排序如何处理？ 答：先hash到不同文件中，每个文件排序，然后每个文件读取行，类似归并排序的思路？</p><p>Hadoop,Spark,storm下面的产品，原理，适用场景</p><p>spark跟hadoop的区别答：spark有RDD机制，写内存，相对hadoop适合迭代运算</p><p>如何用hadoop实现k-means<br>简单介绍 MapReduce 原理，有没有看过源码，说说 Map 阶段怎么实现的,<br>MapReduce 实现统计出现次数最多的前 100 个访问 IP.<br>MapReduce 实现统计不重复用户 ID,MapReduce 实现两个数据集求交集。<br>HBase 行健怎么设计,spark 性能一般优化方法,spark streaming 和 storm 区别.给了一张笔试题， 10 道选择，一道大题。选择题是 java 基础知识，大题一个有三问：根据场景写出 Hive 建表语句； Hsql 从表中查询；<br>用MapReduce写好友推荐，在一堆单词里面找出现次数最多的k个<br>用分布式的方法做采样怎么保证采样结果完全符合预期？<br>后面又问了Hadoop,Spark,storm下面的产品，原理，适用场景，<br>写一个 Hadoop 版本的 wordcount。<br>K-means能否分布式实现？ 答：因为本身是迭代式算法，所以只能半分布式实现，即在计算类的均值、每个样本点属于哪个类的时候<br>还有怎么解决mapreduce数据倾斜</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、简述&quot;&gt;&lt;a href=&quot;#一、简述&quot; class=&quot;headerlink&quot; title=&quot;一、简述&quot;&gt;&lt;/a&gt;一、简述&lt;/h2&gt;&lt;p&gt;MapReduce最早是由Google提出的分布式数据处理模型，随后受到了业内的广泛关注，并被大量应用到各种商业场景中。比如：&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="MapReduce" scheme="http://yoursite.com/tags/MapReduce/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法（13）：深度优先搜索和广度优先搜索</title>
    <link href="http://yoursite.com/2017/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8813%EF%BC%89%EF%BC%9A%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    <id>http://yoursite.com/2017/07/27/数据结构与算法（13）：深度优先搜索和广度优先搜索/</id>
    <published>2017-07-27T14:14:45.000Z</published>
    <updated>2017-09-01T06:36:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>BFS和DFS是两种十分重要的搜索算法，BFS适合查找最优解，DFS适合查找是否存在解(或者说能找到任意一个可行解)。用这两种算法即可以解决大部分树和图的问题。</p><a id="more"></a><h2 id="一、深度优先搜索（DFS）"><a href="#一、深度优先搜索（DFS）" class="headerlink" title="一、深度优先搜索（DFS）"></a>一、深度优先搜索（DFS）</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p>图的深度优先搜索（Depth First Search），和树的先序遍历比较类似。<br>它的思想：假设初始状态是图中所有顶点均未被访问，则从某个顶点V出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和V有路径相通的顶点都被访问到。若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。</p><p>显然，深度优先搜索是一个递归的过程。</p><h3 id="1-2-图解"><a href="#1-2-图解" class="headerlink" title="1.2 图解"></a>1.2 图解</h3><h4 id="1-2-1-无向图的深度优先搜索"><a href="#1-2-1-无向图的深度优先搜索" class="headerlink" title="1.2.1 无向图的深度优先搜索"></a>1.2.1 无向图的深度优先搜索</h4><p>下面以“无向图”为例，来对深度优先搜索进行演示。<br><img src="http://omu7tit09.bkt.clouddn.com/15006043606972.jpg" alt=""><br>对上面的图G1进行深度优先遍历，从顶点A开始。<br><img src="http://omu7tit09.bkt.clouddn.com/15006043873870.jpg" alt=""></p><ul><li>第1步：访问A</li><li>第2步：访问（A的邻接点）C。在第一步访问A之后，接下来应该访问的是A的邻接点，即“C/D/F”中的一个。但在本文的实现中，顶点ABCDEFG是按照顺序存储，C在“D和F的前面，因此，先访问C。”</li><li>第3步：访问（C的邻接点）B。在第2步访问C之后，接下来应该访问C的邻接点，即”B和D”中一个(A已经被访问过，就不算在内)。而由于B在D之前，先访问B。 </li><li>第4步：访问(C的邻接点)D。 在第3步访问了C的邻接点B之后，B没有未被访问的邻接点；因此，返回到访问C的另一个邻接点D。 </li><li>第5步：访问(A的邻接点)F。  前面已经访问了A，并且访问完了”A的邻接点B的所有邻接点(包括递归的邻接点在内)”；因此，此时返回到访问A的另一个邻接点F。 </li><li>第6步：访问(F的邻接点)G。 </li><li>第7步：访问(G的邻接点)E。</li></ul><p>因此访问顺序是：$A=&gt;C=&gt;=&gt;B=&gt;D=&gt;F=&gt;G=&gt;E$</p><h4 id="1-2-2-有向图的深度优先搜索"><a href="#1-2-2-有向图的深度优先搜索" class="headerlink" title="1.2.2 有向图的深度优先搜索"></a>1.2.2 有向图的深度优先搜索</h4><p>下面以“有向图”为例，来对深度优先搜索进行演示。<br><img src="http://omu7tit09.bkt.clouddn.com/15006046826509.jpg" alt=""><br>对上面的图G2进行深度优先遍历，从顶点A开始。<br><img src="http://omu7tit09.bkt.clouddn.com/15006047122696.jpg" alt=""></p><ul><li>第1步：访问A。 </li><li>第2步：访问B。在访问了A之后，接下来应该访问的是A的出边的另一个顶点，即顶点B。 </li><li>第3步：访问C。在访问了B之后，接下来应该访问的是B的出边的另一个顶点，即顶点C,E,F。在本文实现的图中，顶点ABCDEFG按照顺序存储，因此先访问C。 </li><li>第4步：访问E。接下来访问C的出边的另一个顶点，即顶点E。 </li><li>第5步：访问D。接下来访问E的出边的另一个顶点，即顶点B,D。顶点B已经被访问过，因此访问顶点D。 </li><li>第6步：访问F。 接下应该回溯”访问A的出边的另一个顶点F”。 </li><li>第7步：访问G。</li></ul><p>因此访问顺序是：$A =&gt; B =&gt; C =&gt; E =&gt; D =&gt; F =&gt; G$</p><h2 id="二、广度优先搜索（BFS）"><a href="#二、广度优先搜索（BFS）" class="headerlink" title="二、广度优先搜索（BFS）"></a>二、广度优先搜索（BFS）</h2><h3 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h3><p>广度优先搜索算法（Breadth First Search），又称为“宽度优先搜索”或“横向优先搜索”，简称BFS。</p><p>它的思想是：从图中某顶点V出发，在访问了V之后依次访问V的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问他们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问”，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问的顶点作为新的起始点，重复上述过程，知道图中所有顶点都被访问到为止。</p><p>换句话说，广度优先搜索遍历图的过程是以V为起点，由近至远，依次访问和V有路径相同且路径长度为1、2、3……的顶点。</p><h3 id="2-2-图解"><a href="#2-2-图解" class="headerlink" title="2.2 图解"></a>2.2 图解</h3><h4 id="2-2-1-无向图的广度优先搜索"><a href="#2-2-1-无向图的广度优先搜索" class="headerlink" title="2.2.1 无向图的广度优先搜索"></a>2.2.1 无向图的广度优先搜索</h4><p>下面以“无向图”为例，来对广度优先搜索进行演示。还是以上面的图G1为例进行说明。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15006052024122.jpg" alt=""></p><ul><li>第1步：访问A。 </li><li>第2步：依次访问C,D,F。在访问了A之后，接下来访问A的邻接点。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，C在”D和F”的前面，因此，先访问C。再访问完C之后，再依次访问D,F。 </li><li>第3步：依次访问B,G。 在第2步访问完C,D,F之后，再依次访问它们的邻接点。首先访问C的邻接点B，再访问F的邻接点G。 </li><li>第4步：访问E。在第3步访问完B,G之后，再依次访问它们的邻接点。只有G有邻接点E，因此访问G的邻接点E。</li></ul><p>因此访问顺序是：$A =&gt; C =&gt; D =&gt; F =&gt; B =&gt; G =&gt; E$</p><h4 id="2-2-2-有向图的广度优先搜索"><a href="#2-2-2-有向图的广度优先搜索" class="headerlink" title="2.2.2 有向图的广度优先搜索"></a>2.2.2 有向图的广度优先搜索</h4><p>下面以“有向图”为例，来对广度优先搜索进行演示。还是以上面的图G2为例进行说明。<br><img src="http://omu7tit09.bkt.clouddn.com/15006053431729.jpg" alt=""></p><ul><li>第1步：访问A。 </li><li>第2步：访问B。 </li><li>第3步：依次访问C,E,F。 在访问了B之后，接下来访问B的出边的另一个顶点，即C,E,F。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，因此会先访问C，再依次访问E,F。 </li><li>第4步：依次访问D,G。 在访问完C,E,F之后，再依次访问它们的出边的另一个顶点。还是按照C,E,F的顺序访问，C的已经全部访问过了，那么就只剩下E,F；先访问E的邻接点D，再访问F的邻接点G。</li></ul><h2 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h2><p>无向图和有向图的BFS与DFS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Java: 邻接矩阵表示的&quot;无向图(Matrix Undirected Graph)&quot;</div><div class="line"> *</div><div class="line"> * @author skywang</div><div class="line"> * @date 2014/04/19</div><div class="line"> */</div><div class="line">import java.io.IOException;</div><div class="line">import java.util.Scanner;</div><div class="line"></div><div class="line">public class Demo &#123;</div><div class="line">    private char[] mVexs;       // 顶点集合</div><div class="line">    private int[][] mMatrix;    // 邻接矩阵</div><div class="line"></div><div class="line">    /* </div><div class="line">     * 创建图(自己输入数据)</div><div class="line">     */</div><div class="line">    public Demo() &#123;</div><div class="line">        // 输入&quot;顶点数&quot;和&quot;边数&quot;</div><div class="line">        System.out.printf(&quot;input vertex number: &quot;);</div><div class="line">        int vlen = readInt();</div><div class="line">        System.out.printf(&quot;input edge number: &quot;);</div><div class="line">        int elen = readInt();</div><div class="line">        if ( vlen &lt; 1 || elen &lt; 1 || (elen &gt; (vlen*(vlen - 1)))) &#123;</div><div class="line">            System.out.printf(&quot;input error: invalid parameters!\n&quot;);</div><div class="line">            return ;</div><div class="line">        &#125;</div><div class="line">                // 初始化&quot;顶点&quot;</div><div class="line">        mVexs = new char[vlen];</div><div class="line">        for (int i = 0; i &lt; mVexs.length; i++) &#123;</div><div class="line">            System.out.printf(&quot;vertex(%d): &quot;, i);</div><div class="line">            mVexs[i] = readChar();</div><div class="line">        &#125;</div><div class="line">        // 初始化&quot;边&quot;</div><div class="line">        mMatrix = new int[vlen][vlen];</div><div class="line">        for (int i = 0; i &lt; elen; i++) &#123;</div><div class="line">            // 读取边的起始顶点和结束顶点</div><div class="line">            System.out.printf(&quot;edge(%d):&quot;, i);</div><div class="line">            char c1 = readChar();</div><div class="line">            char c2 = readChar();</div><div class="line">            int p1 = getPosition(c1);</div><div class="line">            int p2 = getPosition(c2);</div><div class="line"></div><div class="line">            if (p1==-1 || p2==-1) &#123;</div><div class="line">                System.out.printf(&quot;input error: invalid edge!\n&quot;);</div><div class="line">                return ;</div><div class="line">            &#125;</div><div class="line">            mMatrix[p1][p2] = 1;</div><div class="line">            mMatrix[p2][p1] = 1;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    /*</div><div class="line">     * 创建图(用已提供的矩阵)</div><div class="line">     *</div><div class="line">     * 参数说明：</div><div class="line">     *     vexs  -- 顶点数组</div><div class="line">     *     edges -- 边数组</div><div class="line">     */</div><div class="line">    public Demo(char[] vexs, char[][] edges) &#123;</div><div class="line">                // 初始化&quot;顶点数&quot;和&quot;边数&quot;</div><div class="line">        int vlen = vexs.length;</div><div class="line">        int elen = edges.length;</div><div class="line">        // 初始化&quot;顶点&quot;</div><div class="line">        mVexs = new char[vlen];</div><div class="line">        for (int i = 0; i &lt; mVexs.length; i++)</div><div class="line">            mVexs[i] = vexs[i];</div><div class="line">        // 初始化&quot;边&quot;</div><div class="line">        mMatrix = new int[vlen][vlen];</div><div class="line">        for (int i = 0; i &lt; elen; i++) &#123;</div><div class="line">            // 读取边的起始顶点和结束顶点</div><div class="line">            int p1 = getPosition(edges[i][0]);</div><div class="line">            int p2 = getPosition(edges[i][1]);</div><div class="line">            mMatrix[p1][p2] = 1;</div><div class="line">            mMatrix[p2][p1] = 1;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    /*</div><div class="line">     * 返回ch位置</div><div class="line">     */</div><div class="line">    private int getPosition(char ch) &#123;</div><div class="line">        for(int i=0; i&lt;mVexs.length; i++)</div><div class="line">            if(mVexs[i]==ch)</div><div class="line">                return i;</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">    /*</div><div class="line">     * 读取一个输入字符</div><div class="line">     */</div><div class="line">    private char readChar() &#123;</div><div class="line">        char ch=&apos;0&apos;;</div><div class="line">        do &#123;</div><div class="line">            try &#123;</div><div class="line">                ch = (char)System.in.read();</div><div class="line">            &#125; catch (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125; while(!((ch&gt;=&apos;a&apos;&amp;&amp;ch&lt;=&apos;z&apos;) || (ch&gt;=&apos;A&apos;&amp;&amp;ch&lt;=&apos;Z&apos;)));</div><div class="line">        return ch;</div><div class="line">    &#125;</div><div class="line">    /*</div><div class="line">     * 读取一个输入字符</div><div class="line">     */</div><div class="line">    private int readInt() &#123;</div><div class="line">        Scanner scanner = new Scanner(System.in);</div><div class="line">        return scanner.nextInt();</div><div class="line">    &#125;</div><div class="line">    /*</div><div class="line">     * 返回顶点v的第一个邻接顶点的索引，失败则返回-1</div><div class="line">     */</div><div class="line">    private int firstVertex(int v) &#123;</div><div class="line"></div><div class="line">        if (v&lt;0 || v&gt;(mVexs.length-1))</div><div class="line">            return -1;</div><div class="line"></div><div class="line">        for (int i = 0; i &lt; mVexs.length; i++)</div><div class="line">            if (mMatrix[v][i] == 1)</div><div class="line">                return i;</div><div class="line"></div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">    /*</div><div class="line">     * 返回顶点v相对于w的下一个邻接顶点的索引，失败则返回-1</div><div class="line">     */</div><div class="line">    private int nextVertex(int v, int w) &#123;</div><div class="line"></div><div class="line">        if (v&lt;0 || v&gt;(mVexs.length-1) || w&lt;0 || w&gt;(mVexs.length-1))</div><div class="line">            return -1;</div><div class="line"></div><div class="line">        for (int i = w + 1; i &lt; mVexs.length; i++)</div><div class="line">            if (mMatrix[v][i] == 1)</div><div class="line">                return i;</div><div class="line"></div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">    /*</div><div class="line">     * 深度优先搜索遍历图的递归实现</div><div class="line">     */</div><div class="line">    private void DFS(int i, boolean[] visited) &#123;</div><div class="line"></div><div class="line">        visited[i] = true;</div><div class="line">        System.out.printf(&quot;%c &quot;, mVexs[i]);</div><div class="line">        // 遍历该顶点的所有邻接顶点。若是没有访问过，那么继续往下走</div><div class="line">        for (int w = firstVertex(i); w &gt;= 0; w = nextVertex(i, w)) &#123;</div><div class="line">            if (!visited[w])</div><div class="line">                DFS(w, visited);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    /*</div><div class="line">     * 深度优先搜索遍历图</div><div class="line">     */</div><div class="line">    public void DFS() &#123;</div><div class="line">        boolean[] visited = new boolean[mVexs.length];       // 顶点访问标记</div><div class="line"></div><div class="line">        // 初始化所有顶点都没有被访问</div><div class="line">        for (int i = 0; i &lt; mVexs.length; i++)</div><div class="line">            visited[i] = false;</div><div class="line"></div><div class="line">        System.out.printf(&quot;DFS: &quot;);</div><div class="line">        for (int i = 0; i &lt; mVexs.length; i++) &#123;</div><div class="line">            if (!visited[i])</div><div class="line">                DFS(i, visited);</div><div class="line">        &#125;</div><div class="line">        System.out.printf(&quot;\n&quot;);</div><div class="line">    &#125;</div><div class="line">    /*</div><div class="line">     * 广度优先搜索（类似于树的层次遍历）</div><div class="line">     */</div><div class="line">    public void BFS() &#123;</div><div class="line">        int head = 0;</div><div class="line">        int rear = 0;</div><div class="line">        int[] queue = new int[mVexs.length];            // 辅组队列</div><div class="line">        boolean[] visited = new boolean[mVexs.length];  // 顶点访问标记</div><div class="line"></div><div class="line">        for (int i = 0; i &lt; mVexs.length; i++)</div><div class="line">            visited[i] = false;</div><div class="line"></div><div class="line">        System.out.printf(&quot;BFS: &quot;);</div><div class="line">        for (int i = 0; i &lt; mVexs.length; i++) &#123;</div><div class="line">            if (!visited[i]) &#123;</div><div class="line">                visited[i] = true;</div><div class="line">                System.out.printf(&quot;%c &quot;, mVexs[i]);</div><div class="line">                queue[rear++] = i;  // 入队列</div><div class="line">            &#125;</div><div class="line">            while (head != rear) &#123;</div><div class="line">                int j = queue[head++];  // 出队列</div><div class="line">                for (int k = firstVertex(j); k &gt;= 0; k = nextVertex(j, k)) &#123; //k是为访问的邻接顶点</div><div class="line">                    if (!visited[k]) &#123;</div><div class="line">                        visited[k] = true;</div><div class="line">                        System.out.printf(&quot;%c &quot;, mVexs[k]);</div><div class="line">                        queue[rear++] = k;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        System.out.printf(&quot;\n&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 打印矩阵队列图</div><div class="line">     */</div><div class="line">    public void print() &#123;</div><div class="line">        System.out.printf(&quot;Martix Graph:\n&quot;);</div><div class="line">        for (int i = 0; i &lt; mVexs.length; i++) &#123;</div><div class="line">            for (int j = 0; j &lt; mVexs.length; j++)</div><div class="line">                System.out.printf(&quot;%d &quot;, mMatrix[i][j]);</div><div class="line">            System.out.printf(&quot;\n&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        char[] vexs = &#123;&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;&#125;;</div><div class="line">        char[][] edges = new char[][]&#123;</div><div class="line">            &#123;&apos;A&apos;, &apos;C&apos;&#125;, </div><div class="line">            &#123;&apos;A&apos;, &apos;D&apos;&#125;, </div><div class="line">            &#123;&apos;A&apos;, &apos;F&apos;&#125;, </div><div class="line">            &#123;&apos;B&apos;, &apos;C&apos;&#125;, </div><div class="line">            &#123;&apos;C&apos;, &apos;D&apos;&#125;, </div><div class="line">            &#123;&apos;E&apos;, &apos;G&apos;&#125;, </div><div class="line">            &#123;&apos;F&apos;, &apos;G&apos;&#125;&#125;;</div><div class="line">        Demo pG;</div><div class="line">        // 自定义&quot;图&quot;(输入矩阵队列)</div><div class="line">        //pG = new MatrixUDG();</div><div class="line">        // 采用已有的&quot;图&quot;</div><div class="line">        pG = new Demo(vexs, edges);</div><div class="line">        pG.print();   // 打印图</div><div class="line">        pG.DFS();     // 深度优先遍历</div><div class="line">        pG.BFS();     // 广度优先遍历</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;BFS和DFS是两种十分重要的搜索算法，BFS适合查找最优解，DFS适合查找是否存在解(或者说能找到任意一个可行解)。用这两种算法即可以解决大部分树和图的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图" scheme="http://yoursite.com/tags/%E5%9B%BE/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>机器学习算法系列（31）：在线最优化求解（online Optimization）</title>
    <link href="http://yoursite.com/2017/07/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%8831%EF%BC%89%EF%BC%9A%E5%9C%A8%E7%BA%BF%E6%9C%80%E4%BC%98%E5%8C%96%E6%B1%82%E8%A7%A3%EF%BC%88online%20Optimization%EF%BC%89/"/>
    <id>http://yoursite.com/2017/07/26/机器学习算法系列（31）：在线最优化求解（online Optimization）/</id>
    <published>2017-07-26T15:14:46.000Z</published>
    <updated>2017-12-26T08:04:18.219Z</updated>
    
    <content type="html"><![CDATA[<p>最优化求解问题可能是我们在工作中遇到的最多的一类问题了：从已有的数据中提炼出最适合的模型参数，从而对未知的数据进行预测。当我们面对高维高数据量的场景时，常见的批量处理的方式已经显得力不从心，需要有在线处理的方法来解决此类问题。本文以模型的稀疏性作为主线，逐一介绍几个在线最优化求解算法，并进行推导，力求讲清楚算法的来龙去脉，以及不同算法之间的区别和联系，达到融会贯通。在各个算法原理介绍之后，都给出该算法的工程实现伪代码，可以用于实际工作的参考。</p><a id="more"></a><h2 id="一、动机与目的"><a href="#一、动机与目的" class="headerlink" title="一、动机与目的"></a>一、动机与目的</h2><p>在实际工作中，无论是工程师、项目经理、产品同学都会经常讨论一类话题：“从线上对比的效果来看，某某特征或因素对xx产品的最终效果有很大的影响。”这类话题本质上说的是通过已有的数据反映出某些特定的因素对结果有很强的正（或负）相关性。而如何定量计算这种相关性？如何得到一套模型参数能够使得效果达到最好？这就是最优化计算要做的事情。</p><p>举一类典型点的例子：在推荐和广告计算中，我们经常会需要对某些值进行预测，例如在一条推荐或广告在曝光之前先预测用户是否会点击（CTR预估），或者是否会由此产生某些转换（RPM预估）。这列问题可以表示为：针对一个输入$X=[x_1,x_2,……x_N]\in R^N$，通过某个函数$h(X)$计算（预测）输出$y\in R$。根据$y$值为连续的还是离散的，预测问题被划分成回归问题（Regression）和分类问题（Classification）。而利用已有的样本数据$\{(X_j,y_j) | j=1,2,3….,M\}$训练$h(X)$的过程往往转换成一个最优化求解的过程。</p><p>无论是线性回归（Linear Regression）、逻辑回归（Logistic Regression）、支持向量机（SVM）、深度学习（Deep Learning）中，最优化求解都是基本的步骤。常见的梯度下降、牛顿法、拟牛顿法等属于批量处理的方法（Batch），每次更新都需要对已经训练过的样本重新训练一遍。当我们面对高维高数据量的时候，批量处理的方式就显得笨重和不够高效，因此需要在线处理的方法来解决相同的问题。关于在线最优化问题（Online Optimization）的论文比较多，注意查找阅读费时费力，那么本文就以高维高数据量的应用场景中比较看重的稀疏性作为主线，来介绍一些在线最优化的方法。</p><p>本文的预期读者大概有如下几类：</p><ol><li>具有很深的机器学习经验和背景的高阶人员：就拿这篇文章当做一个关于在线最优化算法的回归材料好了，如有错误和不足欢迎指正。</li><li>具有一定机器学习经验的中级读者：可以将本文作为一个理论资料进行阅读，略过“预备知识”部分，直接进入主题，将之前对于在线最优化算法的理解串联起来，希望对将来的工作提供帮助。</li><li>对机器学习有认识但是时间经验较少的初级读者：从预备知识看起，注意理解相关概念和方法，从而达到融会贯通的目的。</li><li>仅仅对算法的工程实现感兴趣的读者：大致浏览下预备知识的2.3节，了解我们要讨论什么，然后直奔各算法的算法逻辑（伪代码），照着实现就好了。</li><li>高富帅和白富美：只需要知道本文讨论的是一堆好用的求最优解的方法，可以用于分类回归预测的一系列问题，然后吩咐工程师去实践就好了。还可以拿这篇文章嘲笑机器学习的屌丝：看你们弄些啥，累死累活的，挣那么几个钢镚。</li></ol><h2 id="二、预备知识"><a href="#二、预备知识" class="headerlink" title="二、预备知识"></a>二、预备知识</h2><h3 id="2-1-凸函数"><a href="#2-1-凸函数" class="headerlink" title="2.1 凸函数"></a>2.1 凸函数</h3><p>如果$f(X)$是定义在N为向量空间上的实值函数，对于在$f(X)$的定义域$C$上的任意两个点$X_1$和$X_2$，以及任意$[0,1]$之间的值$t$都有：</p><script type="math/tex; mode=display">f(tX_1+(1-t)X_2)≤tf(X_1)+(1-t)f(X_2) \ \ \ ∀𝑋_1,𝑋_2∈𝐶, \ \  0≤𝑡≤1</script><p>则$f(X)$是严格凸函数（Strict Convex），如图一所示，（a）为严格凸函数，（b）为凸函数。<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 上午12.13.26.png" alt="屏幕快照 2017-07-27 上午12.13.26"></p><h3 id="2-2-拉格朗日乘数法及KKT条件"><a href="#2-2-拉格朗日乘数法及KKT条件" class="headerlink" title="2.2 拉格朗日乘数法及KKT条件"></a>2.2 拉格朗日乘数法及KKT条件</h3><p>通常我们需要求解的最优化问题有如下三类：</p><p>1.无约束优化问题：</p><script type="math/tex; mode=display">X=arg\underset{X}{min} \  f(X)</script><p>含义是求解$X$，使得目标函数$f(X)$最小；<br>2.有等式约束的优化问题：</p><script type="math/tex; mode=display">X=arg\underset{X}{min} \ f(X) \\ s.t. \ \ h_k(X)=0; \ \ k=1,2...n</script><p>含义是在n个等式约束$h_k(X)=0$的条件下，求解$X$，使得目标函数$f(X)$最小；<br>3.有不等式约束的优化问题：</p><script type="math/tex; mode=display">X=arg\underset{X}{min} \ f(X) \\ s.t. \ \ h_k(X)=0; \ \ k=1,2...n \\ g_l(X)≤0；l=1,2.....m</script><p>含义是在n个等式约束$h_k(X)$以及m各不等式约束$g_l(X)$的条件下，求解$X$使得目标函数$f(X)$最小。</p><p>针对无约束最优化问题，通常做法就是对$f(X)$求导，并令$\frac{\partial}{\partial X}f(X)=0$，求解可以得到最优值。如果$f(X)$为凸函数，则可以保证结果为全局最优解。</p><p>针对有等式约束的最优化问题，采用拉格朗日乘数法（Lagrange Multiplier）进行求解：通过拉格朗日系数$A=[a_1,a_2…a_n]^T\in R^n$把等式约束和目标函数组合成为一个式子，对该式子进行最优化求解：</p><script type="math/tex; mode=display">X=arg\underset{X}{min}\ [f(X)+A^TH(X)]</script><p>其中,$H(X)=[h_1(X),h_2(X)…h_n(X)]^T\in R^n$，相当于将有等式约束的最优化问题转换成了无约束最优化求解问题，解决方法依旧是对$f(X)+A^TH(X)$的各个参数$(X,A)$求偏导，并令其为0，联立等式求解。</p><p>针对有不等式约束的最优化问题，常用的方法是KKT条件（Karush-Kuhn-Tucker Conditions）：同样地，把所有的不等式约束、等是约束和目标函数全部写为一个式子：</p><script type="math/tex; mode=display">L(X,A,B)=f(X)+A^TH(X)+B^TG(X)</script><p>KKT条件是说最优值必须满足以下条件：</p><script type="math/tex; mode=display">\frac{\partial}{\partial X}L(X,A,B)=0 \\ H(X)=0 \\ B^TG(X)=0</script><p>其中，$B=[b_1,b_2…b_m]^T\in R^m，G(X)=[g_1(X),g_2(X)…g_m(X)]^T \in R^m$。KKT条件是求解最优值$X^*$的必要条件，要使其成为充分必要条件，还需要$f(X)$为凸函数才行。</p><p>在KKT条件中，$B^TG(X)=0$这个条件最有趣，因为$g_l(X)≤0$,如果要满足这个等式，需要$b_l=0$或者$g_l(X)=0$。在我们后面的推导中会用到这个性质。</p><h3 id="2-3-从Batch到Online"><a href="#2-3-从Batch到Online" class="headerlink" title="2.3 从Batch到Online"></a>2.3 从Batch到Online</h3><p>我们面对的最优化问题都是无约束的最优化问题（有约束最优化问题可以利用拉格朗日乘数法或KKT条件转换成无约束最优化问题），因此我们通常可以将它们描述成：</p><script type="math/tex; mode=display">W=𝑎𝑟𝑔\underset{w}{𝑚𝑖𝑛}\ l(𝑊, 𝑍) \\ 𝑍 = \{(𝑋_𝑗,𝑦_𝑗)|𝑗 = 1,2,...𝑀\}\\𝑦_𝑗 =h(𝑊,𝑋_𝑗)</script><p>这里$Z$为观测样本集合（训练集）；$X_j$是第$j$条阉割版的特征向量；$y_j=h(W,X_j)$为预测值；$h(W,X_j)$为特征向量到预测值的映射函数；$l (𝑊,𝑍) $为最优化求解的目标函数，也称作损失函数，损失函数通常可以分解为各样本损失函数的累加，即$l(𝑊,𝑍) =\sum_{j=1}^{M}l(𝑊,𝑍_𝑗)$;$W$为特征权重，也就是我们需要求解的参数。以线性回归和逻辑回归为例，它们的映射函数和损失函数分别为：<br> <img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 上午9.44.34.png" alt="屏幕快照 2017-07-27 上午9.44.34"><br>在2.1中我们给出了无约束最优化问题解析解的求法。而在我们实际的数值计算中，通常做法是随机给定一个初始的$W^{(0)}$，通过迭代，在每次迭代中计算损失函数在当前$W^{(t)}$的下降方向，并更新$W$,直到损失函数稳定在最小的点。例如著名的梯度下降法（Gradient Descent）就是通过计算损失函数的在当前$W^{(t)}$处的梯度（Gradient），以梯度$\nabla_Wl(W^{(t)},Z)$的反方向作为下降方向更新$W$，如果损失函数是一个非平滑的凸函数（Non-Smooth Convex），在不可导处用次梯度（Subgradient）方向的反方向作为下降方向。算法如下：<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 上午9.52.55.png" alt="屏幕快照 2017-07-27 上午9.52.55"><br>GD是一种批量处理的方式（Batch），每次更新$W$的时候都要扫描所有的样本以计算一个全局的梯度$\nabla_Wl(W,Z)$</p><p>考虑另一种权重更新策略：<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 上午9.54.35.png" alt="屏幕快照 2017-07-27 上午9.54.35"><br>在算法2中，每次迭代仅仅根据单个样本更新权重$W$，这种算法称作随机梯度下降（SGD，Stochastic Gradient Descent）</p><p>与 GD 每次扫所有的样本以计算一个全局的梯度相比，SGD 则每次只针对一 个观测到的样本进行更新。通常情况下，SGD 能够比 GD“更快”地令𝑊逼近最优值。当样 本数𝑀特别大的时候，SGD 的优势更加明显，并且由于 SGD 针对观测到的“一条”样本更新 𝑊，很适合进行增量计算，实现梯度下降的 Online 模式(OGD, Online Gradient Descent)。</p><h3 id="2-4-正则化"><a href="#2-4-正则化" class="headerlink" title="2.4 正则化"></a>2.4 正则化</h3><p>正则化(Regularization)的意义本质上是为了避免训练得到的模型过度拟合(overfitting) 训练数据。我们用图 2 来说明什么是过拟合。图 2 是一个局部加权线性回归(Locally weighted linear regression)的训练结果，当学习度为 1 时，相当于进行线性回归，这时候模型与训练样本以及实际曲线拟合得都不够好，模型处于 欠拟合(underfitting)状态;当学习度逐渐增加到 4 的过程中，模型逐渐与实际曲线吻合; 随着学习度继续增加，越来越多的样本直接落到模型曲线上(模型拟合训练数据)，但是模 型却与实际曲线相差越来越大，出现了过拟合。<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 上午9.58.07.png" alt="屏幕快照 2017-07-27 上午9.58.07"><br>过拟合体现出来的现象就是特征权重𝑊的各个维度的绝对值非常大:一些大正数，一些大负数。这种模型虽然能够很好匹配样本(如图 2 中 Degree = 20 的情况)，但是对新样本做 预测的时候会使得预测值与真实值相差很远。</p><p>为了避免过拟合的情况，我们通常在损失函数的基础上加一个关于特征权重𝑊的限制， 限制它的模不要太大，如果用𝜓(𝑊)表示特征权重𝑊的一种求模计算，那么(2-3-1)转换成:</p><p>为了避免过拟合的情况，我们通常在损失函数的基础上加一个关于特征权重$𝑊$的限制， 限制它的模不要太大，如果用$𝜓(𝑊)$表示特征权重$𝑊$的一种求模计算，那么(2-3-1)转换成:</p><script type="math/tex; mode=display">W=arg \underset {W}{min }l(W,Z) \\ s.t. 𝜓(𝑊)<𝛿</script><p>这个时候我们面对的是一个有约束的最优化问题。根据 KKT 条件，我们知道当选取合适的系数𝜆，那么这个有约束最优化问题等价于如下无约束最优化问题:</p><script type="math/tex; mode=display">W=arg\underset{W}{min}[l(W,Z)+𝜆𝜓(𝑊)]</script><p>其中$𝜓(𝑊)$ 称作正则化因子(Regularizer)，是一个关于$𝑊$求模的函数，我们常用正则化因子有L1和L2正则化:<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 上午10.02.31.png" alt="屏幕快照 2017-07-27 上午10.02.31"><br>不管是使用L1还是L2正则化，其基本原理都是一样的，即在最小化损失函数$l(𝑊,𝑍)$的同时，还要考虑$𝑊$的模带来的贡献，从而避免$𝑊$的维度上取一些绝对值很大的值。</p><p>$L_1$和$L_2$正则化的区别主要有两个:</p><ol><li>L1 正则化在0处不可导，而 L2 正则化可导。好 在无论是 L1 还是 L2 正则化本身都是凸函数，因此在计算 L1 正则化的梯度方向的可以采用次梯度代替;</li><li>在 Batch 模式下，L1 正则化通常产生更加稀疏(Sparse)的模型，𝑊的更 多维度为 0，这些为 0 的维度就代表了不是很相关的维度，从而起到了特征选择(Feature Selection)的目的。</li></ol><p>我们对稀疏性(Sparsity)比较感兴趣。除了特征选择的作用以外，稀疏性可以使得预测计算的复杂度降低。那么为什么 L1 正则化会产生这种稀疏性?通常可以根据文献[9]中的理解，如图 3 所示:<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 上午10.08.52.png" alt="屏幕快照 2017-07-27 上午10.08.52"></p><p>假如特征维度𝑁 = 2，那么 L1 正则化引入的约束条件是𝑊只能取转置方形中的值(图3-(a)中黑色方框内)，L2正则化对应的是一个圆形区域(图3-(b)中黑色圆形区 域)，图 3 中绿色部分代表损失函数的等高线，等高线与约束区域的首次相交的地方就是最优解。可以看到，由于 L1 正则化的约束区域与坐标轴相交的地方都有“角”出现，等高线更容易在这个“角”上与约束区域相交，导致另一个维度上的权重值为 0;而 L2 正则化则 没有这种性质，因为没有“角”，等高线在坐标轴上与约束区域相交的概率大为减小。这样 从直观上就解释了 L1 正则化更容易产生稀疏性的原因。</p><p>那么在Online模式下呢，不同于 Batch，Online 中每次𝑊的更新并不是沿着全局梯度进行下降，而是沿着某个样本的产生的梯度方向进行下降，整个寻优过程变得像是一个“随机” 查找的过程(SGD 中 Stochastic 的来历)，这样 Online 最优化求解即使采用 L1 正则化的方式， 也很难产生稀疏解。后面介绍的各个在线最优化求解算法中，稀疏性是一个主要的追求目标。</p><h2 id="三、在线最优化求解算法"><a href="#三、在线最优化求解算法" class="headerlink" title="三、在线最优化求解算法"></a>三、在线最优化求解算法</h2><p>在前面我们做了一些热身，下面将针对在线最优化求解介绍一些算法。在 2.4 中介绍了 L1 正则化在 Online 模式下也不能产生较好的稀疏性，而稀疏性对于高维特征向量以及大数 据集又特别的重要。因此，我们沿着 升模型稀疏性的主线进行算法介绍。</p><h3 id="3-1-TG"><a href="#3-1-TG" class="headerlink" title="3.1 TG"></a>3.1 TG</h3><p>为了得到稀疏的特征权重𝑊，最简单粗暴的方式就是设定一个阈值，当𝑊的某维度上系 数小于这个阈值时将其设置为 0(称作简单截断)。这种方法实现起来很简单，也容易理解。 但实际中(尤其在 OGD 里面)𝑊的某个系数比较小可能是因为该维度训练不足引起的，简单进行截断会造成这部分特征的丢失。</p><p>截断梯度法(TG, Truncated Gradient)是由 John Langford，Lihong Li 和 Tong Zhang 在 2009 年 出[10]，实际上是对简单截断的一种改进。下面首先 述一下 L1 正则化和简单截断的方 法，然后我们再来看 TG 对简单截断的改进以及这三种方法在特定条件下的转化。</p><h4 id="3-1-1-L1正则化法"><a href="#3-1-1-L1正则化法" class="headerlink" title="3.1.1 L1正则化法"></a>3.1.1 L1正则化法</h4><p>由于L1正则项在0处不可导，往往会造成平滑的凸优化问题变成非平滑凸优化问题，因此在每次迭代中采用次梯度计算L1正则项的梯度。权重更新方式为：</p><script type="math/tex; mode=display">𝑊^{(𝑡+1)} = 𝑊^𝑡 −𝜂^{(𝑡)}𝐺^{(t)} −𝜂^{(𝑡)}𝜆sgn(𝑊^{(t)})</script><p>注意，这里$𝜆∈R$是一个标量，且$𝜆≥ 0$，为 L1 正则化参数;$sgn(𝑣)$为符号函数，如果$𝑉=[𝑣_1,𝑣_2,…,𝑣_𝑁] ∈R^𝑁$是一个向量，$𝑣_𝑖$是向量的一个维度，那么有$sgn(𝑉)=[sgn(𝑣_1) , sgn(𝑣_2) , … , sgn(𝑣_𝑁)∈R^𝑁$;$𝜂^{(𝑡)}$为学习率，通常将其设置成$1\sqrt{t}$的函数; $𝐺^{(t)}= 𝛻_𝑊l(𝑊^{(𝑡)},𝑍^{(𝑡)})$ 代表了第𝑡次迭代中损失函数的梯度，由于 OGD 每次仅根据观测到的一个样本进行权重更新，因此也不再使用区分样本的下标$𝑗$。</p><h4 id="3-1-2-简单截断法"><a href="#3-1-2-简单截断法" class="headerlink" title="3.1.2 简单截断法"></a>3.1.2 简单截断法</h4><p>以𝑘为窗口，当𝑡/𝑘不为整数时采用标准的 SGD 进行迭代，当𝑡/𝑘为整数时，采用如下权重更新方式:<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 上午10.25.07.png" alt="屏幕快照 2017-07-27 上午10.25.07"><br>注意，这里面$𝜃∈R$是一个标量，且$𝜃≥0$;如果$𝑉=[𝑣_1, 𝑣_2, … , 𝑣_𝑁] ∈ R^𝑁$是一个向量，$𝑣_𝑖$是向量的一个维度，那么有$𝑇_0(𝑉,𝜃) = [𝑇_0(𝑣_1,𝜃) ,𝑇_0(𝑣_2,𝜃) ,…,𝑇_0(𝑣_𝑁,𝜃)] ∈ R^𝑁$。</p><h4 id="3-1-3-截断梯度法（TG）"><a href="#3-1-3-截断梯度法（TG）" class="headerlink" title="3.1.3 截断梯度法（TG）"></a>3.1.3 截断梯度法（TG）</h4><p>上述的简单截断法被 TG 的作者形容为 too aggressive，因此 TG 在此基础上进行了改进，同样是采用截断的方式，但是比较不那么粗暴。采用相同的方式表示为:<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 上午10.34.07.png" alt="屏幕快照 2017-07-27 上午10.34.07"></p><p>其中$\lambda^{(t)} \in R$且$\lambda ^{(t)}≥0$。TG同样是以k为窗口，每𝑘步进行一次截断。当$𝑡/𝑘$不为整数时$𝜆(𝑡) = 0$，当$𝑡/𝑘$为整数时$𝜆(𝑡) = 𝑘𝜆$。从公式(3-1-3)可以看出，𝜆和𝜃决定了𝑊的稀疏程度，这 两个值越大，则稀疏性越强。尤其令𝜆 = 𝜃时，只需要通过调节一个参数就能控制稀疏性。</p><p>根据公式（3-1-3），我们很容易写出TG的算法逻辑：<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 上午10.38.01.png" alt="屏幕快照 2017-07-27 上午10.38.01"></p><h4 id="3-1-4-TG与简单截断以及L1正则化的关系"><a href="#3-1-4-TG与简单截断以及L1正则化的关系" class="headerlink" title="3.1.4 TG与简单截断以及L1正则化的关系"></a>3.1.4 TG与简单截断以及L1正则化的关系</h4><p>简单截断和截断梯度的区别在于采用了不同的截断公式$𝑇_0$和$𝑇_1$，如图 4 所示。<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 上午10.39.14.png" alt="屏幕快照 2017-07-27 上午10.39.14"><br>为了清晰地进行比较，我们将公式(3-1-3)进行改写， 述特征权重每个维度的更新方式:<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 上午10.44.51.png" alt="屏幕快照 2017-07-27 上午10.44.51"><br>如果令$\lambda_{TG}^{(t)}=\theta$，截断公式$Trnc(w,\lambda_{TG}^{(t)},\theta)$变成：<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 上午10.51.48.png" alt="屏幕快照 2017-07-27 上午10.51.48"><br>此时 TG 退化成简单截断法。<br>如果令$\theta =∞$，截断公式$Trnc(w,\lambda_{TG}^{(t)},\theta)$变成：</p><script type="math/tex; mode=display">Trnc\left(w,\lambda_{TG}^{\left(t\right)},\infty\right)=\left\{\begin{array}{l}    0\ \  if\ |w|\le\lambda_{TG}^{\left(t\right)}\\    w-\lambda_{TG}^{\left(t\right)}sgn \left(w\right)\  \ otherwise\\\end{array}\right.</script><p>如果再令𝑘 = 1，那么特征权重维度更新公式变成<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 上午10.57.02.png" alt="屏幕快照 2017-07-27 上午10.57.02"></p><p>此时 TG 退化成 L1 正则化法。</p><h3 id="3-2-FOBOS"><a href="#3-2-FOBOS" class="headerlink" title="3.2 FOBOS"></a>3.2 FOBOS</h3><h4 id="3-2-1-FOBOS算法原理"><a href="#3-2-1-FOBOS算法原理" class="headerlink" title="3.2.1 FOBOS算法原理"></a>3.2.1 FOBOS算法原理</h4><p>前向后向切分(FOBOS, Forward-Backward Splitting)是由 John Duchi 和 Yoram Singer   出的[11]。从全称上来看，该方法应该叫 FOBAS，但是由于一开始作者管这种方法叫 FOLOS (Forward Looking Subgradients)，为了减少读者的困扰，作者干脆只修改一个字母，叫 FOBOS。<br>在 FOBOS 中，将权重的更新分为两个步骤:<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 上午10.58.47.png" alt="屏幕快照 2017-07-27 上午10.58.47"><br>前一个步骤实际上是一个标准的梯度下降步骤，后一个步骤可以理解为对梯度下降的结果进行微调。<br>观察第二个步骤，发现对𝑊的微调也分为两部分:(1) 前一部分保证微调发生在梯度下 降结果的附近;(2)后一部分则用于处理正则化，产生稀疏性。</p><p>如果将(3-2-1)中的两个步骤合二为一，即将$𝑊^{(𝑡 +\frac{1}{2})}$的计算代入$𝑊^{(𝑡 +1)}$中，有:<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 上午11.00.51.png" alt="屏幕快照 2017-07-27 上午11.00.51"><br>令$𝐹(𝑊) =\frac{1}{2}||𝑊 − 𝑊^{(𝑡)} + 𝜂^{(𝑡)}𝐺^{(𝑡)}||^2 + 𝜂^{(𝑡+\frac{1}{2})} Ψ(𝑊)$如果$W^{(t+1)}$存在一个最优解，那么可以推断0向量一定属于$F(W)$的次梯度集合：<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 上午11.07.41.png" alt="屏幕快照 2017-07-27 上午11.07.41"><br>由于$W^{(t+1)}=arg\underset{W}{min}F(W)$那么有：<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 上午11.08.31.png" alt="屏幕快照 2017-07-27 上午11.08.31"><br>上式实际上给出了FOBOS中权重更新的另一种形式：<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 上午11.10.06.png" alt="屏幕快照 2017-07-27 上午11.10.06"><br>我们这里可以看到，$W^{(t+1)}$不仅仅与迭代前的状态$W^{(t)}$有关，而且与迭代后的$Ψ(𝑊^{(𝑡+1)})$有关。可能这就是FOBOS名称的由来。</p><h4 id="3-2-2-L1-FOBOS"><a href="#3-2-2-L1-FOBOS" class="headerlink" title="3.2.2 L1-FOBOS"></a>3.2.2 L1-FOBOS</h4><p>关于 FOBOS 的收敛性和 Regret 就不在此讨论了，详情可参见论文[11]。这里我们来看 看 FOBOS 如何在 L1 正则化下取得比较好的稀疏性。</p><p>在 L1 正则化下，有$Ψ(𝑊)=𝜆||W||_1$.为了简化描述，用向量$𝑉 = [𝑣_1,𝑣_2 …𝑣_𝑁] ∈ R^𝑁$来表示$W^{(t+\frac{1}{2})}$，用标量$\bar{𝜆} ∈ R$来表示$𝜂^{(𝑡+\frac{1}{2})} 𝜆$，并将公式（3-2-1）等号右边按维度展开：<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 上午11.49.57.png" alt="屏幕快照 2017-07-27 上午11.49.57"><br>我们可以看到，在上式求和公式中的每一项都是大于等于0的，所以公式（3-2-2）可以拆解成对特征权重$W$的每一维度单独求解：<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 上午11.51.59.png" alt="屏幕快照 2017-07-27 上午11.51.59"><br>首先，假设$𝑤^∗$是$minimize_{w_i}(\frac{1}{2}(w_i-v_i)^2+\bar{\lambda }|w_i|)$的最优解，则有$𝑤^*𝑣_i ≥ 0$，这是因为:<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 上午11.56.20.png" alt="屏幕快照 2017-07-27 上午11.56.20"><br>既然有$𝑤_𝑖∗𝑣_𝑖 ≥ 0$，那么我们分两种情况$𝑣_𝑖 ≥ 0$和$𝑣_𝑖 &lt; 0$来讨论:<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 下午12.03.34.png" alt="屏幕快照 2017-07-27 下午12.03.34"><br>综合上面的分析，可以得到在 FOBOS 在 L1 正则化条件下，特征权重的各个维度更新的方式为:<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 下午12.04.37.png" alt="屏幕快照 2017-07-27 下午12.04.37"><br>其中，$𝑔_𝑖^{(𝑡)}$为梯度$𝐺^{(𝑡)}$ 在维度𝑖上的取值。<br>根据公式(3-2-3)，我们很容易就可以设计出 L1-FOBOS 的算法逻辑:<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 下午12.05.26.png" alt="屏幕快照 2017-07-27 下午12.05.26"></p><h4 id="3-2-3-L1-FOBOS与TG的关系"><a href="#3-2-3-L1-FOBOS与TG的关系" class="headerlink" title="3.2.3 L1-FOBOS与TG的关系"></a>3.2.3 L1-FOBOS与TG的关系</h4><p>从公式(3-2-3)可以看出，L1-FOBOS 在每次更新𝑊的时候，对𝑊的每个维度都会进行判定，当满足$𝑤_𝑖^{𝑡} − 𝜂^{(𝑡)}𝑔_𝑖^{(𝑡)} − 𝜂^{(𝑡+\frac{1}{2})}𝜆 ≤ 0$ 时对该维度进行“截断”，令$𝑤_𝑖^{(𝑡+1)} = 0$。那么我们怎么去理解这个判定条件呢?如果我们把判定条件写成$𝑤_𝑖^{𝑡} − 𝜂^{(𝑡)}𝑔_𝑖^{(𝑡)} ≤𝜂^{(𝑡+\frac{1}{2})}𝜆 $，那么这个含 义就很清晰了:当一条样本产生的梯度不足以令对应维度上的权重值发生足够大的变化$𝜂^{(𝑡+\frac{1}{2})}𝜆 $，认为在本次更新过程中该维度不够重要，应当令其权重为 0。</p><p>对于 L1-FOBOS 特征权重的各个维度更新公式(3-2-3)，也可以写作如下形式:<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 下午12.08.48.png" alt="屏幕快照 2017-07-27 下午12.08.48"><br>比较上式与TG的特征权重维度更新公式(3-1-4)，我们发现如果令$𝜃 = ∞，𝑘 = 1，𝜆^{(t)}_{TG}(𝑡) = 𝜂^{(𝑡+\frac{1}{2})}𝜆$,L1-FOBOS 与 TG 完全一致。我们可以认为 L1-FOBOS 是 TG 在特定条件下的特殊形式。</p><h3 id="3-3-RDA"><a href="#3-3-RDA" class="headerlink" title="3.3 RDA"></a>3.3 RDA</h3><h4 id="3-3-1-RDA算法原理"><a href="#3-3-1-RDA算法原理" class="headerlink" title="3.3.1 RDA算法原理"></a>3.3.1 RDA算法原理</h4><p>不论怎样，简单截断、TG、FOBOS 都还是建立在 SGD 的基础之上的，属于梯度下降类 型的方法，这类型方法的优点就是精度比较高，并且 TG、FOBOS 也都能在稀疏性上得到  升。但是有些其它类型的算法，例如 RDA，是从另一个方面来求解 Online Optimization 并且 更有效地 升了特征权重的稀疏性。</p><p>正则对偶平均(RDA, Regularized Dual Averaging)是微软十年的研究成果，RDA 是 Simple Dual Averaging Scheme 一个扩展，由 Lin Xiao 发表于 2010 年。<br>在 RDA 中，特征权重的更新策略为:<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 下午2.29.43.png" alt="屏幕快照 2017-07-27 下午2.29.43"></p><p>其中， $&lt;𝐺^{(𝑟)}, 𝑊&gt;$ 表示梯度$𝐺^{(𝑟)}$对𝑊的积分平均值(积分中值);$Ψ(𝑊)$为正则项;$h(𝑊)$为一个辅助的严格凸函数; $\{𝛽^{(𝑡)}|t ≥ 1\}$ 是一个非负且非自减序列。</p><p>本质上，公式（3-3-1）中包含了3个部分：</p><ol><li>线性函数$\frac{1}{t}\sum _{r=1}^t<g^{(t)},w>$包含了之前所有梯度（或次梯度）的平均值（dual average）；</g^{(t)},w></li><li>正则项$Ψ(𝑊)$</li><li>额外正则项$\frac{\beta ^{(t)}}{t}h(W)$，它是一个严格凸函数</li></ol><h4 id="3-3-2-L1-RDA"><a href="#3-3-2-L1-RDA" class="headerlink" title="3.3.2 L1-RDA"></a>3.3.2 L1-RDA</h4><p>我们下面来看看在 L1 正则化下，RDA 中的特征权重更新具有什么样的形式以及如何产 生稀疏性。</p><p>令$𝛹(𝑊) = 𝜆||𝑊||_1$，并且由于$h(W)$是一个关于𝑊的严格凸函数，不妨令$h(W)=\frac{1}{2}||W||_2^2$， 此外，将非负非自减序列$\{𝛽^{(𝑡)}|t≥1\}$定义为$𝛽^{(𝑡)}=𝛾\sqrt{𝑡}$，将L1正则化代入公式(3-3-1)有:<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 下午2.39.59.png" alt="屏幕快照 2017-07-27 下午2.39.59"></p><p>针对特征权重的各个维度将其拆解成N个独立的标量最小化问题：<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 下午2.41.03.png" alt="屏幕快照 2017-07-27 下午2.41.03"></p><p>这里$\lambda&gt;0,\frac{\gamma}{\sqrt{t}}&gt;0;\bar{g_t}^{(t)}=\frac{1}{t}\sum_{r=1}^tg_i^{(r)}$；公式（3-3-3）就是一个无约束的非平滑最优化问题。</p><p>其中第2项$\lambda|w_i|$在$w_i=0$处不可导。假设$w_i^<em>$是其最优解，并且定义$𝜉\in \partial |w_i^</em>|$为$|w_i|$在$w_i^*$的次导数，那么有：<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 下午2.45.33.png" alt="屏幕快照 2017-07-27 下午2.45.33"><br>如果对公式(3-3-3)求导(求次导数)并等于 0，则有:<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 下午2.46.03.png" alt="屏幕快照 2017-07-27 下午2.46.03"><br>由于$\lambda&gt;0$，我们针对（3-3-5）分三种情况$|\bar{g_i}^{(t)}|&lt;\lambda,|\bar{g_i}^{(t)}|&gt;\lambda和|\bar{g_i}^{(t)}|&lt;-\lambda$来进行讨论：<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 下午2.49.35.png" alt="屏幕快照 2017-07-27 下午2.49.35"></p><p>综合上面的分析，可以得到L1-RDA特征权重的各个维度更新方式为：<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 下午2.50.17.png" alt="屏幕快照 2017-07-27 下午2.50.17"><br>这里我们发现，当某个维度上累积梯度平均值的绝对值$|\bar{g_i}^{(t)}|$小于阈值$\lambda$的时候，改为度权重将被置0，特征权重的稀疏性由此产生。<br>根据公式（3-3-6）,可以设计出L1-RDA的算法逻辑：<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 下午2.52.16.png" alt="屏幕快照 2017-07-27 下午2.52.16"></p><h4 id="3-3-3-L1-RDA与L1-FOBOS的比较"><a href="#3-3-3-L1-RDA与L1-FOBOS的比较" class="headerlink" title="3.3.3 L1-RDA与L1-FOBOS的比较"></a>3.3.3 L1-RDA与L1-FOBOS的比较</h4><p>在3.2.3中我们看到了L1-FOBOS实际上是TG的一种特殊形式，在L1-FOBOS中，进行“截断”的判定条件是$|w_i^{(t)}-𝜂^{(𝑡)}𝑔_i^{(𝑡)}|≤\lambda_{TG}^{(t)}=𝜂^{(𝑡+\frac{1}{2})}𝜆$，通常会定义𝜂为与$\frac{1}{\sqrt{t}}$正相关的函数$(𝜂 = Θ(\frac{1}{\sqrt{t}})$ ，因此L1-FOBOS的截断阈值为$ Θ(\frac{1}{\sqrt{t}}) \lambda$随着t的增加，这个阈值会逐渐降低。</p><p>相比较而言，从3-3-6可以看出，L1-RDA的截断阈值为$\lambda$，是一个常数，并不随着$t$而变化，因此可以认为$L1-RDA$比$L1-FOBOS$在截断判定上更加aggressive，这种性质使得L1-RDA更容易产生稀疏性；此外，RDA中判定对象是梯度的累加均值$\bar{g_i}^{(t)}$，不同于TG或L1-FOBOS中针对单词梯度计算的结果进行判定，避免了由于某些维度由于训练不足导致截断的问题。并且通过调节$\lambda$一个参数，很容易在精度和稀疏性上进行权衡。</p><h3 id="3-4-FTRL"><a href="#3-4-FTRL" class="headerlink" title="3.4 FTRL"></a>3.4 FTRL</h3><p>在 3.3.3 中我们从原理上定性比较了 L1-FOBOS 和 L1-RDA 在稀疏性上的表现。有实验证 明，L1-FOBOS 这一类基于梯度下降的方法有比较高的精度，但是 L1-RDA 却能在损失一定精 度的情况下产生更好的稀疏性。那么这两者的优点能不能在一个算法上体现出来?这就是 FTRL 要解决的问题。</p><p>FTRL(Follow the Regularized Leader)是由 Google 的 H. Brendan McMahan 在 2010 年  出的[14]，后来在 2011 年发表了一篇关于 FTRL 和 AOGD、FOBOS、RDA 比较的论文[15]，2013 年又和 Gary Holt, D. Sculley, Michael Young 等人发表了一篇关于 FTRL 工程化实现的论文[16]。</p><p>本节我们首先从形式上将 L1-FOBOS 和 L1-RDA 进行统一，然后介绍从这种统一形式产生 FTRL 算法，以及介绍 FTRL 算法工程化实现的算法逻辑。</p><h4 id="3-4-1-L1-FOBOS和L1-RDA在形式上的统一"><a href="#3-4-1-L1-FOBOS和L1-RDA在形式上的统一" class="headerlink" title="3.4.1 L1-FOBOS和L1-RDA在形式上的统一"></a>3.4.1 L1-FOBOS和L1-RDA在形式上的统一</h4><p>L1-FOBOS在形式上，每次迭代都可以表示为（这里我们令$𝜂^{(𝑡+\frac{1}{2})}= 𝜂^{(𝑡)}= Θ(\frac{1}{\sqrt{𝑡}})$是一个随着t变化的非增正序列)：<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 下午3.04.49.png" alt="屏幕快照 2017-07-27 下午3.04.49"><br>把两个公式合并到一起，有：<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 下午3.05.29.png" alt="屏幕快照 2017-07-27 下午3.05.29"><br>通过这个公式很难直接求出$W^{(t+1)}$的解析解，但是我们可以按照维度将其分解为N个独立的最优化步骤：<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 下午3.06.29.png" alt="屏幕快照 2017-07-27 下午3.06.29"><br>由于$\frac{𝜂^{(t)}}{2}(g_i^{(t)})^2+w_i^{(t)}g_i^{(t)}$与变量$w_i$无关，因此上式可以等价于：<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 下午3.10.41.png" alt="屏幕快照 2017-07-27 下午3.10.41"><br>再将这N个独立最优化子步骤合并，那么L1-FOBOS可以写作：<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 下午3.12.31.png" alt="屏幕快照 2017-07-27 下午3.12.31"><br>而对于L1-RDA的公式（3-3-2）,我们可以写作：<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 下午3.13.10.png" alt="屏幕快照 2017-07-27 下午3.13.10"><br>这里$G^{(1:t)}=\sum^t_{s=1}G^{(s)}$，如果令$\sigma^{(s)}=\frac{1}{𝜂^{(𝑠)}}-\frac{1}{𝜂^{(𝑠-1)}},𝜎^{(1:𝑡)}=\frac{1}{𝜂^{(𝑡)}} $上面两个式子可以写作：<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 下午3.16.59.png" alt="屏幕快照 2017-07-27 下午3.16.59"><br>需要注意，与论文[15]中的Table 1不同，我们并没有将L1-FOBOS也写成累加梯度的形式。</p><p>比较（3-4-1）和（3-4-2）这两个公式，可以看出L1-FOBOS和L1-RDA的区别在于：</p><ol><li>前者计算的是累加梯度以及L1正则项只考虑当前模的贡献，而后者采用了累加的处理方式；</li><li>前者的第三项限制W的变化不能离已迭代过的解太远，而后者则限制W不能离0点太远。</li></ol><h4 id="3-4-2-FTRL算法原理"><a href="#3-4-2-FTRL算法原理" class="headerlink" title="3.4.2 FTRL算法原理"></a>3.4.2 FTRL算法原理</h4><p>FTRL综合考虑了FOBOS和RDA对于正则项和W限制的区别，其特征权重的更新公式为：<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 下午3.20.56.png" alt="屏幕快照 2017-07-27 下午3.20.56"></p><p>注意，公式（3-4-3）中出现了L2正则项$\frac{1}{2}||W||^2_2$在论文[15]的公式中并没有这一项，但是在其2013年发表的FTRL工程化实现的论文[16]却使用了L2正则项。事实上该项的引入并不影响FTRL的稀疏性，后面的推导会显示这一点。L2正则项的引入仅仅相当于对最优化过程多了一个约束，使得结果求解结果更加平滑。</p><p>公式（3-4-3）看上去很复杂，更新权重貌似非常困难的样子，不妨将其进行改写，将最后一项展开，等价于求下面这样一个最优化问题<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 下午3.26.37.png" alt="屏幕快照 2017-07-27 下午3.26.37"><br>由于$\frac{1}{2}\sum_{s=1}^t\sigma^{(s)}||W^{(s)}||_2^2$相对于W来说是一个常数，并且令$Z^{(t)}=G^{(1:t)}- \sum_{s=1}^t\sigma^{(s)}W^{(s)}$，上式等价于：<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 下午3.29.21.png" alt="屏幕快照 2017-07-27 下午3.29.21"><br>针对特征权重的各个维度将其拆解成N个独立的标量最小化问题：<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 下午3.30.01.png" alt="屏幕快照 2017-07-27 下午3.30.01"><br>到这里，我们遇到了与（3-3-3）类似的问题，用相同的分析方法可以得到：<img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 下午3.30.47.png" alt="屏幕快照 2017-07-27 下午3.30.47"></p><p>从（3-4-4）可以看出，引入L2正则化并没有对FTRL结果的稀疏性产生任何影响。</p><h4 id="3-4-3-Per-Coordinate-Learning-Rates"><a href="#3-4-3-Per-Coordinate-Learning-Rates" class="headerlink" title="3.4.3 Per-Coordinate Learning Rates"></a>3.4.3 Per-Coordinate Learning Rates</h4><p>前面介绍了FTRL的基本推导，但是这里还有一个问题是一直没有被讨论到的：关于学习率$𝜂^{(𝑡)}$的选择和计算。事实上在FTRL中，每个维度上的学习率都是单独考虑的（Per-Coordinate Learning Rates）。</p><p>在一个标准的OGD里面使用的是一个全局的学习率策略$𝜂^{(𝑡)} =\frac{ 1}{\sqrt{𝑡}}$，这个策略保证了学习率是一个正的非增长序列，对于每一个特征维度都是一样的。</p><p>考虑特征维度的变化率：如果特征1比特征2的变化更快，那么在维度1上的学习率应该下降地更快。我们很容易就可以想到可以用某个维度上的梯度分量来反映这种变化率。在FTRL中，维度i上的学习率是这样计算的：</p><script type="math/tex; mode=display">𝜂_𝑖^{(𝑡)}=\frac{𝛼}{𝛽 + \sqrt{\sum_𝑡^{𝑠 = 1} (𝑔_𝑖^{( 𝑠 )})^ 2}}</script><p>由于$\sigma^{(1:t)}=\frac{1}{𝜂^{(𝑡)}}$，所以公式（3-4-4）中</p><script type="math/tex; mode=display">\sum_{s=1}^t=\frac{1}{𝜂_i^{(𝑡)}}=\frac{\beta+\sqrt{\sum_t^{s= 1} (g_i ^{(s)})^2}}{a}</script><p>，这里的$\alpha和\beta$是需要输入的参数，(3-4-4)中学习率写成累加的形式，是为了方便理解后面FTRL的迭代计算逻辑。</p><h4 id="3-4-4-FTRL算法逻辑"><a href="#3-4-4-FTRL算法逻辑" class="headerlink" title="3.4.4 FTRL算法逻辑"></a>3.4.4 FTRL算法逻辑</h4><p>到现在为止，我们已经得到了 FTRL 的特征权重维度的更新方法(公式(3-4-4))，每个特征维度的学习率计算方法(公式(3-4-5))，那么很容易写出FTRL的算法逻辑（这里是根据(3-4-4) 和(3-4-5)写的 L1&amp;L2-FTRL 求解最优化的算法逻辑，而论文[16]中 Algorithm 1 给出的是 L1&amp;L2-FTRL 针对 Logistic Regression 的算法逻辑):<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 下午3.43.42.png" alt="屏幕快照 2017-07-27 下午3.43.42"><br>FTRL 里面的 4 个参数需要针对具体的问题进行设置，指导性的意见参考论文[16]。</p><h2 id="四、结束语"><a href="#四、结束语" class="headerlink" title="四、结束语"></a>四、结束语</h2><p>本文作为在线最优化算法的整理和总结，沿着稀疏性的主线，先后介绍了简单截断法、TG、FOBOS、RDA以及FTRL。从类型上看，简单截断法、TG、FOBOS属于同一类，都是梯度下降类的算法，并且TG在特定条件可以转换成简单截断法和FOBOS；RDA属于简单对偶平均的扩展应用；FTRL可以视作RDA和FOBOS的结合，同时具备二者的有点。目前来看，RDA和FTRL是最好的系数模型Online Learning 的算法。</p><p>谈到高维高数据量的最优化求解，不可避免的要涉及到并行计算的问题。作者之前有篇 博客[4]讨论了 batch 模式下的并行逻辑回归，其实只要修改损失函数，就可以用于其它问题 的最优化求解。另外，对于 Online 下，文献[17]给出了一种很直观的方法:<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-27 下午3.46.45.png" alt="屏幕快照 2017-07-27 下午3.46.45"><br>对于 Online 模式的并行化计算，一方面可以参考 ParallelSGD 的思路，另一方面也可以 借鉴 batch 模式下对高维向量点乘以及梯度分量并行计算的思路。总之，在理解算法原理的 基础上将计算步骤进行拆解，使得各节点能独自无关地完成计算最后汇总结果即可。</p><p>最后，需要指出的是相关论文里面使用的数学符号不尽相同，并且有的论文里面也存在 一定的笔误，但是并不影响我们对其的理解。在本文中尽量采用了统一风格和含义的符号、 变量等，因此在与参考文献中的公式对比的时候会稍有出入。另外，由于笔者的水平有限， 行文中存在的错误难以避免，欢迎大家指正、拍砖。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] Convex function. <a href="http://en.wikipedia.org/wiki/Convex_function" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Convex_function</a><br>[2] Lagrange multiplier. <a href="http://en.wikipedia.org/wiki/Lagrange_multiplier" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Lagrange_multiplier</a><br>[3] Karush–Kuhn–Tucker conditions. <a href="http://en.wikipedia.org/wiki/Karush-Kuhn-Tucker_conditions" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Karush-Kuhn-Tucker_conditions</a><br>[4] 冯扬. 并行逻辑回归. <a href="http://blog.sina.com.cn/s/blog_6cb8e53d0101oetv.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_6cb8e53d0101oetv.html</a><br>[5] Gradient. <a href="http://sv.wikipedia.org/wiki/Gradient" target="_blank" rel="noopener">http://sv.wikipedia.org/wiki/Gradient</a><br>[6] Subgradient. <a href="http://sv.wikipedia.org/wiki/Subgradient" target="_blank" rel="noopener">http://sv.wikipedia.org/wiki/Subgradient</a><br>[7] Andrew Ng. CS229 Lecture notes. <a href="http://cs229.stanford.edu/notes/cs229-notes1.pdf" target="_blank" rel="noopener">http://cs229.stanford.edu/notes/cs229-notes1.pdf</a><br>[8] Stochastic Gradient Descent. <a href="http://en.wikipedia.org/wiki/Stochastic_gradient_descent" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Stochastic_gradient_descent</a><br>[9] T. Hastie, R. Tibshirani &amp; J. Friedman. The Elements of Statistical Learning, Second Edition: Data Mining,<br>Inference, and Prediction. Springer Series in Statistics. Springer, 2009<br>[10] John Langford, Lihong Li &amp; Tong Zhang. Sparse Online Learning via Truncated Gradient. Journal of Machine<br>Learning Research, 2009<br>[11] John Duchi &amp; Yoram Singer. Efficient Online and Batch Learning using Forward Backward Splitting. Journal of<br>Machine Learning Research, 2009<br>[12] Lin Xiao. Dual Averaging Methods for Regularized Stochastic Learning and Online Optimization. Journal of<br>Machine Learning Research, 2010<br>[13] Convex Set. <a href="http://en.wikipedia.org/wiki/Convex_set" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Convex_set</a><br>[14] H. Brendan McMahan &amp; M Streter. Adaptive Bound Optimization for Online Convex Optimization. In COLT,<br>2010<br>[15] H. Brendan McMahan. Follow-the-Regularized-Leader and Mirror Descent: Equivalence Theorems and L1<br>Regularization. In AISTATS, 2011<br>[16] H. Brendan McMahan, Gary Holt, D. Sculley, Michael Young, Dietmar Ebner, Julian Grady, Lan Nie, Todd<br>Phillips, Eugene Davydov, Daniel Golovin, Sharat Chikkerur, Dan Liu, Martin Wattenberg, Arnar Mar Hrafnkelsson, Tom Boulos, Jeremy Kubica, Ad Click Prediction: a View from the Trenches. In ACM SIGKDD, 2013<br>[17] Martin A. Zinkevich, Markus Weimer, Alex Smola &amp; Lihong Li. Parallelized Stochastic Gradient Descent. In NIPS 2010</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最优化求解问题可能是我们在工作中遇到的最多的一类问题了：从已有的数据中提炼出最适合的模型参数，从而对未知的数据进行预测。当我们面对高维高数据量的场景时，常见的批量处理的方式已经显得力不从心，需要有在线处理的方法来解决此类问题。本文以模型的稀疏性作为主线，逐一介绍几个在线最优化求解算法，并进行推导，力求讲清楚算法的来龙去脉，以及不同算法之间的区别和联系，达到融会贯通。在各个算法原理介绍之后，都给出该算法的工程实现伪代码，可以用于实际工作的参考。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="online learning" scheme="http://yoursite.com/tags/online-learning/"/>
    
      <category term="FTRL" scheme="http://yoursite.com/tags/FTRL/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法（12）：排序</title>
    <link href="http://yoursite.com/2017/07/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8812%EF%BC%89%EF%BC%9A%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2017/07/26/数据结构与算法（12）：排序/</id>
    <published>2017-07-26T13:14:45.000Z</published>
    <updated>2017-09-01T06:36:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>经典排序算法在面试中占有很大的比重，也是基础，在这里整理并用Java实现了几大经典排序算法，包括冒泡排序、插入排序、选择排序、希尔排序、归并排序、快速排序、堆排序、同排序。我们默认将一个无序数列排序成由小到大。</p><a id="more"></a><h2 id="一、冒泡排序（Bubble-Sort）"><a href="#一、冒泡排序（Bubble-Sort）" class="headerlink" title="一、冒泡排序（Bubble Sort）"></a>一、冒泡排序（Bubble Sort）</h2><h3 id="1-1-思想"><a href="#1-1-思想" class="headerlink" title="1.1 思想"></a>1.1 思想</h3><p>冒泡排序(bubble sort)：每个回合都从第一个元素开始和它后面的元素比较，如果比它后面的元素更大的话就交换，一直重复，直到这个元素到了它能到达的位置。每次遍历都将剩下的元素中最大的那个放到了序列的“最后”(除去了前面已经排好的那些元素)。注意检测是否已经完成了排序，如果已完成就可以退出了。</p><p><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-09%20%E4%B8%8A%E5%8D%888.49.45.png" alt="屏幕快照 2017-03-09 上午8.49.45"></p><h3 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123; <span class="comment">// 每次需要排序的长度</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123; <span class="comment">// 从第一个元素到第i个元素</span></div><div class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</div><div class="line">                temp = arr[j];</div><div class="line">                arr[j] = arr[j + <span class="number">1</span>];</div><div class="line">                arr[j + <span class="number">1</span>] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="comment">//loop j</span></div><div class="line">    &#125;<span class="comment">//loop i</span></div><div class="line">&#125;<span class="comment">// method bubbleSort</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">10</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">60</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</div><div class="line">        Demo.BubbleSort(arr);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:arr)&#123;</div><div class="line">            System.out.print(i+<span class="string">","</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="1-3-时空复杂度"><a href="#1-3-时空复杂度" class="headerlink" title="1.3 时空复杂度"></a>1.3 时空复杂度</h3><p>冒泡排序的关键字比较次数与数据元素的初始状态无关。第一趟的比较次数为n-1，第i趟的比较次数为n-i，第n-1趟（最后一趟）的比较次数为1，因此冒泡排序总的比较次数为$n(n-1)/2$</p><p>冒泡排序的数据元素移动次数与序列的初始状态有关。在最好的情况下，移动次数为0次；在最坏的情况下，移动次数为$n(n-1)/2$</p><p>冒泡排序的时间复杂度为<strong>$O(n^2)$</strong>。冒泡排序不需要辅助存储单元，其空间复杂度为$O(1)$。如果关键字相等，则冒泡排序不交换数据元素，他是一种稳定的排序方法。</p><blockquote><p>时间复杂度：最好$O(n)$；最坏$O(n^2)$；平均$O(n^2)$<br>空间复杂度：$O(1)$<br>稳定性：稳定</p></blockquote><h2 id="二、选择排序（Selection-Sort）"><a href="#二、选择排序（Selection-Sort）" class="headerlink" title="二、选择排序（Selection Sort）"></a>二、选择排序（Selection Sort）</h2><h3 id="2-1-思想"><a href="#2-1-思想" class="headerlink" title="2.1 思想"></a>2.1 思想</h3><p>每个回合都选择出剩下的元素中最大的那个，选择的方法是首先默认第一元素是最大的，如果后面的元素比它大的话，那就更新剩下的最大的元素值，找到剩下元素中最大的之后将它放入到合适的位置就行了。和冒泡排序类似，只是找剩下的元素中最大的方式不同而已。</p><p><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-09%20%E4%B8%8A%E5%8D%889.15.53.png" alt="屏幕快照 2017-03-09 上午9.15.53">   &lt;/center&gt;</p><h3 id="2-2-代码"><a href="#2-2-代码" class="headerlink" title="2.2 代码"></a>2.2 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> temp, min = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; arr.length - <span class="number">1</span>; ++index) &#123;</div><div class="line">            min = index;</div><div class="line">            <span class="comment">// 循环查找最小值</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = index + <span class="number">1</span>; j &lt; arr.length; ++j) &#123;</div><div class="line">                <span class="keyword">if</span> (arr[min] &gt; arr[j]) &#123;</div><div class="line">                    min = j;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (min != index) &#123;</div><div class="line">                temp = arr[index];</div><div class="line">                arr[index] = arr[min];</div><div class="line">                arr[min] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">10</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">60</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</div><div class="line">        Demo.selectionSort(arr);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:arr)&#123;</div><div class="line">            System.out.print(i+<span class="string">","</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-3-时空复杂度"><a href="#2-3-时空复杂度" class="headerlink" title="2.3 时空复杂度"></a>2.3 时空复杂度</h3><p>对具有$n$个数据元素的序列进行排序时，选择排序需要进行$n-1$趟选择。进行第$i$趟选择时，后面已经有$i-1$个数据元素排好序，第$i$趟从剩下的$n-i+1$个数据元素中选择一个关键字最大的数据元素，并将它与第$i$个数据元素交换，这样即可使后面的$i$个数据元素排好序。</p><p>选择排序的关键字比较次数与序列的初始状态无关。对n个数据元素进行排序时，第一趟的比较次数为$n-1$，第$i$趟的比较次数是$n-1$次，第$n-1$趟（最后一趟）的比较次数是1次。因此，总的比较次数为$n(n-1)/2$</p><p>选择排序每一趟都可能移动一次数据元素，其总的移动次数与序列的初始状态有关。当序列已经排好序时，元素的移动次数为0。当每一趟都需要移动数据元素时，总的移动次数为$n-1$</p><p>选择排序的时间复杂度为$O(n^2)$。选择排序不需要辅助的存储单元，其空间复杂度为$O(1)$。选择排序在排序过程中需要在不相邻的数据元素之间进行交换，它是一种不稳定的排序方法。</p><blockquote><p>时间复杂度：$O(n^2)$<br>空间复杂度：$O(1)$<br>稳定性：不稳定</p></blockquote><h2 id="三、插入排序（Insertion-Sort）"><a href="#三、插入排序（Insertion-Sort）" class="headerlink" title="三、插入排序（Insertion Sort）"></a>三、插入排序（Insertion Sort）</h2><h3 id="3-1-思想"><a href="#3-1-思想" class="headerlink" title="3.1 思想"></a>3.1 思想</h3><p>对具有$n$个数据元素的序列进行排序时，插入排序需要进行$n-1$趟插入。进行第$j（1≤j≤n-1）$趟插入时，前面已经有$j$个元素排好序了，第$j$趟将$a_{j+1}$插入到已经排好序的序列中，这样即可使前面的$j+1$个数据排好序。</p><p><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-09%20%E4%B8%8A%E5%8D%8810.42.28.png" alt="屏幕快照 2017-03-09 上午10.42.28">   </p><p>动图展示<br><img src="http://omu7tit09.bkt.clouddn.com/15003831521624.gif" alt=""></p><h3 id="3-2-代码"><a href="#3-2-代码" class="headerlink" title="3.2 代码"></a>3.2 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; ++i)&#123;</div><div class="line">        <span class="keyword">int</span> value = arr[i];</div><div class="line">        <span class="keyword">int</span> position=i;</div><div class="line">        <span class="keyword">while</span> (position&gt;<span class="number">0</span> &amp;&amp; arr[position-<span class="number">1</span>]&gt;value)&#123;</div><div class="line">            arr[position] = arr[position-<span class="number">1</span>];</div><div class="line">            position--;</div><div class="line">        &#125;</div><div class="line">        arr[position] = value;</div><div class="line">    &#125;<span class="comment">//loop i</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">10</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">60</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</div><div class="line">        Demo.insertionSort(arr);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:arr)&#123;</div><div class="line">            System.out.print(i+<span class="string">","</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-3-时空复杂度"><a href="#3-3-时空复杂度" class="headerlink" title="3.3  时空复杂度"></a>3.3  时空复杂度</h3><p>直接插入排序关键字比较次数和数据元素移动次数与数据元素的初始状态有关。在最好的情况下，待排序的序列是已经排好序的，每一趟插入，只需要比较一次就可以确定待插入的数据元素的位置，需要移动两次数据元素。因此总的关键字比较次数为$n-1$,总的数据元素移动次数为$2(n-1)$</p><p>在最坏的情况下，待排序的序列是反序的，每一趟中，待插入的数据元素需要与前面已排序序列的每一个数据元素进行比较，移动次数等于比较次数。因此，总的比较次数和移动次数都是$n(n-1)/2$</p><p>直接插入排序的时间复杂度为$O(n^2)$。直接插入排序需要一个单元的辅助存储单元，空间复杂度为$O(1)$。直接插入排序只在相邻的数据元素之间进行交换，它是一种稳定的排序方法。</p><blockquote><p>最好情况$O(n)$；最坏情况$O(n^2)$；平均时间复杂度为：$O(n^2)$<br>空间复杂度：$O(1)$<br>稳定性：稳定</p></blockquote><h2 id="四、希尔排序（Shell-Sort）"><a href="#四、希尔排序（Shell-Sort）" class="headerlink" title="四、希尔排序（Shell Sort）"></a>四、希尔排序（Shell Sort）</h2><h3 id="4-1-思想"><a href="#4-1-思想" class="headerlink" title="4.1 思想"></a>4.1 思想</h3><p>希尔排序，也称递减增量排序算法，实质是分组插入排序。由 Donald Shell 于1959年提出。希尔排序是非稳定排序算法。</p><p>希尔排序的基本思想是：将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长了，列数更少了）来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身还是使用数组进行排序。</p><p>例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">13 14 94 33 82</div><div class="line">25 59 94 65 23</div><div class="line">45 27 73 25 39</div><div class="line">10</div></pre></td></tr></table></figure><p>然后我们对每列进行排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">10 14 73 25 23</div><div class="line">13 27 94 33 39</div><div class="line">25 59 94 65 82</div><div class="line">45</div></pre></td></tr></table></figure><p>将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ]。这时10已经移至正确位置了，然后再以3为步长进行排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">10 14 73</div><div class="line">25 23 13</div><div class="line">27 94 33</div><div class="line">39 25 59</div><div class="line">94 65 82</div><div class="line">45</div></pre></td></tr></table></figure><p>排序之后变为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">10 14 13</div><div class="line">25 23 33</div><div class="line">27 25 59</div><div class="line">39 65 73</div><div class="line">45 94 82</div><div class="line">94</div></pre></td></tr></table></figure><p>最后以1步长进行排序（此时就是简单的插入排序了）。</p><h3 id="4-2-代码"><a href="#4-2-代码" class="headerlink" title="4.2 代码"></a>4.2 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        <span class="keyword">int</span>[] data = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">10</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">60</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;  </div><div class="line">        shellSort(data);  </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:data) &#123;</div><div class="line">        System.out.println(i);  &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> temp;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> delta = arr.length/<span class="number">2</span>; delta&gt;=<span class="number">1</span>; delta/=<span class="number">2</span>)&#123;                              <span class="comment">//对每个增量进行一次排序</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=delta; i&lt;arr.length; i++)&#123;             </div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j&gt;=delta &amp;&amp; arr[j]&lt;arr[j-delta]; j-=delta)&#123; <span class="comment">//注意每个地方增量和差值都是delta</span></div><div class="line">                    temp = arr[j-delta];</div><div class="line">                    arr[j-delta] = arr[j];</div><div class="line">                    arr[j] = temp;</div><div class="line">                &#125;</div><div class="line">            &#125;<span class="comment">//loop i</span></div><div class="line">        &#125;<span class="comment">//loop delta</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面源码的步长的选择是从n/2开始，每次再减半，直至为0。步长的选择直接决定了希尔排序的复杂度。在维基百科上有对于步长串行的详细介绍。</p><h2 id="五、归并排序（Merge-Sort）"><a href="#五、归并排序（Merge-Sort）" class="headerlink" title="五、归并排序（Merge Sort）"></a>五、归并排序（Merge Sort）</h2><h3 id="5-1-思想"><a href="#5-1-思想" class="headerlink" title="5.1 思想"></a>5.1 思想</h3><p>典型的是二路合并排序，将原始数据集分成两部分(不一定能够均分)，分别对它们进行排序，然后将排序后的子数据集进行合并，这是典型的分治法策略。</p><p><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-09%20%E4%B8%8B%E5%8D%882.12.47.png" alt="屏幕快照 2017-03-09 下午2.12.47"></p><p><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-09%20%E4%B8%8B%E5%8D%882.12.57.png" alt="屏幕快照 2017-03-09 下午2.12.57"></p><p><img src="http://omu7tit09.bkt.clouddn.com/15003836672934.gif" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        <span class="keyword">int</span>[] data = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">10</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">60</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;  </div><div class="line">        mergesort(data); </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:data) &#123;</div><div class="line">        System.out.println(i); </div><div class="line">        &#125; </div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</div><div class="line">        sort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</div><div class="line">        <span class="comment">//当left==right的时，已经不需要再划分了</span></div><div class="line">        <span class="keyword">if</span> (left&lt;right)&#123;</div><div class="line">            <span class="keyword">int</span> middle = (left+right)/<span class="number">2</span>;</div><div class="line">            sort(a, left, middle);          <span class="comment">//左子数组</span></div><div class="line">            sort(a, middle+<span class="number">1</span>, right);       <span class="comment">//右子数组</span></div><div class="line">            merge(a, left, middle, right);    <span class="comment">//合并两个子数组</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 合并两个有序子序列 arr[left, ..., middle] 和 arr[middle+1, ..., right]。temp是辅助数组。</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> middle, <span class="keyword">int</span> right)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[right - left + <span class="number">1</span>];</div><div class="line">        <span class="keyword">int</span> i=left;     </div><div class="line">        <span class="keyword">int</span> j=middle+<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</div><div class="line">        <span class="comment">//将记录由小到大地放进temp数组</span></div><div class="line">        <span class="keyword">while</span> ( i&lt;=middle &amp;&amp; j&lt;=right)&#123;</div><div class="line">            <span class="keyword">if</span> (arr[i] &lt;=arr[j])&#123;</div><div class="line">                temp[k++] = arr[i++];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                temp[k++] = arr[j++];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (i &lt;=middle)&#123;</div><div class="line">            temp[k++] = arr[i++];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> ( j&lt;=right)&#123;</div><div class="line">            temp[k++] = arr[j++];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//把数据复制回原数组</span></div><div class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;k; ++i)&#123;</div><div class="line">            arr[left+i] = temp[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="5-3-时空复杂度"><a href="#5-3-时空复杂度" class="headerlink" title="5.3 时空复杂度"></a>5.3 时空复杂度</h3><p>在归并排序中，进行一趟归并需要的关键字比较次数和数据元素移动次数最多为$n$，需要归并的趟数$log_{2}n$，故归并排序的时间复杂度为$O(nlog_{2}n)$。归并排序需要长度等于序列长度为$n$的辅助存储单元，故归并排序的空间复杂度为$O(n)$。归并排序是稳定的排序算法。</p><blockquote><p>时间复杂度：$O(nlog_{2}n)$<br>空间复杂度：$O(n)$<br>稳定性：稳定</p></blockquote><h2 id="六、快速排序（Quick-Sort）"><a href="#六、快速排序（Quick-Sort）" class="headerlink" title="六、快速排序（Quick Sort）"></a>六、快速排序（Quick Sort）</h2><h3 id="6-1-思想"><a href="#6-1-思想" class="headerlink" title="6.1 思想"></a>6.1 思想</h3><p>快速排序是图灵奖得主C.R.A Hoare于1960年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为<a href="https://www.wikiwand.com/en/Quicksort" target="_blank" rel="noopener">分治法（Divide-and-Conquer Method）</a></p><p>分治法的基本思想是：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题组合为原问题的解。</p><p>利用分治法可将快速排序分为三步：</p><ol><li>从数列中挑出一个元素作为“基准”（pivot）。</li><li>分区过程，将比基准数大的放到右边，小于或等于它的数都放到左边。这个操作称为“分区操作”，分区操作结束后，基准元素所处的位置就是最终排序后它的位置</li><li>再对“基准”左右两边的子集不断重复第一步和第二步，直到所有子集只剩下一个元素为止。</li></ol><p><img src="http://omu7tit09.bkt.clouddn.com/15005341612963.gif" alt=""></p><p><img src="http://omu7tit09.bkt.clouddn.com/15003837844027.gif" alt=""></p><h3 id="6-2-代码"><a href="#6-2-代码" class="headerlink" title="6.2 代码"></a>6.2 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        <span class="keyword">int</span>[] data = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">10</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">60</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;  </div><div class="line">        quickSort(data);  </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:data) &#123;</div><div class="line">        System.out.println(i);  &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</div><div class="line">        qsort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (left &lt; right)&#123;</div><div class="line">            <span class="keyword">int</span> pivot=partition(arr, left, right);        <span class="comment">//将数组分为两部分</span></div><div class="line">            qsort(arr, left, pivot-<span class="number">1</span>);                   <span class="comment">//递归排序左子数组</span></div><div class="line">            qsort(arr, pivot+<span class="number">1</span>, right);                  <span class="comment">//递归排序右子数组</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> pivot = arr[left];     <span class="comment">//基准记录</span></div><div class="line">        <span class="keyword">while</span> (left&lt;right)&#123;</div><div class="line">            <span class="keyword">while</span> (left&lt;right &amp;&amp; arr[right]&gt;=pivot) --right;</div><div class="line">            arr[left]=arr[right];             <span class="comment">//交换比基准小的记录到左端</span></div><div class="line">            <span class="keyword">while</span> (left&lt;right &amp;&amp; arr[left]&lt;=pivot) ++left;</div><div class="line">            arr[right] = arr[left];           <span class="comment">//交换比基准大的记录到右端</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//扫描完成，基准到位</span></div><div class="line">        arr[left] = pivot;</div><div class="line">        <span class="comment">//返回的是基准的位置</span></div><div class="line">        <span class="keyword">return</span> left;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="6-3-时空复杂度"><a href="#6-3-时空复杂度" class="headerlink" title="6.3 时空复杂度"></a>6.3 时空复杂度</h3><blockquote><p>时间复杂度：最好$O(nlog_2n)$；平均$O(nlog_2n)$，最坏：$O(n^2)$<br>空间复杂度：$O(log_2n)$<br>稳定性：不稳定</p></blockquote><h2 id="七、堆排序（Heap-Sort）"><a href="#七、堆排序（Heap-Sort）" class="headerlink" title="七、堆排序（Heap Sort）"></a>七、堆排序（Heap Sort）</h2><h3 id="7-1-思想"><a href="#7-1-思想" class="headerlink" title="7.1 思想"></a>7.1 思想</h3><p>先上一张堆排序动画演示图：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15005394097386.gif" alt=""></p><p>堆排序在 top K 问题中使用比较频繁。堆排序是采用二叉堆的数据结构来实现的，虽然实质上还是一维数组。堆（二叉堆）可以视为一棵完全的二叉树，完全二叉树的一个“优秀”的性质是，除了最底层之外，每一层都是满的，这使得堆可以利用数组来表示（普通的一般的二叉树通常用链表作为基本容器表示），每一个结点对应数组中的一个元素。</p><p>如下图，是一个堆和数组的相互关系<br><img src="http://omu7tit09.bkt.clouddn.com/15005394683277.png" alt=""></p><p>对于给定的某个结点的下标 i，可以很容易的计算出这个结点的父结点、孩子结点的下标：</p><ul><li>Parent(i) = floor(i/2)，i 的父节点下标</li><li>Left(i) = 2i，i 的左子节点下标</li><li>Right(i) = 2i + 1，i 的右子节点下标<br><img src="http://omu7tit09.bkt.clouddn.com/15005395760507.png" alt=""></li></ul><p>二叉堆具有以下性质：</p><ol><li>父节点的键值总是大于或等于（小于或等于）任何一个子节点的键值。</li><li>每个节点的左右子树都是一个二叉堆（都是最大堆或最小堆）。</li></ol><p>二叉堆一般分为两种：最大堆和最小堆。</p><p>最大堆的定义如下：</p><ul><li>最大堆中的最大元素值出现在根结点（堆顶）</li><li>堆中每个父节点的元素值都大于等于其孩子结点（如果存在）<br><img src="http://omu7tit09.bkt.clouddn.com/15005396877226.png" alt=""></li></ul><p>最小堆的定义如下：</p><ul><li>最小堆中的最小元素值出现在根结点（堆顶）</li><li>堆中每个父节点的元素值都小于等于其孩子结点（如果存在）<br><img src="http://omu7tit09.bkt.clouddn.com/15005397248301.png" alt=""></li></ul><p>【提问】<br>堆是怎么调整的，介绍大顶堆和小顶堆；</p><p>堆排序的原理如下：</p><p>步骤：</p><ol><li>构造最大堆（Build_Max_Heap）：若数组下标范围为0~n，考虑到单独一个元素是大根堆，则从下标n/2开始的元素均为大根堆。于是只要从n/2-1开始，向前依次构造大根堆，这样就能保证，构造到某个节点时，它的左右子树都已经是大根堆。</li><li>堆排序（HeapSort）：由于堆是用数组模拟的。得到一个大根堆后，数组内部并不是有序的。因此需要将堆化数组有序化。思想是移除根节点，并做最大堆调整的递归运算。第一次将heap[0]与heap[n-1]交换，再对heap[0…n-2]做最大堆调整。第二次将heap[0]与heap[n-2]交换，再对heap[0…n-3]做最大堆调整。重复该操作直至heap[0]和heap[1]交换。由于每次都是将最大的数并入到后面的有序区间，故操作完后整个数组就是有序的了。</li><li>最大堆调整（Max_Heapify）：该方法是提供给上述两个过程调用的。目的是将堆的末端子节点作调整，使得子节点永远小于父节点 。</li></ol><p><img src="http://omu7tit09.bkt.clouddn.com/15003839778043.gif" alt=""></p><h3 id="7-2-代码"><a href="#7-2-代码" class="headerlink" title="7.2 代码"></a>7.2 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        <span class="keyword">int</span>[] arr = &#123; <span class="number">50</span>, <span class="number">10</span>, <span class="number">90</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">60</span>, <span class="number">20</span> &#125;;  </div><div class="line">  </div><div class="line">        <span class="comment">// 堆排序  </span></div><div class="line">        heapSort(arr);  </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;  </div><div class="line">            System.out.print(arr[i] + <span class="string">" "</span>);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 堆排序 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;   </div><div class="line">        <span class="comment">// 将待排序的序列构建成一个大顶堆  </span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;   </div><div class="line">            heapAdjust(arr, i, arr.length);   </div><div class="line">        &#125;            </div><div class="line">        <span class="comment">// 逐步将每个最大值的根节点与末尾元素交换，并且再调整二叉树，使其成为大顶堆  </span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;   </div><div class="line">            swap(arr, <span class="number">0</span>, i); <span class="comment">// 将堆顶记录和当前未经排序子序列的最后一个记录交换  </span></div><div class="line">            heapAdjust(arr, <span class="number">0</span>, i); <span class="comment">// 交换之后，需要重新检查堆是否符合大顶堆，不符合则要调整  </span></div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 构建堆的过程 </div><div class="line">     * <span class="doctag">@param</span> arr 需要排序的数组 </div><div class="line">     * <span class="doctag">@param</span> i 需要构建堆的根节点的序号 </div><div class="line">     * <span class="doctag">@param</span> n 数组的长度 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapAdjust</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;  </div><div class="line">        <span class="keyword">int</span> child;  </div><div class="line">        <span class="keyword">int</span> father;   </div><div class="line">        <span class="keyword">for</span> (father = arr[i]; leftChild(i) &lt; n; i = child) &#123;  </div><div class="line">            child = leftChild(i);  </div><div class="line">              </div><div class="line">            <span class="comment">// 如果左子树小于右子树，则需要比较右子树和父节点  </span></div><div class="line">            <span class="keyword">if</span> (child != n - <span class="number">1</span> &amp;&amp; arr[child] &lt; arr[child + <span class="number">1</span>]) &#123;  </div><div class="line">                child++; <span class="comment">// 序号增1，指向右子树  </span></div><div class="line">            &#125;  </div><div class="line">              </div><div class="line">            <span class="comment">// 如果父节点小于孩子结点，则需要交换  </span></div><div class="line">            <span class="keyword">if</span> (father &lt; arr[child]) &#123;  </div><div class="line">                arr[i] = arr[child];  </div><div class="line">            &#125; <span class="keyword">else</span> &#123;  </div><div class="line">                <span class="keyword">break</span>; <span class="comment">// 大顶堆结构未被破坏，不需要调整  </span></div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        arr[i] = father;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">// 获取到左孩子结点  </span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">leftChild</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="comment">// 交换元素位置  </span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;  </div><div class="line">        <span class="keyword">int</span> tmp = arr[index1];  </div><div class="line">        arr[index1] = arr[index2];  </div><div class="line">        arr[index2] = tmp;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="7-3-时空复杂度"><a href="#7-3-时空复杂度" class="headerlink" title="7.3 时空复杂度"></a>7.3 时空复杂度</h3><p>堆排序在建立堆和调整堆的过程中会产生比较大的开销，在元素少的时候并不适用。但是，在元素比较多的情况下，还是不错的一个选择。尤其是在解决诸如“前n大的数”一类问题时，几乎是首选算法。</p><h2 id="八、桶排序"><a href="#八、桶排序" class="headerlink" title="八、桶排序"></a>八、桶排序</h2><p>桶排序 (Bucket sort)或所谓的箱排序的原理是将数组分到有限数量的桶子里，然后对每个桶子再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后将各个桶中的数据有序的合并起来。</p><p>排序过程：</p><ol><li>假设待排序的一组数统一的分布在一个范围中，并将这一范围划分成几个子范围，也就是桶</li><li>将待排序的一组数，分档规入这些子桶，并将桶中的数据进行排序</li><li>将各个桶中的数据有序的合并起来</li></ol><p>设有数组 array = [29, 25, 3, 49, 9, 37, 21, 43]，那么数组中最大数为 49，先设置 5 个桶，那么每个桶可存放数的范围为：0~9、10~19、20~29、30~39、40~49，然后分别将这些数放人自己所属的桶，如下图：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15005389746937.png" alt=""><br>然后，分别对每个桶里面的数进行排序，或者在将数放入桶的同时用插入排序进行排序。最后，将各个桶中的数据有序的合并起来，如下图：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15005389874146.png" alt=""></p><p><a href="http://www.cs.usfca.edu/~galles/visualization/BucketSort.html" target="_blank" rel="noopener">Data Structure Visualizations</a> 提供了一个桶排序的分步动画演示。</p><h2 id="九、各种排序方法的时空复杂度"><a href="#九、各种排序方法的时空复杂度" class="headerlink" title="九、各种排序方法的时空复杂度"></a>九、各种排序方法的时空复杂度</h2><p> <img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-10%20%E4%B8%8B%E5%8D%8812.50.56.png" alt="屏幕快照 2017-03-10 下午12.50.56">   </p><h3 id="9-1-时间复杂度"><a href="#9-1-时间复杂度" class="headerlink" title="9.1 时间复杂度"></a>9.1 时间复杂度</h3><blockquote><p>＂快些以$O(nlog_2n)$的速度归队＂</p></blockquote><p>即快，希，归，堆都是$O(nlog_2n)$，其他都是$O(n^2)$，基数排序例外，是$O(d(n+rd))$</p><h3 id="9-2-空间复杂度"><a href="#9-2-空间复杂度" class="headerlink" title="9.2 空间复杂度"></a>9.2 空间复杂度</h3><ul><li>快排$O(log_2n)$</li><li>归并$O(n)$</li><li>基数$O(r_d)$</li><li>其他$O(1)$</li></ul><h3 id="9-3-稳定性"><a href="#9-3-稳定性" class="headerlink" title="9.3 稳定性"></a>9.3 稳定性</h3><blockquote><p>＂心情不稳定，快些找一堆朋友聊天吧＂</p></blockquote><p>即不稳定的有：快，希，堆</p><h3 id="9-4-其他性质"><a href="#9-4-其他性质" class="headerlink" title="9.4 其他性质"></a>9.4 其他性质</h3><ul><li>直接插入排序，初始基本有序情况下，是$O(n)$</li><li>冒泡排序，初始基本有序情况下，是$O(n)$</li><li>快排在初始状态越差的情况下算法效果越好．</li><li>堆排序适合记录数量比较大的时候，从n个记录中选择k个记录．</li><li>经过一趟排序，元素可以在它最终的位置的有：交换类的（冒泡，快排），选择类的（简单选择，堆）</li><li>比较次数与初始序列无关的是：简单选择与折半插入</li><li>排序趟数与原始序列有关的是：交换类的（冒泡和快排）</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>维基百科：希尔排序，快速排序，归并排序，堆排序<br><a href="http://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html" target="_blank" rel="noopener">排序算法可视化</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经典排序算法在面试中占有很大的比重，也是基础，在这里整理并用Java实现了几大经典排序算法，包括冒泡排序、插入排序、选择排序、希尔排序、归并排序、快速排序、堆排序、同排序。我们默认将一个无序数列排序成由小到大。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法（11）：哈希表</title>
    <link href="http://yoursite.com/2017/07/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8811%EF%BC%89%EF%BC%9A%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <id>http://yoursite.com/2017/07/25/数据结构与算法（11）：哈希表/</id>
    <published>2017-07-25T14:20:45.000Z</published>
    <updated>2017-09-01T07:09:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、哈希表的基本概念"><a href="#一、哈希表的基本概念" class="headerlink" title="一、哈希表的基本概念"></a>一、哈希表的基本概念</h2><p>哈希表（Hash Table）是一种特殊的数据结构，它最大的特点就是可以快速实现查找、插入和删除。因为它独有的特点，Hash表经常被用来解决大数据问题，也因此被广大的程序员所青睐。</p><a id="more"></a><p>我们知道，数组的最大特点就是：寻址容易，插入和删除困难；而链表正好相反，寻址困难，而插入和删除操作容易。那么如果能够结合两者的优点，做出一种寻址、插入和删除操作同样快速容易的数据结构，那该有多好。这就是哈希表创建的基本思想，而实际上哈希表也实现了这样的一个“夙愿”，哈希表就是这样一个集查找、插入和删除操作于一身的数据结构。</p><p>哈希表（Hash Table）：也叫散列表，是根据关键码值（key-value）而直接进行访问的数据结构，也就是我们常用到的map。</p><p>哈希函数：也称为是散列函数，是Hash表的映射函数，它可以把任意长度的输入变换成固定长度的输出，该输出就是哈希值。哈希函数能使对一个数据序列的访问过程变得更加迅速有效，通过哈希函数，数据元素能够被很快的进行定位。</p><p>哈希表和哈希函数的标准定义：若关键字为k，则其值存放在h(k)的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系f为哈希函数，按这个思想建立的表为哈希表。</p><p>设所有可能出现的关键字集合记为U(简称全集)。实际发生(即实际存储)的关键字集合记为K（|K|比|U|小得多）。</p><p>散列方法是使用函数h将U映射到表T[0..m-1]的下标上（m=O(|U|)）。这样以U中关键字为自变量，以h为函数的运算结果就是相应结点的存储地址。从而达到在O(1)时间内就可完成查找。<br>其中：</p><ol><li>h：U→{0，1，2，…，m-1} ，通常称h为哈希函数(Hash Function)。哈希函数h的作用是压缩待处理的下标范围，使待处理的|U|个值减少到m个值，从而降低空间开销。</li><li>T为哈希表(Hash Table)。</li><li>$h(K_i)(K_i∈U)$是关键字为Ki结点存储地址(亦称散列值或散列地址)。</li><li>将结点按其关键字的哈希地址存储到哈希表中的过程称为散列(Hashing)</li></ol><p>设计出一个简单、均匀、存储利用率高的散列函数是散列技术中最关键的问题。<br>但是，一般散列函数都面临着冲突的问题。两个不同的关键字，由于散列函数值相同，因而被映射到同一表位置上。该现象称为冲突(Collision)或碰撞。发生冲突的两个关键字称为该散列函数的同义词(Synonym)。</p><p>最理想的解决冲突的方法是安全避免冲突。要做到这一点必须满足两个条件：其一是$|U|≤m$，其二是选择合适的散列函数。这只适用于|U|较小，且关键字均事先已知的情况，此时经过精心设计散列函数h有可能完全避免冲突。</p><p>但通常情况下，h是一个压缩映像。虽然$|K|≤m$，但$|U|&gt;m$，故无论怎样设计h，也不可能完全避免冲突。因此，只能在设计h时尽可能使冲突最少。同时还需要确定解决冲突的方法，使发生冲突的同义词能够存储到表中。</p><p>冲突的频繁程度除了与h相关外，还与表的填满程度相关。设m和n分别表示表长和表中填入的结点数，则将α=n/m定义为散列表的装填因子(Load Factor)。α越大，表越满，冲突的机会也越大。通常取α≤1。 </p><h2 id="二、哈希表的实现方法"><a href="#二、哈希表的实现方法" class="headerlink" title="二、哈希表的实现方法"></a>二、哈希表的实现方法</h2><p>我们之前说了，哈希表是一个集查找、插入和删除操作于一身的数据结构。那这么完美的数据结构到底是怎么实现的呢？哈希表有很多种不同的实现方法，为了实现哈希表的创建，这些所有的方法都离不开两个问题——“定址”和“解决冲突”。</p><p>在这里，我们通过详细地介绍哈希表最常用的方法——取余法（定值）+拉链法（解决冲突），来一起窥探一下哈希表强大的优点。</p><p>取余法大家一定不会感觉陌生，就是我们经常说的取余数的操作。</p><p>拉链法是什么，“拉链”说白了就是“链表数组”。我这么一解释，大家更晕了，啥是“链表数组”啊？为了更好地解释“链表数组”，我们用下图进行解释：图中的主干部分是一个顺序存储结构数组，但是有的数组元素为空，有的对应一个值，有的对应的是一个链表，这就是“链表数组”。比如数组0的位置对应一个链表，链表有两个元素“496”和“896”，这说明元素“496”和“896”有着同样的Hash地址，这就是我们上边介绍的“冲突”或者“碰撞”。但是“链表数组”的存储方式很好地解决了Hash表中的冲突问题，发生冲突的元素会被存在一个对应Hash地址指向的链表中。实际上，“链表数组”就是一个指针数组，每一个指针指向一个链表的头结点，链表可能为空，也可能不为空。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15005228099157.png" alt=""></p><p>说完这些，大家肯定已经理解了“链表数组”的概念，那我们就一起看看Hash表是如何根据“取余法+拉链法”构建的吧。</p><p>将所有关键字为同义词的结点链接在同一个链表中。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数组$T[0..m-1]$。凡是散列地址为i的结点，均插入到以$T[i]$为头指针的单链表中。T中各分量的初值均应为空指针。在拉链法中，装填因子$α$可以大于1，但一般均取$α≤1$。</p><p>举例说明拉链法的执行过程，设有一组关键字为(26，36，41，38，44，15，68，12，6，51)，用取余法构造散列函数，初始情况如下图所示：<br><img src="http://omu7tit09.bkt.clouddn.com/15005228566431.png" alt=""><br>最终结果如下图所示：<br><img src="http://omu7tit09.bkt.clouddn.com/15005228676672.png" alt=""><br>理解了Hash表的创建，那根据建立的Hash表进行查找就很容易被理解了。</p><p>查找操作，如果理解了插入和删除，查找操作就比较简单了，令待查找的关键字是x，也可分为几种情况：</p><ul><li>1）x所属的Hash地址未被占用，即不存在与x相同的Hash地址关键字，当然也不存在x了；</li><li>2）x所属的Hash地址被占用了，但它所存的关键不属于这个Hash地址，与1）相同，不存在与x相同Hash地址的关键字；</li><li>3）x所属的Hash地址被占用了，且它所存的关键属于这个Hash地址，即存在与x相同sHash地址的关键字，只是不知这个关键字是不是x，需要进一步查找。</li></ul><p>由此可见，Hash表插入、删除和插入操作的效率都相当的高。</p><p>思考一个问题：如果关键字是字符串怎么办？我们怎么根据字符串建立Hash表？</p><p>通常都是将元素的key转换为数字进行散列，如果key本身就是整数，那么散列函数可以采用keymod tablesize（要保证tablesize是质数）。而在实际工作中经常用字符串作为关键字，例如身姓名、职位等等。这个时候需要设计一个好的散列函数进程处理关键字为字符串的元素。参考《数据结构与算法分析》第5章，有以下几种处理方法：</p><ul><li>方法1：将字符串的所有的字符的ASCII码值进行相加，将所得和作为元素的关键字。此方法的缺点是不能有效的分布元素，例如假设关键字是有8个字母构成的字符串，散列表的长度为10007。字母最大的ASCII码为127，按照方法1可得到关键字对应的最大数值为127×8=1016，也就是说通过散列函数映射时只能映射到散列表的槽0-1016之间，这样导致大部分槽没有用到，分布不均匀，从而效率低下。</li><li>方法2：假设关键字至少有三个字母构成，散列函数只是取前三个字母进行散列。该方法只是取字符串的前三个字符的ASCII码进行散列，最大的得到的数值是2851，如果散列的长度为10007，那么只有28%的空间被用到，大部分空间没有用到。因此如果散列表太大，就不太适用。</li><li>方法3：借助Horner’s 规则，构造一个质数（通常是37）的多项式，（非常的巧妙，不知道为何是37）。计算公式为:$key[keysize-i-1]*37^i, 0≤i&lt;keysize$求和。该方法存在的问题是如果字符串关键字比较长，散列函数的计算过程就变长，有可能导致计算的hashVal溢出。针对这种情况可以采取字符串的部分字符进行计算，例如计算偶数或者奇数位的字符。</li></ul><h2 id="三、哈希表定址与解决冲突"><a href="#三、哈希表定址与解决冲突" class="headerlink" title="三、哈希表定址与解决冲突"></a>三、哈希表定址与解决冲突</h2><h3 id="3-1-哈希表“定址的方法”"><a href="#3-1-哈希表“定址的方法”" class="headerlink" title="3.1 哈希表“定址的方法”"></a>3.1 哈希表“定址的方法”</h3><p>其实常用的“定址”的手法有“五种”：</p><ol><li>直接定址法：很容易理解，key=Value+C；这个“C”是常量。Value+C其实就是一个简单的哈希函数。</li><li>除法取余法：key=value%C</li><li>数字分析法：这种蛮有意思，比如有一组value1=112233，value2=112633，value3=119033，针对这样的数我们分析数中间两个数比较波动，其他数不变。那么我们取key的值就可以是key1=22,key2=26,key3=90。</li><li>平方取中法</li><li>折叠法：举个例子，比如value=135790，要求key是2位数的散列值。那么我们将value变为13+57+90=160，然后去掉高位“1”,此时key=60，哈哈，这就是他们的哈希关系，这样做的目的就是key与每一位value都相关，来做到“散列地址”尽可能分散的目地。</li></ol><p>影响哈希查找效率的一个重要因素是哈希函数本身。当两个不同的数据元素的哈希值相同时，就会发生冲突。为减少发生冲突的可能性，哈希函数应该将数据尽可能分散地映射到哈希表的每一个表项中。</p><h3 id="3-2-哈希表“解决冲突”的方法"><a href="#3-2-哈希表“解决冲突”的方法" class="headerlink" title="3.2 哈希表“解决冲突”的方法"></a>3.2 哈希表“解决冲突”的方法</h3><p>Hash表解决冲突的方法主要有以下几种：</p><p>链接地址法：<br>将哈希值相同的数据元素存放在一个链表中，在查找哈希表的过程中，当查找到这个链表时，必须采用线性查找方法。</p><p>开放定址法：<br>如果两个数据元素的哈希值相同，则在哈希表中为后插入的数据元素另外选择一个表项。当程序查找哈希表时，如果没有在第一个对应的哈希表项中找到符合查找要求的数据元素，程序就会继续往后查找，直到找到一个符合查找要求的数据元素，或者遇到一个空的表项。线性探测带来的最大问题就是冲突的堆积，你把别人预定的坑占了，别人也就要像你一样去找坑。改进的办法有二次方探测法和随机数探测法。开放地址法包括线性探测、二次探测以及双重散列等方法。其中线性探测法示意图如下：<br><img src="http://omu7tit09.bkt.clouddn.com/15005233364103.png" alt="">散列过程如下图所示：<img src="http://omu7tit09.bkt.clouddn.com/15005233651325.png" alt=""></p><p>再散列函数法：<br>发生冲突时就换一个散列函数计算，总会有一个可以把冲突解决掉，它能够使得关键字不产生聚集，但相应地增加了计算的时间。</p><p>公共溢出区法：<br>其实就是为所有的冲突，额外开辟一块存储空间。如果相对基本表而言，冲突的数据很少的时候，使用这种方法比较合适。</p><h3 id="3-3-哈希表“定址”和“解决冲突”之间的权衡"><a href="#3-3-哈希表“定址”和“解决冲突”之间的权衡" class="headerlink" title="3.3 哈希表“定址”和“解决冲突”之间的权衡"></a>3.3 哈希表“定址”和“解决冲突”之间的权衡</h3><p>虽然哈希表是在关键字和存储位置之间建立了对应关系，但是由于冲突的发生，哈希表的查找仍然是一个和关键字比较的过程，不过哈希表平均查找长度比顺序查找要小得多，比二分查找也小。</p><p>查找过程中需和给定值进行比较的关键字个数取决于下列三个因素：哈希函数、处理冲突的方法和哈希表的装填因子。</p><p>哈希函数的”好坏”首先影响出现冲突的频繁程度，但如果哈希函数是均匀的，则一般不考虑它对平均查找长度的影响。</p><p>对同一组关键字，设定相同的哈希函数，但使用不同的冲突处理方法，会得到不同的哈希表，它们的平均查找长度也不同。</p><p>一般情况下，处理冲突方法相同的哈希表，其平均查找长度依赖于哈希表的装填因子α。显然，α越小，产生冲突的机会就越大；但α过小，空间的浪费就过多。通过选择一个合适的装填因子α，可以将平均查找长度限定在一个范围内。</p><p>总而言之，哈希表“定址”和“解决冲突”之间的权衡决定了哈希表的性能。</p><h2 id="四、实现Hashmap"><a href="#四、实现Hashmap" class="headerlink" title="四、实现Hashmap"></a>四、实现Hashmap</h2><p>假设我们要设计的是一个用来保存某大学所有在校学生个人信息的数据表。因为在校学生数量也不是特别巨大(8W?)，每个学生的学号是唯一的,因此，我们可以简单的应用直接定址法，声明一个10W大小的数组，每个学生的学号作为主键。然后每次要添加或者查找学生，只需要根据需要去操作即可。</p><p>但是，显然这样做是很脑残的。这样做系统的可拓展性和复用性就非常差了，比如有一天人数超过10W了？如果是用来保存别的数据呢？或者我只需要保存20条记录呢？声明大小为10W的数组显然是太浪费了的。</p><p>如果我们是用来保存大数据量（比如银行的用户数，4大的用户数都应该有3-5亿了吧？），这时候我们计算出来的HashCode就很可能会有冲突了， 我们的系统应该有“处理冲突”的能力，此处我们通过挂链法“处理冲突”。</p><p>如果我们的数据量非常巨大，并且还持续在增加，如果我们仅仅只是通过挂链法来处理冲突，可能我们的链上挂了上万个数据后，这个时候再通过静态搜索来查找链表，显然性能也是非常低的。所以我们的系统应该还能实现自动扩容，当容量达到某比例后，即自动扩容，使装载因子保存在一个固定的水平上。</p><p>综上所述，我们对这个Hash容器的基本要求应该有如下几点：</p><ul><li>满足Hash表的查找要求</li><li>能支持从小数据量到大数据量的自动转变（自动扩容）</li><li>使用挂链法解决冲突</li></ul><p>代码详见hashmap源码剖析</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、哈希表的基本概念&quot;&gt;&lt;a href=&quot;#一、哈希表的基本概念&quot; class=&quot;headerlink&quot; title=&quot;一、哈希表的基本概念&quot;&gt;&lt;/a&gt;一、哈希表的基本概念&lt;/h2&gt;&lt;p&gt;哈希表（Hash Table）是一种特殊的数据结构，它最大的特点就是可以快速实现查找、插入和删除。因为它独有的特点，Hash表经常被用来解决大数据问题，也因此被广大的程序员所青睐。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法（10）：查找</title>
    <link href="http://yoursite.com/2017/07/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8810%EF%BC%89%EF%BC%9A%E6%9F%A5%E6%89%BE/"/>
    <id>http://yoursite.com/2017/07/24/数据结构与算法（10）：查找/</id>
    <published>2017-07-24T15:14:45.000Z</published>
    <updated>2017-12-26T06:35:12.066Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>查找（Search）就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。在计算机应用中，查找是常用的基本运算，例如编译程序中符号表的查找。先说明几个概念：</p><a id="more"></a><p>查找表（Search Table）：由同一类型的数据元素（或记录）构成的集合<br>关键字（Key）：数据元素中某个数据项的值，又称为键值。<br>主键（Primary Key）：可唯一地标识某个数据元素或记录的关键字。</p><p>平均查找长度（Average Search Length，ASL）：需和指定key进行比较的关键字的个数的期望值，称为查找算法在查找成功时的平均查找长度。</p><p>对于含有n个数据元素的查找表，查找成功的平均查找长度为：$ASL = P_i*C_i$的和。</p><ul><li>$P_i$：查找表中第i个数据元素的概率。</li><li>$C_i$：找到第i个数据元素时已经比较过的次数。</li></ul><p>查找表按照操作方式可分为：</p><ol><li>静态查找表（Static Search Table）:只做查找操作的查找表。它的主要操作是：</li></ol><ul><li>查询某个“特定的”数据元素是否在表中</li><li>检索某个“特定的”数据元素和各种属性</li></ul><ol><li>动态查找表（Dynamic Search Table）：在查找的同时进行插入或删除等操作：</li></ol><ul><li>查找时插入数据</li><li>查找时删除数据</li></ul><p>按照查找表是否有序分为无序查找和有序查找：</p><ul><li>无序查找：被查找数列有序无序均可；</li><li>有序查找：被查找数列必须为有序数列。</li></ul><h2 id="二、无序表查找"><a href="#二、无序表查找" class="headerlink" title="二、无序表查找"></a>二、无序表查找</h2><p><strong>说明：</strong>顺序查找适合于存储结构为顺序存储或链接存储的线性表。</p><p><strong>基本思想：</strong>顺序查找也称为线形查找，属于无序查找算法。从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。</p><p><strong>算法分析：</strong>最好情况是在第一个位置就找到了，此为O(1)；最坏情况是在最后一个位置才找到，此为O(n)；所以平均查找次数为$(n+1)/2$，最终时间复杂度为$O(n)$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 最基础的遍历无序列表的查找算法</span></div><div class="line"><span class="comment"># 时间复杂度O(n)</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sequential_search</span><span class="params">(lis, key)</span>:</span></div><div class="line">    length = len(lis)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">        <span class="keyword">if</span> lis[i] == key:</div><div class="line">            <span class="keyword">return</span> i</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    LIST = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">123</span>, <span class="number">22</span>, <span class="number">54</span>, <span class="number">7</span>, <span class="number">99</span>, <span class="number">300</span>, <span class="number">222</span>]</div><div class="line">    result = sequential_search(LIST, <span class="number">123</span>)</div><div class="line">    print(result)</div></pre></td></tr></table></figure><h2 id="三、有序表查找"><a href="#三、有序表查找" class="headerlink" title="三、有序表查找"></a>三、有序表查找</h2><p>查找表中的数据必须按照某个主键进行某种排序！</p><h3 id="3-1-二分查找"><a href="#3-1-二分查找" class="headerlink" title="3.1 二分查找"></a>3.1 二分查找</h3><p><strong>说明：</strong>元素必须是有序的，如果是无序的则要先进行排序操作。<br><strong>基本思想：</strong>也称为折半查找，属于有序查找算法。用给定值k先与中间结点的关键字比较，中间结点把线性表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间节点关键字的比较结果确定下一步查找哪个字表，这样递归进行，知道查找到或查找结束发现表中没有这样的结点。</p><p><strong>复杂度分析：</strong>最坏情况下,关键字比较次数为$log_2(n+1)$，且期望时间复杂度为$O(log_2n)$</p><p><strong>注意：</strong>折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再发生变化，折半查找能得到不错的效率。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 针对有序查找表的二分查找算法</span></div><div class="line"><span class="comment"># 时间复杂度O(log(n))</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(list, key)</span>:</span></div><div class="line">    low = <span class="number">0</span></div><div class="line">    high = len(list) - <span class="number">1</span></div><div class="line">    time = <span class="number">0</span></div><div class="line">    <span class="keyword">while</span> low &lt;= high:</div><div class="line">        time += <span class="number">1</span></div><div class="line">        mid = int((low + high) / <span class="number">2</span>)</div><div class="line">        <span class="keyword">if</span> key &lt; list[mid]:</div><div class="line">            high = mid - <span class="number">1</span></div><div class="line">        <span class="keyword">elif</span> key &gt; list[mid]:</div><div class="line">            low = mid + <span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="comment"># 打印折半的次数</span></div><div class="line">            print(<span class="string">"times: %s"</span> % time)</div><div class="line">            <span class="keyword">return</span> mid</div><div class="line">    print(<span class="string">"times: %s"</span> % time)</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    LIST = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">22</span>, <span class="number">54</span>, <span class="number">99</span>, <span class="number">123</span>, <span class="number">200</span>, <span class="number">222</span>, <span class="number">444</span>]</div><div class="line">    result = binary_search(LIST, <span class="number">99</span>)</div><div class="line">    print(result)</div></pre></td></tr></table></figure><h3 id="3-2-插值查找"><a href="#3-2-插值查找" class="headerlink" title="3.2 插值查找"></a>3.2 插值查找</h3><p>在介绍插值查找之前，首先考虑一个新问题，为什么上述算法一定要是折半，而不是折四分之一或者折更多呢？</p><p>打个比方，在英文字典里面查“apple”，你下意识翻开字典是翻前面的书页还是后面的书页呢？如果再让你查“zoo”，你又怎么查？很显然，这里绝对不会是从中农间开始查起，而是有一定目的的往前或往后翻。</p><p>同样的，比如要在取值范围1~10000之间100个元素从小到大均匀分布的数组中查找5，我们自然会从数组下标较小的开始查找。</p><p>经过上面的分析，折半查找这种查找方式，不是自适应的（也就是说是傻瓜式的）。二分查找中查找点计算如下：</p><script type="math/tex; mode=display">mid=(low+high)/2</script><p>即</p><script type="math/tex; mode=display">mid=low+(high-low)/2</script><p>通过类比，我们可以将查找的点改进为如下：</p><script type="math/tex; mode=display">mid=low+\frac{key -list[low]}{list[high]-list [low]}\times (high-low)</script><p>也就是将上述的比例参数1/2改进为自适应的，根据关键字在整个有序表中所处的位置，让mid值的变化更靠近关键字key，这样也就间接地减少了比较次数。</p><p><strong>基本思想：</strong>基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，插值查找也属于有序查找。</p><p><strong>注意：</strong>对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。</p><p><strong>复杂度分析：</strong>查找成功或者失败的时间复杂度均为$O(log2(log2n))$。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 插值查找算法</span></div><div class="line"><span class="comment"># 时间复杂度O(log(n))</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(lis, key)</span>:</span></div><div class="line">    low = <span class="number">0</span></div><div class="line">    high = len(lis) - <span class="number">1</span></div><div class="line">    time = <span class="number">0</span></div><div class="line">    <span class="keyword">while</span> low &lt;= high:</div><div class="line">        time += <span class="number">1</span></div><div class="line">        <span class="comment"># 计算mid值是插值算法的核心代码</span></div><div class="line">        mid = low + int((high - low) * (key - lis[low])/(lis[high] - lis[low]))</div><div class="line">        print(<span class="string">"mid=%s, low=%s, high=%s"</span> % (mid, low, high))</div><div class="line">        <span class="keyword">if</span> key &lt; lis[mid]:</div><div class="line">            high = mid - <span class="number">1</span></div><div class="line">        <span class="keyword">elif</span> key &gt; lis[mid]:</div><div class="line">            low = mid + <span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="comment"># 打印查找的次数</span></div><div class="line">            print(<span class="string">"times: %s"</span> % time)</div><div class="line">            <span class="keyword">return</span> mid</div><div class="line">    print(<span class="string">"times: %s"</span> % time)</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    LIST = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">22</span>, <span class="number">54</span>, <span class="number">99</span>, <span class="number">123</span>, <span class="number">200</span>, <span class="number">222</span>, <span class="number">444</span>]</div><div class="line">    result = binary_search(LIST, <span class="number">444</span>)</div><div class="line">    print(result)</div></pre></td></tr></table></figure><h3 id="3-3-斐波那契查找"><a href="#3-3-斐波那契查找" class="headerlink" title="3.3 斐波那契查找"></a>3.3 斐波那契查找</h3><p>在介绍斐波那契查找算法之前，我们先介绍一下和它很紧密相连并且大家都熟知的一个概念——黄金分割。</p><p>黄金比例又称为黄金分割，是指事物各部分间一定的数学比例关系，即将整体一分为二，较大部分与较小部分之比等于整体与较大部分之比，其比值约为1：0.618。</p><p>0.618倍公认为是最具有审美意义的比例数字，这个数值的作用不仅仅体现在诸如绘画、雕塑、音乐、建筑等艺术领域，而且在管理、工程设计等方面有着不可忽视的作用。因此被称为黄金分割。</p><p>大家记不记得斐波那契数列：1，1，2，3，5，8，13，21，34，55，89……（从第三个数开始，后面每一个数都是前两个数的和）。然后我们会发现，随着斐波那契数列的递增，前后两个数的比值会越来越接近0.618，利用这个特性，我们就可以将黄金比例运用到查找技术中。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15003947614841.jpg" alt=""></p><p><strong>基本思想：</strong>也是二分查找的一种提升算法，通过运用黄金比例的概念在数列中选择查找点进行查找，提高查找效率。同样地，斐波那契查找也属于一种有序查找算法。</p><p>相对于折半查找，一般将待比较的key值与第mid=（low+high）/2位置的元素进行比较，比较结果分为三种情况：</p><ol><li>相等，mid位置的元素即为所求</li><li><blockquote><p>,low=mid+1</p></blockquote></li><li>&lt;,high=mid-1</li></ol><p>斐波那契查找和折半查找很相似，它是根据斐波那契序列的特点对有序表进行分割的。他要求开始表中记录的个数为某个斐波那契小1，即$n=F(k)-1$</p><p>开始将k值与第F(k-1)位置的记录进行比较（即mid=low+F(k-1)-1），比较结果也分为三种</p><ol><li>相等，mid位置的元素即为所求</li><li><blockquote><p>,low=mid+1,k-=2：说明，low=high+1说明待查找的元素在[mid+1,high]范围内，k-=2说明范围[mid,high]内的元素个数为$n-(F(k-1))=Fk-1-F(k-1)=Fk-F(k-1)-1=f(k-2)-1$个，所以可以递归地应用斐波那契查找。</p></blockquote></li><li>&lt;,high=mid-1,k-=1:说明，low=mid+1，说明待查找的元素在[mid+1,high]范围内，k-=1说明范围[low,mid-1]内的元素个数为F(k-1)-1个，所以可以递归的应用斐波那契查找</li></ol><p><strong>复杂度分析：</strong>最坏情况下，时间复杂度为$O(log_2n)$，且其期望复杂度也为$O(log_2n)$。就平均性能，要优于二分查找。但是在最坏情况下，比如这里如果key为1，则始终处于左侧半区查找，此时其效率要低于二分查找。</p><p>总结：二分查找的mid运算是加法与除法，插值查找则是复杂的四则运算，而斐波那契查找只是最简单的加减运算。在海量数据的查找中，这种细微的差别可能会影响最终的查找效率。因此，三种有序表的查找方法本质上是分割点的选择不同，各有优劣，应根据实际情况进行选择。</p><h2 id="四、线性索引查找"><a href="#四、线性索引查找" class="headerlink" title="四、线性索引查找"></a>四、线性索引查找</h2><p>对于海量的无序数据，为了提高查找速度，一般会为其构造索引表。索引就是把一个关键字与他相对应的记录进行关联的过程。</p><p>一个索引由若干个索引项构成，每个索引项至少包含关键字和其对应的记录在存储器中的位置等信息。</p><p>索引按照结构可以分为：线性索引、树形索引和多级索引。<br>线性索引：将索引项的集合通过线性结构来组织，也叫索引表</p><p>线性索引可分为：稠密索引、分块索引和倒排索引。</p><ul><li>稠密索引：</li></ul><p>指的是在线性索引中，为数据集合中的每个记录都建立一个索引项。<img src="http://omu7tit09.bkt.clouddn.com/15004257295693.png" alt="">这其实就相当于给无序的集合，建立了一张有序的线性表，其索引项一定是按照关键码进行有序的排列。这也相当于把查找过程中需要的排序工作给提前做了。</p><ul><li>分块索引：</li></ul><p>分块查找又称索引顺序查找，是顺序查找的一种改进方法。</p><p>算法思想：将n个数据元素“按块有序”划分为m块（m&lt;n）。每一块中的结点不必有序，但块与块之间必须“按块有序”；即第一块中人艺元素的关键字都必须小于第2块中任一元素的关键字；而第二块中任一元素又都必须小于第三块中的任一元素，……</p><p>算法流程：<br>首先选取各块中的最大关键字构成一个索引表；查找分为两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；然后，在已确定的块中用顺序法进行查找。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15004259399950.png" alt="">这其实是有序查找和无序查找的一种中间状态或者说妥协状态。因为数据量过大，建立完整的稠密索引耗时耗力，占用资源过多；但如果不做任何排序或索引，那么遍历的查找也无法接受，只能这种，做一定程度的排序或索引。分块索引的效率比遍历查找的$O(n)$要高一些，但与二分查找的$O(logn)$还是要差不少。</p><ul><li>倒排索引：<br>不是由记录来确定属性值，而是由属性值来确定记录的位置，这种被称为倒排索引。其中记录号表存储具有相同关键字的所有记录的地址或引用（可以是指向记录的指针或该记录的主关键字）。倒排索引是最基础的搜索引擎技术。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、基本概念&quot;&gt;&lt;a href=&quot;#一、基本概念&quot; class=&quot;headerlink&quot; title=&quot;一、基本概念&quot;&gt;&lt;/a&gt;一、基本概念&lt;/h2&gt;&lt;p&gt;查找（Search）就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。在计算机应用中，查找是常用的基本运算，例如编译程序中符号表的查找。先说明几个概念：&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="查找算法" scheme="http://yoursite.com/tags/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>机器学习算法系列（30）：Scikit-Learn总结</title>
    <link href="http://yoursite.com/2017/07/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%8830%EF%BC%89%EF%BC%9AScikit-Learn%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/07/23/机器学习算法系列（30）：Scikit-Learn总结/</id>
    <published>2017-07-23T15:14:45.000Z</published>
    <updated>2017-12-26T08:04:14.506Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://ff120.github.io/2017/05/14/机器学习专题/机器学习_Scikit-Learn使用技巧/" target="_blank" rel="noopener">http://ff120.github.io/2017/05/14/机器学习专题/机器学习_Scikit-Learn使用技巧/</a><br>Scikit-learn是一个很受欢迎的机器学习方面的python工具包，它定义的一些范式和处理流程影响深远，所以，了解这个工具包对于机器学习算法的整个流程会有一个整体的了解。它已经实现了很多方法帮助我们便捷的处理数据，例如，划分数据集为训练集和验证集，交叉验证，数据预处理，归一化等等。</p><a id="more"></a><h2 id="一、性能评价指标"><a href="#一、性能评价指标" class="headerlink" title="一、性能评价指标"></a>一、性能评价指标</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># 计算均方误差</div><div class="line">from sklearn import metrics</div><div class="line">import numpy as np</div><div class="line">rmse = np.sqrt(metrics.mean_squared_error(y_test,y_pred))</div><div class="line"></div><div class="line"># 计算准确率</div><div class="line">acc = metrics.accuracy_score(y_test,y_pred)</div><div class="line"></div><div class="line">#混淆矩阵</div><div class="line">cm = metrics.confusion_matrix(y_test,y_pred)</div><div class="line"></div><div class="line"># classification_report</div><div class="line">cr = metrics.classification_report(y_true,y_pred)</div><div class="line"></div><div class="line"># ROC AUC 曲线</div><div class="line">from sklearn.metrics import roc_curve,auc</div></pre></td></tr></table></figure><h2 id="二、数据集划分"><a href="#二、数据集划分" class="headerlink" title="二、数据集划分"></a>二、数据集划分</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">from sklearn import cross_validation</div><div class="line">X_train,X_test,y_train,y_test = cross_validation.train_test_split(X,y,test_size=0.3,random_state=0)</div><div class="line"></div><div class="line"># K折</div><div class="line">from sklearn.cross_validation import KFold</div><div class="line">kf = KFold(n_samples, n_folds=2)</div><div class="line">for train, test in kf:</div><div class="line">    print(&quot;%s %s&quot; % (train, test))</div><div class="line"></div><div class="line"># 保证不同的类别之间的均衡，这里需要用到标签labels</div><div class="line">from sklearn.cross_validation import StratifiedKFold</div><div class="line">labels = [0, 0, 0, 0, 1, 1, 1, 1, 1, 1]</div><div class="line">skf = StratifiedKFold(labels, 3)</div><div class="line">for train, test in skf:</div><div class="line">    print(&quot;%s %s&quot; % (train, test))</div><div class="line">    </div><div class="line"># 留一交叉验证</div><div class="line">from sklearn.cross_validation import LeaveOneOut</div><div class="line">loo = LeaveOneOut(n_samples)</div><div class="line">for train, test in loo:</div><div class="line">    print(&quot;%s %s&quot; % (train, test))</div><div class="line"></div><div class="line"># 留P交叉验证</div><div class="line">from sklearn.cross_validation import LeavePOut</div><div class="line">lpo = LeavePOut(n_samples, p=2)</div><div class="line">for train, test in lpo:</div><div class="line">    print(&quot;%s %s&quot; % (train, test))</div><div class="line">    </div><div class="line">    </div><div class="line"># 按照额外提供的标签留一交叉验证,常用的情况是按照时间序列</div><div class="line">from sklearn.cross_validation import LeaveOneLabelOut</div><div class="line">labels = [1, 1,1, 2, 2]</div><div class="line">lolo = LeaveOneLabelOut(labels)</div><div class="line">for train, test in lolo:</div><div class="line">    print(&quot;%s %s&quot; % (train, test))</div><div class="line">    </div><div class="line"># 按照额外提供的标签留P交叉验证</div><div class="line">from sklearn.cross_validation import LeavePLabelOut</div><div class="line">labels = [1, 1, 2, 2, 3, 3,3]</div><div class="line">lplo = LeavePLabelOut(labels, p=2)</div><div class="line">for train, test in lplo:</div><div class="line">    print(&quot;%s %s&quot; % (train, test))</div><div class="line"></div><div class="line"># 随机分组</div><div class="line">from sklearn.cross_validation import ShuffleSplit</div><div class="line">ss = ShuffleSplit(16, n_iter=3, test_size=0.25,random_state=0)</div><div class="line">for train_index, test_index in ss:</div><div class="line">    print(&quot;%s %s&quot; % (train_index, test_index))</div><div class="line"></div><div class="line"># 考虑类别均衡的随机分组</div><div class="line">from sklearn.cross_validation import StratifiedShuffleSplit</div><div class="line">import numpy as np</div><div class="line">X = np.array([[1, 2], [3, 4], [1, 2], [3, 4]])</div><div class="line">y = np.array([0, 0, 1, 1])</div><div class="line">sss = StratifiedShuffleSplit(y, 3, test_size=0.5, random_state=0)</div><div class="line">for train, test in sss:</div><div class="line">    print(&quot;%s %s&quot; % (train, test))</div></pre></td></tr></table></figure><h2 id="三、特征选择"><a href="#三、特征选择" class="headerlink" title="三、特征选择"></a>三、特征选择</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"># 基于方差的特征选择</div><div class="line">from sklearn import feature_selection</div><div class="line">vt = feature_selection.VarianceThreshold(threshold=&apos;&apos;)</div><div class="line">vt.fit(X_train)</div><div class="line">X_train_transformed = vt.transform(X_train)</div><div class="line">X_test_transformed = vt.transform(X_test)</div><div class="line"></div><div class="line"># 按照某种排序规则 选择前K个特征</div><div class="line"># 除了使用系统定义好的函数f_classif，还可以自己定义函数</div><div class="line">sk = SelectKBest(feature_selection.f_classif,k=100)</div><div class="line">sk.fit(X_train,y_train)</div><div class="line">X_train_transformed = sk.transform(X_train)</div><div class="line">X_test_transformed = sk.transform(X_test)</div><div class="line"></div><div class="line"># 递归特征消除</div><div class="line">rfecv = RFECV(estimator=svc, step=step, cv=StratifiedKFold(y, n_folds = n_folds),scoring=&apos;accuracy&apos;)</div><div class="line">rfecv.fit(X_train, y_train)</div><div class="line">X_train_transformed = rfecv.transform(X_train)</div><div class="line">X_test_transformed = rfecv.transform(y_train)</div><div class="line"></div><div class="line"># 使用L1做特征选择</div><div class="line">from sklearn.svm import LinearSVC</div><div class="line">lsvc = LinearSVC(C=1, penalty=&quot;l1&quot;, dual=False)</div><div class="line">lsvc.fit(X_train,y_train)</div><div class="line">X_train_transformed = lsvc.transform(X_train)</div><div class="line">X_test_transformed = lsvc.transform(y_train)</div><div class="line"></div><div class="line"># 基于树的特征选择</div><div class="line">from sklearn.ensemble import ExtraTreesClassifier</div><div class="line">etc = ExtraTreesClassifier()</div><div class="line">etc.fit(X_train, y_train)</div><div class="line">X_train_transformed = etc.transform(X_train)</div><div class="line">X_test_transformed = etc.transform(X_test)</div><div class="line"></div><div class="line"># 基于线性判别分析做特征选择</div><div class="line">from sklearn.discriminant_analysis import LinearDiscriminantAnalysis</div><div class="line">lda = LinearDiscriminantAnalysis(solver=&apos;lsqr&apos;,shrinkage=&apos;auto&apos;)</div><div class="line">lda.fit(X_train, y_train)</div><div class="line">X_train_transformed = lda.transform(X_train)</div><div class="line">X_test_transformed = lda.transform(X_test)</div></pre></td></tr></table></figure><blockquote><p>基于方差的特征选择</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">from sklearn.feature_selection import VarianceThreshold</div><div class="line">X = [[0, 0, 1], [0, 1, 0], [1, 0, 0], [0, 1, 1], [0, 1, 0], [0, 1, 1]]</div><div class="line">sel = VarianceThreshold(threshold=(.8 * (1 - .8)))</div><div class="line">X2 = sel.fit_transform(X)</div><div class="line">X2</div><div class="line">Out[5]: </div><div class="line">array([[0, 1],</div><div class="line">       [1, 0],</div><div class="line">       [0, 0],</div><div class="line">       [1, 1],</div><div class="line">       [1, 0],</div><div class="line">       [1, 1]])</div></pre></td></tr></table></figure><p>可以看到，方差小于0.16的只有第一维特征，所以X2保留下来的是原来的第二维和第三维特征。这应该是最简单的特征选择方法了：假设某特征的特征值只有0和1，并且在所有输入样本中，95%的实例的该特征取值都是1，那就可以认为这个特征作用不大。如果100%都是1，那这个特征就没意义了。当特征值都是离散型变量的时候这种方法才能用，如果是连续型变量，就需要将连续变量离散化之后才能用，而且实际当中，一般不太会有95%以上都取某个值的特征存在，所以这种方法虽然简单但是不太好用。可以把它作为特征选择的预处理，先去掉那些取值变化小的特征，然后再从接下来提到的的特征选择方法中选择合适的进行进一步的特征选择。</p><blockquote><p>Univariate feature selection （单变量特征选择）</p></blockquote><p>主要使用统计的方法计算各个统计值，再根据一定的阈值筛选出符合要求的特征，去掉不符合要求的特征。</p><p>主要的统计方法有</p><ul><li>F值分类： f_classif </li><li>值回归：f_regression</li><li>卡方统计：chi2 (适用于非负特征值和稀疏特征值)</li></ul><p>主要的选择策略</p><ul><li>选择排名前K的特征：SelectKbest</li><li>选择前百分之几的特征：SelectPercentile</li><li>SelectFpr：Select features based on a false positive rate test.</li><li>SelectFdr：Select features based on an estimated false discovery rate.</li><li>SelectFwe：Select features based on family-wise error rate.</li><li>GenericUnivariateSelect：Univariate feature selector with configurable mode.</li></ul><p>其中</p><ul><li>false positive rate：FP / (FP + TP) 假设类别为0，1；记0为negative,1为positive, FPR就是实际的类别是0，但是分类器错误的预测为1的个数 与 分类器预测的类别为1的样本的总数（包括正确的预测为1和错误的预测为1） 的比值。</li><li>estimated false discovery rate: 错误的拒绝原假设的概率；</li><li>family-wise error rate: 至少有一个检验犯第一类错误的概率；假设检验的两类错误： &gt; - 第一类错误：原假设是正确的，但是却被拒绝了。(用α表示） &gt; - 第二类错误：原假设是错误的，但是却被接受了。(用β表示)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://ff120.github.io/2017/05/14/机器学习专题/机器学习_Scikit-Learn使用技巧/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://ff120.github.io/2017/05/14/机器学习专题/机器学习_Scikit-Learn使用技巧/&lt;/a&gt;&lt;br&gt;Scikit-learn是一个很受欢迎的机器学习方面的python工具包，它定义的一些范式和处理流程影响深远，所以，了解这个工具包对于机器学习算法的整个流程会有一个整体的了解。它已经实现了很多方法帮助我们便捷的处理数据，例如，划分数据集为训练集和验证集，交叉验证，数据预处理，归一化等等。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Scikit-Learn" scheme="http://yoursite.com/tags/Scikit-Learn/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法（9）：Trie树</title>
    <link href="http://yoursite.com/2017/07/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%EF%BC%9ATrie%E6%A0%91/"/>
    <id>http://yoursite.com/2017/07/23/数据结构与算法（9）：Trie树/</id>
    <published>2017-07-23T12:20:45.000Z</published>
    <updated>2017-09-01T06:36:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>Trie树是一种非常重要的数据结构，它在信息检索，字符串匹配等领域有广泛的应用，同时，它也是很多算法和复杂数据结构的基础，如后缀树，AC自动机等，因此，掌握Trie树这种数据结构，对于一名IT人员，显得非常基础且必要！</p><a id="more"></a><h2 id="一、什么是Trie树"><a href="#一、什么是Trie树" class="headerlink" title="一、什么是Trie树"></a>一、什么是Trie树</h2><p>Trie树，又叫字典树、前缀树（Prefix Tree）、单词查找树或键树，是一种多叉树结构。</p><p>字典树（Trie）可以保存一些字符串-&gt;值的对应关系。基本上，它跟 Java 的 HashMap 功能相同，都是 key-value 映射，只不过 Trie 的 key 只能是字符串。是一种哈希树的变种</p><p>如下图：<br><img src="http://omu7tit09.bkt.clouddn.com/15022924407569.png" alt=""></p><p>上图是一棵Trie树，表示了关键字集合{“a”,”to”,”tea”,”ted”,”ten”,”i”,”in”,”inn”}。从上图可以归纳出Trie树的基本性质：</p><ol><li>根节点不包含字符，除节结点外的每一个节点都包含一个字符。</li><li>从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。</li><li>每个节点的所有子节点包含的字符互不相同。</li></ol><p>通常在实现的时候，会在节点结构中设置一个标志，用来标记该结点处是否构成一个单词（关键字）。</p><p>可以看出，Trie树的关键字一般都是字符串，而且Trie树把每个关键字保存在一条路径上，而不是一个结点中。另外，两个有公共前缀的关键字，在Trie树中前缀部分的路径相同，所以Trie树又叫做前缀树（Prefix Tree）。</p><h2 id="二、Trie的优缺点"><a href="#二、Trie的优缺点" class="headerlink" title="二、Trie的优缺点"></a>二、Trie的优缺点</h2><p>Trie的核心思想是空间换时间。利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。</p><h3 id="2-1-优点"><a href="#2-1-优点" class="headerlink" title="2.1 优点"></a>2.1 优点</h3><p>Trie的强大之处就在于它的时间复杂度，插入和查询的效率很高，都为$O(K)$，其中 $K$ 是待插入/查询的字符串的长度，而与Trie中保存了多少个元素无关。</p><p>关于查询，会有人说 hash 表时间复杂度是$O(1)$不是更快？但是，哈希搜索的效率通常取决于 hash 函数的好坏，若一个坏的 hash 函数导致很多的冲突，效率并不一定比Trie树高。</p><p>而Trie树中不同的关键字就不会产生冲突。它只有在允许一个关键字关联多个值的情况下才有类似hash碰撞发生。</p><p>此外，Trie树不用求 hash 值，对短字符串有更快的速度。因为通常，求hash值也是需要遍历字符串的。</p><p>Trie树可以对关键字按字典序排序。</p><h3 id="2-2-缺点"><a href="#2-2-缺点" class="headerlink" title="2.2 缺点"></a>2.2 缺点</h3><p>当然，当 hash 函数很好时，Trie树的查找效率会低于哈希搜索。</p><p>其次因为Trie的核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。所以它的空间消耗比较大。</p><h2 id="三、Trie树的应用"><a href="#三、Trie树的应用" class="headerlink" title="三、Trie树的应用"></a>三、Trie树的应用</h2><p>典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。</p><h3 id="3-1-字符串检索"><a href="#3-1-字符串检索" class="headerlink" title="3.1 字符串检索"></a>3.1 字符串检索</h3><p>给出N个单词组成的熟词表，以及一篇全用小写英文书写的文章，请你按最早出现的顺序写出所有不在熟词表中的生词。</p><p>检索/查询功能是Trie树最原始的功能。给定一组字符串，查找某个字符串是否出现过，思路就是从根节点开始一个一个字符进行比较：</p><ul><li>如果沿路比较，发现不同的字符，则表示该字符串在集合中不存在。</li><li>如果所有的字符全部比较完并且全部相同，还需判断最后一个节点的标志位（标记该节点是否代表一个关键字）。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct trie_node</div><div class="line">&#123;</div><div class="line">    bool isKey;   // 标记该节点是否代表一个关键字</div><div class="line">    trie_node *children[26]; // 各个子节点 </div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="3-2-词频统计"><a href="#3-2-词频统计" class="headerlink" title="3.2 词频统计"></a>3.2 词频统计</h3><p>Trie树常被搜索引擎系统用于文本词频统计 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct trie_node</div><div class="line">&#123;</div><div class="line">    int count;   // 记录该节点代表的单词的个数</div><div class="line">    trie_node *children[26]; // 各个子节点 </div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>思路：为了实现词频统计，我们修改了节点结构，用一个整型变量count来计数。对每一个关键字执行插入操作，若已存在，计数加1，若不存在，插入后count置1。</p><h3 id="3-3-排序"><a href="#3-3-排序" class="headerlink" title="3.3 排序"></a>3.3 排序</h3><p>Trie树可以对大量字符串按字典序进行排序，思路也很简单：<br>给定N个互不相同的仅由一个单词构成的英文名，让你将他们按字典序从小到大输出。用字典树进行排序，采用数组的方式创建字典树，这棵树的每个结点的所有儿子很显然地按照其字母大小排序。对这棵树进行先序遍历即可。</p><h3 id="3-4-前缀匹配"><a href="#3-4-前缀匹配" class="headerlink" title="3.4 前缀匹配"></a>3.4 前缀匹配</h3><p>例如：找出一个字符串集合中所有以ab开头的字符串。我们只需要用所有字符串构造一个trie树，然后输出以$a-&gt;b-&gt;$开头的路径上的关键字即可。</p><p>trie树前缀匹配常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能</p><h3 id="3-5-最长公共前缀"><a href="#3-5-最长公共前缀" class="headerlink" title="3.5 最长公共前缀"></a>3.5 最长公共前缀</h3><p>查找一组字符串的最长公共前缀，只需要将这组字符串构建成Trie树，然后从跟节点开始遍历，直到出现多个节点为止（即出现分叉）。</p><p>举例说明：给出N 个小写英文字母串，以及Q 个询问，即询问某两个串的最长公共前缀的长度是多少？</p><p>解决方案：首先对所有的串建立其对应的字母树。此时发现，对于两个串的最长公共前缀的长度即它们所在结点的公共祖先个数，于是，问题就转化为了离线（Offline）的最近公共祖先（Least Common Ancestor，简称LCA）问题。而最近公共祖先问题同样是一个经典问题，可以用下面几种方法：</p><ol><li>利用并查集（Disjoint Set），可以采用采用经典的Tarjan 算法；</li><li>求出字母树的欧拉序列（Euler Sequence ）后，就可以转为经典的最小值查询（Range Minimum Query，简称RMQ）问题了；</li></ol><p>关于并查集，Tarjan算法，RMQ问题，网上有很多资料。</p><h3 id="3-6-作为辅助结构"><a href="#3-6-作为辅助结构" class="headerlink" title="3.6 作为辅助结构"></a>3.6 作为辅助结构</h3><p>如后缀树，AC自动机等。</p><h3 id="3-7-应用实例"><a href="#3-7-应用实例" class="headerlink" title="3.7 应用实例"></a>3.7 应用实例</h3><ol><li>一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。<ul><li>之前在此文：海量数据处理面试题集锦与Bit-map详解中给出的参考答案：用trie树统计每个词出现的次数，时间复杂度是$O(n<em>le)$（le表示单词的平均长度），然后是找出出现最频繁的前10个词。也可以用堆来实现（具体的操作可参考第三章、寻找最小的k个数），时间复杂度是$O(n</em>lg10)$。所以总的时间复杂度，是$O(n<em>le)$与$O(n</em>lg10)$中较大的哪一个。</li></ul></li><li>有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。</li><li>1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。请怎么设计和实现？</li><li>一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。</li><li>寻找热门查询：搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录，这些查询串的重复读比较高，虽然总数是1千万，但是如果去除重复和，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就越热门。请你统计最热门的10个查询串，要求使用的内存不能超过1G。<ul><li>(1) 请描述你解决这个问题的思路；</li><li>(2) 请给出主要的处理流程，算法，以及算法的复杂度。</li></ul></li></ol><h2 id="四、Trie树的实现"><a href="#四、Trie树的实现" class="headerlink" title="四、Trie树的实现"></a>四、Trie树的实现</h2><p>Trie树的插入、删除、查找的操作都是一样的，只需要简单的对树进行一遍遍历即可，时间复杂度：O（n）（n是字符串的长度）。</p><p>trie树每一层的节点数是$26^i$级别的。所以为了节省空间，对于Tried树的实现可以使用数组和链表两种方式。空间的花费，不会超过单词数×单词长度。</p><ol><li><p>数组：由于我们知道一个Tried树节点的子节点的数量是固定26个（针对不同情况会不同，比如兼容数字，则是36等），所以可以使用固定长度的数组来保存节点的子节点</p><ul><li>优点：在对子节点进行查找时速度快</li><li>缺点：浪费空间，不管子节点有多少个，总是需要分配26个空间</li></ul></li><li><p>链表：使用链表的话我们需要在每个子节点中保存其兄弟节点的链接，当我们在一个节点的子节点中查找是否存在一个字符时，需要先找到其子节点，然后顺着子节点的链表从左往右进行遍历</p><ul><li>优点：节省空间，有多少个子节点就占用多少空间，不会造成空间浪费</li><li>缺点：对子节点进行查找相对较慢，需要进行链表遍历，同时实现也较数组麻烦</li></ul></li></ol><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 单词查找树</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</div><div class="line"><span class="comment">/** 单词查找树根节点，根节点为一个空的节点 */</span></div><div class="line"><span class="keyword">private</span> Vertex root = <span class="keyword">new</span> Vertex();</div><div class="line"><span class="comment">/** 单词查找树的节点(内部类) */</span></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Vertex</span> </span>&#123;</div><div class="line"><span class="comment">/** 单词出现次数统计 */</span></div><div class="line"><span class="keyword">int</span> wordCount;</div><div class="line"><span class="comment">/** 以某个前缀开头的单词，它的出现次数 */</span></div><div class="line"><span class="keyword">int</span> prefixCount;</div><div class="line"><span class="comment">/** 子节点用数组表示 */</span></div><div class="line">Vertex[] vertexs = <span class="keyword">new</span> Vertex[<span class="number">26</span>];</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 树节点的构造函数</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vertex</span><span class="params">()</span> </span>&#123;</div><div class="line">wordCount = <span class="number">0</span>;</div><div class="line">prefixCount = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 单词查找树构造函数</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 向单词查找树添加一个新单词</div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> word</div><div class="line"> *            单词</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWord</span><span class="params">(String word)</span> </span>&#123;</div><div class="line">addWord(root, word.toLowerCase());</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 向单词查找树添加一个新单词</div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> root</div><div class="line"> *            单词查找树节点</div><div class="line"> * <span class="doctag">@param</span> word</div><div class="line"> *            单词</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWord</span><span class="params">(Vertex vertex, String word)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (word.length() == <span class="number">0</span>) &#123;</div><div class="line">vertex.wordCount++;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (word.length() &gt; <span class="number">0</span>) &#123;</div><div class="line">vertex.prefixCount++;</div><div class="line"><span class="keyword">char</span> c = word.charAt(<span class="number">0</span>);</div><div class="line"><span class="keyword">int</span> index = c - <span class="string">'a'</span>;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == vertex.vertexs[index]) &#123;</div><div class="line">vertex.vertexs[index] = <span class="keyword">new</span> Vertex();</div><div class="line">&#125;</div><div class="line">addWord(vertex.vertexs[index], word.substring(<span class="number">1</span>));</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 统计某个单词出现次数</div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> word</div><div class="line"> *            单词</div><div class="line"> * <span class="doctag">@return</span> 出现次数</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countWord</span><span class="params">(String word)</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> countWord(root, word);</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 统计某个单词出现次数</div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> root</div><div class="line"> *            单词查找树节点</div><div class="line"> * <span class="doctag">@param</span> word</div><div class="line"> *            单词</div><div class="line"> * <span class="doctag">@return</span> 出现次数</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countWord</span><span class="params">(Vertex vertex, String word)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (word.length() == <span class="number">0</span>) &#123;</div><div class="line"><span class="keyword">return</span> vertex.wordCount;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="keyword">char</span> c = word.charAt(<span class="number">0</span>);</div><div class="line"><span class="keyword">int</span> index = c - <span class="string">'a'</span>;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == vertex.vertexs[index]) &#123;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="keyword">return</span> countWord(vertex.vertexs[index], word.substring(<span class="number">1</span>));</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 统计以某个前缀开始的单词，它的出现次数</div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> word</div><div class="line"> *            前缀</div><div class="line"> * <span class="doctag">@return</span> 出现次数</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrefix</span><span class="params">(String word)</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> countPrefix(root, word);</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 统计以某个前缀开始的单词，它的出现次数(前缀本身不算在内)</div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> root</div><div class="line"> *            单词查找树节点</div><div class="line"> * <span class="doctag">@param</span> word</div><div class="line"> *            前缀</div><div class="line"> * <span class="doctag">@return</span> 出现次数</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countPrefix</span><span class="params">(Vertex vertex, String prefixSegment)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (prefixSegment.length() == <span class="number">0</span>) &#123;</div><div class="line"><span class="keyword">return</span> vertex.prefixCount;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="keyword">char</span> c = prefixSegment.charAt(<span class="number">0</span>);</div><div class="line"><span class="keyword">int</span> index = c - <span class="string">'a'</span>;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == vertex.vertexs[index]) &#123;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="keyword">return</span> countPrefix(vertex.vertexs[index], prefixSegment.substring(<span class="number">1</span>));</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 调用深度递归算法得到所有单词</div><div class="line"> * <span class="doctag">@return</span> 单词集合</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">listAllWords</span><span class="params">()</span> </span>&#123;</div><div class="line">List&lt;String&gt; allWords = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line"><span class="keyword">return</span> depthSearchWords(allWords, root, <span class="string">""</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 递归生成所有单词</div><div class="line"> * <span class="doctag">@param</span> allWords 单词集合</div><div class="line"> * <span class="doctag">@param</span> vertex 单词查找树的节点</div><div class="line"> * <span class="doctag">@param</span> wordSegment 单词片段</div><div class="line"> * <span class="doctag">@return</span> 单词集合</div><div class="line"> */ </div><div class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">depthSearchWords</span><span class="params">(List&lt;String&gt; allWords, Vertex vertex,</span></span></div><div class="line">String wordSegment) &#123;</div><div class="line">Vertex[] vertexs = vertex.vertexs;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexs.length; i++) &#123;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != vertexs[i]) &#123;</div><div class="line"><span class="keyword">if</span> (vertexs[i].wordCount &gt; <span class="number">0</span>) &#123;</div><div class="line">allWords.add(wordSegment + (<span class="keyword">char</span>)(i + <span class="string">'a'</span>));</div><div class="line"><span class="keyword">if</span>(vertexs[i].prefixCount &gt; <span class="number">0</span>)&#123;</div><div class="line">depthSearchWords(allWords, vertexs[i], wordSegment + (<span class="keyword">char</span>)(i + <span class="string">'a'</span>));</div><div class="line">&#125;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">depthSearchWords(allWords, vertexs[i], wordSegment + (<span class="keyword">char</span>)(i + <span class="string">'a'</span>));</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> allWords;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">Trie trie = <span class="keyword">new</span> Trie();</div><div class="line">trie.addWord(<span class="string">"abc"</span>);</div><div class="line">trie.addWord(<span class="string">"abcd"</span>);</div><div class="line">trie.addWord(<span class="string">"abcde"</span>);</div><div class="line">trie.addWord(<span class="string">"abcdef"</span>);</div><div class="line">System.out.println(trie.countPrefix(<span class="string">"abc"</span>));</div><div class="line">System.out.println(trie.countWord(<span class="string">"abc"</span>));</div><div class="line">System.out.println(trie.listAllWords());</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Trie树是一种非常重要的数据结构，它在信息检索，字符串匹配等领域有广泛的应用，同时，它也是很多算法和复杂数据结构的基础，如后缀树，AC自动机等，因此，掌握Trie树这种数据结构，对于一名IT人员，显得非常基础且必要！&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="Trie树" scheme="http://yoursite.com/tags/Trie%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>机器学习算法系列（29）：Sparsity and Some Basics of L1 Regularization</title>
    <link href="http://yoursite.com/2017/07/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%8829%EF%BC%89%EF%BC%9ASparsity%20and%20Some%20Basics%20of%20L1%20Regularization/"/>
    <id>http://yoursite.com/2017/07/23/机器学习算法系列（29）：Sparsity and Some Basics of L1 Regularization/</id>
    <published>2017-07-23T12:14:45.000Z</published>
    <updated>2017-12-26T08:04:05.758Z</updated>
    
    <content type="html"><![CDATA[<p>转载自<a href="http://freemind.pluskid.org/machine-learning/sparsity-and-some-basics-of-l1-regularization/#ed61992b37932e208ae114be75e42a3e6dc34cb3" target="_blank" rel="noopener">pluskid的个人博客</a><br>Sparsity 是当今机器学习领域中的一个重要话题。John Lafferty 和 Larry Wasserman 在 2006 年的一篇<a href="http://www3.stat.sinica.edu.tw/statistica/J16N2/editorial3.pdf" target="_blank" rel="noopener">评论</a>中提到：</p><a id="more"></a><blockquote><p>Some current challenges … are high dimensional data, sparsity, semi-supervised learning, the relation between computation and risk, and structured prediction.</p><blockquote><p>—John Lafferty and Larry Wasserman. Challenges in statistical machine learning. Statistica Sinica. Volume 16, Number 2, pp. 307-323, 2006.</p></blockquote></blockquote><p>Sparsity 的最重要的“客户”大概要属 high dimensional data 了吧。现在的机器学习问题中，具有非常高维度的数据随处可见。例如，在文档或图片分类中常用的 <a href="https://www.wikiwand.com/en/Bag-of-words_model" target="_blank" rel="noopener">bag of words</a> 模型里，如果词典的大小是一百万，那么每个文档将由一百万维的向量来表示。高维度带来的的一个问题就是计算量：在一百万维的空间中，即使计算向量的内积这样的基本操作也会是非常费力的。不过，如果向量是稀疏的的话（事实上在 bag of words 模型中文档向量通常都是非常稀疏的），例如两个向量分别只有$L_1$和$L_2$个非零元素，那么计算内积可以只使用$min(L_1,L_2 )$次乘法完成。因此稀疏性对于解决高维度数据的计算量问题是非常有效的。</p><p>当然高维度带来的问题不止是在计算量上。例如在许多生物相关的问题中，数据的维度非常高，但是由于收集数据需要昂贵的实验，因此可用的训练数据却相当少，这样的问题通常称为“small , large  problem”—我们一般用  表示数据点的个数，用  表示变量的个数，即数据维度。当$p&gt;&gt;n$的时候，不做任何其他假设或者限制的话，学习问题基本上是没法进行的。<br>因为如果用上所有变量的话，$p$越大，通常会导致模型越复杂，但是反过来$n$又很小，于是就会出现很严重的 overfitting 问题。例如，最简单的线性回归模型：</p><script type="math/tex; mode=display">f(X)=\sum_{j=1}^p</script><p>使用square loss来学习的话，就变成最小化如下的问题：</p><script type="math/tex; mode=display">J(w)=\frac{1}{n}\sum_{i=1}^n(y_i-f(x_i))^2=\frac{1}{n}||y-Xw||^2</script><p>这里$X=(x_1,······,x_n)^T \in R^{n \times p}$是数据矩阵，而$y=(y_1,······,y_n)^T$是由标签组成的列向量。该问题具有解析解$\hat{w}=(X^TX)^{-1}X^Ty$然而，如果$p&gt;n$的话，矩阵$X^TX$将会不是满秩的，而这个解也没法算出来。捉着更确切地说，将会有无穷多个解。也就是说，我们的数据不足以确定一个解，如果我们从所有可行解随机选一个的话，很可能并不是很好地解，总而言之，我们过拟合了。</p><p>解决 overfitting 最常用的办法就是 regularization ，例如著名的 ridge regression 就是添加一个  $\ell_2 $regularizer ：</p><script type="math/tex; mode=display">J_R(w)=\frac{1}{n}||y-Xw||^2+\lambda ||w||^2</script><p>直观地看，添加这个regularizer会使得模型的解偏向于norm较小的w。从凸优化的角度来说，最小化上面这个$J(w)$等价于如下问题：</p><script type="math/tex; mode=display">\underset{w}{min}\frac{1}{n}||y-Xw||^2</script><p>其中$C$和$\lambda$对应的是个常数。也就是说，也就是说，我们通过限制$w$的norm的大小实现了对模型空间的限制，从而在一定程度上（取决于$\lambda$的大小）避免了overfitting。不过ridge regression并不具有产生稀疏解的能力，得到的系数$w$仍然需要数据中的所有特征才能计算预测结果，从计算量上来说并没有得到改观。</p><p>不过，特别是在像生物或者医学等通常需要和人交互的领域，稀疏的解除了计算量上的好处之外，更重要的是更具有“可解释性”。比如说，一个病如果依赖于 5 个变量的话，将会更易于医生理解、描述和总结规律，但是如果依赖于 5000 个变量的话，基本上就超出人肉可处理的范围了。</p><p>在这里引入稀疏性的方法是用$L_1$regularization 代替 $L_2$regularization，得到如下的目标函数：</p><script type="math/tex; mode=display">J_L(w)=\frac{1}{n}||y-Xw||^2+\lambda ||w||_1</script><p>该问题通常被称为LASSO（least absolute shrinkage and selection operator）。LASSO 仍然是一个 convex optimization 问题，不过不再具有解析解。它的优良性质是能产生稀疏性，导致$w$中许多项变成零。</p><p>可是，为什么它能产生稀疏性呢？这也是一直让我挺感兴趣的一个问题，事实上在之前申请学校的时候一次电话面试中我也被问到了这个问题。我当时的回答是背后的理论我并不是很清楚，但是我知道一个直观上的理解。下面我们就先来看一下这个直观上的理解。</p><p>首先，和 ridge regression 类似，上面形式的 LASSO 问题也等价于如下形式：</p><script type="math/tex; mode=display">\underset {w}{min }\frac{1}{n}||y-Xw||^2, \ \ \ s.t. ||w||_1≤C</script><p>也就是说，我们将模型空间限制在$w$的一个 $\ell_1$-ball中。为了便于可视化，我们考虑两维的情况，在 $(w^1,w^2)$平面上可以画出目标函数的等高线，而约束条件则成为平面上半径为$C$的一个 norm ball 。等高线与 norm ball 首次相交的地方就是最优解。如图 所示：</p><p><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-24 下午5.47.44.png" alt="屏幕快照 2017-07-24 下午5.47.44"></p><p>可以看到，$\ell_1-ball$与$\ell_2-ball$的不同就在于他和每个坐标轴相交的地方都有“角”出现，而目标函数的测地线除非位置摆得非常好，大部分时候都会在角的地方相交。注意到在角的位置为产生稀疏性，例如图中的相交点就有$w^1=0$  ，而更高维的时候（想象一下三维的 $\ell_1 $-ball 是什么样的？）除了角点以外，还有很多边的轮廓也是既有很大的概率成为第一次相交的地方，又会产生稀疏性。</p><p>相比之下，$\ell_2 $-ball 就没有这样的性质，因为没有角，所以第一次相交的地方出现在具有稀疏性的位置的概率就变得非常小了。这就从直观上来解释了为什么$\ell_1$  regularization 能产生稀疏性，而$\ell_2$regularization 不行的原因了。</p><p>不过，如果只限于 intuitive 的解释的话，就不那么好玩了，但是背后完整的理论又不是那么容易能够搞清楚的，既然这次的标题是 Basics ，我们就先来看一个简单的特殊情况好了。</p><p>接下来我们考虑 orthonormal design 的情况：$\frac{1}{n}X^TX=I$，然后看看LASSO的解具体是什么样子。注意orthonormal design 实际上是要求特征之间相互正交。这可以通过对数据进行 <a href="https://www.wikiwand.com/en/Principal_component_analysis" target="_blank" rel="noopener">PCA</a>以及模长 normalize 来实现。</p><p>注意到LASSO 的目标函数是 convex 的，根据 <a href="https://www.wikiwand.com/en/Karush–Kuhn–Tucker_conditions" target="_blank" rel="noopener">KKT</a> 条件，在最优解的地方要求 gradient  。不过这里有一点小问题：$\ell_1$ -norm 不是光滑的，不存在 gradient ，所以我们需要用一点 <a href="https://www.wikiwand.com/zh-hans/次导数" target="_blank" rel="noopener">subgradient</a> 的东西。</p><p>定义：（subgradient，subdifferential）.对于在$p$维欧式空间中的凸开子集$U$上定义的实值函数$f:U \rightarrow R$，一个向量$p$维向量$v$称为$f$在一点$x_0 \in U$处的subgradient，如果对于任意$x \in U$，满足</p><script type="math/tex; mode=display">f(x)-f(x_0)≥v·(x-x_0)</script><p>由在点$x_0$处的所有subgradient所组成的集合称为$x_0$处的subdifferential，记为$\partial f(x_0)$</p><p>注意 subgradient 和 subdifferential 只是对凸函数定义的。例如一维的情况，$f(x)=|x|$，在$x=0$处的subdifferential 就是$[-1,+1]$这个区间（集合）。注意在$f$的 gradient 存在的点，subdifferential 将是由 gradient 构成的一个单点集合。这样就将 gradient 的概念加以推广了。这个推广有一个很好的性质。</p><p>性质（CONDITION GLOBAL MINIMIZER）.点$x_0$是凸函数$f$的一个全局最小值点，当且仅当$0\in \partial f(x_0)$</p><p>证明很简单，将$0\in \partial f(x_0)$带入定义的那个式子就可以得到。有了这个工具之后，就可以对 LASSO 的最优解进行分析了。在此之前，我们先看一下原始的 least square 问题的最优解现在变成了什么样子，由于 orthonormal design ，我们有</p><script type="math/tex; mode=display">\hat{w}=\frac{1}{n}X^Ty</script><p>然后我们再来看LASSO，假设$\bar{w}=(\bar{w}^1,······，\bar{w}^p)^T$是$J_L(w)$的全局最优值点。考虑第$j$个变量$\bar{w}^j$，有两种情况。</p><p>第一种情况：gradient存在，此时$\bar{w}^j≠0$</p><p>由于gradient在最小值点必须等于零，我们有</p><script type="math/tex; mode=display">\frac{\partial J_L(w)}{\partial w_j}|_{\bar{w}_j}=0</script><p>亦即</p><script type="math/tex; mode=display">-\frac{2}{n}(X^Ty-X^TX\bar{w})_j+\lambda sign(\bar{w}^j)=0</script><p>根据orthonormal design性质以及least square问题在orthonormal design时的解$\hat{w}^j$化简得到</p><script type="math/tex; mode=display">\bar{w}^j=\hat{w}^j-\frac{\lambda}{2}sign(\bar{w}^j)</script><p>从这个式子也可以明显地看出$\bar{w}^j$和$\hat{w}^j$是同号的，于是$sign(\bar{w}^j)=sign(\hat{w}^j)$所以上面的式子变为</p><script type="math/tex; mode=display">\bar{w}^j=\hat{w}^j-\frac{\lambda}{2}sign(\bar{w}^j)=sign(\hat{w}^j)(|\hat{w}^j|-\frac{\lambda}{2})</script><p>再用一次$sign(\bar{w}^j)=sign(\hat{w}^j)$，两边同时乘以$sign(\bar{w}^j)$，可以得到</p><script type="math/tex; mode=display">|\hat{w}^j|-\frac{\lambda}{2}=|\bar{w}^j|≥0</script><p>于是刚才的式子可以进一步写成</p><script type="math/tex; mode=display">\bar{w}^j=sign(\hat{w}^j)(|\hat{w}^j|-\frac{\lambda}{2})_+</script><p>这里$(x)_+=max \{x,0\}$表示$x$ 的正部。</p><p>第二种情况：gradient不存在，此时$\bar{w}^j=0$根据subgradient在最小值点出的性质，此时有：</p><script type="math/tex; mode=display">0=\bar{w}^j\in \partial {J_L(\bar{w})}=\{-\frac{2}{n}(X^Ty-X^TX\bar{w})_j+\lambda e:e \in [-1,1]\}</script><p>亦即存在$e_0 \in [-1,1]$使得</p><script type="math/tex; mode=display">0=2\bar{w}^j-2\hat{w}^j+\lambda e_0</script><p>于是</p><script type="math/tex; mode=display">|\hat{w}^j|=\frac{\lambda}{2}|e_0|≤\frac{\lambda}{2}</script><p>又因为$\bar{w}^j=0$，所以这个时候式子也可以统一为</p><script type="math/tex; mode=display">\bar{w}^j=sign(\hat{w}^j)(|\hat{w}^j|-\frac{\lambda}{2})_+</script><p>的形式。 </p><p>如此一来，在 orthonormal design 的情况下，LASSO 的最优解就可以写为</p><script type="math/tex; mode=display">\bar{w}^j=sign(\hat{w}^j)(|\hat{w}^j|-\frac{\lambda}{2})_+</script><p>可以用图形象地表达出来。<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-24 下午7.12.33.png" alt="屏幕快照 2017-07-24 下午7.12.33"></p><p>图上画了原始的 least square 解，LASSO 的解以及 ridge regression 的解，用上面同样的方法（不过由于 ridge regularizer 是 smooth 的，所以过程却简单得多）可以得知 ridge regression 的解是如下形式</p><script type="math/tex; mode=display">\frac{n}{1+n\lambda}\hat{w}^j</script><p>可以认为ridge regression 只是做了一个全局缩放，而 LASSO 则是做了一个 soft thresholding ：将绝对值小于$\frac{\lambda}{2}$的那些系数直接变成零了，这也就更加令人信服地解释了 LASSO 为何能够产生稀疏解了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自&lt;a href=&quot;http://freemind.pluskid.org/machine-learning/sparsity-and-some-basics-of-l1-regularization/#ed61992b37932e208ae114be75e42a3e6dc34cb3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pluskid的个人博客&lt;/a&gt;&lt;br&gt;Sparsity 是当今机器学习领域中的一个重要话题。John Lafferty 和 Larry Wasserman 在 2006 年的一篇&lt;a href=&quot;http://www3.stat.sinica.edu.tw/statistica/J16N2/editorial3.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;评论&lt;/a&gt;中提到：&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="L1正则" scheme="http://yoursite.com/tags/L1%E6%AD%A3%E5%88%99/"/>
    
      <category term="稀疏性" scheme="http://yoursite.com/tags/%E7%A8%80%E7%96%8F%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法（8）：红黑树</title>
    <link href="http://yoursite.com/2017/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%888%EF%BC%89%EF%BC%9A%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>http://yoursite.com/2017/07/22/数据结构与算法（8）：红黑树/</id>
    <published>2017-07-22T15:14:45.000Z</published>
    <updated>2017-09-01T06:36:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>红黑树，即R-B Tree，本文的主要内容包括：红黑树的特性、红黑树的时间复杂度和它的证明，红黑树的时间复杂度和它的证明，红黑树的左旋、右旋、插入、删除等操作</p><a id="more"></a><h2 id="一、红黑树的定义"><a href="#一、红黑树的定义" class="headerlink" title="一、红黑树的定义"></a>一、红黑树的定义</h2><h3 id="1-1-红黑树的定义"><a href="#1-1-红黑树的定义" class="headerlink" title="1.1 红黑树的定义"></a>1.1 红黑树的定义</h3><p>R-B Tree，全称是Red-black Tree，又称为“红黑树”，它是一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红（Red）或黑（Black）</p><p>红黑树是一种自平衡二叉查找树，是在计算机科学在用到的一种数据结构，典型的用途是实现关联数组。它是在1972年由鲁道夫.贝尔发明的，称之为“对称二叉B树”，它的现代名字是在 Leo J. Guibas 和 Robert Sedgewick 于1978年写的一篇论文中获得的。它是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的：他可以在$O(logn)$的时间内做查找、插入和删除，这里的n是树中元素的数目。</p><p>红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制的一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求:</p><ul><li>性质1：节点是红色或黑色</li><li>性质2：根节点是黑色</li><li>性质3：所有叶子节点都是黑色（叶子是NIL节点）</li><li>性质4：每个红色节点必须有两个黑色的子节点。(从每个叶子到根的所有路径上不能有两个连续的红色节点。)</li><li>性质5.：从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li></ul><p>注意：</p><p>性质3中的叶子节点，是只为空(NIL或null)的节点。</p><p>性质5确保从根到叶子的最长的可能路径不多于最短的可能路径的两倍长，因而，红黑树是相对是接近平衡的二叉树。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。</p><p>要知道为什么这些性质确保了这个结果，注意到性质4导致了路径不能有两个毗连的红色节点就足够了。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。</p><p>【提问】<br>请解释红黑性，以及为什么每次操作都是稳定O(logn)的复杂度</p><p>下面是一个具体的红黑树的图例：<br><img src="http://omu7tit09.bkt.clouddn.com/15005162551705.png" alt=""></p><h3 id="1-2-红黑树的应用"><a href="#1-2-红黑树的应用" class="headerlink" title="1.2 红黑树的应用"></a>1.2 红黑树的应用</h3><p>红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是$O(lgn)$，效率非常之高。</p><p>例如，Java集合中的$TreeSet$和$TreeMap$，C++的STL中的Set、Map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。</p><h2 id="二、红黑树的基本操作：左旋和右旋"><a href="#二、红黑树的基本操作：左旋和右旋" class="headerlink" title="二、红黑树的基本操作：左旋和右旋"></a>二、红黑树的基本操作：左旋和右旋</h2><p>红黑树的基本操作是添加、删除。在对红黑树进行添加或删除之后，都会用到旋转方法。为什么呢？道理很简单，添加或删除红黑树中的节点之后，红黑树就发生了变化，可能不满足红黑树的5条性质，也就不再是一颗红黑树了，而是一颗普通的树。而通过旋转，可以使这颗树重新成为红黑树。简单点说，旋转的目的是让树保持红黑树的特性。</p><p>恢复红黑树的性质需要少量(O(logn))的颜色变更(实际是非常快速的)和不超过三次树旋转(对于插入操作是两次)。虽然插入和删除很复杂，但操作时间仍可以保持为O(logn) 次。</p><p>旋转包括两种：左旋 和 右旋。下面分别对它们进行介绍。</p><h3 id="2-1-左旋"><a href="#2-1-左旋" class="headerlink" title="2.1 左旋"></a>2.1 左旋</h3><p><img src="http://omu7tit09.bkt.clouddn.com/15006239185477.jpg" alt=""><br>对X进行左旋，意味着“将X变成一个左节点”。</p><p>左旋的伪代码《算法导论》：参考上面的示意图和下面的伪代码，理解“红黑树T的节点x进行左旋”是如何进行的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">LEFT-ROTATE(T, x)  </div><div class="line">01  y ← right[x]            // 前提：这里假设x的右孩子为y。下面开始正式操作</div><div class="line">02  right[x] ← left[y]      // 将 “y的左孩子” 设为 “x的右孩子”，即 将β设为x的右孩子</div><div class="line">03  p[left[y]] ← x          // 将 “x” 设为 “y的左孩子的父亲”，即 将β的父亲设为x</div><div class="line">04  p[y] ← p[x]             // 将 “x的父亲” 设为 “y的父亲”</div><div class="line">05  if p[x] = nil[T]       </div><div class="line">06  then root[T] ← y                 // 情况1：如果 “x的父亲” 是空节点，则将y设为根节点</div><div class="line">07  else if x = left[p[x]]  </div><div class="line">08            then left[p[x]] ← y    // 情况2：如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”</div><div class="line">09            else right[p[x]] ← y   // 情况3：(x是它父节点的右孩子) 将y设为“x的父节点的右孩子”</div><div class="line">10  left[y] ← x             // 将 “x” 设为 “y的左孩子”</div><div class="line">11  p[x] ← y                // 将 “x的父节点” 设为 “y”</div></pre></td></tr></table></figure><p>理解左旋之后，看看下面更鲜明的例子。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15006241308266.jpg" alt=""></p><h3 id="2-2-右旋"><a href="#2-2-右旋" class="headerlink" title="2.2 右旋"></a>2.2 右旋</h3><p><img src="http://omu7tit09.bkt.clouddn.com/15006241686012.jpg" alt=""><br>对Y进行右旋，意味着“将Y变成一个右节点”</p><p>右旋的伪代码《算法导论》：参考上面的示意图和下面的伪代码，理解“红黑树T的节点y进行右旋”是如何进行的。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">RIGHT-ROTATE(T, y)  </div><div class="line">01  x ← left[y]             // 前提：这里假设y的左孩子为x。下面开始正式操作</div><div class="line">02  left[y] ← right[x]      // 将 “x的右孩子” 设为 “y的左孩子”，即 将β设为y的左孩子</div><div class="line">03  p[right[x]] ← y         // 将 “y” 设为 “x的右孩子的父亲”，即 将β的父亲设为y</div><div class="line">04  p[x] ← p[y]             // 将 “y的父亲” 设为 “x的父亲”</div><div class="line">05  if p[y] = nil[T]       </div><div class="line">06  then root[T] ← x                 // 情况1：如果 “y的父亲” 是空节点，则将x设为根节点</div><div class="line">07  else if y = right[p[y]]  </div><div class="line">08            then right[p[y]] ← x   // 情况2：如果 y是它父节点的右孩子，则将x设为“y的父节点的左孩子”</div><div class="line">09            else left[p[y]] ← x    // 情况3：(y是它父节点的左孩子) 将x设为“y的父节点的左孩子”</div><div class="line">10  right[x] ← y            // 将 “y” 设为 “x的右孩子”</div><div class="line">11  p[y] ← x                // 将 “y的父节点” 设为 “x”</div></pre></td></tr></table></figure><p>理解右旋之后，看看下面一个更鲜明的例子。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15006242377514.jpg" alt=""></p><p>综上，左旋和右旋是相对的两个概念，原理类似。理解一个也就理解了另一个。</p><p>在实际应用中，若没有彻底理解左旋和右旋，可能会将它们混淆。下面谈谈我对如何区分左旋 和右旋 的理解。</p><h3 id="2-3-区分左旋和右旋"><a href="#2-3-区分左旋和右旋" class="headerlink" title="2.3 区分左旋和右旋"></a>2.3 区分左旋和右旋</h3><p>仔细观察上面”左旋”和”右旋”的示意图。我们能清晰的发现，它们是对称的。无论是左旋还是右旋，被旋转的树，在旋转前是二叉查找树，并且旋转之后仍然是一颗二叉查找树。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15006243056330.jpg" alt=""></p><p>左旋示例图(以x为节点进行左旋)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">                              z</div><div class="line">  x                          /                  </div><div class="line"> / \      --(左旋)--&gt;       x</div><div class="line">y   z                      /</div><div class="line">                          y</div></pre></td></tr></table></figure><p>对x进行左旋，意味着，将“x的右孩子”设为“x的父亲节点”；即，将 x变成了一个左节点(x成了为z的左孩子)！。 因此，左旋中的“左”，意味着“被旋转的节点将变成一个左节点”。</p><p>右旋示例图(以x为节点进行右旋)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">                              y</div><div class="line">  x                            \                 </div><div class="line"> / \      --(右旋)--&gt;           x</div><div class="line">y   z                            \</div><div class="line">                                  z</div></pre></td></tr></table></figure><p>对x进行右旋，意味着，将“x的左孩子”设为“x的父亲节点”；即，将 x变成了一个右节点(x成了为y的右孩子)！ 因此，右旋中的“右”，意味着“被旋转的节点将变成一个右节点”。</p><h2 id="三、红黑树的基本操作：添加"><a href="#三、红黑树的基本操作：添加" class="headerlink" title="三、红黑树的基本操作：添加"></a>三、红黑树的基本操作：添加</h2><p>将一个节点插入到红黑树中，需要执行哪些步骤呢？首先，将红黑树当作一颗二叉查找树，将节点插入；然后，将节点着色为红色；最后，通过旋转和重新着色等方法来修正该树，使之重新成为一颗红黑树。详细描述如下：</p><ul><li>第一步: 将红黑树当作一颗二叉查找树，将节点插入。</li></ul><p>红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。此外，无论是左旋还是右旋，若旋转之前这棵树是二叉查找树，旋转之后它一定还是二叉查找树。这也就意味着，任何的旋转和重新着色操作，都不会改变它仍然是一颗二叉查找树的事实。</p><p>好吧？那接下来，我们就来想方设法的旋转以及重新着色，使这颗树重新成为红黑树！</p><ul><li>第二步：将插入的节点着色为”红色”。</li></ul><p>为什么着色成红色，而不是黑色呢？为什么呢？在回答之前，我们需要重新温习一下红黑树的特性：</p><ol><li>每个节点或者是黑色，或者是红色。</li><li>根节点是黑色。</li><li>每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！]</li><li>如果一个节点是红色的，则它的子节点必须是黑色的。</li><li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</li></ol><p>将插入的节点着色为红色，不会违背”特性(5)”！少违背一条特性，就意味着我们需要处理的情况越少。接下来，就要努力的让这棵树满足其它性质即可；满足了的话，它就又是一颗红黑树了。o(∩∩)o…哈哈</p><ul><li>第三步: 通过一系列的旋转或着色等操作，使之重新成为一颗红黑树。</li></ul><p>第二步中，将插入节点着色为”红色”之后，不会违背”特性(5)”。那它到底会违背哪些特性呢？</p><ol><li>对于”特性(1)”，显然不会违背了。因为我们已经将它涂成红色了。</li><li>对于”特性(2)”，显然也不会违背。在第一步中，我们是将红黑树当作二叉查找树，然后执行的插入操作。而根据二叉查找数的特点，插入操作不会改变根节点。所以，根节点仍然是黑色。</li><li>对于”特性(3)”，显然不会违背了。这里的叶子节点是指的空叶子节点，插入非空节点并不会对它们造成影响。</li><li>对于”特性(4)”，是有可能违背的！</li><li>那接下来，想办法使之”满足特性(4)”，就可以将树重新构造成红黑树了。</li></ol><p>下面看看代码到底是怎样实现这三步的。</p><p> 添加操作的伪代码《算法导论》</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">RB-INSERT(T, z)  </div><div class="line"> y ← nil[T]                        <span class="comment">// 新建节点“y”，将y设为空节点。</span></div><div class="line"> x ← root[T]                       <span class="comment">// 设“红黑树T”的根节点为“x”</span></div><div class="line"> <span class="keyword">while</span> x ≠ nil[T]                  <span class="comment">// 找出要插入的节点“z”在二叉树T中的位置“y”</span></div><div class="line">     <span class="keyword">do</span> y ← x                      </div><div class="line">        <span class="keyword">if</span> key[z] &lt; key[x]  </div><div class="line">           then x ← left[x]  </div><div class="line">           <span class="keyword">else</span> x ← right[x]  </div><div class="line"> p[z] ← y                          <span class="comment">// 设置 “z的父亲” 为 “y”</span></div><div class="line"> <span class="keyword">if</span> y = nil[T]                     </div><div class="line">    then root[T] ← z               <span class="comment">// 情况1：若y是空节点，则将z设为根</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> key[z] &lt; key[y]        </div><div class="line">            then left[y] ← z       <span class="comment">// 情况2：若“z所包含的值” &lt; “y所包含的值”，则将z设为“y的左孩子”</span></div><div class="line">            <span class="keyword">else</span> right[y] ← z      <span class="comment">// 情况3：(“z所包含的值” &gt;= “y所包含的值”)将z设为“y的右孩子” </span></div><div class="line"> left[z] ← nil[T]                  <span class="comment">// z的左孩子设为空</span></div><div class="line"> right[z] ← nil[T]                 <span class="comment">// z的右孩子设为空。至此，已经完成将“节点z插入到二叉树”中了。</span></div><div class="line"> color[z] ← RED                    <span class="comment">// 将z着色为“红色”</span></div><div class="line"> RB-INSERT-FIXUP(T, z)             <span class="comment">// 通过RB-INSERT-FIXUP对红黑树的节点进行颜色修改以及旋转，让树T仍然是一颗红黑树</span></div></pre></td></tr></table></figure><p>结合伪代码以及为代码上面的说明，先理解RB-INSERT。理解了RB-INSERT之后，我们接着对 RB-INSERT-FIXUP的伪代码进行说明。</p><p>添加修正操作的伪代码《算法导论》</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">RB-INSERT-FIXUP(T, z)</div><div class="line">while color[p[z]] = RED                                                  // 若“当前节点(z)的父节点是红色”，则进行以下处理。</div><div class="line">    do if p[z] = left[p[p[z]]]                                           // 若“z的父节点”是“z的祖父节点的左孩子”，则进行以下处理。</div><div class="line">          then y ← right[p[p[z]]]                                        // 将y设置为“z的叔叔节点(z的祖父节点的右孩子)”</div><div class="line">               if color[y] = RED                                         // Case 1条件：叔叔是红色</div><div class="line">                  then color[p[z]] ← BLACK                    ▹ Case 1   //  (01) 将“父节点”设为黑色。</div><div class="line">                       color[y] ← BLACK                       ▹ Case 1   //  (02) 将“叔叔节点”设为黑色。</div><div class="line">                       color[p[p[z]]] ← RED                   ▹ Case 1   //  (03) 将“祖父节点”设为“红色”。</div><div class="line">                       z ← p[p[z]]                            ▹ Case 1   //  (04) 将“祖父节点”设为“当前节点”(红色节点)</div><div class="line">                  else if z = right[p[z]]                                // Case 2条件：叔叔是黑色，且当前节点是右孩子</div><div class="line">                          then z ← p[z]                       ▹ Case 2   //  (01) 将“父节点”作为“新的当前节点”。</div><div class="line">                               LEFT-ROTATE(T, z)              ▹ Case 2   //  (02) 以“新的当前节点”为支点进行左旋。</div><div class="line">                          color[p[z]] ← BLACK                 ▹ Case 3   // Case 3条件：叔叔是黑色，且当前节点是左孩子。(01) 将“父节点”设为“黑色”。</div><div class="line">                          color[p[p[z]]] ← RED                ▹ Case 3   //  (02) 将“祖父节点”设为“红色”。</div><div class="line">                          RIGHT-ROTATE(T, p[p[z]])            ▹ Case 3   //  (03) 以“祖父节点”为支点进行右旋。</div><div class="line">       else (same as then clause with &quot;right&quot; and &quot;left&quot; exchanged)      // 若“z的父节点”是“z的祖父节点的右孩子”，将上面的操作中“right”和“left”交换位置，然后依次执行。</div><div class="line">color[root[T]] ← BLACK</div></pre></td></tr></table></figure><p>根据被插入节点的父节点的情况，可以将”当节点z被着色为红色节点，并插入二叉树”划分为三种情况来处理。</p><ul><li>第一种情况说明：被插入的节点是根节点。处理方法：直接把此节点涂为黑色。</li><li>第二种情况说明：被插入的节点的父节点是黑色。处理方法：什么也不需要做。节点被插入后，仍然是红黑树。</li><li>第三种情况说明：被插入的节点的父节点是红色。处理方法：那么，该情况与红黑树的“特性(5)”相冲突。这种情况下，被插入节点是一定存在非空祖父节点的；进一步的讲，被插入节点也一定存在叔叔节点(即使叔叔节点为空，我们也视之为存在，空节点本身就是黑色节点)。理解这点之后，我们依据”叔叔节点的情况”，将这种情况进一步划分为3种情况(Case)。<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-18 下午9.31.32.png" alt="屏幕快照 2017-08-18 下午9.31.32"></li></ul><p>上面三种情况(Case)处理问题的核心思路都是：将红色的节点移到根节点；然后，将根节点设为黑色。下面对它们详细进行介绍。</p><blockquote><p>Case 1：叔叔是红色</p></blockquote><p>现象说明：当前节点(即，被插入节点)的父节点是红色，且当前节点的祖父节点的另一个子节点（叔叔节点）也是红色。</p><p>处理策略</p><ol><li>将“父节点”设为黑色。</li><li>将“叔叔节点”设为黑色。</li><li>将“祖父节点”设为“红色”。</li><li>将“祖父节点”设为“当前节点”(红色节点)；即，之后继续对“当前节点”进行操作。</li></ol><p>下面谈谈为什么要这样处理。(建议理解的时候，通过下面的图进行对比)</p><p>“当前节点”和“父节点”都是红色，违背“特性(4)”。所以，将“父节点”设置“黑色”以解决这个问题。</p><p>但是，将“父节点”由“红色”变成“黑色”之后，违背了“特性(5)”：因为，包含“父节点”的分支的黑色节点的总数增加了1。  解决这个问题的办法是：将“祖父节点”由“黑色”变成红色，同时，将“叔叔节点”由“红色”变成“黑色”。关于这里，说明几点：第一，为什么“祖父节点”之前是黑色？这个应该很容易想明白，因为在变换操作之前，该树是红黑树，“父节点”是红色，那么“祖父节点”一定是黑色。 第二，为什么将“祖父节点”由“黑色”变成红色，同时，将“叔叔节点”由“红色”变成“黑色”；能解决“包含‘父节点’的分支的黑色节点的总数增加了1”的问题。这个道理也很简单。“包含‘父节点’的分支的黑色节点的总数增加了1” 同时也意味着 “包含‘祖父节点’的分支的黑色节点的总数增加了1”，既然这样，我们通过将“祖父节点”由“黑色”变成“红色”以解决“包含‘祖父节点’的分支的黑色节点的总数增加了1”的问题； 但是，这样处理之后又会引起另一个问题“包含‘叔叔’节点的分支的黑色节点的总数减少了1”，现在我们已知“叔叔节点”是“红色”，将“叔叔节点”设为“黑色”就能解决这个问题。 所以，将“祖父节点”由“黑色”变成红色，同时，将“叔叔节点”由“红色”变成“黑色”；就解决了该问题。</p><p>按照上面的步骤处理之后：当前节点、父节点、叔叔节点之间都不会违背红黑树特性，但祖父节点却不一定。若此时，祖父节点是根节点，直接将祖父节点设为“黑色”，那就完全解决这个问题了；若祖父节点不是根节点，那我们需要将“祖父节点”设为“新的当前节点”，接着对“新的当前节点”进行分析。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15030632250739.jpg" alt=""></p><blockquote><p>Case 2：叔叔是黑色，且当前节点是右孩子</p></blockquote><p>现象说明：当前节点(即，被插入节点)的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的右孩子</p><p>处理策略</p><ol><li>将“父节点”作为“新的当前节点”。</li><li>以“新的当前节点”为支点进行左旋。</li></ol><p>下面谈谈为什么要这样处理。(建议理解的时候，通过下面的图进行对比)</p><p>首先，将“父节点”作为“新的当前节点”；接着，以“新的当前节点”为支点进行左旋。 为了便于理解，我们先说明第(02)步，再说明第(01)步；为了便于说明，我们设置“父节点”的代号为F(Father)，“当前节点”的代号为S(Son)。</p><p>为什么要“以F为支点进行左旋”呢？根据已知条件可知：S是F的右孩子。而之前我们说过，我们处理红黑树的核心思想：将红色的节点移到根节点；然后，将根节点设为黑色。既然是“将红色的节点移到根节点”，那就是说要不断的将破坏红黑树特性的红色节点上移(即向根方向移动)。 而S又是一个右孩子，因此，我们可以通过“左旋”来将S上移！ </p><p>按照上面的步骤(以F为支点进行左旋)处理之后：若S变成了根节点，那么直接将其设为“黑色”，就完全解决问题了；若S不是根节点，那我们需要执行步骤(01)，即“将F设为‘新的当前节点’”。那为什么不继续以S为新的当前节点继续处理，而需要以F为新的当前节点来进行处理呢？这是因为“左旋”之后，F变成了S的“子节点”，即S变成了F的父节点；而我们处理问题的时候，需要从下至上(由叶到根)方向进行处理；也就是说，必须先解决“孩子”的问题，再解决“父亲”的问题；所以，我们执行步骤(01)：将“父节点”作为“新的当前节点”。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15030632924092.jpg" alt=""></p><blockquote><p>Case 3：叔叔是黑色，且当前节点是左孩子</p></blockquote><p>现象说明：当前节点(即，被插入节点)的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子</p><p>处理策略</p><ol><li>将“父节点”设为“黑色”。</li><li>将“祖父节点”设为“红色”。</li><li>以“祖父节点”为支点进行右旋。</li></ol><p>下面谈谈为什么要这样处理。(建议理解的时候，通过下面的图进行对比)</p><p>为了便于说明，我们设置“当前节点”为S(Original Son)，“兄弟节点”为B(Brother)，“叔叔节点”为U(Uncle)，“父节点”为F(Father)，祖父节点为G(Grand-Father)。</p><p>S和F都是红色，违背了红黑树的“特性(4)”，我们可以将F由“红色”变为“黑色”，就解决了“违背‘特性(4)’”的问题；但却引起了其它问题：违背特性(5)，因为将F由红色改为黑色之后，所有经过F的分支的黑色节点的个数增加了1。那我们如何解决“所有经过F的分支的黑色节点的个数增加了1”的问题呢？ 我们可以通过“将G由黑色变成红色”，同时“以G为支点进行右旋”来解决。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15030633480303.jpg" alt=""></p><p>提示：上面的进行Case 3处理之后，再将节点”120”当作当前节点，就变成了Case 2的情况。</p><h2 id="四、红黑树的基本操作：删除"><a href="#四、红黑树的基本操作：删除" class="headerlink" title="四、红黑树的基本操作：删除"></a>四、红黑树的基本操作：删除</h2><p>将红黑树内的某一个节点删除。需要执行的操作依次是：首先，将红黑树当作一颗二叉查找树，将该节点从二叉查找树中删除；然后，通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。详细描述如下：</p><ul><li>第一步：将红黑树当作一颗二叉查找树，将节点删除。</li></ul><p>这和”删除常规二叉查找树中删除节点的方法是一样的”。分3种情况：</p><ol><li>被删除节点没有儿子，即为叶节点。那么，直接将该节点删除就OK了。</li><li>被删除节点只有一个儿子。那么，直接删除该节点，并用该节点的唯一子节点顶替它的位置。</li><li>被删除节点有两个儿子。那么，先找出它的后继节点；然后把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。在这里，后继节点相当于替身，在将后继节点的内容复制给”被删除节点”之后，再将后继节点删除。这样就巧妙的将问题转换为”删除后继节点”的情况了，下面就考虑后继节点。 在”被删除节点”有两个非空子节点的情况下，它的后继节点不可能是双子非空。既然”的后继节点”不可能双子都非空，就意味着”该节点的后继节点”要么没有儿子，要么只有一个儿子。若没有儿子，则按”情况① “进行处理；若只有一个儿子，则按”情况2”进行处理。</li></ol><ul><li>第二步：通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。</li></ul><p>因为”第一步”中删除节点之后，可能会违背红黑树的特性。所以需要通过”旋转和重新着色”来修正该树，使之重新成为一棵红黑树。</p><p>删除操作的伪代码《算法导论》</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">RB-DELETE(T, z)</div><div class="line">if left[z] = nil[T] or right[z] = nil[T]         </div><div class="line">   then y ← z                                  // 若“z的左孩子” 或 “z的右孩子”为空，则将“z”赋值给 “y”；</div><div class="line">   else y ← TREE-SUCCESSOR(z)                  // 否则，将“z的后继节点”赋值给 “y”。</div><div class="line">if left[y] ≠ nil[T]</div><div class="line">   then x ← left[y]                            // 若“y的左孩子” 不为空，则将“y的左孩子” 赋值给 “x”；</div><div class="line">   else x ← right[y]                           // 否则，“y的右孩子” 赋值给 “x”。</div><div class="line">p[x] ← p[y]                                    // 将“y的父节点” 设置为 “x的父节点”</div><div class="line">if p[y] = nil[T]                               </div><div class="line">   then root[T] ← x                            // 情况1：若“y的父节点” 为空，则设置“x” 为 “根节点”。</div><div class="line">   else if y = left[p[y]]                    </div><div class="line">           then left[p[y]] ← x                 // 情况2：若“y是它父节点的左孩子”，则设置“x” 为 “y的父节点的左孩子”</div><div class="line">           else right[p[y]] ← x                // 情况3：若“y是它父节点的右孩子”，则设置“x” 为 “y的父节点的右孩子”</div><div class="line">if y ≠ z                                    </div><div class="line">   then key[z] ← key[y]                        // 若“y的值” 赋值给 “z”。注意：这里只拷贝z的值给y，而没有拷贝z的颜色！！！</div><div class="line">        copy y&apos;s satellite data into z         </div><div class="line">if color[y] = BLACK                            </div><div class="line">   then RB-DELETE-FIXUP(T, x)                  // 若“y为黑节点”，则调用</div><div class="line">return y</div></pre></td></tr></table></figure><p>结合伪代码以及为代码上面的说明，先理解RB-DELETE。理解了RB-DELETE之后，接着对 RB-DELETE-FIXUP的伪代码进行说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">RB-DELETE-FIXUP(T, x)</div><div class="line">while x ≠ root[T] and color[x] = BLACK  </div><div class="line">    do if x = left[p[x]]      </div><div class="line">          then w ← right[p[x]]                                             // 若 “x”是“它父节点的左孩子”，则设置 “w”为“x的叔叔”(即x为它父节点的右孩子)                                          </div><div class="line">               if color[w] = RED                                           // Case 1: x是“黑+黑”节点，x的兄弟节点是红色。(此时x的父节点和x的兄弟节点的子节点都是黑节点)。</div><div class="line">                  then color[w] ← BLACK                        ▹  Case 1   //   (01) 将x的兄弟节点设为“黑色”。</div><div class="line">                       color[p[x]] ← RED                       ▹  Case 1   //   (02) 将x的父节点设为“红色”。</div><div class="line">                       LEFT-ROTATE(T, p[x])                    ▹  Case 1   //   (03) 对x的父节点进行左旋。</div><div class="line">                       w ← right[p[x]]                         ▹  Case 1   //   (04) 左旋后，重新设置x的兄弟节点。</div><div class="line">               if color[left[w]] = BLACK and color[right[w]] = BLACK       // Case 2: x是“黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色。</div><div class="line">                  then color[w] ← RED                          ▹  Case 2   //   (01) 将x的兄弟节点设为“红色”。</div><div class="line">                       x ←  p[x]                               ▹  Case 2   //   (02) 设置“x的父节点”为“新的x节点”。</div><div class="line">                  else if color[right[w]] = BLACK                          // Case 3: x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的。</div><div class="line">                          then color[left[w]] ← BLACK          ▹  Case 3   //   (01) 将x兄弟节点的左孩子设为“黑色”。</div><div class="line">                               color[w] ← RED                  ▹  Case 3   //   (02) 将x兄弟节点设为“红色”。</div><div class="line">                               RIGHT-ROTATE(T, w)              ▹  Case 3   //   (03) 对x的兄弟节点进行右旋。</div><div class="line">                               w ← right[p[x]]                 ▹  Case 3   //   (04) 右旋后，重新设置x的兄弟节点。</div><div class="line">                        color[w] ← color[p[x]]                 ▹  Case 4   // Case 4: x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的。(01) 将x父节点颜色 赋值给 x的兄弟节点。</div><div class="line">                        color[p[x]] ← BLACK                    ▹  Case 4   //   (02) 将x父节点设为“黑色”。</div><div class="line">                        color[right[w]] ← BLACK                ▹  Case 4   //   (03) 将x兄弟节点的右子节设为“黑色”。</div><div class="line">                        LEFT-ROTATE(T, p[x])                   ▹  Case 4   //   (04) 对x的父节点进行左旋。</div><div class="line">                        x ← root[T]                            ▹  Case 4   //   (05) 设置“x”为“根节点”。</div><div class="line">       else (same as then clause with &quot;right&quot; and &quot;left&quot; exchanged)        // 若 “x”是“它父节点的右孩子”，将上面的操作中“right”和“left”交换位置，然后依次执行。</div><div class="line">color[x] ← BLACK</div></pre></td></tr></table></figure><p>下面对删除函数进行分析。在分析之前，我们再次温习一下红黑树的几个特性：</p><ol><li>每个节点或者是黑色，或者是红色。</li><li>根节点是黑色。</li><li>每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！]</li><li>如果一个节点是红色的，则它的子节点必须是黑色的。</li><li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</li></ol><p>前面我们将”删除红黑树中的节点”大致分为两步，在第一步中”将红黑树当作一颗二叉查找树，将节点删除”后，可能违反”特性(2)、(4)、(5)”三个特性。第二步需要解决上面的三个问题，进而保持红黑树的全部特性。</p><p>为了便于分析，我们假设”x包含一个额外的黑色”(x原本的颜色还存在)，这样就不会违反”特性(5)”。为什么呢？</p><p>通过RB-DELETE算法，我们知道：删除节点y之后，x占据了原来节点y的位置。 既然删除y(y是黑色)，意味着减少一个黑色节点；那么，再在该位置上增加一个黑色即可。这样，当我们假设”x包含一个额外的黑色”，就正好弥补了”删除y所丢失的黑色节点”，也就不会违反”特性(5)”。 因此，假设”x包含一个额外的黑色”(x原本的颜色还存在)，这样就不会违反”特性(5)”。</p><p>现在，x不仅包含它原本的颜色属性，x还包含一个额外的黑色。即x的颜色属性是”红+黑”或”黑+黑”，它违反了”特性(1)”。</p><p>现在，我们面临的问题，由解决”违反了特性(2)、(4)、(5)三个特性”转换成了”解决违反特性(1)、(2)、(4)三个特性”。RB-DELETE-FIXUP需要做的就是通过算法恢复红黑树的特性(1)、(2)、(4)。RB-DELETE-FIXUP的思想是：将x所包含的额外的黑色不断沿树上移(向根方向移动)，直到出现下面的姿态：</p><ol><li>x指向一个”红+黑”节点。此时，将x设为一个”黑”节点即可。</li><li>x指向根。此时，将x设为一个”黑”节点即可。</li><li>非前面两种姿态。</li></ol><p>将上面的姿态，可以概括为3种情况。</p><ul><li>第一种情况说明：x是“红+黑”节点。处理方法：直接把x设为黑色，结束。此时红黑树性质全部恢复。</li><li>第二种情况说明：x是“黑+黑”节点，且x是根。处理方法：什么都不做，结束。此时红黑树性质全部恢复。</li><li>第三种情况说明：x是“黑+黑”节点，且x不是根。处理方法：这种情况又可以划分为4种子情况。这4种子情况如下表所示：</li></ul><p><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-08-18 下午9.39.41.png" alt="屏幕快照 2017-08-18 下午9.39.41"></p><blockquote><p>Case 1：x是”黑+黑”节点，x的兄弟节点是红色</p></blockquote><p>现象说明：x是”黑+黑”节点，x的兄弟节点是红色。(此时x的父节点和x的兄弟节点的子节点都是黑节点)。</p><p>处理策略</p><ol><li>将x的兄弟节点设为“黑色”。</li><li>将x的父节点设为“红色”。</li><li>对x的父节点进行左旋。</li><li>左旋后，重新设置x的兄弟节点。</li></ol><p>下面谈谈为什么要这样处理。(建议理解的时候，通过下面的图进行对比)</p><p>这样做的目的是将“Case 1”转换为“Case 2”、“Case 3”或“Case 4”，从而进行进一步的处理。对x的父节点进行左旋；左旋后，为了保持红黑树特性，就需要在左旋前“将x的兄弟节点设为黑色”，同时“将x的父节点设为红色”；左旋后，由于x的兄弟节点发生了变化，需要更新x的兄弟节点，从而进行后续处理。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15030636491500.jpg" alt=""></p><blockquote><p>Case 3：x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的</p></blockquote><p>现象说明：x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的。</p><p>处理策略</p><ol><li>将x兄弟节点的左孩子设为“黑色”。</li><li>将x兄弟节点设为“红色”。</li><li>对x的兄弟节点进行右旋。</li><li>右旋后，重新设置x的兄弟节点。</li></ol><p>下面谈谈为什么要这样处理。(建议理解的时候，通过下面的图进行对比)</p><p>我们处理“Case 3”的目的是为了将“Case 3”进行转换，转换成“Case 4”,从而进行进一步的处理。转换的方式是对x的兄弟节点进行右旋；为了保证右旋后，它仍然是红黑树，就需要在右旋前“将x的兄弟节点的左孩子设为黑色”，同时“将x的兄弟节点设为红色”；右旋后，由于x的兄弟节点发生了变化，需要更新x的兄弟节点，从而进行后续处理。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15030636989746.jpg" alt=""></p><blockquote><p>Case 4：x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色</p></blockquote><p>现象说明：x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色。</p><p>处理策略</p><ol><li>将x父节点颜色 赋值给 x的兄弟节点。</li><li>将x父节点设为“黑色”。</li><li>将x兄弟节点的右子节设为“黑色”。</li><li>对x的父节点进行左旋。</li><li>设置“x”为“根节点”。</li></ol><p>下面谈谈为什么要这样处理。(建议理解的时候，通过下面的图进行对比)</p><p>我们处理“Case 4”的目的是：去掉x中额外的黑色，将x变成单独的黑色。处理的方式是“：进行颜色修改，然后对x的父节点进行左旋。下面，我们来分析是如何实现的。</p><p>为了便于说明，我们设置“当前节点”为S(Original Son)，“兄弟节点”为B(Brother)，“兄弟节点的左孩子”为BLS(Brother’s Left Son)，“兄弟节点的右孩子”为BRS(Brother’s Right Son)，“父节点”为F(Father)。</p><p>我们要对F进行左旋。但在左旋前，我们需要调换F和B的颜色，并设置BRS为黑色。为什么需要这里处理呢？因为左旋后，F和BLS是父子关系，而我们已知BL是红色，如果F是红色，则违背了“特性(4)”；为了解决这一问题，我们将“F设置为黑色”。 但是，F设置为黑色之后，为了保证满足“特性(5)”，即为了保证左旋之后：</p><ul><li>第一，“同时经过根节点和S的分支的黑色节点个数不变”。若满足“第一”，只需要S丢弃它多余的颜色即可。因为S的颜色是“黑+黑”，而左旋后“同时经过根节点和S的分支的黑色节点个数”增加了1；现在，只需将S由“黑+黑”变成单独的“黑”节点，即可满足“第一”。</li><li>第二，“同时经过根节点和BLS的分支的黑色节点数不变”。若满足“第二”，只需要将“F的原始颜色”赋值给B即可。之前，我们已经将“F设置为黑色”(即，将B的颜色”黑色”，赋值给了F)。至此，我们算是调换了F和B的颜色。</li><li>第三，“同时经过根节点和BRS的分支的黑色节点数不变”。在“第二”已经满足的情况下，若要满足“第三”，只需要将BRS设置为“黑色”即可。</li></ul><p>经过，上面的处理之后。红黑树的特性全部得到的满足！接着，我们将x设为根节点，就可以跳出while循环(参考伪代码)；即完成了全部处理。</p><p>至此，我们就完成了Case 4的处理。理解Case 4的核心，是了解如何“去掉当前节点额外的黑色”。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15030638085415.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;红黑树，即R-B Tree，本文的主要内容包括：红黑树的特性、红黑树的时间复杂度和它的证明，红黑树的时间复杂度和它的证明，红黑树的左旋、右旋、插入、删除等操作&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
      <category term="红黑树" scheme="http://yoursite.com/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>机器学习算法系列（28）：L1、L2正则化</title>
    <link href="http://yoursite.com/2017/07/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%8828%EF%BC%89%EF%BC%9AL1%E3%80%81L2%E6%AD%A3%E5%88%99%E5%8C%96/"/>
    <id>http://yoursite.com/2017/07/22/机器学习算法系列（28）：L1、L2正则化/</id>
    <published>2017-07-22T15:14:45.000Z</published>
    <updated>2017-12-26T08:27:56.295Z</updated>
    
    <content type="html"><![CDATA[<p>之前讨论了机器学习中的偏差-方差权衡。机器学习里的损失函数（代价函数）可以用来描述模型与真模型（ground truth）之间的差距，因此可以解决“偏差”的问题。但是仅有损失函数，我们无法解决方差的问题，因而会有过拟合风险。</p><a id="more"></a><p>这次我们讨论损失函数的反面——正则项，看看L1正则项和L2正则项是如何使机器学习模型避免过拟合的。</p><p>我们希望选择或学习一个合适的模型。若在空间中存在“真模型”，那我们所选择的模型要与真模型的参数个数相同，所选择的模型的参数向量与真模型的参数向量相近。</p><p>过拟合指的是我们以为追求提高模型对训练数据的预测能力，所选模型的复杂度往往会比真模型更高。即学习时选择的模型所包含的参数过多，以致于出现这一模型对已知数据预测得很好，但对未知数据预测得很差的现象。</p><h2 id="一、从经验风险最小化到结构经验最小化"><a href="#一、从经验风险最小化到结构经验最小化" class="headerlink" title="一、从经验风险最小化到结构经验最小化"></a>一、从经验风险最小化到结构经验最小化</h2><p>经验风险最小化（empirical risk minimization）认为经验风险最小的模型是最优的模型，即求解最优化问题：</p><script type="math/tex; mode=display">\underset{f\in\mathscr{F}}{\min}\frac{1}{N}\sum_{i=1}^N{L\left(y_i,f\left(x_i\right)\right)}</script><p>当样本容量足够大的时候，经验风险最小化学习效果良好。比如极大似然估计，当模型是条件概率分布，损失函数是对数损失函数时，经验风险最小化就等价于极大似然估计。</p><p>但是当样本容量很小时，经验风险最小化学习会产生过拟合（over-fitting）的现象。这就引出了结构风险最小化，它等价于正则化（regularization）。结构风险在经验风险上加上表示模型复杂度的正则化项（regularizer）或罚项（penalty term），它的定义为：</p><script type="math/tex; mode=display">R_{srm}\left(f\right)=\frac{1}{N}\sum_{i=1}^N{L\left(y_i,f\left(x_i\right)\right)}+\lambda J\left(f\right)</script><p>其中$J(f)$为模型的复杂度，模型$f$越复杂，复杂度$J(f)$就越大；反之，模型越简单，复杂度$J(f)$就越小，即复杂度表示了对复杂模型的惩罚。$\lambda≥0$是系数，用以权衡经验风险和模型复杂度。结构风险小需要经验风险和模型复杂度同时小。结构风险小的模型往往对训练数据以及未知的测试数据都有较好的预测。比如贝叶斯估计中的最大后验概率估计就是结构风险最小化的一个例子。当模型是条件概率分布、损失函数是对数损失函数、模型复杂度由模型的先验概率表示时，结构风险最小化就等价于最大后验概率估计。<br>结构风险最小化的策略认为结构风险最小的模型是最优的模型，求解最优模型即求解最优化问题：</p><script type="math/tex; mode=display">\min_{f\in\mathscr{F}}\frac{1}{N}\sum_{i=1}^N{L\left(y_i,f\left(x_i\right)\right)}+\lambda J\left(f\right)</script><p>这样，监督学习问题变成了经验风险或结构风险函数的最优化问题。</p><p>其中正则化是结构风险最小化策略的实现，是在经验风险上加一个正则化项或罚项。正则化项一般是模型复杂度的单调递增函数，模型越复杂，正则化值就越大。比如，正则化项可以是模型参数向量的范数。它的一般形式如下：</p><script type="math/tex; mode=display">\min_{f\in\mathscr{F}}\frac{1}{N}\sum_{i=1}^N{L\left(y_i,f\left(x_i\right)\right)}+\lambda J\left(f\right)</script><p>第一项是经验风险，第二项是正则化项，$\lambda≥0$为调整两者之间关系的系数。</p><h2 id="二、范数与正则项"><a href="#二、范数与正则项" class="headerlink" title="二、范数与正则项"></a>二、范数与正则项</h2><p>在线性代数、函数分析等数学分支中，范数（Norm）是一个函数，其赋予某个向量空间（或矩阵）中的每个向量以长度或大小。对于零向量，另其长度为零。直观的说，向量或矩阵的范数越大，则我们可以说这个向量或矩阵也就越大。有时范数有很多更为常见的叫法，如绝对值其实便是一维向量空间中实数或复数的范数，而Euclidean距离也是一种范数。</p><p>范数满足通常意义上长度的三个基本性质：</p><ul><li>非负性：$||\vec{x}||≥0$</li><li>齐次性：$||c·\vec{x}||=|c|||\vec{x}||$</li><li>三角不等式：$||\vec{x}+\vec{y}||≤||\vec{x}||+||\vec{y}||$</li></ul><p>在这里，我们需要关注的最主要是范数的「非负性」。我们刚才讲，损失函数通常是一个有下确界的函数。而这个性质保证了我们可以对损失函数做最优化求解。如果我们要保证目标函数依然可以做最优化求解，那么我们就必须让正则项也有一个下界。非负性无疑提供了这样的下界，而且它是一个下确界——由齐次性保证（当 c=0 时）。</p><p>因此，我们说，范数的性质使得它天然地适合作为机器学习的正则项。而范数需要的向量，则是机器学习的学习目标——参数向量。</p><p>范数的一般化定义：设$p≥1$的实数，$p-norm$定义为：</p><script type="math/tex; mode=display">||x||_p:=(\sum_{i=1}^n|x_i|^p)^{\frac{1}{p}}  \ \ \  \ （1）</script><p>机器学习中有几个常用的范数，分别是：</p><ul><li>$L_1-$范数：$||x⃗ ||=∑^d_{i=1}| x_i|$;</li><li>$L_2-$范数：$||x⃗ ||_2=(∑^d_{i=1}x^2_i)^{1/2}$；</li><li>$L_p-$范数：$||x||_p=(\sum_{i=1}^n|x_i|^p)^{\frac{1}{p}}$</li><li>$L_∞-$范数：$||x⃗ ||_∞=lim_{p→+∞}(∑^d_{i=1}x^p_i)^{1/p}$。</li></ul><p>当p=1时，我们称之为taxicab Norm，也叫Manhattan Norm。其来源是曼哈顿的出租车司机在四四方方的曼哈顿街道中从一点到另一点所需要走过的距离。也即我们所要讨论的l1范数。其表示某个向量中所有元素绝对值的和。</p><p>而当p=2时，则是我们最为常见的Euclidean norm。也称为Euclidean distance。也即我们要讨论的l2范数。 </p><p>而当p=0时，因其不再满足三角不等性，严格的说此时p已不算是范数了，但很多人仍然称之为l0范数。 这三个范数有很多非常有意思的特征，尤其是在机器学习中的正则化（Regularization）以及稀疏编码（Sparse Coding）有非常有趣的应用。</p><p>下图给出了一个Lp球的形状随着P的减少的可视化图。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15008845934277.png" alt=""></p><p>在机器学习中，如果使用了$||\vec{w}||_p作为正则项$，则我们说，该机器学习任务引入了$L_p-$正则项。</p><h3 id="2-1-L-0-与-L-1-正则项（LASSO-regularizer）"><a href="#2-1-L-0-与-L-1-正则项（LASSO-regularizer）" class="headerlink" title="2.1 $L_0$与$L_1-$正则项（LASSO regularizer）"></a>2.1 $L_0$与$L_1-$正则项（LASSO regularizer）</h3><p>在机器学习里，最简单的学习算法可能是所谓的线性回归模型</p><script type="math/tex; mode=display">F(x⃗ ;w⃗ ,b)=∑_{i=1}^nw_i⋅x_i+b</script><p>我们考虑这样一种普遍的情况，即：预测目标背后的真是规律，可能只和某几个维度的特征有关；而其它维度的特征，要不然作用非常小，要不然纯粹是噪声。在这种情况下，除了这几个维度的特征对应的参数之外，其它维度的参数应该为零。若不然，则当其它维度的特征存在噪音时，模型的行为会发生预期之外的变化，导致过拟合。</p><p>于是，我们得到了避免过拟合的第一个思路：使尽可能多的参数为零。为此，最直观地我们可以引入$L_0$-范数。令</p><script type="math/tex; mode=display">Ω(F(x⃗ ;w⃗ ))\overset{def}=ℓ_0\frac{∥w⃗ ∥_0}{n},ℓ_0>0</script><p>这意味着，我们希望绝大多数$\vec{w}$的分量为零。</p><p>通过引入 $L_0-$正则项，我们实际上引入了一种「惩罚」机制，即：若要增加模型复杂度以加强模型的表达能力降低损失函数，则每次使得一个参数非零，则引入 $ℓ_0$ 的惩罚系数。也就是说，如果使得一个参数非零得到的收益（损失函数上的收益）不足 $ℓ_0$；那么增加这样的复杂度是得不偿失的。</p><p>通过引入$L_0-$正则项，我们可以使模型稀疏化且易于解释，并且在某种意义上实现了「特征选择」。这看起来很美好，但是 $L_0-$正则项也有绕不过去坎：</p><ul><li>非连续</li><li>非凸</li><li>不可求导</li></ul><p>因此，$L_0$正则项虽好，但是求解这样的最优化问题，难以在多项式时间内找到有效解（NP-Hard 问题）。于是，我们转而考虑 L0L0-范数最紧的凸放松（tightest convex relaxation）：L1-范数。令</p><script type="math/tex; mode=display">Ω(F(x⃗ ;w⃗ ))\overset{def}{=}ℓ_1\frac{∥w⃗ ∥_1}{n},ℓ_1>0</script><p>我们来看一下参数更新的过程，有哪些变化。考虑目标函数</p><script type="math/tex; mode=display">Obj(F)=L(F)+γ⋅ℓ_1\frac{∥w⃗ ∥_1}{n}</script><p>对参数$w_i$求偏导数</p><script type="math/tex; mode=display">\frac{∂Obj}{∂w_i}=\frac{∂L}{∂w_i}+\frac{γℓ_1}{n}sgn(w_i)</script><p>因此参数更新的过程为</p><script type="math/tex; mode=display">w_i→w′_i\overset{def}{=}w_i−η\frac{∂L}{∂w_i}−η\frac{γℓ_1}{n}sgn(w_i)</script><p>因为$η\frac{γℓ_1}{n}&gt;0$所以多出的项$η\frac{γℓ_1}{n}sgn(w_i)$使得$w_i→0$，实现稀疏化。</p><h3 id="2-2-L-2-正则项（Ridge-Regularizer）"><a href="#2-2-L-2-正则项（Ridge-Regularizer）" class="headerlink" title="2.2 $L_2$正则项（Ridge Regularizer）"></a>2.2 $L_2$正则项（Ridge Regularizer）</h3><p>让我们回过头，考虑多项式模型，它的一般形式为：</p><script type="math/tex; mode=display">F=∑_{i=1}^nw_i⋅x^i+b</script><p>我们注意到，当多项式模型过拟合时，函数曲线倾向于靠近噪声点。这意味着，函数曲线会在噪声点之间来回扭曲跳跃。这也就是说，在某些局部，函数曲线的切线斜率会非常高（函数导数的绝对值非常大）。对于多项式模型来说，函数导数的绝对值，实际上就是多项式系数的一个线性加和。这也就是说，过拟合的多项式模型，它的参数的绝对值会非常大（至少某几个参数分量的绝对值非常大）。因此，如果我们有办法使得这些参数的值，比较稠密均匀地集中在0附近，就能有效地避免过拟合。</p><p>于是我们引入$L_2-$正则项，令</p><script type="math/tex; mode=display">Ω(F(x⃗ ;w⃗ ))\overset{def}=ℓ_2\frac{∥w⃗ ∥_2 }{2n},ℓ_2>0</script><p>因此有目标函数</p><script type="math/tex; mode=display">Obj(F)=L(F)+γ⋅ℓ_2\frac{∥w⃗ ∥_2 }{2n}</script><p>对参数$w_i$求偏导数，有</p><script type="math/tex; mode=display">\frac{∂Obj}{∂w_i}=\frac{∂L}{∂w_i}+\frac{γℓ_2}{n}w_i</script><p>再有参数更新</p><script type="math/tex; mode=display">w_i→w′_i\overset{def}{=}w_i−η\frac{∂L}{∂w_i}−η\frac{γℓ_2}{n}w_i=(1−η\frac{γℓ_2}n)w_i−η\frac{∂L}{∂w_i}</script><p>考虑到$η\frac{γℓ_2}{n}&gt;0$，因此，引入$L_2-$正则项之后，相当于衰减了（decay）参数的权重，使参数趋近于0。</p><h3 id="2-3-L-1-正则项与-L-2-正则项的区别"><a href="#2-3-L-1-正则项与-L-2-正则项的区别" class="headerlink" title="2.3 $L_1-$正则项与$L_2-$正则项的区别"></a>2.3 $L_1-$正则项与$L_2-$正则项的区别</h3><p>现在，我们考虑这样一个问题：为什么使用$L-1-$正则项，会倾向于使得参数稀疏化；而使用$L_2-$正则项，会倾向于使得参数稠密地接近于0？</p><p>这里引用一张来自周志华老师的著作，《机器学习》（西瓜书）里的插图，尝试解释这个问题。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15008845171281.png" alt=""></p><p>为了简便起见，我们只考虑模型有两个参数$w_1$和$w_2$的情形。</p><p>在图中，我们有三组等值线，位于同一条等值线上的$w_1$与$w_2$映射到相同的平方损失项、$L_1-$范数和$L_2-$范数。并且，对于三组等值线来说，当$(w_1,w_2)$沿着等值线法线方向，向外扩张，则对应的值增大；反之，若沿着法线向内收缩，则对应的值减小。</p><p>因此，对于目标函数$Obj(F)$来说，实际上是要在正则项的等值线与损失函数的等值线中寻找一个交点，使得二者的和最小。</p><p>对于$L_1-$正则项来说，因为$L_1-$正则项是一组菱形，这些交点容易落在坐标轴上。因此，另一个参数的值在这个交点上就是0，从而实现了稀疏化。</p><p>对于 $L_2-$正则项来说，因为 $L_2-$正则项的等值线是一组圆形。所以，这些交点可能落在整个平面的任意位置。所以它不能实现「稀疏化」。但是，另一方面，由于 $(w_1,w_2)$ 落在圆上，所以它们的值会比较接近。这就是为什么 $L_2-$正则项可以使得参数在零附近稠密而平滑。</p><h2 id="三、贝叶斯先验"><a href="#三、贝叶斯先验" class="headerlink" title="三、贝叶斯先验"></a>三、贝叶斯先验</h2><p>从贝叶斯的角度来看，正则化等价于对模型参数引入先验分布。</p><h3 id="3-1-Linear-Regression"><a href="#3-1-Linear-Regression" class="headerlink" title="3.1 Linear Regression"></a>3.1 Linear Regression</h3><p>我们先看下最原始的线性回归：<br><img src="http://omu7tit09.bkt.clouddn.com/15008831241254.png" alt=""></p><script type="math/tex; mode=display">\begin{align*} & p(\epsilon^{(i)})  = \frac{1}{\sqrt{2\pi}\delta}exp\left(  -\frac{(\epsilon^{(i)})^2}{2\delta^2} \right)\\ \Rightarrow & p(y^{(i)}|x^{(i)};\theta) = \frac{1}{\sqrt{2\pi}\delta}exp\left( -\frac{(y^{(i)} - w^Tx^{(i)})^2}{2\delta^2}  \right)\end{align*}</script><p>由最大似然估计（MLE）：</p><script type="math/tex; mode=display">\begin{align*}L(w) & = p(\vec{y}|X;w)\\& = \prod_{i=1}^{m} p(y^{(i)}|x^{(i)};\theta)\\& = \prod_{i=1}^{m} \frac{1}{\sqrt{2\pi}\delta}exp\left( -\frac{(y^{(i)} - w^Tx^{(i)})^2}{2\delta^2}  \right)\end{align*}</script><p>取对数：</p><script type="math/tex; mode=display">\begin{align*}l(w) & = \log L(w)\\& =\log \prod_{i=1}^{m} \frac{1}{\sqrt{2\pi}\delta}exp\left( -\frac{(y^{(i)} - w^Tx^{(i)})}{2\delta^2}  \right)\\& = \sum_{i=1}^{m} \log \frac{1}{\sqrt{2\pi}\delta}exp\left( -\frac{(y^{(i)} - w^Tx^{(i)})^2}{2\delta^2}  \right)\\& = m \log \frac{1}{\sqrt{2\pi}\delta} - \frac{1}{\delta^2}\cdot \frac{1}{2} \sum_{i=1}^{m} (y^{(i)} - w^Tx^{(i)})^2\end{align*}</script><p>即</p><script type="math/tex; mode=display">w_{MLE} = \arg \underset{w}{\min} \sum_{i=1}^{m} (y^{(i)} - w^Tx^{(i)})^2</script><p>这就导出了我们最原始的$least-squares$损失函数，但这是在我们对参数$w$没有加入任何先验分布的情况下。在数据维度很高的情况下，我们的模型参数很多，模型复杂度高，容易发生过拟合。</p><p>比如我们常说的 “small n, large p problem”。（我们一般用 n 表示数据点的个数，用 p 表示变量的个数 ，即数据维度。当  的时候，不做任何其他假设或者限制的话，学习问题基本上是没法进行的。因为如果用上所有变量的话， p 越大，通常会导致模型越复杂，但是反过来 n 又很小，于是就会出现很严重的 overfitting 问题。Linear regression一般只对low dimension适用，比如n=50, p=5，而且这五个变量还不存在multicolinearity.<br><img src="http://omu7tit09.bkt.clouddn.com/15008831886499.png" alt=""></p><p>这个时候，我们可以对参数$w$引入先验分布，降低模型复杂度。</p><h3 id="3-2-Ridge-Regression"><a href="#3-2-Ridge-Regression" class="headerlink" title="3.2 Ridge Regression"></a>3.2 Ridge Regression</h3><p>Ridge Regression的提出就是为了解决multicolinearity的，加一个L2 penalty term也是因为算起来方便。然而它并不能shrink parameters to 0.所以没法做variable selection。</p><p>我们对参数 w 引入协方差为 $\alpha$ 的零均值高斯先验。<br><img src="http://omu7tit09.bkt.clouddn.com/15008832011388.jpg" alt=""></p><p>取对数：<br><img src="http://omu7tit09.bkt.clouddn.com/15008832214560.jpg" alt=""></p><p>等价于：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15008832817463.jpg" alt=""><br>这不就是Ridge Regression吗？<br><img src="http://omu7tit09.bkt.clouddn.com/15008832999831.png" alt=""><br>看我们得到的参数，在零附近是不是很密集，老实说 ridge regression 并不具有产生稀疏解的能力，也就是说参数并不会真出现很多零。假设我们的预测结果与两个特征相关，L2正则倾向于综合两者的影响，给影响大的特征赋予高的权重；而L1正则倾向于选择影响较大的参数，而舍弃掉影响较小的那个。实际应用中 L2正则表现往往会优于 L1正则，但 L1正则会大大降低我们的计算量。</p><blockquote><p>Typically ridge or ℓ2 penalties are <strong>much better</strong> for minimizing prediction error rather than ℓ1 penalties. The reason for this is that when two predictors are highly correlated, ℓ1 regularizer will simply pick one of the two predictors. In contrast, the ℓ2 regularizer will keep both of them and jointly shrink the corresponding coefficients a little bit. Thus, while the ℓ1 penalty can certainly reduce overfitting, you may also experience a loss in predictive power.</p></blockquote><p>那现在我们知道了，对参数引入 高斯先验 等价于L2正则化。</p><h3 id="3-3-LASSO"><a href="#3-3-LASSO" class="headerlink" title="3.3 LASSO"></a>3.3 LASSO</h3><p>LASSO是针对Ridge Regression的没法做variable selection的问题提出来的，L1 penalty虽然算起来麻烦，没有解析解，但是可以把某些系数shrink到0。</p><p>在Ridge Regression中，我们对 w 引入了高斯分布，那么拉普拉斯分布(Laplace distribution)呢？</p><p>注：LASSO - least absolute shrinkage and selection operator.<br><img src="http://omu7tit09.bkt.clouddn.com/15008835165358.png" alt=""></p><p>我们看下拉普拉斯分布长啥样：<br><img src="http://omu7tit09.bkt.clouddn.com/15008835341132.jpg" alt=""></p><p><img src="http://omu7tit09.bkt.clouddn.com/15008835458006.png" alt=""><br>关于拉普拉斯和正态分布的渊源，大家可以参见 正态分布的前世今生。<br>重复之前的推导过程我们很容易得到：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15008835638203.jpg" alt=""><br>该问题通常被称为 LASSO (least absolute shrinkage and selection operator) 。LASSO 仍然是一个 convex optimization 问题，不具有解析解。它的优良性质是能产生稀疏性，导致 w 中许多项变成零。</p><p>再次总结下，对参数引入 拉普拉斯先验 等价于 L1正则化。</p><h3 id="3-4-Elastic-Net"><a href="#3-4-Elastic-Net" class="headerlink" title="3.4 Elastic Net"></a>3.4 Elastic Net</h3><p>然而LASSO虽然可以做variable selection，但是不consistent啊，而且当n很小时至多只能选出n个变量；而且不能做group selection。</p><p>可能有同学会想，既然 L1和 L2正则各自都有自己的优势，那我们能不能将他们 combine 起来？</p><p>于是有了在L1和L2 penalty之间做个权重就是elastic net</p><p><img src="http://omu7tit09.bkt.clouddn.com/15008836000503.png" alt=""><br>因为lasso在解决之前提到的“small n, large p problem”存在一定缺陷。<br><img src="http://omu7tit09.bkt.clouddn.com/15008836178996.png" alt=""></p><p>得到结果：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15008836391269.jpg" alt=""></p><p><img src="http://omu7tit09.bkt.clouddn.com/15008836498017.png" alt=""><br><img src="http://omu7tit09.bkt.clouddn.com/15008836608354.png" alt=""></p><p>此外针对不consistent有了adaptive lasso，针对不能做group selection有了group lasso, 在graphical models里有了graphical lasso。然后有人说unbiasedness, sparsity and continuity这三条都满足多好，于是有了MCP和SCAD同时满足这三条性质。还有很多penalized regression的方法。</p><h3 id="3-5-总结"><a href="#3-5-总结" class="headerlink" title="3.5 总结"></a>3.5 总结</h3><p><img src="http://omu7tit09.bkt.clouddn.com/15008840329778.png" alt=""></p><p>正则化参数等价于对参数引入 先验分布，使得 模型复杂度 变小（缩小解空间），对于噪声以及 outliers 的鲁棒性增强（泛化能力）。整个最优化问题从贝叶斯观点来看是一种贝叶斯最大后验估计，其中 正则化项对应后验估计中的先验信息，损失函数对应后验估计中的似然函数，两者的乘积即对应贝叶斯最大后验估计的形式。</p><p>这篇文章从理论推导讲到算法实现。除了高斯先验、拉普拉斯先验，还讲了其他先验：<br>Lazy Sparse Stochastic Gradient Descent for Regularized Mutlinomial Logistic Regression</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前讨论了机器学习中的偏差-方差权衡。机器学习里的损失函数（代价函数）可以用来描述模型与真模型（ground truth）之间的差距，因此可以解决“偏差”的问题。但是仅有损失函数，我们无法解决方差的问题，因而会有过拟合风险。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="L1正则" scheme="http://yoursite.com/tags/L1%E6%AD%A3%E5%88%99/"/>
    
      <category term="L2正则" scheme="http://yoursite.com/tags/L2%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法（7）：数据库索引原理及优化</title>
    <link href="http://yoursite.com/2017/07/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%887%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2017/07/21/数据结构与算法（7）：数据库索引原理及优化/</id>
    <published>2017-07-21T14:20:45.000Z</published>
    <updated>2017-09-01T06:36:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文以MySQL数据库为研究对象，讨论与数据库索引相关的一些话题。特别需要说明的是，MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，哈希索引，全文索引等等。为了避免混乱，本文将只关注于BTree索引，因为这是平常使用MySQL时主要打交道的索引，至于哈希索引和全文索引本文暂不讨论。</p><a id="more"></a><p>文章主要内容分为三个部分。</p><p>第一部分主要从数据结构及算法理论层面讨论MySQL数据库索引的数理基础。</p><p>第二部分结合MySQL数据库中MyISAM和InnoDB数据存储引擎中索引的架构实现讨论聚集索引、非聚集索引及覆盖索引等话题。</p><p>第三部分根据上面的理论基础，讨论MySQL中高性能使用索引的策略。</p><h2 id="一、数据结构及算法基础"><a href="#一、数据结构及算法基础" class="headerlink" title="一、数据结构及算法基础"></a>一、数据结构及算法基础</h2><p>为什么这里要讲查询算法和数据结构呢？因为之所以要建立索引，其实就是为了构建一种数据结构，可以在上面应用一种高效的查询算法，最终提高数据的查询速度。</p><h3 id="1-1-索引的本质"><a href="#1-1-索引的本质" class="headerlink" title="1.1 索引的本质"></a>1.1 索引的本质</h3><p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。</p><p>我们知道，数据库查询是数据库的最主要功能之一。我们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。最基本的查询算法当然是顺序查找（linear search），这种复杂度为O(n)的算法在数据量很大时显然是糟糕的，好在计算机科学的发展提供了很多更优秀的查找算法，例如二分查找（binary search）、二叉树查找（binary tree search）等。</p><p>如果稍微分析一下会发现，每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p><p>看一个例子：<br><img src="http://omu7tit09.bkt.clouddn.com/15021866010199.png" alt=""></p><p>图1展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O(log2n)O(log2n)的复杂度内获取到相应数据。</p><p>虽然这是一个货真价实的索引，但是实际的数据库系统几乎没有使用二叉查找树或其进化品种红黑树（red-black tree）实现的，原因会在下文介绍。</p><h3 id="1-2-B树和B-树"><a href="#1-2-B树和B-树" class="headerlink" title="1.2 B树和B+树"></a>1.2 B树和B+树</h3><p>目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构，在本文的下一节会结合存储器原理及计算机存取原理讨论为什么B-Tree和B+Tree在被如此广泛用于索引，这一节先单纯从数据结构角度描述它们。</p><p>要理解B树，必须从二叉查找树（Binary search tree）讲起。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15021868503030.png" alt=""></p><p>二叉查找树是一种查找效率非常高的数据结构，它有三个特点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">（1）每个节点最多只有两个子树。</div><div class="line">（2）左子树都为小于父节点的值，右子树都为大于父节点的值。</div><div class="line">（3）在n个节点中找到目标值，一般只需要log(n)次比较。</div></pre></td></tr></table></figure><p>二叉查找树的结构不适合数据库，因为它的查找效率与层数相关。越处在下层的数据，就需要越多次比较。它的搜索时间复杂度为$O(log_2N)$，所以它的搜索效率和树的深度有关极端情况下，n个数据需要n次比较才能找到目标值。对于数据库来说，每进入一层，就要从硬盘读取一次数据，这非常致命，因为硬盘的读取时间远远大于数据处理时间，数据库读取硬盘的次数越少越好，这一点也会在后面深入剖析。</p><p>如果要提高查询速度，那么就要降低树的深度。要降低树的深度，很自然的方法就是采用多叉树，再结合平衡二叉树的思想，我们可以构建一个平衡多叉树结构，然后就可以在上面构建平衡多路查找算法，提高大数据量下的搜索效率。</p><h4 id="1-2-1-B树"><a href="#1-2-1-B树" class="headerlink" title="1.2.1 B树"></a>1.2.1 B树</h4><p>B树（B-tree）是一种树状数据结构，能够用来存储排序后的数据。这种数据结构能够让查找数据、循序存取、插入数据及删除的动作，都在对数时间内完成。B树，概括来说是一个一般化的二叉查找树，可以拥有多于2个子节点。与自平衡二叉查找树不同，B-树为系统最优化大块数据的读和写操作。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。这种数据结构常被应用在数据库和文件系统的实作上。</p><p>在B树中查找给定关键字的方法是，首先把根结点取来，在根结点所包含的关键字K1,…,Kn查找给定的关键字（可用顺序查找或二分查找法），若找到等于给定值的关键字，则查找成功；否则，一定可以确定要查找的关键字在Ki与Ki+1之间，Pi为指向子树根节点的指针，此时取指针Pi所指的结点继续查找，直至找到，或指针Pi为空时查找失败。</p><p>B树作为一种多路搜索树（并不是二叉的）：</p><ul><li>定义任意非叶子结点最多只有M个儿子；且M&gt;2；</li><li>根结点的儿子数为[2, M]；</li><li>除根结点以外的非叶子结点的儿子数为[M/2, M]；</li><li>每个结点存放至少M/2-1（取上整）和至多M-1个关键字；(至少2个关键字）</li><li>非叶子结点的关键字个数=指向儿子的指针个数-1；</li><li>非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；</li><li>非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；</li><li>所有叶子结点位于同一层；</li></ul><p>此外，在B树中，除非数据已经填满，否则不会增加新的层。也就是说，B树追求层越少越好。</p><p>这样的数据结构，非常有利于减少读取硬盘的次数。假定一个节点可以容纳100个值，那么三层的B树可以容纳100万个数据，但若换成二叉查找树，则需要20层！假定操作系统一次读取一个节点，并且根节点保留在内存中，那么B树在100万个数据中查找目标值，只需要读取两次硬盘。</p><p>如下图为一个M=3的B树示例：<img src="http://omu7tit09.bkt.clouddn.com/15005176551496.jpg" alt=""><br>B树创建的示意图：<img src="http://omu7tit09.bkt.clouddn.com/15005176765359.gif" alt=""></p><h4 id="1-2-2-B-树"><a href="#1-2-2-B-树" class="headerlink" title="1.2.2 B+树"></a>1.2.2 B+树</h4><p>B+树是B树的变体，MySQL普遍使用B+Tree实现其索引结构。也是一种多路搜索树，其定义基本与B-树相同，除了：</p><ul><li>1）非叶子结点的子树指针与关键字个数相同；</li><li>2）非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；</li><li>3）为所有叶子结点增加一个链指针；</li><li>4）所有关键字都在叶子结点出现；</li></ul><p>下图为M=3的B+树的示意图：<img src="http://omu7tit09.bkt.clouddn.com/15005180938867.jpg" alt=""></p><p>B+树的搜索与B树也基本相同，区别是B+树只有达到叶子结点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；</p><p>B+树的性质：</p><ul><li>1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；</li><li>2.不可能在非叶子结点命中；</li><li>3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；</li><li>4.更适合文件索引系统。</li></ul><p>下面为一个B+树创建的示意图：<br><img src="http://omu7tit09.bkt.clouddn.com/15005181702417.gif" alt=""></p><p>一般在数据库系统或文件系统中使用的B+ Tree结构都在经典B+ Tree的基础上进行了优化，增加了顺序访问指针。做这个优化的目的是为了提高区间访问的性能，例如下图中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15022005016480.png" alt=""></p><p>【提问】<br>数据库索引用什么建的 ：b+树；解释一下B+树，并说出数据库索引的原理；</p><h2 id="二、计算机组成原理"><a href="#二、计算机组成原理" class="headerlink" title="二、计算机组成原理"></a>二、计算机组成原理</h2><p>上文说过，红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-/+Tree作为索引结构，这一节将结合计算机组成原理相关知识讨论B-/+Tree作为索引的理论基础。</p><p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。下面先介绍内存和磁盘存取原理，然后再结合这些原理分析B-/+Tree作为索引的效率。</p><h3 id="2-1-主存存取原理"><a href="#2-1-主存存取原理" class="headerlink" title="2.1 主存存取原理"></a>2.1 主存存取原理</h3><p>目前计算机使用的主存基本都是随机读写存储器（RAM），现代RAM的结构和存取原理比较复杂，这里本文抛却具体差别，抽象出一个十分简单的存取模型来说明RAM的工作原理。 </p><p><img src="http://omu7tit09.bkt.clouddn.com/15022016341745.jpg" alt=""></p><p>从抽象角度看，主存是一系列的存储单元组成的矩阵，每个存储单元存储固定大小的数据。每个存储单元有唯一的地址，现代主存的编址规则比较复杂，这里将其简化成一个二维地址：通过一个行地址和一个列地址可以唯一定位到一个存储单元。上图展示了一个4 x 4的主存模型。</p><p>主存的存取过程如下：</p><p>当系统需要读取主存时，则将地址信号放到地址总线上传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线上，供其它部件读取。写主存的过程类似，系统将要写入单元地址和数据分别放在地址总线和数据总线上，主存读取两个总线的内容，做相应的写操作。</p><p>这里可以看出，主存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取A0再取A1和先取A0再取D3的时间消耗是一样的。</p><h3 id="2-2-磁盘存取原理"><a href="#2-2-磁盘存取原理" class="headerlink" title="2.2 磁盘存取原理"></a>2.2 磁盘存取原理</h3><p>上文说过，索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。</p><p>磁盘读取数据靠的是机械运动，当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。</p><p>为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间，最后便是对读取数据的传输。 所以每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分。其中：</p><ul><li>寻道时间是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下。</li><li>旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2 = 4.17ms。</li><li>传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。</li></ul><p>那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 = 9ms左右，听起来还挺不错的，但要知道一台500 -MIPS的机器每秒可以执行5亿条指令，因为指令依靠的是电的性质，换句话说执行一次IO的时间可以执行40万条指令，数据库动辄十万百万乃至千万级数据，每次9毫秒的时间，显然是个灾难。</p><h3 id="2-3-局部性原理与磁盘预读"><a href="#2-3-局部性原理与磁盘预读" class="headerlink" title="2.3 局部性原理与磁盘预读"></a>2.3 局部性原理与磁盘预读</h3><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。</p><p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p><h2 id="三、B-Tree索引的性能分析"><a href="#三、B-Tree索引的性能分析" class="headerlink" title="三、B-/+Tree索引的性能分析"></a>三、B-/+Tree索引的性能分析</h2><p>到这里终于可以分析为何数据库索引采用B-/+Tree存储结构了。上文说过数据库索引是存储到磁盘的而我们又一般以使用磁盘I/O次数来评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h-1个节点（根节点常驻内存）。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p><p>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为$O(h)=O(log_dN)$。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</p><p>综上所述，如果我们采用B-Tree存储结构，搜索时I/O次数一般不会超过3次，所以用B-Tree作为索引结构效率是非常高的。</p><h3 id="3-1-B-树性能分析"><a href="#3-1-B-树性能分析" class="headerlink" title="3.1 B+树性能分析"></a>3.1 B+树性能分析</h3><p>从上面介绍我们知道，B树的搜索复杂度为O(h)=O(logdN)，所以树的出度d越大，深度h就越小，I/O的次数就越少。B+Tree恰恰可以增加出度d的宽度，因为每个节点大小为一个页大小，所以出度的上限取决于节点内key和data的大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dmax=floor(pagesize/(keysize+datasize+pointsize))//floor表示向下取整</div></pre></td></tr></table></figure><p>由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，从而拥有更好的性能。</p><h3 id="3-2-B-树查找过程"><a href="#3-2-B-树查找过程" class="headerlink" title="3.2 B+树查找过程"></a>3.2 B+树查找过程</h3><p><img src="http://omu7tit09.bkt.clouddn.com/15022027728175.jpg" alt=""></p><p>B-树和B+树查找过程基本一致。如上图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。</p><p>这一章从理论角度讨论了与索引相关的数据结构与算法问题，下一章将讨论B+Tree是如何具体实现为MySQL中索引，同时将结合MyISAM和InnDB存储引擎介绍非聚集索引和聚集索引两种不同的索引实现形式。</p><h2 id="四、MySQL索引实现"><a href="#四、MySQL索引实现" class="headerlink" title="四、MySQL索引实现"></a>四、MySQL索引实现</h2><p>在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，本文主要讨论MyISAM和InnoDB两个存储引擎的索引实现方式。</p><h3 id="4-1-MyISAM索引实现"><a href="#4-1-MyISAM索引实现" class="headerlink" title="4.1 MyISAM索引实现"></a>4.1 MyISAM索引实现</h3><p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图： </p><p><img src="http://omu7tit09.bkt.clouddn.com/15022030611951.jpg" alt=""></p><p>这里设表一共有三列，假设我们以Col1为主键，则上图是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示： </p><p><img src="http://omu7tit09.bkt.clouddn.com/15022030773455.jpg" alt=""></p><p>同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。 </p><p>MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p><h3 id="4-2-InnoDB索引实现"><a href="#4-2-InnoDB索引实现" class="headerlink" title="4.2 InnoDB索引实现"></a>4.2 InnoDB索引实现</h3><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p><p>第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p><p> <img src="http://omu7tit09.bkt.clouddn.com/15022032855928.jpg" alt=""></p><p>上图是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p><p>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，下图为定义在Col3上的一个辅助索引：<br><img src="http://omu7tit09.bkt.clouddn.com/15022037126899.jpg" alt=""></p><p>这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p><p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。</p><p>再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p><h2 id="五、索引使用策略及优化"><a href="#五、索引使用策略及优化" class="headerlink" title="五、索引使用策略及优化"></a>五、索引使用策略及优化</h2><p>MySQL的优化主要分为结构优化（Scheme optimization）和查询优化（Query optimization）。本章讨论的高性能索引策略主要属于结构优化范畴。本章的内容完全基于上文的理论基础，实际上一旦理解了索引背后的机制，那么选择高性能的策略就变成了纯粹的推理，并且可以理解这些策略背后的逻辑。</p><h3 id="5-1-联合索引及最左前缀原理"><a href="#5-1-联合索引及最左前缀原理" class="headerlink" title="5.1 联合索引及最左前缀原理"></a>5.1 联合索引及最左前缀原理</h3><blockquote><p>联合索引（复合索引）</p></blockquote><p>首先介绍一下联合索引。联合索引其实很简单，相对于一般索引只有一个字段，联合索引可以为多个字段创建一个索引。它的原理也很简单，比如，我们在（a,b,c）字段上创建一个联合索引，则索引记录会首先按照A字段排序，然后再按照B字段排序然后再是C字段，因此，联合索引的特点就是：</p><ul><li>第一个字段一定是有序的</li><li>当第一个字段值相等的时候，第二个字段又是有序的，比如下表中当A=2时所有B的值是有序排列的，依次类推，当同一个B值得所有C字段是有序排列的</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">| A | B | C | </div><div class="line">| 1 | 2 | 3 | </div><div class="line">| 1 | 4 | 2 | </div><div class="line">| 1 | 1 | 4 | </div><div class="line">| 2 | 3 | 5 | </div><div class="line">| 2 | 4 | 4 | </div><div class="line">| 2 | 4 | 6 | </div><div class="line">| 2 | 5 | 5 |</div></pre></td></tr></table></figure><p>其实联合索引的查找就跟查字典是一样的，先根据第一个字母查，然后再根据第二个字母查，或者只根据第一个字母查，但是不能跳过第一个字母从第二个字母开始查。这就是所谓的最左前缀原理。</p><blockquote><p>最左前缀原理</p></blockquote><p>我们再来详细介绍一下联合索引的查询。还是上面例子，我们在（a,b,c）字段上建了一个联合索引，所以这个索引是先按a 再按b 再按c进行排列的，所以以下的查询方式都可以用到索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select * from table where a=1；</div><div class="line">select * from table where a=1 and b=2；</div><div class="line">select * from table where a=1 and b=2 and c=3；</div></pre></td></tr></table></figure><p>上面三个查询按照 （a ）, （a，b ）,（a，b，c ）的顺序都可以利用到索引，这就是最左前缀匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select * from table where a=1 and c=3； //那么只会用到索引a。</div></pre></td></tr></table></figure><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">select * from table where b=2 and a=1；</div><div class="line">select * from table where b=2 and a=1 and c=3；</div></pre></td></tr></table></figure><p>如果用到了最左前缀而只是颠倒了顺序，也是可以用到索引的，因为mysql查询优化器会判断纠正这条sql语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划。但我们还是最好按照索引顺序来查询，这样查询优化器就不用重新编译了。</p><blockquote><p>前缀索引</p></blockquote><p>除了联合索引之外，对mysql来说其实还有一种前缀索引。前缀索引就是用列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引key变短而减少了索引文件的大小和维护开销。</p><ul><li>字符串列(varchar,char,text等)，需要进行全字段匹配或者前匹配。也就是=‘xxx’ 或者 like ‘xxx%’</li><li>字符串本身可能比较长，而且前几个字符就开始不相同。比如我们对中国人的姓名使用前缀索引就没啥意义，因为中国人名字都很短，另外对收件地址使用前缀索引也不是很实用，因为一方面收件地址一般都是以XX省开头，也就是说前几个字符都是差不多的，而且收件地址进行检索一般都是like ’%xxx%’，不会用到前匹配。相反对外国人的姓名可以使用前缀索引，因为其字符较长，而且前几个字符的选择性比较高。同样电子邮件也是一个可以使用前缀索引的字段。</li><li>前一半字符的索引选择性就已经接近于全字段的索引选择性。如果整个字段的长度为20，索引选择性为0.9，而我们对前10个字符建立前缀索引其选择性也只有0.5，那么我们需要继续加大前缀字符的长度，但是这个时候前缀索引的优势已经不明显，没有太大的建前缀索引的必要了。</li></ul><p>一些文章中也提到：</p><p>MySQL 前缀索引能有效减小索引文件的大小，提高索引的速度。但是前缀索引也有它的坏处：MySQL 不能在 ORDER BY 或 GROUP BY 中使用前缀索引，也不能把它们用作覆盖索引(Covering Index)。</p><h3 id="5-2-索引优化策略"><a href="#5-2-索引优化策略" class="headerlink" title="5.2 索引优化策略"></a>5.2 索引优化策略</h3><ul><li>最左前缀匹配原则，上面讲到了</li><li>主键外检一定要建索引</li><li>对 where,on,group by,order by 中出现的列使用索引</li><li>尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0</li><li>对较小的数据列使用索引,这样会使索引文件更小,同时内存中也可以装载更多的索引键</li><li>索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);</li><li>为较长的字符串使用前缀索引</li><li>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可</li><li>不要过多创建索引, 权衡索引个数与DML之间关系，DML也就是插入、删除数据操作。这里需要权衡一个问题，建立索引的目的是为了提高查询效率的，但建立的索引过多，会影响插入、删除数据的速度，因为我们修改的表数据，索引也需要进行调整重建</li><li>对于like查询，”%”不要放在前面。 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SELECT * FROMhoudunwangWHEREunameLIKE&apos;后盾%&apos; -- 走索引 </div><div class="line">SELECT * FROMhoudunwangWHEREunameLIKE &quot;%后盾%&quot; -- 不走索引</div></pre></td></tr></table></figure><ul><li>查询where条件数据类型不匹配也无法使用索引 </li><li>字符串与数字比较不使用索引; </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CREATE TABLEa(achar(10)); </div><div class="line">EXPLAIN SELECT * FROMaWHEREa=&quot;1&quot; – 走索引 </div><div class="line">EXPLAIN SELECT * FROM a WHERE a=1 – 不走索引</div></pre></td></tr></table></figure><p>正则表达式不使用索引,这应该很好理解,所以为什么在SQL中很难看到regexp关键字的原因</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文以MySQL数据库为研究对象，讨论与数据库索引相关的一些话题。特别需要说明的是，MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，哈希索引，全文索引等等。为了避免混乱，本文将只关注于BTree索引，因为这是平常使用MySQL时主要打交道的索引，至于哈希索引和全文索引本文暂不讨论。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据库索引原理及优化" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法（6）：B树、B+树</title>
    <link href="http://yoursite.com/2017/07/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%886%EF%BC%89%EF%BC%9AB%E6%A0%91%E3%80%81B+%E6%A0%91/"/>
    <id>http://yoursite.com/2017/07/20/数据结构与算法（6）：B树、B+树/</id>
    <published>2017-07-20T14:14:45.000Z</published>
    <updated>2017-08-26T02:43:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>具体讲解之前，有一点，再次强调下：B-树，即为B树。因为B树的原英文名称为B-tree，而国内很多人喜欢把B-tree译作B-树，其实，这是个非常不好的直译，很容易让人产生误解。如人们可能会以为B-树是一种树，而B树又是一种一种树。而事实上是，B-tree就是指的B树。特此说明。</p><a id="more"></a><h2 id="一、B树"><a href="#一、B树" class="headerlink" title="一、B树"></a>一、B树</h2><p>B树（B-tree）是一种树状数据结构，能够用来存储排序后的数据。这种数据结构能够让查找数据、循序存取、插入数据及删除的动作，都在对数时间内完成。B树，概括来说是一个一般化的二叉查找树，可以拥有多于2个子节点。与自平衡二叉查找树不同，B-树为系统最优化大块数据的读和写操作。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。这种数据结构常被应用在数据库和文件系统的实作上。</p><p>在B树中查找给定关键字的方法是，首先把根结点取来，在根结点所包含的关键字K1,…,Kn查找给定的关键字（可用顺序查找或二分查找法），若找到等于给定值的关键字，则查找成功；否则，一定可以确定要查找的关键字在Ki与Ki+1之间，Pi为指向子树根节点的指针，此时取指针Pi所指的结点继续查找，直至找到，或指针Pi为空时查找失败。</p><p>B树作为一种多路搜索树（并不是二叉的）：</p><ul><li>定义任意非叶子结点最多只有M个儿子；且M&gt;2；</li><li>根结点的儿子数为[2, M]；</li><li>除根结点以外的非叶子结点的儿子数为[M/2, M]；</li><li>每个结点存放至少M/2-1（取上整）和至多M-1个关键字；(至少2个关键字）</li><li>非叶子结点的关键字个数=指向儿子的指针个数-1；</li><li>非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；</li><li>非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；</li><li>所有叶子结点位于同一层；</li></ul><p>如下图为一个M=3的B树示例：<br><img src="http://omu7tit09.bkt.clouddn.com/15005176551496.jpg" alt=""><br>B树创建的示意图：<br><img src="http://omu7tit09.bkt.clouddn.com/15005176765359.gif" alt=""></p><h2 id="二、B-树"><a href="#二、B-树" class="headerlink" title="二、B+树"></a>二、B+树</h2><p>B+树是B树的变体，也是一种多路搜索树，其定义基本与B-树相同，除了：</p><ul><li>1）非叶子结点的子树指针与关键字个数相同；</li><li>2）非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；</li><li>3）为所有叶子结点增加一个链指针；</li><li>4）所有关键字都在叶子结点出现；</li></ul><p>下图为M=3的B+树的示意图：<img src="http://omu7tit09.bkt.clouddn.com/15005180938867.jpg" alt=""></p><p>B+树的搜索与B树也基本相同，区别是B+树只有达到叶子结点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；</p><p>B+树的性质：</p><ul><li>1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；</li><li>2.不可能在非叶子结点命中；</li><li>3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；</li><li>4.更适合文件索引系统。</li></ul><p>下面为一个B+树创建的示意图：<br><img src="http://omu7tit09.bkt.clouddn.com/15005181702417.gif" alt=""></p><h2 id="三、B-树"><a href="#三、B-树" class="headerlink" title="三、B*树"></a>三、B*树</h2><p>$B^*$树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针，将结点的最低利用率从1/2提高到2/3。</p><p>$B^*$树如下图所示：<img src="http://omu7tit09.bkt.clouddn.com/15005182105086.jpg" alt=""></p><p>$B^*$树定义了非叶子结点关键字个数至少为$\frac{2}{3}M$，即块的最低使用率为2/3（代替B+树的1/2）；</p><p>B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；</p><p>$B^*$树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；</p><p>所以，$B^*$树分配新结点的概率比B+树要低，空间使用率更高。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;具体讲解之前，有一点，再次强调下：B-树，即为B树。因为B树的原英文名称为B-tree，而国内很多人喜欢把B-tree译作B-树，其实，这是个非常不好的直译，很容易让人产生误解。如人们可能会以为B-树是一种树，而B树又是一种一种树。而事实上是，B-tree就是指的B树。特此说明。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="B树" scheme="http://yoursite.com/tags/B%E6%A0%91/"/>
    
      <category term="B+树" scheme="http://yoursite.com/tags/B-%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法（5）：AVL树</title>
    <link href="http://yoursite.com/2017/07/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%885%EF%BC%89%EF%BC%9AAVL%E6%A0%91/"/>
    <id>http://yoursite.com/2017/07/19/数据结构与算法（5）：AVL树/</id>
    <published>2017-07-19T14:14:45.000Z</published>
    <updated>2017-08-18T13:53:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，对于一般的二叉搜索树（Binary Search Tree），其期望高度（即为一棵平衡树时）为$log_2n$，其各操作的时间复杂度$O(log_2n)$同时也由此而决定。但是，在某些极端的情况下（如在插入的序列是有序的时），二叉搜索树将退化成近似链或链，此时，其操作的时间复杂度将退化成线性的，即O(n)。我们可以通过随机化建立二叉搜索树来尽量的避免这种情况，但是在进行了多次的操作之后，由于在删除时，我们总是选择将待删除节点的后继代替它本身，这样就会造成总是右边的节点数目减少，以至于树向左偏沉。这同时也会造成树的平衡性受到破坏，提高它的操作的时间复杂度。于是就有了我们下边介绍的平衡二叉树。</p><a id="more"></a><h2 id="一、平衡二叉树"><a href="#一、平衡二叉树" class="headerlink" title="一、平衡二叉树"></a>一、平衡二叉树</h2><p>平衡二叉树定义：平衡二叉树（Balanced Binary Tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用算法有红黑树、AVL树等。在平衡二叉搜索树中，我们可以看到，其高度一般都良好地维持在O(log2n)，大大降低了操作的时间复杂度。</p><p>其严格定义为：<br>一颗空树是平衡二叉树；若T是一棵非空二叉树，其左、右子树为TL和TR，令hl和hr分别为左、右子树的深度。当且仅当</p><ul><li>TL、TR都是平衡二叉树；</li><li>并且满足公式$|hl-hr|≤1$时，则T是平衡二叉树</li></ul><p>相应地，定义$hl-hr$为二叉平衡树的平衡因子（balance factor）。因此，平衡二叉树上所有结点的平衡因子可能是-1，0，1。换言之，若一颗二叉树上任一结点的平衡因子的绝对值都不大于1，则该树就是平衡二叉树。</p><p>最小二叉平衡树的节点的公式如下：$F(n)=F(n-1)+F(n-2)+1$</p><p>这个类似于一个递归的数列，可以参考Fibonacci数列，1是根节点，$F(n-1)$是左子树的节点数量，$F(n-2)$是右子树的节点数量。</p><h2 id="二、平衡查找树（AVL树）"><a href="#二、平衡查找树（AVL树）" class="headerlink" title="二、平衡查找树（AVL树）"></a>二、平衡查找树（AVL树）</h2><h3 id="2-1-AVL树的定义"><a href="#2-1-AVL树的定义" class="headerlink" title="2.1 AVL树的定义"></a>2.1 AVL树的定义</h3><p>平衡二叉树（AVL树，发明者的姓名缩写）：一种高度平衡的排序二叉树，其每一个节点的左子树和右子树的高度差最多等于1。平衡二叉树首先必须是一棵二叉排序树！</p><p>平衡因子（Balance Factor）：将二叉树上节点的左子树深度减去右子树深度的值。对于平衡二叉树所有包括分支节点和叶节点的平衡因子只可能是-1,0和1，只要有一个节点的因子不在这三个值之内，该二叉树就是不平衡的。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15005205553707.png" alt=""><br>最小不平衡子树：距离插入结点最近的，且平衡因子的绝对值大于1的节点为根的子树。</p><p>n个结点的AVL树最大深度约1.44log2n。查找、插入和删除在平均和最坏情况下都是O(logn)。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。</p><p>可以采用动态平衡技术保持一个平衡二叉树。构造平衡二叉树的时候，也可以采用相同的方法，默认初始时，是一个空树，插入节点时，通过动态平衡技术对二叉树进行调整。</p><p>Adeleon-Velskii和Landis提出了一个动态地保持二叉排序树平衡的方法，其基本思想是：在构造二叉排序树的过程中，每当插入一个结点时，首先检查是否因插入而破坏了树的平衡性，若是因插入结点而破坏了树的平衡性，则找出其中最小不平衡树，在保持排序树特性的前提下，调整最小不平衡子树各结点之间的连接关系，以达到新的平衡。通常这样得到的平衡二叉排序树简称为AVL树。</p><h3 id="2-2-AVL树的自平衡操作——旋转"><a href="#2-2-AVL树的自平衡操作——旋转" class="headerlink" title="2.2 AVL树的自平衡操作——旋转"></a>2.2 AVL树的自平衡操作——旋转</h3><p>AVL树最关键的也是最难的一步操作就是旋转。旋转主要是为了实现AVL树在实施了插入和删除操作以后，树重新回到平衡的方法。下面我们重点研究一下AVL树的旋转。</p><h4 id="2-2-1-不平衡的四种情况"><a href="#2-2-1-不平衡的四种情况" class="headerlink" title="2.2.1 不平衡的四种情况"></a>2.2.1 不平衡的四种情况</h4><p>对于一个平衡的节点，由于任意节点最多有两个儿子，因此高度不平衡时，此节点的两颗子树的高度差2。容易看出，这种不平衡出现在下面四种情况：<br><img src="http://omu7tit09.bkt.clouddn.com/15005152623585.jpg" alt=""></p><ul><li>1) 6节点的左子树3节点高度比右子树7节点大2，左子树3节点的左子树1节点高度大于右子树4节点，这种情况成为左左。</li><li>2) 6节点的左子树2节点高度比右子树7节点大2，左子树2节点的左子树1节点高度小于右子树4节点，这种情况成为左右。</li><li>3) 2节点的左子树1节点高度比右子树5节点小2，右子树5节点的左子树3节点高度大于右子树6节点，这种情况成为右左。</li><li>4) 2节点的左子树1节点高度比右子树4节点小2，右子树4节点的左子树3节点高度小于右子树6节点，这种情况成为右右。</li></ul><p>从图2中可以可以看出，1和4两种情况是对称的，这两种情况的旋转算法是一致的，只需要经过一次旋转就可以达到目标，我们称之为单旋转。2和3两种情况也是对称的，这两种情况的旋转算法也是一致的，需要进行两次旋转，我们称之为双旋转。</p><h4 id="2-2-2-单旋转"><a href="#2-2-2-单旋转" class="headerlink" title="2.2.2 单旋转"></a>2.2.2 单旋转</h4><p>单旋转是针对于左左和右右这两种情况的解决方案，这两种情况是对称的，只要解决了左左这种情况，右右就很好办了。图3是左左情况的解决方案，节点k2不满足平衡特性，因为它的左子树k1比右子树Z深2层，而且k1子树中，更深的一层的是k1的左子树X子树，所以属于左左情况。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15005154583748.jpg" alt=""></p><p>为使树恢复平衡，我们把k2变成这棵树的根节点，因为k2大于k1，把k2置于k1的右子树上，而原本在k1右子树的Y大于k1，小于k2，就把Y置于k2的左子树上，这样既满足了二叉查找树的性质，又满足了平衡二叉树的性质。</p><p>这样的操作只需要一部分指针改变，结果我们得到另外一颗二叉查找树，它是一棵AVL树，因为X向上一移动了一层，Y还停留在原来的层面上，Z向下移动了一层。整棵树的新高度和之前没有在左子树上插入的高度相同，插入操作使得X高度长高了。因此，由于这颗子树高度没有变化，所以通往根节点的路径就不需要继续旋转了。</p><h4 id="2-2-3-双旋转"><a href="#2-2-3-双旋转" class="headerlink" title="2.2.3 双旋转"></a>2.2.3 双旋转</h4><p>双旋转：对于左右和右左这两种情况，单旋转不能使它达到一个平衡状态，要经过两次旋转。双旋转是针对于这两种情况的解决方案，同样的，这样两种情况也是对称的，只要解决了左右这种情况，右左就很好办了。图4是左右情况的解决方案，节点k3不满足平衡特性，因为它的左子树k1比右子树Z深2层，而且k1子树中，更深的一层的是k1的右子树k2子树，所以属于左右情况。<img src="http://omu7tit09.bkt.clouddn.com/15005157505500.jpg" alt=""></p><p>为使树恢复平衡，我们需要进行两步，第一步，把k1作为根，进行一次右右旋转，旋转之后就变成了左左情况，所以第二步再进行一次左左旋转，最后得到了一棵以k2为根的平衡二叉树树。</p><h2 id="三、构建过程"><a href="#三、构建过程" class="headerlink" title="三、构建过程"></a>三、构建过程</h2><p>下面是由[1,2,3,4,5,6,7,10,9]构建平衡二叉树<br><img src="http://omu7tit09.bkt.clouddn.com/15005207292560.png" alt=""><br><img src="http://omu7tit09.bkt.clouddn.com/15005207359778.png" alt=""><br><img src="http://omu7tit09.bkt.clouddn.com/15005207400396.png" alt=""><br><img src="http://omu7tit09.bkt.clouddn.com/15005207454726.png" alt=""><br><img src="http://omu7tit09.bkt.clouddn.com/15005207493083.png" alt=""><br><img src="http://omu7tit09.bkt.clouddn.com/15005207531838.png" alt=""><br><img src="http://omu7tit09.bkt.clouddn.com/15005207574693.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，对于一般的二叉搜索树（Binary Search Tree），其期望高度（即为一棵平衡树时）为$log_2n$，其各操作的时间复杂度$O(log_2n)$同时也由此而决定。但是，在某些极端的情况下（如在插入的序列是有序的时），二叉搜索树将退化成近似链或链，此时，其操作的时间复杂度将退化成线性的，即O(n)。我们可以通过随机化建立二叉搜索树来尽量的避免这种情况，但是在进行了多次的操作之后，由于在删除时，我们总是选择将待删除节点的后继代替它本身，这样就会造成总是右边的节点数目减少，以至于树向左偏沉。这同时也会造成树的平衡性受到破坏，提高它的操作的时间复杂度。于是就有了我们下边介绍的平衡二叉树。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
      <category term="平衡二叉树" scheme="http://yoursite.com/tags/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="AVL树" scheme="http://yoursite.com/tags/AVL%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法（4）：二叉查找树</title>
    <link href="http://yoursite.com/2017/07/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
    <id>http://yoursite.com/2017/07/19/数据结构与算法（4）：二叉查找树/</id>
    <published>2017-07-19T13:14:45.000Z</published>
    <updated>2017-08-26T02:38:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><p>二叉排序树（Binary Sort Tree）又称为二叉查找树（Binary Search Tree）、二叉搜索树。它是特殊的二叉树：对于二叉树，假设x为二叉树中的任意一个结点，x节点包含关键字key，节点x的$key$值记为$key[x]$。如果y是x的左子树中的一个结点，则$key[y]&lt;= key[x]$；如果y是x的右子树的一个结点，则$key[y] &gt;= key[x]$。那么，这棵树就是二叉查找树。</p><a id="more"></a><p>二叉查找树是先对待查找的数据进行生成树，确保树的左分支的值小于右分支的值，然后再就行和每个节点的父节点比较大小，查找最合适的范围。这个算法的效率查找效率很高，但是如果使用这种查找方法要首先创建树。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15006200093921.jpg" alt=""><br>它或者是一颗空树，或者是具有下列性质的二叉树：</p><ol><li>若任意节点的左子树不为空，则左子树上的所有节点的值均小于它的根结点的值；</li><li>若任意节点的右子树不为空，则左子树上所有节点的值均小于它的根结点的值；</li><li>任意节点的左、右子树也分别为二叉查找树。</li><li>没有键值相等的节点。</li></ol><p>二叉查找树的性质：对二叉查找树进行中序遍历，即可得到有序的数列。</p><p>构造一颗二叉排序树的目的，其实并不是为了排序，而是为了提高查找和插入删除关键字的速度。不管怎么说，在一个有序数据集上的查找，速度总是要快于无序的数据集的，而二叉排序树这样的非线性结构，也有利于插入和排序的实现。</p><p>二叉查找树的高度决定了二叉查找树的查找效率。</p><h2 id="二、查找、插入与删除"><a href="#二、查找、插入与删除" class="headerlink" title="二、查找、插入与删除"></a>二、查找、插入与删除</h2><h3 id="2-1-查找"><a href="#2-1-查找" class="headerlink" title="2.1 查找"></a>2.1 查找</h3><p>在二叉查找树中查找x的过程如下：</p><ol><li>若二叉树是空树，则查找失败。</li><li>若x等于根结点的数据，则查找成功，否则。</li><li>若x小于根结点的数据，则递归查找其左子树，否则。</li><li>递归查找其右子树。</li></ol><p>复杂度分析，它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡（比如，我们查找上图（b）中的“93”，我们需要进行n次查找操作）。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷。</p><p>根据上述的步骤，写出其查找操作的代码： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**查找指定的元素,默认从 </span></div><div class="line">    * 根结点出开始查询*/  </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(T t)</span>  </span></div><div class="line">   &#123;  </div><div class="line">      <span class="keyword">return</span> contains(t, rootTree);  </div><div class="line">         </div><div class="line">   &#125;  </div><div class="line"> <span class="comment">/**从某个结点出开始查找元素*/</span>  </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(T t, BinaryNode&lt;T&gt; node)</span>  </span></div><div class="line">   &#123;  </div><div class="line">      <span class="keyword">if</span>(node==<span class="keyword">null</span>)  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//结点为空，查找失败  </span></div><div class="line">      <span class="keyword">int</span> result = t.compareTo(node.data);  </div><div class="line">       <span class="keyword">if</span>(result&gt;<span class="number">0</span>)  </div><div class="line">          <span class="keyword">return</span> contains(t,node.right);<span class="comment">//递归查询右子树  </span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(result&lt;<span class="number">0</span>)  </div><div class="line">          <span class="keyword">return</span> contains(t, node.left);<span class="comment">//递归查询左子树    </span></div><div class="line">      <span class="keyword">else</span>  </div><div class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">   &#125;  </div><div class="line">    <span class="comment">/** </span></div><div class="line">       这里我提供一个对二叉树最大值 </div><div class="line">       最小值的搜索*/  </div><div class="line">   </div><div class="line">  </div><div class="line"> <span class="comment">/**找到二叉查找树中的最小值*/</span>  </div><div class="line">   <span class="function"><span class="keyword">public</span> T <span class="title">findMin</span><span class="params">()</span>  </span></div><div class="line">   &#123;  </div><div class="line">      <span class="keyword">if</span>(isEmpty())  </div><div class="line">      &#123;  </div><div class="line">          System.out.println(<span class="string">"二叉树为空"</span>);  </div><div class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">      &#125;<span class="keyword">else</span>  </div><div class="line">       <span class="keyword">return</span> findMin(rootTree).data;  </div><div class="line">         </div><div class="line">   &#125;  </div><div class="line">   <span class="comment">/**找到二叉查找树中的最大值*/</span>  </div><div class="line">   <span class="function"><span class="keyword">public</span> T <span class="title">findMax</span><span class="params">()</span>  </span></div><div class="line">   &#123;  </div><div class="line">       <span class="keyword">if</span>(isEmpty())  </div><div class="line">          &#123;  </div><div class="line">              System.out.println(<span class="string">"二叉树为空"</span>);  </div><div class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">          &#125;<span class="keyword">else</span>  </div><div class="line">           <span class="keyword">return</span> findMax(rootTree).data;  </div><div class="line">   &#125;  </div><div class="line">  </div><div class="line"><span class="comment">/**查询出最小元素所在的结点*/</span>  </div><div class="line">   <span class="function"><span class="keyword">public</span> BinaryNode&lt;T&gt; <span class="title">findMin</span><span class="params">(BinaryNode&lt;T&gt; node)</span>  </span></div><div class="line">   &#123;  </div><div class="line">       <span class="keyword">if</span>(node==<span class="keyword">null</span>)  </div><div class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(node.left==<span class="keyword">null</span>)  </div><div class="line">           <span class="keyword">return</span> node;  </div><div class="line">       <span class="keyword">return</span> findMin(node.left);<span class="comment">//递归查找  </span></div><div class="line">   &#125;  </div><div class="line">   <span class="comment">/**查询出最大元素所在的结点*/</span>  </div><div class="line">   <span class="function"><span class="keyword">public</span> BinaryNode&lt;T&gt; <span class="title">findMax</span><span class="params">(BinaryNode&lt;T&gt; node)</span>  </span></div><div class="line">   &#123;  </div><div class="line">       <span class="keyword">if</span>(node!=<span class="keyword">null</span>)  </div><div class="line">       &#123;  </div><div class="line">           <span class="keyword">while</span>(node.right!=<span class="keyword">null</span>)  </div><div class="line">               node=node.right;  </div><div class="line">       &#125;  </div><div class="line">       <span class="keyword">return</span> node;         </div><div class="line">   &#125;</div></pre></td></tr></table></figure><h3 id="2-2-插入"><a href="#2-2-插入" class="headerlink" title="2.2 插入"></a>2.2 插入</h3><p>插入：从根结点开始逐个与关键字进行对比，小了去左边，大了去右边，碰到子树为空的情况就将新的节点连接。二叉查找树的插入过程如下：</p><ul><li>1) 若当前的二叉查找树为空，则插入的元素为根节点;</li><li>2) 若插入的元素值小于根节点值，则将元素插入到左子树中;</li><li>3) 若插入的元素值不小于根节点值，则将元素插入到右子树中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**插入元素*/</span>  </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(T t)</span>  </span></div><div class="line">   &#123;  </div><div class="line">       rootTree = insert(t, rootTree);  </div><div class="line">   &#125;  </div><div class="line"><span class="comment">/**在某个位置开始判断插入元素*/</span>  </div><div class="line">   <span class="function"><span class="keyword">public</span> BinaryNode&lt;T&gt; <span class="title">insert</span><span class="params">(T t,BinaryNode&lt;T&gt; node)</span>  </span></div><div class="line">   &#123;  </div><div class="line">       <span class="keyword">if</span>(node==<span class="keyword">null</span>)  </div><div class="line">       &#123;  </div><div class="line">           <span class="comment">//新构造一个二叉查找树  </span></div><div class="line">           <span class="keyword">return</span> <span class="keyword">new</span> BinaryNode&lt;T&gt;(t, <span class="keyword">null</span>, <span class="keyword">null</span>);  </div><div class="line">       &#125;  </div><div class="line">       <span class="keyword">int</span> result = t.compareTo(node.data);  </div><div class="line">       <span class="keyword">if</span>(result&lt;<span class="number">0</span>)  </div><div class="line">          node.left= insert(t,node.left);  </div><div class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(result&gt;<span class="number">0</span>)  </div><div class="line">          node.right= insert(t,node.right);  </div><div class="line">       <span class="keyword">else</span>  </div><div class="line">           ;<span class="comment">//doNothing  </span></div><div class="line">       <span class="keyword">return</span> node;  </div><div class="line">   &#125;</div></pre></td></tr></table></figure><h3 id="2-3-删除"><a href="#2-3-删除" class="headerlink" title="2.3 删除"></a>2.3 删除</h3><p>如果要删除的节点是叶子，直接删；如果只有左子树或只有右子树，则删除节点后，将子树连接到父节点即可；如果同时有左右子树，则可以将二叉排序树进行中序遍历，取将要被删除的节点的前驱或者后继节点替代这个被删除的节点的位置。</p><p>二叉查找树的删除，分三种情况进行处理：</p><ul><li>1) p为叶子节点，直接删除该节点，再修改其父节点的指针（注意分是根节点和不是根节点），如图a;</li></ul><p><img src="http://omu7tit09.bkt.clouddn.com/15005146123186.png" alt=""></p><ul><li>p为单支节点（即只有左子树或右子树）。让p的子树与p的父亲节点相连，删除p即可（注意分是根节点和不是根节点），如图b;</li></ul><p><img src="http://omu7tit09.bkt.clouddn.com/15005146249207.png" alt=""></p><ul><li>p的左子树和右子树均不空。找到p的后继y，因为y一定没有左子树，所以可以删除y，并让y的父亲节点成为y的右子树的父亲节点，并用y的值代替p的值；或者方法二是找到p的前驱x，x一定没有右子树，所以可以删除x，并让x的父亲节点成为y的左子树的父亲节点。如图c。</li></ul><p><img src="http://omu7tit09.bkt.clouddn.com/15005146461446.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**删除元素*/</span>  </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(T t)</span>  </span></div><div class="line">   &#123;  </div><div class="line">       rootTree = remove(t,rootTree);  </div><div class="line">   &#125; <span class="comment">/**在某个位置开始判断删除某个结点*/</span>  </div><div class="line">   <span class="function"><span class="keyword">public</span> BinaryNode&lt;T&gt; <span class="title">remove</span><span class="params">(T t,BinaryNode&lt;T&gt; node)</span>  </span></div><div class="line">   &#123;  </div><div class="line">       <span class="keyword">if</span>(node == <span class="keyword">null</span>)  </div><div class="line">           <span class="keyword">return</span> node;<span class="comment">//没有找到,doNothing  </span></div><div class="line">       <span class="keyword">int</span> result = t.compareTo(node.data);  </div><div class="line">       <span class="keyword">if</span>(result&gt;<span class="number">0</span>)  </div><div class="line">           node.right = remove(t,node.right);  </div><div class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(result&lt;<span class="number">0</span>)  </div><div class="line">           node.left = remove(t,node.left);  </div><div class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>&amp;&amp;node.right!=<span class="keyword">null</span>)  </div><div class="line">       &#123;  </div><div class="line">           node.data = findMin(node.right).data;  </div><div class="line">           node.right = remove(node.data,node.right);  </div><div class="line">       &#125;  </div><div class="line">       <span class="keyword">else</span>  </div><div class="line">           node = (node.left!=<span class="keyword">null</span>)?node.left:node.right;  </div><div class="line">       <span class="keyword">return</span> node;  </div><div class="line">             </div><div class="line">   &#125;</div></pre></td></tr></table></figure><h3 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4 总结"></a>2.4 总结</h3><p>二叉排序树总结：</p><ul><li>二叉排序树以链式进行存储，保持了链式结构在插入和删除操作上的优点。</li><li>在极端情况下，查询次数为1，但最大操作次数不会超过树的深度。也就是说，二叉排序树的查找性能取决于二叉排序书的形状，也就引申除了后面的平衡二叉树。</li><li>给定一个元素集合，可以构造不同的二叉排序树，当它同时是一个完全二叉树的时候，查找的时间复杂度为$O(log(n))$，近似于二分查找。</li><li>当出现最极端的斜树时，时间复杂度为$O(n)$，等同于顺序查找，效果最差。</li></ul><p><img src="http://omu7tit09.bkt.clouddn.com/15004265816210.jpg" alt=""></p><p>下图为二叉树查找和顺序查找以及二分查找性能的对比图：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15004290403634.png" alt=""><br>基于二叉查找树进行优化，进而可以得到其他的树表查找算法，比如平衡树、红黑树等高效算法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、定义&quot;&gt;&lt;a href=&quot;#一、定义&quot; class=&quot;headerlink&quot; title=&quot;一、定义&quot;&gt;&lt;/a&gt;一、定义&lt;/h2&gt;&lt;p&gt;二叉排序树（Binary Sort Tree）又称为二叉查找树（Binary Search Tree）、二叉搜索树。它是特殊的二叉树：对于二叉树，假设x为二叉树中的任意一个结点，x节点包含关键字key，节点x的$key$值记为$key[x]$。如果y是x的左子树中的一个结点，则$key[y]&amp;lt;= key[x]$；如果y是x的右子树的一个结点，则$key[y] &amp;gt;= key[x]$。那么，这棵树就是二叉查找树。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
      <category term="二叉查找树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法（3）：二叉树</title>
    <link href="http://yoursite.com/2017/07/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2017/07/19/数据结构与算法（3）：二叉树/</id>
    <published>2017-07-19T12:14:45.000Z</published>
    <updated>2017-08-26T02:42:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构中有很多树的结构，这里整理了二叉树、二叉查找树、AVL树、红黑树、B树、B+树、trie树的基本概念与操作。</p><a id="more"></a><h2 id="一、二叉树的概念"><a href="#一、二叉树的概念" class="headerlink" title="一、二叉树的概念"></a>一、二叉树的概念</h2><h3 id="1-1-树的基本概念"><a href="#1-1-树的基本概念" class="headerlink" title="1.1 树的基本概念"></a>1.1 树的基本概念</h3><p>树是一种数据结构，它是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。<br><img src="http://omu7tit09.bkt.clouddn.com/15006198825490.jpg" alt=""><br>它具有以下特点：</p><ul><li>每个节点有零个或多个子节点；</li><li>没有父节点的节点称为根节点；</li><li>每一个非根节点有且只有一个父节点；</li><li>除了根节点外，每个子节点可以分为多个不相交的子树。</li></ul><p>若一个结点有子树，那么该结点称为子树根的”双亲”，子树的根是该结点的”孩子”。有相同双亲的结点互为”兄弟”。一个结点的所有子树上的任何结点都是该结点的后裔。从根结点到某个结点的路径上的所有结点都是该结点的祖先。</p><ul><li>结点的度：结点拥有的子树的数目。</li><li>叶子：度为零的结点。</li><li>分支结点：度不为零的结点。</li><li>树的度：树中结点的最大的度。</li><li>层次：根结点的层次为1，其余结点的层次等于该结点的双亲结点的层次加1。</li><li>树的高度：树中结点的最大层次。</li><li>无序树：如果树中结点的各子树之间的次序是不重要的，可以交换位置。</li><li>有序树：如果树中结点的各子树之间的次序是重要的, 不可以交换位置。</li><li>森林：0个或多个不相交的树组成。对森林加上一个根，森林即成为树；删去根，树即成为森林。</li><li><h3 id="1-2-二叉树的定义"><a href="#1-2-二叉树的定义" class="headerlink" title="1.2 二叉树的定义"></a>1.2 二叉树的定义</h3>二叉树是每个节点最多有两个子树（不存在度大于2的结点）的树结构。二叉树的子树有左右之分，次序不能颠倒。它有5种基本形态：二叉树可以是空集；根可以有空的左子树或右子树；或者左右子树皆为空。<br><img src="http://omu7tit09.bkt.clouddn.com/15006186299230.jpg" alt=""></li></ul><h3 id="1-3-二叉树的性质"><a href="#1-3-二叉树的性质" class="headerlink" title="1.3 二叉树的性质"></a>1.3 二叉树的性质</h3><h4 id="1-3-1-性质一"><a href="#1-3-1-性质一" class="headerlink" title="1.3.1 性质一"></a>1.3.1 性质一</h4><p>二叉树的第i层至多有$2^{i-1}$个结点；</p><p>证明：下面用”数学归纳法”进行证明。</p><ul><li>当$i=1$时，第$i$层的节点数目为$2^{i-1}=2^{0}=1$。因为第1层上只有一个根结点，所以命题成立。</li><li>假设当$i&gt;1$，第$i$层的节点数目为$2^{i-1}$。这个是根据(01)推断出来的！</li><li>下面根据这个假设，推断出”第$(i+1)$层的节点数目为$2^{i}$”即可。由于二叉树的每个结点至多有两个孩子，故”第$(i+1)$层上的结点数目” 最多是 “第i层的结点数目的2倍”。即，第$(i+1)$层上的结点数目最大值$=2×2^{i-1}=2^{i}$。</li><li>故假设成立，原命题得证！</li></ul><h4 id="1-3-2-性质二"><a href="#1-3-2-性质二" class="headerlink" title="1.3.2 性质二"></a>1.3.2 性质二</h4><p>深度为k的二叉树至多有$2^{k-1}$个结点；</p><p>证明：在具有相同深度的二叉树中，当每一层都含有最大结点数时，其树中结点数最多。利用”性质1”可知，深度为k的二叉树的结点数至多为: $2^0+2^1+…+2^{k-1}=2^k-1$故原命题得证！</p><h4 id="1-3-3-性质三"><a href="#1-3-3-性质三" class="headerlink" title="1.3.3 性质三"></a>1.3.3 性质三</h4><p>包含n个结点的二叉树的高度至少为$log_2 (n+1)$；</p><p>证明：根据”性质2”可知，高度为h的二叉树最多有2{h}–1个结点。反之，对于包含n个节点的二叉树的高度至少为$log_2(n+1)$。</p><h4 id="1-3-4-性质四"><a href="#1-3-4-性质四" class="headerlink" title="1.3.4 性质四"></a>1.3.4 性质四</h4><p>对任何一颗二叉树T，如果其终端结点数为$n_0$，度为2的结点数为$n_2$，则$n_0=n_2+1$</p><p>证明：因为二叉树中所有结点的度数均不大于2，所以结点总数(记为n)=”0度结点数$(n_0)$” + “1度结点数$(n_1)$” + “2度结点数$(n_2)$”。由此，得到等式一。(等式一) $n=n_0+n_1+n_2$</p><p>另一方面，0度结点没有孩子，1度结点有一个孩子，2度结点有两个孩子，故二叉树中孩子结点总数是：$n_1+2n_2$。</p><p>此外，只有根不是任何结点的孩子。故二叉树中的结点总数又可表示为等式二。 (等式二) $n=n1+2n_2+1$</p><p>由(等式一)和(等式二)计算得到：n0=n2+1。原命题得证！</p><h3 id="1-4-满二叉树和完全二叉树"><a href="#1-4-满二叉树和完全二叉树" class="headerlink" title="1.4 满二叉树和完全二叉树"></a>1.4 满二叉树和完全二叉树</h3><h4 id="1-4-1-满二叉树"><a href="#1-4-1-满二叉树" class="headerlink" title="1.4.1 满二叉树"></a>1.4.1 满二叉树</h4><p>满二叉树的定义：<br>除最后一层无任何子节点外，每一层上的所有结点都有两个子结点。也可以这样理解，除叶子结点外的所有结点均有两个子结点。节点数达到最大值，所有叶子结点必须在同一层上。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15006193058861.jpg" alt=""></p><p>满二叉树的性质：</p><ol><li>一棵树的深度为h，最大层数为k，深度与最大层数相同，k=h；</li><li>叶子数为$2^h$</li><li>第k层的结点数是：$2^{k-1}$；</li><li>总结点数是$2^k-1$，且总节点数一定是奇数。</li></ol><h4 id="1-4-2-完全二叉树"><a href="#1-4-2-完全二叉树" class="headerlink" title="1.4.2 完全二叉树"></a>1.4.2 完全二叉树</h4><p>定义：一颗二叉树中，只有最小面两层结点的度可以小于2，并且最下一层的叶结点集中在靠左的若干位置上。这样的二叉树称为完全二叉树。</p><p>特点：叶子结点只能出现在最下层和次下层，且最小层的叶子结点集中在树的左部。显然，一颗满二叉树必定是一颗完全二叉树，而完全二叉树未必是满二叉树。</p><p>注意：完全二叉树是效率很高的数据结构，堆是一种完全二叉树或者近似完全二叉树，所以效率极高，像十分常用的排序算法、Dijkstra算法、Prim算法等都要用堆才能优化，二叉排序树的效率也要借助平衡树来提高，而平衡性基于完全二叉树。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15004334427457.png" alt=""></p><h2 id="二、二叉树的遍历"><a href="#二、二叉树的遍历" class="headerlink" title="二、二叉树的遍历"></a>二、二叉树的遍历</h2><p>【提问】</p><ol><li>请分别写出并解释二叉树的先序、中序、后续遍历的递归与非递归版本</li><li>给定二叉树的先序跟后序遍历，能不能将二叉树重建：不能，因为先序为父节点-左节点-右节点，后序为左节点-右节点-父节点，两者的拓扑序列是一样的，所以无法建立；如果换成一棵二叉搜索树的后续能不能建立：可以，因为只要将遍历结果排序就可以得到中序结果。</li></ol><p>这块内容讨论二叉树的常见遍历方式的代码（java）实现，包括前序（preorder）、中序（inorder）、后序（postorder）、层序（levelorder），进一步考虑递归和非递归的实现方式。<br>递归的实现方法相对简单，但由于递归的执行方式每次都会产生一个新的方法调用栈，如果递归层级较深，会造成较大的内存开销，相比之下，非递归的方式则可以避免这个问题。递归遍历容易实现，非递归则没那么简单，非递归调用本质上是通过维护一个栈，模拟递归调用的方法调用栈的行为。</p><p>在此之前，先简单定义节点的数据结构：</p><p>二叉树节点最多只有两个儿子，并保存一个节点的值，为了实验的方便，假定它为 int。同时，我们直接使用 Java 的 System.out.print 方法来输出节点值，以显示遍历结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;  </div><div class="line">    <span class="keyword">public</span> Node left;  </div><div class="line">    <span class="keyword">public</span> Node right;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;  </div><div class="line">        <span class="keyword">this</span>.value=v;  </div><div class="line">        <span class="keyword">this</span>.left=<span class="keyword">null</span>;  </div><div class="line">        <span class="keyword">this</span>.right=<span class="keyword">null</span>;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-1-前序遍历"><a href="#2-1-前序遍历" class="headerlink" title="2.1 前序遍历"></a>2.1 前序遍历</h3><h4 id="2-1-1-递归实现"><a href="#2-1-1-递归实现" class="headerlink" title="2.1.1 递归实现"></a>2.1.1 递归实现</h4><p>递归实现很简单，在每次访问到某个节点时，先输出节点值，然后再依次递归的对左儿子、右儿子调用遍历的方法。代码如下</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</div><div class="line">        System.out.print(root.value);</div><div class="line">        preOrder(root.left);</div><div class="line">        preOrder(root.right);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="2-1-2-非递归实现"><a href="#2-1-2-非递归实现" class="headerlink" title="2.1.2 非递归实现"></a>2.1.2 非递归实现</h4><p>利用栈实现循环先序遍历二叉树，维护一个栈，将根节点入栈，只要栈不为空，出栈并访问，接着依次将访问节点的右节点、左节点入栈。这种方式是对先序遍历的一种特殊实现，简洁明了，但是不具备很好地扩展性，在中序和后序方式中不适用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span>;</div><div class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</div><div class="line">    stack.push(root);</div><div class="line">    <span class="keyword">while</span>(!stack.isEmpty)&#123;</div><div class="line">        Node temp = stack.pop();</div><div class="line">        System.out.print(temp.value);</div><div class="line">        <span class="keyword">if</span>(temp.right!=<span class="keyword">null</span>)stack.push(temp.right);</div><div class="line">        <span class="keyword">if</span>(temp.left!=<span class="keyword">null</span>)stack.push(temp.left);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>还有一种方式就是利用栈模拟递归过程实现循环先序遍历二叉树。这种方式具备扩展性，它模拟了递归的过程，将左子树不断的压入栈，直到null，然后处理栈顶节点的右子树。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span>;</div><div class="line">    Stack&lt;Node&gt; s = <span class="keyword">new</span> Stack&lt;Node&gt;();</div><div class="line">    <span class="keyword">while</span>(root!=<span class="keyword">null</span>||!s.isEmtpy())&#123;</div><div class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</div><div class="line">            System.out.print(root.value);、<span class="comment">//先访问</span></div><div class="line">            s.push(root);<span class="comment">//再入栈</span></div><div class="line">            root = root.left;</div><div class="line">        &#125;</div><div class="line">        root = s.pop();</div><div class="line">        root = root.right;<span class="comment">//如果是null，出栈并处理右子树</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-2-中序遍历"><a href="#2-2-中序遍历" class="headerlink" title="2.2 中序遍历"></a>2.2 中序遍历</h3><h4 id="2-2-1-递归实现"><a href="#2-2-1-递归实现" class="headerlink" title="2.2.1 递归实现"></a>2.2.1 递归实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</div><div class="line">        preOrder(root.left);</div><div class="line">        System.out.print(root.value);</div><div class="line">        preOrder(root.right);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="2-2-2-非递归实现"><a href="#2-2-2-非递归实现" class="headerlink" title="2.2.2 非递归实现"></a>2.2.2 非递归实现</h4><p>利用栈模拟递归过程实现循环中序遍历二叉树。跟前序遍历的非递归实现方法二很类似。唯一的不同是访问当前节点的时机：前序遍历在入栈前访问，而中序遍历在出栈后访问。</p><blockquote><p>java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span>;</div><div class="line">    Stack&lt;Node&gt; s = Stack&lt;Node&gt;();</div><div class="line">    <span class="keyword">while</span>(root!=<span class="keyword">null</span>||s.isEmpty())&#123;</div><div class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</div><div class="line">            s.push(root);</div><div class="line">            root=root.left;</div><div class="line">        &#125;</div><div class="line">        root = s.pop(root);</div><div class="line">        System.out.print(root.value);</div><div class="line">        root = root.right;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-3-后序遍历"><a href="#2-3-后序遍历" class="headerlink" title="2.3 后序遍历"></a>2.3 后序遍历</h3><h4 id="2-3-1-递归实现"><a href="#2-3-1-递归实现" class="headerlink" title="2.3.1 递归实现"></a>2.3.1 递归实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</div><div class="line">        preOrder(root.left);</div><div class="line">        preOrder(root.right);</div><div class="line">        System.out.print(root.value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="2-3-2-非递归实现"><a href="#2-3-2-非递归实现" class="headerlink" title="2.3.2 非递归实现"></a>2.3.2 非递归实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span>;</div><div class="line">    Stack&lt;Node&gt; s1 = <span class="keyword">new</span> Stack&lt;Node&gt;();</div><div class="line">    Stack&lt;Node&gt; s2 = <span class="keyword">new</span> Stack&lt;Node&gt;();</div><div class="line">    Node node = root;</div><div class="line">    s1.push(node);</div><div class="line">    <span class="keyword">while</span>(s1!=<span class="keyword">null</span>)&#123;<span class="comment">//这个while循环的功能是找出后序遍历的逆序，存在s2里面</span></div><div class="line">        node = s1.pop();</div><div class="line">        <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) s1.push(node.left);</div><div class="line">        <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)s1.push(node.right);</div><div class="line">        s2.push(node);     </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(s2!=<span class="keyword">null</span>)&#123;<span class="comment">//将s2中的元素出栈，即为后序遍历次序</span></div><div class="line">        node = s2.pop();</div><div class="line">        System.out.print(node.value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-4-层序遍历"><a href="#2-4-层序遍历" class="headerlink" title="2.4 层序遍历"></a>2.4 层序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">levelTravel</span><span class="params">(Node root)</span></span>&#123;  </div><div class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span>;  </div><div class="line">        Queue&lt;Node&gt; q=<span class="keyword">new</span> LinkedList&lt;Node&gt;();  </div><div class="line">        q.add(root);  </div><div class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;  </div><div class="line">            Node temp =  q.poll();  </div><div class="line">            System.out.println(temp.value);  </div><div class="line">            <span class="keyword">if</span>(temp.left!=<span class="keyword">null</span>)q.add(temp.left);  </div><div class="line">            <span class="keyword">if</span>(temp.right!=<span class="keyword">null</span>)q.add(temp.right);  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>总结一下：树的遍历主要有两种，一种是深度优先遍历，像前序、中序、后序；另一种是广度优先遍历，像层次遍历。在树结构中两者的区别还不是非常明显，但从树扩展到有向图，到无向图的时候，深度优先搜索和广度优先搜索的效率和作用还是有很大不同的。 深度优先一般用递归，广度优先一般用队列。一般情况下能用递归实现的算法大部分也能用堆栈来实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构中有很多树的结构，这里整理了二叉树、二叉查找树、AVL树、红黑树、B树、B+树、trie树的基本概念与操作。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
      <category term="先序遍历" scheme="http://yoursite.com/tags/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
      <category term="中序遍历" scheme="http://yoursite.com/tags/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
      <category term="后序遍历" scheme="http://yoursite.com/tags/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法（2）：栈与队列</title>
    <link href="http://yoursite.com/2017/07/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%EF%BC%9A%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2017/07/18/数据结构与算法（2）：栈与队列/</id>
    <published>2017-07-18T15:14:44.000Z</published>
    <updated>2017-08-18T13:50:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、栈"><a href="#一、栈" class="headerlink" title="一、栈"></a>一、栈</h2><h3 id="1-1-栈的定义"><a href="#1-1-栈的定义" class="headerlink" title="1.1 栈的定义"></a>1.1 栈的定义</h3><p>栈（stack）是限定仅在表尾进行插入和删除操作的线性表。允许插入和删除的一端称为栈顶（top），另一端称为栈底，不含任何数据元素的栈称为空栈。它有以下几个特点：</p><a id="more"></a><ul><li>栈中的数据是按照“后进先出（LIFO，Last In First Out）”方式进出栈的。</li><li>向栈中添加、删除数据时，只能从栈顶进行操作</li></ul><p>栈通常包括的三种操作：push、peek、pop</p><ul><li>push：向栈中添加元素</li><li>peek：返回栈顶元素</li><li>pop：返回并删除栈顶元素的操作。</li></ul><h3 id="1-2-进栈与出栈"><a href="#1-2-进栈与出栈" class="headerlink" title="1.2 进栈与出栈"></a>1.2 进栈与出栈</h3><p>下图为栈的示例图，栈中的数据依次为：$30=&gt;20=&gt;10$<br><img src="http://omu7tit09.bkt.clouddn.com/15006162493543.jpg" alt=""></p><p>下图为出栈的示意图：<br><img src="http://omu7tit09.bkt.clouddn.com/15006162992929.jpg" alt=""></p><ul><li>出栈前：栈顶元素是30。此时，栈中的元素依次是$30 = &gt; 20 =&gt; 10 $</li><li>出栈后：30出栈之后，栈顶元素变成20。此时，栈中的元素依次是 $20 =&gt; 10$</li></ul><p>下图为入栈的示意图：<br><img src="http://omu7tit09.bkt.clouddn.com/15006163920060.jpg" alt=""></p><ul><li>入栈前：栈顶元素是20。此时，栈中的元素依次是$20 =&gt; 10 $</li><li>入栈后：40入栈之后，栈顶元素变成40。此时，栈中的元素依次是 $40 =&gt; 20 =&gt; 10$</li></ul><h2 id="二、队列"><a href="#二、队列" class="headerlink" title="二、队列"></a>二、队列</h2><h3 id="2-1-队列的定义"><a href="#2-1-队列的定义" class="headerlink" title="2.1 队列的定义"></a>2.1 队列的定义</h3><p>队列（queue）是只允许在一段进行插入操作，而在另一端进行删除操作的线性表。允许插入的一段称为队尾，允许删除的一端称为队头。它有以下几个特点：</p><ul><li>队列中数据是按照“先进先出（FIFO，First-In-First-Out）”方式进出队列的。</li><li>队列只允许在“队首”进行删除操作，而在“队尾”进行插入操作。</li></ul><h3 id="2-2-出队列和入队列"><a href="#2-2-出队列和入队列" class="headerlink" title="2.2 出队列和入队列"></a>2.2 出队列和入队列</h3><p>下图为队列的示意图：<br><img src="http://omu7tit09.bkt.clouddn.com/15006168233543.jpg" alt=""><br>队列中有10，20，30共3个数据。</p><p>下图为出队列的示意图：<br><img src="http://omu7tit09.bkt.clouddn.com/15006168586219.jpg" alt=""></p><ul><li>出队列前：队首是10，队尾是30。</li><li>出队列后：出队列(队首)之后。队首是20，队尾是30。</li></ul><p>下图为入队列的示意图：<br><img src="http://omu7tit09.bkt.clouddn.com/15006168910576.jpg" alt=""></p><ul><li>入队列前：队首是20，队尾是30。</li><li>入队列后：40入队列(队尾)之后。队首是20，队尾是40。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、栈&quot;&gt;&lt;a href=&quot;#一、栈&quot; class=&quot;headerlink&quot; title=&quot;一、栈&quot;&gt;&lt;/a&gt;一、栈&lt;/h2&gt;&lt;h3 id=&quot;1-1-栈的定义&quot;&gt;&lt;a href=&quot;#1-1-栈的定义&quot; class=&quot;headerlink&quot; title=&quot;1.1 栈的定义&quot;&gt;&lt;/a&gt;1.1 栈的定义&lt;/h3&gt;&lt;p&gt;栈（stack）是限定仅在表尾进行插入和删除操作的线性表。允许插入和删除的一端称为栈顶（top），另一端称为栈底，不含任何数据元素的栈称为空栈。它有以下几个特点：&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="栈" scheme="http://yoursite.com/tags/%E6%A0%88/"/>
    
      <category term="队列" scheme="http://yoursite.com/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法（1）：数组与链表</title>
    <link href="http://yoursite.com/2017/07/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89%EF%BC%9A%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2017/07/18/数据结构与算法（1）：链表/</id>
    <published>2017-07-18T14:14:45.000Z</published>
    <updated>2017-08-30T06:55:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>线性表是一种线性结构，它是具有相同类型的n个数据元素组成的优先序列。介绍线性表的几个基本组成部分：数组、单向链表、双向链表。</p><a id="more"></a><h2 id="一、数组"><a href="#一、数组" class="headerlink" title="一、数组"></a>一、数组</h2><p>数组有上界和下界，数组的元素在上下界内是连续的。</p><p>存储10，20，30，40，50的数组的示意图如下：<br><img src="http://omu7tit09.bkt.clouddn.com/15006132398847.jpg" alt=""><br>数组的特点是：数据是连续的；随机访问速度块。</p><p>数组中稍微复杂一点的是多维数组和动态数组。对于C语言而言，多维数组本质上也是通过一维数组实现的。至于动态数组，是指数组的容量能动态增长的数组；对于C语言而言，若要提供动态数组，需要手动实现；而对于C++而言，STL提供了Vector；对于Java而言，Collection集合中提供了ArrayList和Vector。</p><p>数组是将元素在内存中连续存放，由于每个元素占用内存相同，可以通过下标迅速访问数组中任何元素。但是如果要在数组中增加一个元素，需要移动大量元素，在内存中空出一个元素的空间，然后将要增加的元素放在其中。同样的道理，如果想删除一个元素，同样需要移动大量元素去填掉被移动的元素。如果应用需要快速访问数据，很少或不插入和删除元素，就应该用数组。</p><h2 id="二、单向链表"><a href="#二、单向链表" class="headerlink" title="二、单向链表"></a>二、单向链表</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p>单向链表（单链表）是链表的一种，它由节点组成，每个节点都包含下一个节点的指针。</p><p>单链表的示意图如下：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15006133555450.jpg" alt=""><br>表头为空，表头的后继节点是“节点10”（数据为10的节点），“节点10”的后继节点是“节点20”（数据为20的结点）……</p><h3 id="2-2-单链表删除节点"><a href="#2-2-单链表删除节点" class="headerlink" title="2.2 单链表删除节点"></a>2.2 单链表删除节点</h3><p><img src="http://omu7tit09.bkt.clouddn.com/15006134720249.jpg" alt=""><br>删除“节点30”<br>删除之前：“节点20”的后继节点为“节点30”，而“节点30”的后继节点为“节点40”<br>删除之后：“节点20”的后继节点为“节点40”</p><h3 id="2-3-单链表添加节点"><a href="#2-3-单链表添加节点" class="headerlink" title="2.3 单链表添加节点"></a>2.3 单链表添加节点</h3><p><img src="http://omu7tit09.bkt.clouddn.com/15006135467317.jpg" alt=""><br>在“节点10 ”与“节点20”之间添加“节点15”</p><p>添加之前：“节点10”的后继节点为“节点20”<br>添加之后：“节点10”的后继节点为“节点15”，而“节点15”的后继节点为“节点20”。</p><p>单链表的特点是：节点的链接方向是单向的；相对于数组来说，单链表的随机访问速度较慢，但是单链表删除、添加数据的效率很高。</p><h2 id="三、双向链表"><a href="#三、双向链表" class="headerlink" title="三、双向链表"></a>三、双向链表</h2><h3 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h3><p>双向链表（双链表）是链表的一种。和单链表一样，双链表也是由节点组成，它的每一个数据节点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表的任意一个节点开始，都可以很方便地访问它的前驱结点和后继节点。一般我们都构造双向循环链表。</p><p>双链表的示意图如下：<br><img src="http://omu7tit09.bkt.clouddn.com/15006137887925.jpg" alt=""><br>表头为空，表头的后继节点为“节点10”（数据为10的结点）；“节点10”的后继节点是“节点20”（数据为10的节点），“节点20”的前继节点是“节点10”；“节点20”的后继节点是“节点30”，“节点30”的前继节点是“节点20”;……；末尾节点的后继节点是表头。</p><h3 id="3-2-双链表删除节点"><a href="#3-2-双链表删除节点" class="headerlink" title="3.2 双链表删除节点"></a>3.2 双链表删除节点</h3><p><img src="http://omu7tit09.bkt.clouddn.com/15006139529251.jpg" alt=""><br>删除“节点30”</p><p>删除之前：“节点20”的后继节点为“节点30”，“节点30”的前继节点为“节点20”。“节点30”的后继节点为“节点40”，“节点40”的前继节点为“节点30”<br>删除之后：“节点20”的后继节点为“节点40”，“节点40”的前继节点为“节点20”</p><h3 id="3-3-双链表添加节点"><a href="#3-3-双链表添加节点" class="headerlink" title="3.3 双链表添加节点"></a>3.3 双链表添加节点</h3><p><img src="http://omu7tit09.bkt.clouddn.com/15006140850713.jpg" alt=""><br>在”节点10”与”节点20”之间添加”节点15”<br>添加之前：”节点10”的后继节点为”节点20”，”节点20” 的前继节点为”节点10”。<br>添加之后：”节点10”的后继节点为”节点15”，”节点15” 的前继节点为”节点10”。”节点15”的后继节点为”节点20”，”节点20” 的前继节点为”节点15”。</p><h2 id="四、数组与链表的区别"><a href="#四、数组与链表的区别" class="headerlink" title="四、数组与链表的区别"></a>四、数组与链表的区别</h2><p>数组是将元素在内存中连续存放，由于每个元素占用内存相同，可以通过下标迅速访问数组中任何元素。但是如果要在数组中增加一个元素，需要移动大量元素，在内存中空出一个元素的空间，然后将要增加的元素放在其中。同样的道理，如果想删除一个元素，同样需要移动大量元素去填掉被移动的元素。如果应用需要快速访问数据，很少或不插入和删除元素，就应该用数组。</p><p>链表恰好相反，链表中的元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起。比如：上一个元素有个指针指到下一个元素，以此类推，直到最后一个元素。如果要访问链表中一个元素，需要从第一个元素开始，一直找到需要的元素位置。但是增加和删除一个元素对于链表数据结构就非常简单了，只要修改元素中的指针就可以了。如果应用需要经常插入和删除元素你就需要用链表数据结构了。</p><p>C++语言中可以用数组处理一组数据类型相同的数据，但不允许动态定义数组的大小，即在使用数组之前必须确定数组的大小。而在实际应用中，用户使用数组之前有时无法准确确定数组的大小，只能将数组定义成足够大小，这样数组中有些空间可能不被使用，从而造成内存空间的浪费。链表是一种常见的数据组织形式，它采用动态分配内存的形式实现。需要时可以用new分配内存空间，不需要时用delete将已分配的空间释放，不会造成内存空间的浪费。</p><ul><li><p>(1) 从逻辑结构角度来看</p><ul><li>a：数组必须事先定义固定的长度（元素个数），不能适应数据动态地增减的情况。当数据增加时，可能超出原先定义的元素个数；当数据减少时，造成内存浪费。</li><li>b：链表动态地进行存储分配，可以适应数据动态地增减的情况，且可以方便地插入、删除数据项。（数组中插入、删除数据项时，需要移动其它数据项）</li></ul></li><li><p>(2)从内存存储角度来看</p><ul><li>a：(静态)数组从栈中分配空间, 对于程序员方便快速,但自由度小。</li><li>b：链表从堆中分配空间, 自由度大但申请管理比较麻烦. </li></ul></li></ul><blockquote><p>总结</p></blockquote><p>数组静态分配内存，链表动态分配内存；<br>数组在内存中连续，链表不连续；<br>数组元素在栈区，链表元素在堆区；<br>数组利用下标定位，时间复杂度为O(1)，链表定位元素时间复杂度O(n)；<br>数组插入或删除元素的时间复杂度O(n)，链表的时间复杂度O(1)。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线性表是一种线性结构，它是具有相同类型的n个数据元素组成的优先序列。介绍线性表的几个基本组成部分：数组、单向链表、双向链表。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>机器学习算法系列（27）：Isolation Forest</title>
    <link href="http://yoursite.com/2017/07/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%8827%EF%BC%89%EF%BC%9AIsolation%20Forest/"/>
    <id>http://yoursite.com/2017/07/15/机器学习算法系列（27）：Isolation Forest/</id>
    <published>2017-07-15T15:14:45.000Z</published>
    <updated>2017-12-26T10:51:18.319Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“An outlier is an observation which deviates so much from other observations as to arouse suspicions that it was generated by a different mechanism.” — D. M. Hawkins, Identification of Outliers, Chapman and Hall, 1980.</p></blockquote><a id="more"></a><p>异常检测 (anomaly detection)，或者又被称为“离群点检测” (outlier detection)，是机器学习研究领域中跟现实紧密联系、有广泛应用需求的一类问题。但是，什么是异常，并没有标准答案，通常因具体应用场景而异。如果要给一个比较通用的定义，很多文献通常会引用 Hawkins 在文章开头那段话。很多后来者的说法，跟这个定义大同小异。这些定义虽然笼统，但其实暗含了认定“异常”的两个标准或者说假设：</p><ul><li>1）异常数据跟样本中大多数数据不太一样。</li><li>2）异常数据在整体数据样本中占比比较小。</li></ul><p>为了刻画异常数据的“不一样”，最直接的做法是利用各种统计的、距离的、密度的量化指标去描述数据样本跟其他样本的疏离程度。而 Isolation Forest (Liu et al. 2011) 的想法要巧妙一些，它尝试直接去刻画数据的“疏离”(isolation)程度，而不借助其他量化指标。Isolation Forest 因为简单、高效，在学术界和工业界都有着不错的名声。</p><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>我们先用一个简单的例子来说明 Isolation Forest 的基本想法。假设现在有一组一维数据（如下图所示），我们要对这组数据进行随机切分，希望可以把点 A 和点 B 单独切分出来。具体的，我们先在最大值和最小值之间随机选择一个值 x，然后按照 <x 和="">=x 可以把数据分成左右两组。然后，在这两组数据中分别重复这个步骤，直到数据不可再分。显然，点 B 跟其他数据比较疏离，可能用很少的次数就可以把它切分出来；点 A 跟其他数据点聚在一起，可能需要更多的次数才能把它切分出来。<br><img src="http://orsw4brg1.bkt.clouddn.com/v2-dc4248661ea4a274f671c096c0f1eef4_b.jpg" alt=""></x></p><p>我们把数据从一维扩展到两维。同样的，我们沿着两个坐标轴进行随机切分，尝试把下图中的点A’和点B’分别切分出来。我们先随机选择一个特征维度，在这个特征的最大值和最小值之间随机选择一个值，按照跟特征值的大小关系将数据进行左右切分。然后，在左右两组数据中，我们重复上述步骤，再随机的按某个特征维度的取值把数据进行细分，直到无法细分，即：只剩下一个数据点，或者剩下的数据全部相同。跟先前的例子类似，直观上，点B’跟其他数据点比较疏离，可能只需要很少的几次操作就可以将它细分出来；点A’需要的切分次数可能会更多一些。<br><img src="http://orsw4brg1.bkt.clouddn.com/iforest2.jpg" alt=""><br>按照先前提到的关于“异常”的两个假设，一般情况下，在上面的例子中，点B和点B’ 由于跟其他数据隔的比较远，会被认为是异常数据，而点A和点A’ 会被认为是正常数据。直观上，异常数据由于跟其他数据点较为疏离，可能需要较少几次切分就可以将它们单独划分出来，而正常数据恰恰相反。这其实正是 Isolation Forest（IF）的核心概念。IF采用二叉树去对数据进行切分，数据点在二叉树中所处的深度反应了该条数据的“疏离”程度。整个算法大致可以分为两步：</p><ul><li>训练：抽取多个样本，构建多棵二叉树（Isolation Tree，即 iTree）；</li><li>预测：综合多棵二叉树的结果，计算每个数据点的异常分值。</li></ul><blockquote><p>训练：</p></blockquote><p>构建一棵 iTree 时，先从全量数据中抽取一批样本，然后随机选择一个特征作为起始节点，并在该特征的最大值和最小值之间随机选择一个值，将样本中小于该取值的数据划到左分支，大于等于该取值的划到右分支。然后，在左右两个分支数据中，重复上述步骤，直到满足如下条件：</p><ul><li>1）数据不可再分，即：只包含一条数据，或者全部数据相同。</li><li>2）二叉树达到限定的最大深度。</li></ul><p><img src="http://orsw4brg1.bkt.clouddn.com/431880-20150905115956889-1354964997.jpg" alt=""></p><blockquote><p>预测：</p></blockquote><p>计算数据 x 的异常分值时，先要估算它在每棵 iTree 中的路径长度（也可以叫深度）。具体的，先沿着一棵 iTree，从根节点开始按不同特征的取值从上往下，直到到达某叶子节点。假设 iTree 的训练样本中同样落在 x 所在叶子节点的样本数为 T.size，则数据 x 在这棵 iTree 上的路径长度 h(x)，可以用下面这个公式计算：</p><script type="math/tex; mode=display">h(x)=e+C(T.size)</script><p>公式中，$e$表示数据$x$从$iTree$的根节点到叶节点过程中经过的边的数目，$C(T.size)$ 可以认为是一个修正值，它表示在一棵用 $T.size$ 条样本数据构建的二叉树的平均路径长度。一般的，$C(n)$的计算公式如下：</p><script type="math/tex; mode=display">C(n)=2H(n-1)-\frac{2(n-1)}{n}</script><p>其中，$H(n-1)$可用$ln(n-1)+0.5772156649$估算，这里的常数是欧拉常数。数据 x 最终的异常分值 Score(x) 综合了多棵 iTree 的结果：</p><script type="math/tex; mode=display">Score(x)=2^{-\frac{E[h(x)]}{C(\psi)}}</script><p>公式中，$E(h(x)) $表示数据 x 在多棵 iTree 的路径长度的均值，$\psi$表示单棵 iTree 的训练样本的样本数，$C(\psi)$ 表示用$\psi$条数据构建的二叉树的平均路径长度，它在这里主要用来做归一化。</p><p>从异常分值的公式看，如果数据 x 在多棵 iTree 中的平均路径长度越短，得分越接近 1，表明数据 x 越异常；如果数据 x 在多棵 iTree 中的平均路径长度越长，得分越接近 0，表示数据 x 越正常；如果数据 x 在多棵 iTree 中的平均路径长度接近整体均值，则打分会在 0.5 附近。</p><h2 id="二、算法特点"><a href="#二、算法特点" class="headerlink" title="二、算法特点"></a>二、算法特点</h2><p>在论文中，也比较了其它的常用异常挖掘的算法。比如常用的统计方法，基于分类的方法，和基于聚类的方法，这些传统算法通常是对正常的数据构建一个模型，然后把不符合这个模型的数据，认为是异常数据。而且，这些模型通常为正常数据作优化，而不是为异常数据作优化。而iForest可以显示地找出异常数据，而不用对正常的数据构建模型。</p><p>由于异常数据的两个特征（少且不同： few and different）：异常数据只占很少量;异常数据特征值和正常数据差别很大。</p><p>异常数据的这两个特征，确定了算法的理论基础。因此，构建二叉树型结构的时候，异常数据离根更近，而正常数据离根更远，更深。算法为了效率考虑，也限定了树的深度：ceil(log2(n))，这个值近似于树的平均深度，因为只需要关心那些低于平均高度的数据点，而不需要树进行完全生成。</p><p>算法只需要两个参数：树的多少与采样的多少。实验发现，在100颗树的时候，路径的长度就已经覆盖得比较好了，因此选100颗也就够了。采样，是为了更好的将正常数据和异常数据分离开来。有别于其它模型，采样数据越多，反面会降低iForest识别异常数据的能力。因为，通常使用256个样本，这也是scikit-learn实现时默认使用的采样数。</p><p>由于算法只需要采样数据256条样本，并且对树的深度也有限制，因此，算法对内存要求很低，且处理速度很快，其时间复杂度也是线性的。</p><p>不像其它算法，需要计算距离或者密度来寻找异常数据，iForest算法可以很好的处理高维数据和大数据，并且也可以作为在线预测。假设采样为256条，结点最大为511个，假设一个节点占b字节，共使用t颗树，那么需要的内存只有511tb字节，基本上只需要几M到几十M的内存就够了。数据还显示，预测287,748条数据只花了7.6秒。</p><p>另外，iForest既能发现群异常数据，也能发现散点异常数据。同时也能处理训练数据中不包含异常数据的情况。</p><h2 id="三、代码示例"><a href="#三、代码示例" class="headerlink" title="三、代码示例"></a>三、代码示例</h2> <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"> print(__doc__)</div><div class="line"></div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> IsolationForest</div><div class="line"></div><div class="line">rng = np.random.RandomState(<span class="number">42</span>)</div><div class="line"></div><div class="line"><span class="comment"># Generate train data</span></div><div class="line">X = <span class="number">0.3</span> * rng.randn(<span class="number">100</span>, <span class="number">2</span>)</div><div class="line">X_train = np.r_[X + <span class="number">2</span>, X - <span class="number">2</span>]</div><div class="line"><span class="comment"># Generate some regular novel observations</span></div><div class="line">X = <span class="number">0.3</span> * rng.randn(<span class="number">20</span>, <span class="number">2</span>)</div><div class="line">X_test = np.r_[X + <span class="number">2</span>, X - <span class="number">2</span>]</div><div class="line"><span class="comment"># Generate some abnormal novel observations</span></div><div class="line">X_outliers = rng.uniform(low=<span class="number">-4</span>, high=<span class="number">4</span>, size=(<span class="number">20</span>, <span class="number">2</span>))</div><div class="line"></div><div class="line"><span class="comment"># fit the model</span></div><div class="line">clf = IsolationForest(max_samples=<span class="number">100</span>, random_state=rng)</div><div class="line">clf.fit(X_train)</div><div class="line">y_pred_train = clf.predict(X_train)</div><div class="line">y_pred_test = clf.predict(X_test)</div><div class="line">y_pred_outliers = clf.predict(X_outliers)</div><div class="line"></div><div class="line"><span class="comment"># plot the line, the samples, and the nearest vectors to the plane</span></div><div class="line">xx, yy = np.meshgrid(np.linspace(<span class="number">-5</span>, <span class="number">5</span>, <span class="number">50</span>), np.linspace(<span class="number">-5</span>, <span class="number">5</span>, <span class="number">50</span>))</div><div class="line">Z = clf.decision_function(np.c_[xx.ravel(), yy.ravel()])</div><div class="line">Z = Z.reshape(xx.shape)</div><div class="line"></div><div class="line">plt.title(<span class="string">"IsolationForest"</span>)</div><div class="line">plt.contourf(xx, yy, Z, cmap=plt.cm.Blues_r)</div><div class="line"></div><div class="line">b1 = plt.scatter(X_train[:, <span class="number">0</span>], X_train[:, <span class="number">1</span>], c=<span class="string">'white'</span>,</div><div class="line">                 s=<span class="number">20</span>, edgecolor=<span class="string">'k'</span>)</div><div class="line">b2 = plt.scatter(X_test[:, <span class="number">0</span>], X_test[:, <span class="number">1</span>], c=<span class="string">'green'</span>,</div><div class="line">                 s=<span class="number">20</span>, edgecolor=<span class="string">'k'</span>)</div><div class="line">c = plt.scatter(X_outliers[:, <span class="number">0</span>], X_outliers[:, <span class="number">1</span>], c=<span class="string">'red'</span>,</div><div class="line">                s=<span class="number">20</span>, edgecolor=<span class="string">'k'</span>)</div><div class="line">plt.axis(<span class="string">'tight'</span>)</div><div class="line">plt.xlim((<span class="number">-5</span>, <span class="number">5</span>))</div><div class="line">plt.ylim((<span class="number">-5</span>, <span class="number">5</span>))</div><div class="line">plt.legend([b1, b2, c],</div><div class="line">           [<span class="string">"training observations"</span>,</div><div class="line">            <span class="string">"new regular observations"</span>, <span class="string">"new abnormal observations"</span>],</div><div class="line">           loc=<span class="string">"upper left"</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><p> <img src="http://orsw4brg1.bkt.clouddn.com/%E4%B8%8B111%E8%BD%BD.png" alt=""><br> 算法基本上不需要配置参数就可以直接使用，通常就以下几个(参数明显比随机森林简单)：</p><ul><li>n_estimators: 默认为100，配置iTree树的多少</li><li>max_samples: 默认为265，配置采样大小</li><li>max_features: 默认为全部特征，对高维数据，可以只选取部分特征</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;“An outlier is an observation which deviates so much from other observations as to arouse suspicions that it was generated by a different mechanism.” — D. M. Hawkins, Identification of Outliers, Chapman and Hall, 1980.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="iForest" scheme="http://yoursite.com/tags/iForest/"/>
    
      <category term="异常检测算法" scheme="http://yoursite.com/tags/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/"/>
    
      <category term="集成算法" scheme="http://yoursite.com/tags/%E9%9B%86%E6%88%90%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>机器学习算法系列（26）：因子分解机（FM）与场感知分解机（FFM）</title>
    <link href="http://yoursite.com/2017/07/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%8826%EF%BC%89%EF%BC%9A%E5%9B%A0%E5%AD%90%E5%88%86%E8%A7%A3%E6%9C%BA%EF%BC%88FM%EF%BC%89%E4%B8%8E%E5%9C%BA%E6%84%9F%E7%9F%A5%E5%88%86%E8%A7%A3%E6%9C%BA%EF%BC%88FFM%EF%BC%89/"/>
    <id>http://yoursite.com/2017/07/13/机器学习算法系列（26）：因子分解机（FM）与场感知分解机（FFM）/</id>
    <published>2017-07-13T15:14:45.000Z</published>
    <updated>2017-12-26T08:03:55.068Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自<a href="https://tech.meituan.com/deep-understanding-of-ffm-principles-and-practices.html" target="_blank" rel="noopener">美团点评技术团队</a></p><p>FM和FFM模型是最近几年提出的模型，凭借其在数据量比较打并且特征稀疏的情况下，忍让能够得到优秀的性能和效果，屡次在各大公司举办的CTR预估比赛中获得不错的战绩。</p><a id="more"></a><p>在计算广告领域，点击率CTR（click-through rate）和转化率CVR（conversion rate）是衡量广告流量的两个关键指标。准确的估计CTR、CVR对于提高流量的价值，增加广告收入有重要的指导作用。预估CTR、CVR，业界常用的方法由人工特征工程+LR（Logistic Regression）、GBDT（Gradient Boosting Decision Tree）+LR、FM（Factorization Machine）和FFM（Field-aware Factorization Machine）模型。在这些模型中，FM和FFM近年来表现突出，分别在Criteo和Avazu举办的CTR预测竞赛中夺得冠军。</p><p>本文基于对FFM模型的深度调研和使用经验，从原理、实现和应用几个方面对FFM进行探讨，希望能够从原理上解释FFM模型在点击率预估上取得优秀效果的原因。因为FFM是在FM的基础上改进得来的，所以，我们首先引入FM模型。</p><h2 id="一、FM（因子分解机）"><a href="#一、FM（因子分解机）" class="headerlink" title="一、FM（因子分解机）"></a>一、FM（因子分解机）</h2><h3 id="1-1-FM的原理及推导"><a href="#1-1-FM的原理及推导" class="headerlink" title="1.1 FM的原理及推导"></a>1.1 FM的原理及推导</h3><p>因子分解机（Factorization Machine，简称FM），又称分解机。是由德国康斯坦茨大学的Steffen Rendle（现任职于Google）于2010年最早提出的，旨在解决大规模稀疏数据下的特征组合问题。在系统介绍FM之前，先了解一下在实际场景中，稀疏数据是怎样产生的。</p><p>假设一个广告分类的问题，根据用户和广告位相关的特征，预测用户是否点击了广告。元数据如下：</p><div class="table-container"><table><thead><tr><th>Clicked?</th><th>Country</th><th>Day</th><th>Ad_type</th></tr></thead><tbody><tr><td>1</td><td>USA</td><td>26/11/15</td><td>Movie</td></tr><tr><td>0</td><td>China</td><td>1/7/14</td><td>Game</td></tr><tr><td>1</td><td>China</td><td>19/2/15</td><td>Game</td></tr></tbody></table></div><p>“Clicked？”是label，Country、Day、Ad_type是特征。由于三种特征都是categorical类型的，需要经过独热编码（One-Hot Encoding）转换成数值型特征。    </p><div class="table-container"><table><thead><tr><th>Clicked?</th><th>Country=USA</th><th>Country=China</th><th>Day=26/11/15</th><th>Day=1/7/14</th><th>Day=19/2/15</th><th>Ad_type=Movie</th><th>Ad_type=Game</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td></tr></tbody></table></div><p>由上表可以看出，经过One-Hot编码之后，大部分样本数据特征是比较稀疏的。上面的样例中，每个样本有7维特征，但平均仅有3维特征具有非零值。实际上，这种情况并不是此例独有的，在真实应用场景中这种情况普遍存在。例如，CTR/CVR预测时，用户的性别、职业、教育水平、品类偏好、商品的品类等，经过One-Hot编码转换后都会导致样本数据的稀疏性。特别是商品品类这种类型的特征，如商品的末级品类约有550个，采用One-Hot编码生成550个数值特征，但每个样本的这550个特征，有且仅有一个是有效的（非零）。由此可见，数据稀疏性是实际问题中不可避免的挑战。</p><p>One-Hot编码的另一个特点就是导致特征空间大。例如，商品品类有550维特征，一个categorical特征转换为550维数值特征，特征空间剧增。</p><p>同时通过观察大量的样本数据可以发现，某些特征经过关联之后，与label之间的相关性就会提高。如：“USA”与“Thanksgiving”、“China”与“Chinese New Year”这样的关联特征，对用户的点击有着正向的影响。换句话说，来自“China”的用户很可能会在“Chinese New Year”有大量的浏览、购买行为，而在“Thanksgiving”却不会有特别的消费行为。这种关联特征与label的正向相关性在实际问题中是普遍存在的，如“化妆品”类商品与“女”性，“球类运动配件”的商品与“男”性，“电影票”的商品与“电影”品类偏好等。因此，引入两个特征的组合是非常有意义的。</p><p>表示特征之间的关联，最直接的方法的是构造组合特征。样本中特征之间的关联信息在one-hot编码和浅层学习模型（如LR、SVM）是做不到的。目前工业界主要有两种手段得到组合特征：</p><ul><li>1）人工特征工程（数据分析＋人工构造）；</li><li>2）通过模型做组合特征的学习（深度学习方法、FM/FFM方法）</li></ul><p>本章主要讨论FM和FFM用来学习特征之间的关联。多项式模型是包含特征组合的最直观的模型。在多项式模型中，特征 $x_i$ 和 $x_j$ 的组合采用 $x_i$ 表示，即 $x_i$ 和 $x_j$ 都非零时，组合特征 $x_ix_j$ 才有意义。从对比的角度，本文只讨论二阶多项式模型。模型的表达式如下：</p><script type="math/tex; mode=display">y(x)=w_0+\sum_{i=1}^nw_ix_i+\sum_{i=1}^n\sum_{j=i+1}^nw_{ij}x_ix_j</script><p>其中，$n$代表样本的特征数量，$x_i$是第$i$个特征的值，$w_0、w_i、w_{ij}$是模型的参数。</p><p>从这个公式可以看出，组合特征的参数一共有$\frac{n(n-1)}{2}$个，任意两个参数都是独立的。然而，在数据稀疏性普遍存在的实际应用场景中，二次项参数的训练是很困难的。其原因是，回归模型的参数$w$的学习结果就是从训练样本中计算充分统计量（凡是符合指数族分布的模型都具有此性质），而在这里交叉项的每一个参数$w_{ij}$的学习过程需要大量的$x_i$、$x_j$同时非零的训练样本数据。由于样本数据本来就很稀疏，能够满足“$x_i$和$x_j$都非零”的样本数就会更少。训练样本不充分，学到的参数$w_{ij}$就不是充分统计量结果，导致参数$w_{ij}$不准确，而这会严重影响模型预测的效果（performance）和稳定性。</p><p>那么，如何解决二次项参数的训练问题呢？矩阵分解提供了一种解决思路。在Model-based的协同过滤中，一个rating矩阵可以分解为user矩阵和item矩阵，每个user和item都可以采用一个隐向量表示。比如在下图中的例子，我们把每个user表示成一个二维向量，同时把每个item表示成一个二维向量，两个向量点积就是矩阵中user对item的打分。<img src="http://omu7tit09.bkt.clouddn.com/14999608253323.png" alt=""></p><p>类似地，所有二次项参数 $w_{ij}$可以组成一个对称阵 $W$（为了方便说明FM的由来，对角元素可以设置为正实数），那么这个矩阵就可以分解为 $W=V^TV$，$V$ 的第$ j$列便是第 $j$ 维特征的隐向量。换句话说，每个参数 $w_{ij}=⟨v_i,v_j⟩$，这就是FM模型的核心思想。因此，FM的模型方程为（本文不讨论FM的高阶形式）</p><script type="math/tex; mode=display">y(x)=w_0+\sum _{i=1}^nw_ix_i+\sum_{i=1}^n\sum_{j=i+1}^n⟨vi,vj⟩x_ix_j \  \  \ \   \  \ ···（2）</script><p>其中，$v_i$是第i维特征的隐向量，$⟨⋅,⋅⟩$代表向量点积，计算公式为</p><script type="math/tex; mode=display">⟨v_i,v_j⟩=\sum_{f=1}^kv_{i,f}·v_{j,f}</script><p>隐向量的长度为$k(k&lt;&lt;n)$，包含k个描述特征的因子。<br>具体解读一下这个公式</p><ul><li>线性模型+交叉项：直观地看FM模型表达式，前两项是线性回归模型的表达式，最后一项是二阶特征交叉项（又称组合特征项），表示模型将两个互异的特征分量之间的关联信息考虑进来。用交叉项表示组合特征，从而建立特征与结果之间的非线性关系。</li><li>交叉项系数 → 隐向量内积：由于FM模型是在线性回归基础上加入了特征交叉项，模型求解时不直接求特征交叉项的系数$w_{ij}$（因为对应的组合特征数据稀疏，参数学习不充分），故而采用隐向量的内积$⟨v_i,v_j⟩$表示$w_{ij}$。具体的，FM求解过程中的做法是：对每一个特征分量$x_i$引入隐向量$v_i＝(v_{i,1},v_{i,2},⋯,v_{i,k})$，利用$v_iv^T_j$内积结果对交叉项的系数$w_{ij}$进行估计，公式表示：$ŵ_{ij}=v_iv^T_j$</li></ul><p>根据上式，二次项的参数数量减少为$kn$个，远少于多项式模型的参数数量。</p><p>此外，参数因子化表示后，使得$x_hx_i$的参数与$x_ix_j$的参数不再相互独立。这样我们就可以在样本系数的情况下相对合理地估计FM模型交叉项的参数。具体地：</p><script type="math/tex; mode=display">⟨v_h,v_i⟩=\sum_{f=1}^k v_{h,f}·v_{i,f}</script><script type="math/tex; mode=display">⟨v_i,v_j⟩=\sum_{f=1}^k v_{i,f}·v_{j,f}</script><p>$x_hx_i$与$x_ix_j$的系数分别为$⟨v_h,v_i⟩$和$⟨v_i,v_j⟩$，它们之间有共同项$v_i$，也就是说，所有包含$x_i$的非零组合特征（存在某个$j≠i$,使得$x_ix_j≠0$）的样本都可以用来学习隐向量$v_i$，这在很大程度上避免了数据系数行造成参数估计不准确的影响。而在多项式模型中，$w_{hi}$和$w_{ij}$是相互独立的。</p><p>显而易见，公式(2)是一个通用的拟合方程，可以采用不同的损失函数用于解决回归、二元分类等问题，比如可以采用MSE（Mean Square Error）损失函数来求解回归问题，也可以采用Hinge、Cross-Entropy损失来求解分类问题。当然，在进行二元分类时，FM的输出需要经过Sigmoid变换，这与Logistic回归是一样的。</p><div class="table-container"><table><thead><tr><th>FM应用场景</th><th>损失函数</th><th>说明</th></tr></thead><tbody><tr><td>回归</td><td>均方误差（MSE）损失</td><td>Mean Square Error，与平方误差类似</td></tr><tr><td>二类分类</td><td>Hinge/Cross-Entopy损失</td><td>分类时，结果需要做sigmoid变换</td></tr><tr><td>排序</td><td></td></tr></tbody></table></div><p>直观上看，FM的复杂度是$O(kn^2)$，但是，通过下面的等价转换，可以将FM的二次项化简，其复杂度可以优化到$O(kn)$，即：</p><script type="math/tex; mode=display">\sum_{i=1}^n\sum_{j=i+1}^n⟨v_i,v_j⟩x_i,x_j=\frac{1}{2}\sum_{f=1}^k[(\sum_{i=1}^nv_{i,f}x_i)^2-\sum_{i=1}^nv_{i,f}^2x_i^2]</script><p>下面给出详细推导：</p><script type="math/tex; mode=display">\sum_{i=1}^n\sum_{j=i+1}^n⟨v_i,v_j⟩x_ix_j \\ =\frac{1}{2}\sum_{i=1}^n\sum_{f=1}^n⟨v_i,v_j⟩x_ix_j-\frac{1}{2}\sum_{i=1}^n⟨v_i,v_i⟩x_ix_i\\=\frac{1}{2}(\sum_{i=1}^n\sum_{j=1}^n\sum_{f=1}^kv_{i,f}v_{j,f}x_ix_j-\sum_{i=1}^n\sum_{f=1}^kv_{i,f}v_{i,f}x_ix_i)\\=\frac{1}{2}\sum_{f=1}^k[(\sum_{i=1}^nv_{i,f}x_i)·(\sum_{j=1}^nv_{j,f}x_j)-\sum_{i=1}^nv_{i,f}^2x_i^2]\\=\frac{1}{2}\sum_{f=1}^k[(\sum_{i=1}^nv_{i,f}x_i)^2- \sum_{i=1}^nv_{i,f}^2x_i^2]</script><p>解读第一步到第二部，这里用A表示系数矩阵V的上三角元素，B表示对角线上的交叉项系数。由于系数矩阵V是一个对称阵，所以下三角和上三角相等，有下式成立：</p><script type="math/tex; mode=display">A=\frac{1}{2}(2A+B)-\frac{1}{2}B</script><p>其中，</p><script type="math/tex; mode=display">A=\sum_{i=1}^n\sum_{j=i+1}^n⟨v_i,v_j⟩x_ix_j,B=\sum_{i=1}^n⟨v_i,v_j⟩x_ix_i</script><p>如果用随机梯度下降（SGD）法学系模型参数。那么模型各个参数的梯度如下：</p><script type="math/tex; mode=display">\frac{\partial}{\partial\theta}y\left(x\right)=\left\{\begin{array}{l}    1,\ \ if\ \theta\ is\ w_0\left(\textrm{常数项}\right)\\    x_i,\ if\ \theta\ is\ w_i\left(\textrm{线性项}\right)\\    x_i\underset{j=1}{\overset{n}{\varSigma}}v_{j,f}x_j-v_{i,f}x_{i}^{2},\ if\ \theta\ is\ v_{i,f}\left(\textrm{交叉项}\right)\\\end{array}\right.</script><p>其中，$v_{j,f}$是隐向量$v_j$的第f个元素。</p><p>由于$\underset{j=1}{\overset{n}{\varSigma}}v_{j,f}x_j$只与f有关，在参数迭代过程中，只需要计算第一次所有f的$\underset{j=1}{\overset{n}{\varSigma}}v_{j,f}x_j$，就能够方便地得到所有$v_{i,f}$的梯度。显然，计算所有f的$\underset{j=1}{\overset{n}{\varSigma}}v_{j,f}x_j$的复杂度是$O(kn)$；已知$\underset{j=1}{\overset{n}{\varSigma}}v_{j,f}x_j$时，计算每个参数梯度的复杂度是$O(n)$；得到梯度后，更新每个参数的复杂度是$O(1)$；模型参数一共有$nk+n+1$个。因此，FM参数训练的时间复杂度为$O(kn )$</p><h3 id="1-2-FM的优势"><a href="#1-2-FM的优势" class="headerlink" title="1.2 FM的优势"></a>1.2 FM的优势</h3><p>综上可知，FM算法可以再线性时间内完成模型训练，以及对新样本作出预测，所以说FM是一个非常高效的模型。FM模型的核心作用可以概括为以下三个：</p><ul><li>1）FM降低了交叉项参数学习不充分的影响：one-hot编码后的样本数据非常稀疏，组合特征更是如此。为了解决交叉项参数学习不充分、导致模型有偏或不稳定的问题。作者借鉴矩阵分解的思路：每一维特征用k维的隐向量表示，交叉项的参数$w_ij$用对应特征隐向量的内积表示，即$⟨v_i,v_j⟩$。这样参数学习由之前学习交叉项参数$w_{ij}$的过程，转变为学习$n$个单特征对应k维隐向量的过程。很明显，单特征参数（k维隐向量$v_i$）的学习要比交叉项参数$w_{ij}$学习的更加充分。示例说明：<br>假如有10w条训练样本，其中出现女性特征的样本数为3w，出现男性特征的样本数为7w，出现汽车特征的样本数为2000，出现化妆品的样本数为1000。特征共现的样本数如下：</li></ul><div class="table-container"><table><thead><tr><th>共现交叉特征</th><th>样本数</th><th>注</th></tr></thead><tbody><tr><td>&lt;女性，汽车&gt;</td><td>500</td><td>同时出现&lt;女性，汽车&gt;的样本数</td></tr><tr><td>&lt;女性，化妆品&gt;</td><td>1000</td><td>同时出现&lt;女性，化妆品&gt;的样本数</td></tr><tr><td>&lt;男性，汽车&gt;</td><td>1500</td><td>同时出现&lt;男性，汽车&gt;的样本数</td></tr><tr><td>&lt;男性，化妆品&gt;</td><td>0</td><td>样本中无此特征组合项</td></tr></tbody></table></div><p>&lt;女性，汽车&gt;的含义是女性看汽车广告。可以看到，但特征对应的样本数远大于组合特征对应的样本数。训练时，但特征参数相比交叉项特征参数会学习地更充分。因此，可以说FM降低了因数据稀疏，导致交叉项参数学习不充分的影响。</p><ul><li><p>2）FM提升了模型预估能力。依然看上面的示例，样本中没有没有&lt;男性，化妆品&gt;交叉特征，即没有男性看化妆品广告的数据。如果yoga多项式模型来建模，对应的交叉项参数$w_{男性，化妆品}$是学不出来的，因为数据中没有对应的共现交叉特征。那么多项式模型就不能对出现的男性看化妆品广告场景给出准确地预估。<br>FM模型是否能得到交叉项参数$w_{男性，化妆品}$呢？答案是肯定的。由于FM模型是把交叉项参数用对应的特征隐向量内积表示，这里表示为$w_{男性，化妆品}=<v_{男性}，v_{化妆品}>$，即用男性特征隐向量$v_{男性}$和化妆品特征隐向量$v_{化妆品}$的内积表示交叉项参数$w_{男性，化妆品}$由于FM学习的参数就是单特征的隐向量，那么男性看化妆品广告的预估结果可以用$<v_{男性}，v_{化妆品}>$得到。这样，即便训练集中没有出现男性看化妆品广告的样本，FM模型仍然可以用来预估，提升了预估呢不给力。</v_{男性}，v_{化妆品}></v_{男性}，v_{化妆品}></p></li><li><p>3）FM提升了参数学习效率：这个显而易见，参数个数由$(n2+n+1)(n2+n+1)$变为$(nk+n+1)(nk+n+1)$个，模型训练复杂度也由$O(mn^2)$变为$O(mnk)$。mm为训练样本数。对于训练样本和特征数而言，都是线性复杂度。此外，就FM模型本身而言，它是在多项式模型基础上对参数的计算做了调整，因此也有人把FM模型称为多项式的广义线性模型，也是恰如其分的。从交互项的角度看，FM仅仅是一个可以表示特征之间交互关系的函数表法式，可以推广到更高阶形式，即将多个互异特征分量之间的关联信息考虑进来。例如在广告业务场景中，如果考虑User-Ad-Context三个维度特征之间的关系，在FM模型中对应的degree为3。</p><p>最后一句话总结，FM最大特点和优势：<strong>FM模型对稀疏数据有更好的学习能力，通过交互项可以学习特征之间的关联关系，并且保证了学习效率和预估能力</strong>。</p><p>与其他模型相比，它的优势如下：</p><ul><li>FM是一种比较灵活的模型，通过合适的特征变换方式，FM可以模拟二阶多项式核的SVM模型、MF模型、SVD++模型等；</li><li>相比SVM的二阶多项式核而言，FM在样本稀疏的情况下是有优势的；而且，FM的训练/预测复杂度是线性的，而二项多项式核SVM需要计算核矩阵，核矩阵复杂度就是N平方。</li><li>相比MF而言，我们把MF中每一项的rating分改写为 $r_{ui}∼β_u+γ_i+x^T_uy_i$，从公式(2)中可以看出，这相当于只有两类特征 $u$ 和$ i$ 的FM模型。对于FM而言，我们可以加任意多的特征，比如user的历史购买平均值，item的历史购买平均值等，但是MF只能局限在两类特征。SVD++与MF类似，在特征的扩展性上都不如FM，在此不再赘述。</li></ul></li></ul><h2 id="二、FFM（场感知分解机器）"><a href="#二、FFM（场感知分解机器）" class="headerlink" title="二、FFM（场感知分解机器）"></a>二、FFM（场感知分解机器）</h2><h3 id="2-1-FFM的原理及推导"><a href="#2-1-FFM的原理及推导" class="headerlink" title="2.1 FFM的原理及推导"></a>2.1 FFM的原理及推导</h3><p>场感知分解机器（Field-aware Factorization Machine ，简称FFM）最初的概念来自Yu-Chin Juan(阮毓钦，毕业于中国台湾大学，现在美国Criteo工作)与其比赛队员，是他们借鉴了来自Michael Jahrer的论文中的field概念提出了FM的升级版模型。通过引入field的概念，FFM把相同性质的特征归于同一个field。以上面的广告分类为例，“Day=26/11/15”、“Day=1/7/14”、“Day=19/2/15”这三个特征都是代表日期的，可以放到同一个field中。同理，商品的末级品类编码生成了550个特征，这550个特征都是说明商品所属的品类，因此它们也可以放到同一个field中。简单来说，同一个categorical特征经过One-Hot编码生成的数值特征都可以放到同一个field，包括用户性别、职业、品类偏好等。在FFM中，每一维特征 $x_i$，针对其它特征的每一种field $f_j$，都会学习一个隐向量 $v_{i,f_j}$。因此，隐向量不仅与特征相关，也与field相关。也就是说，“Day=26/11/15”这个特征与“Country”特征和“Ad_type”特征进行关联的时候使用不同的隐向量，这与“Country”和“Ad_type”的内在差异相符，也是FFM中“field-aware”的由来。</p><p>假设样本的 nn 个特征属于 ff 个field，那么FFM的二次项有 nfnf个隐向量。而在FM模型中，每一维特征的隐向量只有一个。FM可以看作FFM的特例，是把所有特征都归属到一个field时的FFM模型。根据FFM的field敏感特性，可以导出其模型方程。</p><script type="math/tex; mode=display">y(x)=w_0+∑_{i=1}^nw_ix_i+∑_{i=1}^n∑_{j=i+1}^n⟨v_{i,fj},v_{j,f_i}⟩x_ix_j</script><p>其中，$f_j$是第j个特征所属的field。如果隐向量的长度为k，那么FFM的二次参数有nfk个，远多于FM模型的nk个。此外，由于隐向量与field相关，FFM二次项并不能够化简，其复杂度为$O(kn^2)$。</p><p>下面以一个例子简单说明FFM的特征组合方式。输入记录如下</p><div class="table-container"><table><thead><tr><th>User</th><th>Movie</th><th><span class="Apple-tab-span" style="white-space:pre"></span>Genre</th><th>Price</th></tr></thead><tbody><tr><td>YuChin</td><td><span class="Apple-tab-span" style="white-space:pre"></span>3Idiots</td><td><span class="Apple-tab-span" style="white-space:pre"></span>Comedy, Drama</td><td>$9.99</td></tr></tbody></table></div><p>这条记录可以编码成5个特征，其中“Genre=Comedy”和“Genre=Drama”属于同一个field，“Price”是数值型，不用One-Hot编码转换。为了方便说明FFM的样本格式，我们将所有的特征和对应的field映射成整数编号。</p><div class="table-container"><table><thead><tr><th>Field name</th><th>Field index</th><th>Feature name</th><th>Feature index</th></tr></thead><tbody><tr><td>User</td><td>1</td><td><span class="Apple-tab-span" style="white-space:pre"></span>User=YuChin</td><td>1</td></tr><tr><td>Movie</td><td>2</td><td>Movie=3Idiots</td><td>2</td></tr><tr><td>Genre</td><td>3</td><td>Genre=Comedy</td><td>3</td></tr><tr><td></td><td></td><td>Genre=Drama</td><td>4</td></tr><tr><td>Price</td><td>4</td><td>Price</td><td>5</td></tr></tbody></table></div><p>那么，FFM的组合特征有10项，如下图所示。<img src="http://omu7tit09.bkt.clouddn.com/15000038125272.png" alt=""></p><p>其中，红色表示Field编码，蓝色表示Feature编码，绿色表示样本的组合特征取值（离散化后的结果）。二阶交叉项的系数是通过与Field相关的隐向量的内积得到的。如果单特征有n个，全部做二阶特征组合的话，会有$C^2_n=\frac{n(n−1)}{2}$个。</p><h3 id="2-2-FFM的应用"><a href="#2-2-FFM的应用" class="headerlink" title="2.2 FFM的应用"></a>2.2 FFM的应用</h3><p>在DSP的场景中，FFM主要用来预估站内的CTR和CVR，即一个用户对一个商品的潜在点击率和点击后的转化率。</p><p>CTR和CVR预估模型都是在线下训练，然后用于线上预测。两个模型采用的特征大同小异，主要有三类：用户相关的特征、商品相关的特征、以及用户-商品匹配特征。用户相关的特征包括年龄、性别、职业、兴趣、品类偏好、浏览/购买品类等基本信息，以及用户近期点击量、购买量、消费额等统计信息。商品相关的特征包括所属品类、销量、价格、评分、历史CTR/CVR等信息。用户-商品匹配特征主要有浏览/购买品类匹配、浏览/购买商家匹配、兴趣偏好匹配等几个维度。</p><p>为了使用FFM方法，所有的特征必须转换成“field_id:feat_id:value”格式，field_id代表特征所属field的编号，feat_id是特征编号，value是特征的值。数值型的特征比较容易处理，只需分配单独的field编号，如用户评论得分、商品的历史CTR/CVR等。categorical特征需要经过One-Hot编码成数值型，编码产生的所有特征同属于一个field，而特征的值只能是0或1，如用户的性别、年龄段，商品的品类id等。除此之外，还有第三类特征，如用户浏览/购买品类，有多个品类id且用一个数值衡量用户浏览或购买每个品类商品的数量。这类特征按照categorical特征处理，不同的只是特征的值不是0或1，而是代表用户浏览或购买数量的数值。按前述方法得到field_id之后，再对转换后特征顺序编号，得到feat_id，特征的值也可以按照之前的方法获得。</p><p>CTR、CVR预估样本的类别是按不同方式获取的。CTR预估的正样本是站内点击的用户-商品记录，负样本是展现但未点击的记录；CVR预估的正样本是站内支付（发生转化）的用户-商品记录，负样本是点击但未支付的记录。构建出样本数据后，采用FFM训练预估模型，并测试模型的性能。</p><div class="table-container"><table><thead><tr><th></th><th><span class="Apple-tab-span" style="white-space:pre"></span>#(field)</th><th>#(feature)</th><th>AUC</th><th>Logloss</th></tr></thead><tbody><tr><td>站内CTR</td><td>39</td><td>2456</td><td>0.77</td><td>0.38</td></tr><tr><td>站内CVR</td><td>67</td><td>2441</td><td>0.92</td><td>0.13</td></tr></tbody></table></div><p>由于模型是按天训练的，每天的性能指标可能会有些波动，但变化幅度不是很大。这个表的结果说明，站内CTR/CVR预估模型是非常有效的。</p><p>在训练FFM的过程中，有许多小细节值得特别关注。</p><p>第一，样本归一化。FFM默认是进行样本数据的归一化，即 pa.normpa.norm 为真；若此参数设置为假，很容易造成数据inf溢出，进而引起梯度计算的nan错误。因此，样本层面的数据是推荐进行归一化的。</p><p>第二，特征归一化。CTR/CVR模型采用了多种类型的源特征，包括数值型和categorical类型等。但是，categorical类编码后的特征取值只有0或1，较大的数值型特征会造成样本归一化后categorical类生成特征的值非常小，没有区分性。例如，一条用户-商品记录，用户为“男”性，商品的销量是5000个（假设其它特征的值为零），那么归一化后特征“sex=male”（性别为男）的值略小于0.0002，而“volume”（销量）的值近似为1。特征“sex=male”在这个样本中的作用几乎可以忽略不计，这是相当不合理的。因此，将源数值型特征的值归一化到 [0,1][0,1] 是非常必要的。</p><p>第三，省略零值特征。从FFM模型的表达式可以看出，零值特征对模型完全没有贡献。包含零值特征的一次项和组合项均为零，对于训练模型参数或者目标值预估是没有作用的。因此，可以省去零值特征，提高FFM模型训练和预测的速度，这也是稀疏样本采用FFM的显著优势。</p><h3 id="2-3-FFM实现"><a href="#2-3-FFM实现" class="headerlink" title="2.3 FFM实现"></a>2.3 FFM实现</h3><p>Yu-Chin Juan实现了一个C++版的FFM模型，源码可从Github下载[10]。这个版本的FFM省略了常数项和一次项，模型方程如下。</p><script type="math/tex; mode=display">ϕ(w,x)=∑_{j1,j2∈C_2}⟨w_{j_1,f_2},w_{j_2,f_1}⟩x_{j_1}x_{j_2}</script><p>其中，$C_2$是非零特征的二元组合，$j_1$是特征，属于field $f_1$，$w_{j_1,f_2}$是特征 $j_1$对field $f_2$ 的隐向量。此FFM模型采用logistic loss作为损失函数，和L2惩罚项，因此只能用于二元分类问题。</p><script type="math/tex; mode=display">\underset{w}{min}∑_{i=1}^Llog(1+exp{−y_iϕ(w,x_i)})+\frac{λ}{2}‖w‖2</script><p>其中，$y_i∈{−1,1}$是第 i个样本的label，L是训练样本数量，λ 是惩罚项系数。模型采用SGD优化，优化流程如下。<img src="http://omu7tit09.bkt.clouddn.com/15000056384443.png" alt=""><br>参考 Algorithm1, 下面简单解释一下FFM的SGD优化过程。<br>算法的输入 tr、va、pa 分别是训练样本集、验证样本集和训练参数设置。</p><ol><li>根据样本特征数量（tr.ntr.n）、field的个数（tr.mtr.m）和训练参数（papa），生成初始化模型，即随机生成模型的参数；</li><li>如果归一化参数 pa.normpa.norm 为真，计算训练和验证样本的归一化系数，样本i的归一化系数为<script type="math/tex; mode=display">R[i]=\frac{1}{||X[i]||}</script></li><li>对每一轮迭代，如果随机更新参数 pa.randpa.rand 为真，随机打乱训练样本的顺序；</li><li>对每一个训练样本，执行如下操作:<ul><li>计算每一个样本的FFM项，即公式中的输出 $ϕ$；</li><li>计算每一个样本的训练误差，如算法所示，这里采用的是交叉熵损失函数 $log(1+eϕ)$；  </li><li>利用单个样本的损失函数计算梯度 $gΦ$，再根据梯度更新模型参数；</li></ul></li></ol><ul><li><ol><li>对每一个验证样本，计算样本的FFM输出，计算验证误差；</li></ol></li><li><ol><li>重复步骤3~5，直到迭代结束或验证误差达到最小。</li></ol></li></ul><p>在SGD寻优时，代码采用了一些小技巧，对于提升计算效率是非常有效的。</p><p>第一，梯度分步计算。采用SGD训练FFM模型时，只采用单个样本的损失函数来计算模型参数的梯度。</p><script type="math/tex; mode=display">L=L_{err}+L_{reg}=log(1+exp\{−y_iϕ(w,x_i)\})+\frac{λ}{2}‖w‖^2</script><script type="math/tex; mode=display">\frac{∂L}{∂w}=\frac{∂L_{err}}{∂ϕ}\frac{∂ϕ}{∂w}+\frac{∂L_{reg}}{∂w}</script><p>上面的公式表明，$\frac{∂L_{err}}{∂ϕ}$与具体的模型参数无关。因此，每次更新模型时，只需计算一次，之后直接调用$\frac{∂L_{err}}{∂ϕ}$的值即可。对于更新 $nfk$个模型参数，这种方式能够极大提升运算效率。</p><p>第二，自适应学习率。此版本的FFM实现没有采用常用的指数递减的学习率更新策略，而是利用 $nfk$ 个浮点数的临时空间，自适应地更新学习率。学习率是参考AdaGrad算法计算的[11]，按如下方式更新</p><script type="math/tex; mode=display">w_{j_1,j_2}^ {'}=w_{j_1,f_2}-\frac{η}{\sqrt{1+\sum_t(g^t_{w_{j_1,f_2}})^2}}·g_{w_{j_1,f_2}}</script><p>其中，$w_{j_1,f_2}$是特征 $j_1$ 对field $f_2$ 隐向量的一个元素，元素下标未标出；$g_{w_{j_1,f_2}}$是损失函数对参数 $w_{j_1,f_2}$的梯度；$g^t_{w_{j_1,f_2}}$是第 t 次迭代的梯度；η是初始学习率。可以看出，随着迭代的进行，每个参数的历史梯度会慢慢累加，导致每个参数的学习率逐渐减小。另外，每个参数的学习率更新速度是不同的，与其历史梯度有关，根据AdaGrad的特点，对于样本比较稀疏的特征，学习率高于样本比较密集的特征，因此每个参数既可以比较快速达到最优，也不会导致验证误差出现很大的震荡。</p><p>第三，OpenMP多核并行计算。OpenMP是用于共享内存并行系统的多处理器程序设计的编译方案，便于移植和多核扩展[12]。FFM的源码采用了OpenMP的API，对参数训练过程SGD进行了多线程扩展，支持多线程编译。因此，OpenMP技术极大地提高了FFM的训练效率和多核CPU的利用率。在训练模型时，输入的训练参数ns_threads指定了线程数量，一般设定为CPU的核心数，便于完全利用CPU资源。</p><p>第四，SSE3指令并行编程。SSE3全称为数据流单指令多数据扩展指令集3，是CPU对数据层并行的关键指令，主要用于多媒体和游戏的应用程序中。SSE3指令采用128位的寄存器，同时操作4个单精度浮点数或整数。SSE3指令的功能非常类似于向量运算。例如，a 和 b 采用SSE3指令相加（a 和 b 分别包含4个数据），其功能是 a 中的4个元素与 b 中4个元素对应相加，得到4个相加后的值。采用SSE3指令后，向量运算的速度更加快捷，这对包含大量向量运算的FFM模型是非常有利的。</p><p>除了上面的技巧之外，FFM的实现中还有很多调优技巧需要探索。例如，代码是按field和特征的编号申请参数空间的，如果选取了非连续或过大的编号，就会造成大量的内存浪费；在每个样本中加入值为1的新特征，相当于引入了因子化的一次项，避免了缺少一次项带来的模型偏差等。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本文主要介绍了FFM的思路来源和理论原理，并结合源码说明FFM的实际应用和一些小细节。从理论上分析，FFM的参数因子化方式具有一些显著的优势，特别适合处理样本稀疏性问题，且确保了较好的性能；从应用结果来看，站内CTR/CVR预估采用FFM是非常合理的，各项指标都说明了FFM在点击率预估方面的卓越表现。当然，FFM不一定适用于所有场景且具有超越其他模型的性能，合适的应用场景才能成就FFM的“威名”。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="http://blog.csdn.net/lilyth_lilyth/article/details/48032119" target="_blank" rel="noopener">http://blog.csdn.net/lilyth_lilyth/article/details/48032119</a></li><li><a href="http://www.cnblogs.com/Matrix_Yao/p/4773221.html" target="_blank" rel="noopener">http://www.cnblogs.com/Matrix_Yao/p/4773221.html</a></li><li><a href="http://www.herbrich.me/papers/adclicksfacebook.pdf" target="_blank" rel="noopener">http://www.herbrich.me/papers/adclicksfacebook.pdf</a></li><li><a href="https://www.kaggle.com/c/criteo-display-ad-challenge" target="_blank" rel="noopener">https://www.kaggle.com/c/criteo-display-ad-challenge</a></li><li><a href="https://www.kaggle.com/c/avazu-ctr-prediction" target="_blank" rel="noopener">https://www.kaggle.com/c/avazu-ctr-prediction</a></li><li><a href="https://en.wikipedia.org/wiki/Demand-side_platform" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Demand-side_platform</a></li><li><a href="http://www.algo.uni-konstanz.de/members/rendle/pdf/Rendle2010FM.pdf" target="_blank" rel="noopener">http://www.algo.uni-konstanz.de/members/rendle/pdf/Rendle2010FM.pdf</a></li><li><a href="http://www.cs.cmu.edu/~wcohen/10-605/2015-guest-lecture/FM.pdf" target="_blank" rel="noopener">http://www.cs.cmu.edu/~wcohen/10-605/2015-guest-lecture/FM.pdf</a></li><li><a href="http://www.csie.ntu.edu.tw/~r01922136/slides/ffm.pdf" target="_blank" rel="noopener">http://www.csie.ntu.edu.tw/~r01922136/slides/ffm.pdf</a></li><li><a href="https://github.com/guestwalk/libffm" target="_blank" rel="noopener">https://github.com/guestwalk/libffm</a></li><li><a href="https://en.wikipedia.org/wiki/Stochastic_gradient_descent#AdaGrad" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Stochastic_gradient_descent#AdaGrad</a></li><li><a href="http://openmp.org/wp/openmp-specifications/" target="_blank" rel="noopener">http://openmp.org/wp/openmp-specifications/</a></li><li><a href="http://blog.csdn.net/gengshenghong/article/details/7008704" target="_blank" rel="noopener">http://blog.csdn.net/gengshenghong/article/details/7008704</a></li><li><a href="https://kaggle2.blob.core.windows.net/competitions/kddcup2012/2748/media/Opera.pdf" target="_blank" rel="noopener">https://kaggle2.blob.core.windows.net/competitions/kddcup2012/2748/media/Opera.pdf</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自&lt;a href=&quot;https://tech.meituan.com/deep-understanding-of-ffm-principles-and-practices.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;美团点评技术团队&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;FM和FFM模型是最近几年提出的模型，凭借其在数据量比较打并且特征稀疏的情况下，忍让能够得到优秀的性能和效果，屡次在各大公司举办的CTR预估比赛中获得不错的战绩。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="FM" scheme="http://yoursite.com/tags/FM/"/>
    
      <category term="FFM" scheme="http://yoursite.com/tags/FFM/"/>
    
  </entry>
  
  <entry>
    <title>机器学习算法系列（25）：最速下降法、牛顿法、拟牛顿法</title>
    <link href="http://yoursite.com/2017/07/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%8825%EF%BC%89%EF%BC%9A%E6%9C%80%E9%80%9F%E4%B8%8B%E9%99%8D%E6%B3%95%E3%80%81%E7%89%9B%E9%A1%BF%E6%B3%95%E3%80%81%E6%8B%9F%E7%89%9B%E9%A1%BF%E6%B3%95/"/>
    <id>http://yoursite.com/2017/07/08/机器学习算法系列（25）：最速下降法、牛顿法、拟牛顿法/</id>
    <published>2017-07-08T15:14:45.000Z</published>
    <updated>2017-12-26T08:03:51.245Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、最速下降法"><a href="#一、最速下降法" class="headerlink" title="一、最速下降法"></a>一、最速下降法</h2><p>最速下降法，又称为梯度下降法，是无约束最优化领域中最简单的算法，单独就这种算法来看，属于早就“过时”了的一种算法。但是，它的理念是其他某些算法的组成部分，或者说是在其他算法中，也有最速下降法的影子。它是一种迭代算法，每一步需要求解目标函数的梯度向量。</p><a id="more"></a><p>假设$f(x)$是$R^n$上具有一阶连续偏导的函数。要求解的无约束最优化问题是：</p><script type="math/tex; mode=display">\underset {x\in R^n}{min} \ f(x)</script><p>梯度下降法是一种迭代算法。选取适当的初值$x^{(0)}$，不断迭代，更新$x$的值，进行目标函数的极小化，直到收敛。由于负梯度方向是使函数值下降最快的方向，在迭代的每一步，以负梯度方向更新$x$的值，从而达到减少函数值的目的。</p><p>由于$f(x)$具有一阶连续偏导数，若第$k$次迭代值为$x^{(k)}$，则可将$f(x)$在$x^{(k)}$附近进行一阶泰勒展开：</p><script type="math/tex; mode=display">f(x)=f(x^{(k)})+g_k^T(x-x^{(k)})</script><p>这里，$g_k=g(x^{(k)})=∇f(x^{(k)})$为$f(x)$在$x^{(k)}$的梯度。</p><p>求出第$k+1$次迭代值$x^{(k+1)}$:</p><script type="math/tex; mode=display">x^{(k+1)}\leftarrow x^{(k)}+\lambda_kp_k</script><p>其中$p_k$是搜索方向，取负梯度方向$p_k=-∇f(x^{(k)})$,$\lambda _k$是步长，由一维搜索确定，即$\lambda_k$使得</p><script type="math/tex; mode=display">f(x^{(k)}+\lambda_kp_k)=\underset {\lambda≥0}{min} \ f(x^{(k)}+\lambda p_k)</script><p>算法步骤如下：</p><p>输入：目标函数$f(x)$，梯度函数$g(x)=∇f(x)$，计算精度$\xi$;</p><p>输出：$f(x)$的极小点$x^*$</p><ol><li>取初始值$x^{(0)}\in R^{n}$，置$k=0$</li><li>计算 $f(x^{(k)})$</li><li>计算梯度$g_k=g(x^{(k)})$，当$||g_k||＜\xi$时，停止迭代，令$x^*=x^{(k)}$；否则，令$p_k = -g(x^{(k)})$，求$\lambda_k$，使<script type="math/tex; mode=display">f(x^{(k)}+\lambda_kp_k)=\underset {\lambda≥0}{min} \ f(x^{(k)}+\lambda p_k)</script></li><li>置$x^{(k+1 )}=x^{(k)}+\lambda _kp_k$，计算$f(x^{(k+1)})$当$||f(x^{(k+1)})-f(x^{(k)})||＜\xi$或$||x^{(k=1)}-x^{(k)}||＜\xi$，停止迭代，令$x^*=x^{(k+1)}$</li><li>否则，置$k=k+1$，转到步骤3。</li></ol><p>当目标函数是凸函数时，梯度下降法的解释全局最优解。一般情况下，其解不保证是全局最优解。梯度下降法的收敛速度也未必是很快的。</p><h2 id="二、牛顿法"><a href="#二、牛顿法" class="headerlink" title="二、牛顿法"></a>二、牛顿法</h2><p>考虑如下无约束的极小化问题</p><script type="math/tex; mode=display">\underset{X}{min}\ f(x)</script><p>其中$X=(x_1,x_2,x_3，···，x_N)^T \in R^N$这里我们假定$f$为凸函数，且两阶连续可微。记$x^*$为目标函数的极小值。</p><p>为了简单起见，首先考虑$N=1$的简单情形（此时目标函数$f(X)$变为$f(x)$）。牛顿法的基本思想是：在现有极小值估计值的附近对$f(x)$作二阶泰勒展开，进而找极小点的下一个估计值。设$x_k$为当前的极小点估计值，则</p><script type="math/tex; mode=display">f(x) = f(x_k)+ f^{'}(x_k)(x-x_k)+\frac{1}{2}f^{''}(x_k)(x-x_k)^2</script><p>表示$f(x)$在$x_k$附近的二阶泰勒展开式（略去了关于$x-x_k$的高阶项）。由于求得是最值，由极值必要条件可知，$f(x)$应该满足<script type="math/tex">f^{'}(x)=0</script>，即</p><script type="math/tex; mode=display">f^{'}(x_k)+f^{''}(x_k)(x-x_k)^2</script><p>从而求得</p><script type="math/tex; mode=display">x=x_k-\frac{f^{'}(x_k)}{f^{''}{(x_k)}}</script><p>于是，若给定初始值$x_0$，则可以构造如下的迭代格式</p><script type="math/tex; mode=display">x_{k+1}=x_k-\frac{f^{'}(x_k)}{f^{''}{(x_k)}}</script><p>于是，若给定初始值$x_0$，则可以构造如下的迭代格式</p><script type="math/tex; mode=display">x_{k+1}=x_k-\frac{f^{'}(x_k)}{f^{''}{(x_k)}} , \  k=0,1,···</script><p>产生序列$\{x_k\}$来逼近$f(x)$的极小点。在一定条件下$\{x_k\}$可以收敛到$f(x)$的极小点。</p><p>对于$N&gt;1$的情形，二阶泰勒展开式可以做推广，此时</p><script type="math/tex; mode=display">f(X)=f(X_k)+∇f(X_k)\ ·\ (X-X_k)+\frac{1}{2}· (X-X_k)^T·∇^2f(X_k)·(X-X_k)</script><p>其中$∇f$为$f$的梯度向量，$∇^2f$为海森矩阵，其定义分别为</p><script type="math/tex; mode=display">\nabla f=\left[\begin{array}{c}    \frac{\partial f}{\partial x_1}\\    \frac{\partial f}{\partial x_2}\\    ···\\    \frac{\partial f}{\partial x_N}\\\end{array}\right],\\nabla f^2=\left[\begin{matrix}    \frac{\partial^2f}{\partial x_{1}^{2}}&        \frac{\partial^2f}{\partial x_1\partial x_2}&        ···&        \frac{\partial^2f}{\partial x_1\partial x_N}\\    \frac{\partial^2f}{\partial x_2\partial x_1}&        \frac{\partial^2f}{\partial x_{2}^{2}}&        ···&        \frac{\partial^2f}{\partial x_2\partial x_N}\\    ···&        ···&        ···&        ···\\    \frac{\partial^2f}{\partial x_N\partial x_1}&        \frac{\partial^2f}{\partial x_N\partial x_2}&        ···&        \frac{\partial^2f}{\partial x_{N}^{2}}\\\end{matrix}\right]</script><p>注意，$∇f$和$∇^2f$中的元素均为关于$X$的函数，以下分别将其简记为$g$和$H$。特别地，若$f$的混合偏导数可交换次序(即对$\forall\ i,j$，成立$\frac{\partial^2f}{\partial x_i\partial x_j}=\frac{\partial^2f}{\partial x_j\partial x_i}$)，则海森矩阵$H$为对称矩阵，而$∇f(X_k)$和$∇^2f(X_k )$则表示将$X$取为$X_k$后得到的实值向量和矩阵，以下分别将其简记为$g_k$和$H_k$（这里字母g表示gradient，H表示Hessian）</p><p>同样地，由于是求极小点，极值必要条件要求它为$f(X)$的驻点，即</p><script type="math/tex; mode=display">∇f(X)=0</script><p>亦即对二阶泰勒展开作用一个梯度算子</p><script type="math/tex; mode=display">g_k+H_k·(X-X_k)=0</script><p>进一步，若矩阵$H_k$非奇异，则可解得</p><script type="math/tex; mode=display">X=X_k-H_k^{-1}·g_k</script><p>于是，若给定初始值$X_0$，则同样可以构造出迭代格式</p><script type="math/tex; mode=display">X_{k+1}=X_k-H^{-1}_k·g_k</script><p>这就是原始的牛顿迭代法，其迭代格式中的搜索方向$d_k=-H^{-1}_k·g_k$称为牛顿方向。下面给出牛顿法的完整算法描述：</p><ol><li>给定初值$X_0$和精度阀值$\xi$，并令$k:=0$</li><li>计算$g_k$和$H_k$</li><li>若$||g_k||＜\xi$，则停止迭代；否则确定搜索方向$d_k=-H^{-1}_k·g_k$</li><li>计算新的迭代点$X_{k+1}:=X_k+d_k$</li><li>令k:=k+1，转至步2</li></ol><p>当目标函数是二次函数时，由于二次泰勒展开函数与原目标函数不是近似而是完全相同的二次式，海森矩阵退化成一个常数矩阵，从任一初始点出发，秩序一步迭代即可达到$f(X)$的极小点$X^*$，因此牛顿法是一种具有二次收敛性的算法。对于非二次函数，若函数的二次形性态较强，或迭代点已进入极小点的领域，则其收敛速度也是很快的，这是牛顿法的主要优点。</p><p>但原始牛顿法由于迭代公式中没有步长因子，而是定步长迭代，对于非二次型目标函数，有时会使函数值上升，即出现$f(X_{k=1})&gt;f(X_k )$的情况，这表明原始牛顿法不能保证函数值稳定地下降，在严重的情况下甚至可能造成迭代点列$\{X_k\}$的发散而导致计算失败。</p><p>为了消除这个弊病，人们提出了“阻尼牛顿法”，阻尼牛顿法每次迭代的方向仍然采用$d_k$，但每次迭代需沿此方向作一维搜索（line search），寻求最优的步长因子$\lambda _k $，即</p><script type="math/tex; mode=display">\lambda_k =arg \underset{\lambda \in R}{min}f(X_k+\lambda d_k)</script><p>下面给出阻尼牛顿法的完整算法描述：</p><ol><li>给定初值$X_0$和精度阀值$\xi$，并令$k:=0$</li><li>计算$g_k$和$H_k$</li><li>若$||g_k||＜\xi$，则停止迭代；否则确定搜索方向$d_k=-H^{-1}_k·g_k$</li><li>利用$\lambda_k =arg \underset{\lambda \in R}{min}f(X_k+\lambda d_k)$得到步长$\lambda _k$，计算新的迭代点$X_{k+1}:=X_k+d_k$</li><li>令k:=k+1，转至步2</li></ol><p>至此完成了牛顿法的算法介绍，接下来对其做个小结：</p><p>牛顿法是梯度下降法的进一步发展，梯度下降法利用目标函数的一阶偏导数信息、以负梯度方向作为搜索方向，只考虑目标函数在迭代点的局部性质；而牛顿法不仅使用目标函数的一阶偏导数，还进一步利用了目标函数的二阶偏导数，这样就考虑了梯度变化的趋势，因而能更全面地确定合适的搜索方向加快收敛，它具二阶收敛速度。但牛顿法主要存在以下两个缺点：</p><ol><li>对目标函数有较严格的要求。函数必须具有连续的一、二阶偏导数，海森矩阵必须正定。</li><li>极端相当复杂，除需要计算梯度以外，还需要计算二阶偏导数矩阵和它的逆矩阵。计算量、存储量均很大，且均以维数$N$的平方比增加，当$N$很大时这个问题更加突出。</li></ol><h2 id="三、拟牛顿法"><a href="#三、拟牛顿法" class="headerlink" title="三、拟牛顿法"></a>三、拟牛顿法</h2><p>牛顿法虽然收敛速度快，但是计算过程中需要计算目标函数的二阶偏导数，计算复杂度较大。而且有时目标函数的海森矩阵无法保持正定，从而使牛顿法失效。为了克服这两个问题，人们提出了拟牛顿法。这个方法的基本思想是：不用二阶偏导数而构造出可以近似海森矩阵或者海森矩阵的逆的正定对称阵，在拟牛顿的条件下优化目标函数。不同的构造方法就产生了不同的拟牛顿法。</p><p>也有人把“拟牛顿法”翻译成“准牛顿法”，其实都是表示“类似于牛顿法”的意思，因此只是对算法中用来计算搜索方向的海森矩阵（或海森矩阵的逆）作了近似计算罢了。</p><p>在介绍具体的拟牛顿法之前，我们先推到一个拟牛顿条件，或者叫拟牛顿方程，还有的叫做割线条件。因为对海森矩阵（或海森矩阵的逆）做近似总不能随便近似，也需要理论指导，而拟牛顿条件则是用来提供理论指导的，它指出了用来近似的矩阵应该满足的条件。</p><p>为明确起见，下文中用$B$表示对海森矩阵$H$本身的近似，而用$D$表示对海森矩阵的逆$H^{-1}$的近似，即$B≈H,D≈H^{-1}$</p><h3 id="3-1-拟牛顿条件"><a href="#3-1-拟牛顿条件" class="headerlink" title="3.1 拟牛顿条件"></a>3.1 拟牛顿条件</h3><p>设经过$k+1$次迭代后得到$X_{k+1}$，此时将目标函数$f(X)$在$X_{k+1}$附近作泰勒展开，取二阶近似，得到</p><script type="math/tex; mode=display">f(X)≈ f(X_{k+1})+∇f(X_{k+1})\ ·\ (X-X_{k+1})+\frac{1}{2}· (X-X_{k+1})^T·∇^2f(X_{k+1})·(X-X_{k+1})</script><p>在两边同时作用一个梯度算子$∇$，可得</p><script type="math/tex; mode=display">∇f(X)≈∇f（X_{k+1}）+H_{k+1}·(X-X_{k+ 1})</script><p>取$X=X_k$并整理，可得</p><script type="math/tex; mode=display">g_{k+1}-g_k≈H_{k+1}·(X_{k+1}-X_k)</script><p>若引入记号$s_k=X_{k+1}， y_k=g_{k+1}-g_k$则可以改写成</p><script type="math/tex; mode=display">y_k≈H_{k+1}·s_k</script><p>或者</p><script type="math/tex; mode=display">s_k≈H^{-1}_{k+1}·y_k</script><p>这就是所谓的拟牛顿条件，它对迭代过程中的海森矩阵$H_{k+1}$作约束，因此，对$H_{k+1}$做近似的$B_{k+1}$，以及对$H_{k+1}^{-1}$做近似的$D_{k+1 }$可以将</p><script type="math/tex; mode=display">y_k≈H_{k+1}·s_k</script><p>或者</p><script type="math/tex; mode=display">s_k≈H^{-1}_{k+1}·y_k</script><p>作为指导。</p><h3 id="3-2-DFP算法"><a href="#3-2-DFP算法" class="headerlink" title="3.2 DFP算法"></a>3.2 DFP算法</h3><p>DFP算法是以William C.Davidon、Roger Fletcher、Michael J.D.Powell三个人的名字的首字母命名的，它由Davidon于1959年首先提出，是最早的拟牛顿法。该算法的核心是：通过迭代的方法，对$H_{k+1}^{-1}$做近似，迭代格式为</p><script type="math/tex; mode=display">D_{k+1}=D_k+\Delta D_k , k=0,1,2,···</script><p>其中的$D_0$通常取为单位矩阵$I$。因此，关键是每一步的校正矩阵$\Delta D_k$如何构造。</p><p>注意，我们猜想$\Delta D_k$可能与$s_k,y_k$和$D_k$发生关联。这里，我们采用“待定法”，即首先将$\Delta D_k$待定城某种形式，然后结合拟牛顿条件来进行推导。</p><p>那将$\Delta D_k$待定成什么形式呢？说起来比较tricky，我们将其待定为</p><script type="math/tex; mode=display">\Delta D_k=\alpha uu^T+\beta vv^T</script><p>其中$\alpha$和$\beta$为待定向量。从形式上看，这种待定公式至少保证了矩阵$\Delta D_k$的对称性（因为$uu^T$和$vv^T$均为对称矩阵）</p><p>将其代入迭代式，并结合拟牛顿指导条件，可得</p><script type="math/tex; mode=display">s_k=D_ky_k+\alpha uu^Ty_k+\beta vv^Ty_k</script><p>将其改写一下</p><script type="math/tex; mode=display">s_k=D_ky_k+u(\alpha u^Ty_k)+v(\beta v^Ty_k)\\=D_ky_k+(\alpha u^Ty_k)u+(\beta v^Ty_k)v</script><p>括号中为两个数，既然是数，我们不妨作如下简单赋值</p><script type="math/tex; mode=display">\alpha u^Ty_k=1 ，\  \beta v^Ty_k=-1$$即$$\alpha=\frac{1}{u^Ty_k},\beta=-\frac{1}{v^Ty_k}</script><p>其中向量$u,v$仍有待确定。</p><p>我们把$s_k=D_ky_k+u-v$写作</p><script type="math/tex; mode=display">u-v=s_k-D_ky_k</script><p>要上式成立，不妨直接取</p><script type="math/tex; mode=display">u=s_k,v=D_ky_k</script><p>代入求$\alpha$和$\beta$的式子，便得到</p><script type="math/tex; mode=display">\alpha=\frac{1}{s^T_ky_k},\beta=\frac{1}{(D_ky_k)^Ty_k}=-\frac{1}{y^T_kD_ky_k}</script><p>其中第二个式子用到了$D_k$的对称性。至此，我们已经将校正矩阵$\Delta D_k$构造出来了，我们就可以得到</p><script type="math/tex; mode=display">\Delta D_k=\frac{s_ks_k^T}{s_k^Ty_k}-\frac{D_ky_ky_k^TD_k}{y_k^TD_ky_k}</script><p>综上，我们给出DFP算法的一个完整的算法描述。</p><ol><li>给定初值$X_0$和精度阀值$\xi$，并令$k:=0$</li><li>确定搜索方向$d_k=-D^{-1}_k·g_k$</li><li>利用$\lambda_k =arg \underset{\lambda \in R}{min}f(X_k+\lambda d_k)$得到步长$\lambda _k$，令$s_k=\lambda_kd_k$，计算新的迭代点$X_{k+1}:=X_k+s_k$</li><li>若$||g_{k=1}||&lt;\xi$，则算法结束</li><li>计算$y_k=g_{k+1}-g_k$</li><li>计算<script type="math/tex; mode=display">D_{k+1}=D_k+\frac{s_ks_k^T}{s_k^Ty_k}-\frac{D_ky_ky_k^TD_k}{y_k^TD_ky_k}</script></li><li>令$k:=k+1$转至步骤2.</li></ol><h3 id="3-3-BFGS算法"><a href="#3-3-BFGS算法" class="headerlink" title="3.3 BFGS算法"></a>3.3 BFGS算法</h3><p>BFGS算法是以其发明者Broyden、Fletcher、Goldfarb和Shanno四个人的名字的首字母命名的。与DFP算法相比，BFGS算法性能更加。目前它已成为求解无约束非线性优化问题最常用的方法之一。BFGS算法已有较完善的局部收敛理论，对其全局收敛的研究也取得了重要成果。</p><p>BFGS算法中核心公式的推导过程和DFP完全类似，只是互换了其中$s_k$和$y_k$的位置。需要注意的是，BFGS算法是直接逼近海森矩阵，即$B_k≈H_k$,仍采用迭代方法，设迭代格式为</p><script type="math/tex; mode=display">B_{k+1}=B_k+\Delta B_k , k=0,1,2,···</script><p>其中的$B_0$也常取为单位矩阵$I$。因此，关键是每一步的校正矩阵$\Delta B_k$如何构造，同样，将其待定为</p><script type="math/tex; mode=display">\Delta B_k=\alpha uu^T+\beta vv^T</script><p>将其代入上式，并结合指导条件$y_k≈H_{k+1}·s_k$，可得</p><script type="math/tex; mode=display">y_k=B_ks_k+(au^Ts_k)u+(\beta v^Ts_k)v</script><p>通过令$au^Ts_k=1,\beta v^Ts_k=-1$,以及</p><script type="math/tex; mode=display">u=y_k,v=B_ks_k$$可以算得$$\alpha=\frac{1}{y^T_ks_k},\beta = -\frac{1}{s^T_kB_ks_k}</script><p>综上，便得到了如下的校正矩阵$\Delta B_k$的公式</p><script type="math/tex; mode=display">\Delta B_k=\frac{y_ky_k^T}{y_k^Ts_k}-\frac{B_ks_ks_k^TB_k}{s^T_kB_ks_k}</script><p>好了，现在把矩阵$\Delta B_k$和$\Delta D_k$拿出来对比一下，除了你将$D$换成$B$外，就是把$s_k$和$y_k$互换了一下位置。</p><p>最后，给出BFGS算法的一个完整算法描述：</p><ol><li>给定初值$X_0$和精度阀值$\xi$，并令$k:=0$</li><li>确定搜索方向$d_k=-B^{-1}_k·g_k$</li><li>利用$\lambda_k =arg \underset{\lambda \in R}{min}f(X_k+\lambda d_k)$得到步长$\lambda _k$，令$s_k=\lambda_kd_k$，计算新的迭代点$X_{k+1}:=X_k+s_k$</li><li>若$||g_{k=1}||&lt;\xi$，则算法结束</li><li>计算$y_k=g_{k+1}-g_k$</li><li>计算<script type="math/tex; mode=display">B_{k+1}=B_k+\frac{y_ky_k^T}{y_k^Ts_k}-\frac{B_ks_ks_k^TB_k}{s^T_kB_ks_k}</script></li><li>令$k:=k+1$转至步骤2.</li></ol><h3 id="3-4-L-BFGS算法"><a href="#3-4-L-BFGS算法" class="headerlink" title="3.4 L-BFGS算法"></a>3.4 L-BFGS算法</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、最速下降法&quot;&gt;&lt;a href=&quot;#一、最速下降法&quot; class=&quot;headerlink&quot; title=&quot;一、最速下降法&quot;&gt;&lt;/a&gt;一、最速下降法&lt;/h2&gt;&lt;p&gt;最速下降法，又称为梯度下降法，是无约束最优化领域中最简单的算法，单独就这种算法来看，属于早就“过时”了的一种算法。但是，它的理念是其他某些算法的组成部分，或者说是在其他算法中，也有最速下降法的影子。它是一种迭代算法，每一步需要求解目标函数的梯度向量。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="损失函数" scheme="http://yoursite.com/tags/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习算法系列（24）：机器学习中的损失函数</title>
    <link href="http://yoursite.com/2017/07/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%8824%EF%BC%89%EF%BC%9A%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2017/07/08/机器学习算法系列（24）：损失函数/</id>
    <published>2017-07-08T15:14:45.000Z</published>
    <updated>2017-12-26T08:03:48.016Z</updated>
    
    <content type="html"><![CDATA[<p>损失函数（loss function）是用来估量模型的预测值f(x)与真实值$Y$不一致的程度，它是一个非负实数值函数，通常使用$L(Y,f(x))$来表示，损失函数越小，模型的鲁棒性就越好。损失函数是经验风险函数的核心部分，也是结构风险函数的重要组成部分。模型的结构风险函数包括了经验风险项和正则项，通常可以表示成如下的式子：</p><script type="math/tex; mode=display">\theta^* = argmin_\theta \frac{1}{N}\sum_{i=1}^NL(y_i,f(x_i;\theta))+\lambda Φ(θ)</script><a id="more"></a><p>前面的均值函数表示的是经验风险函数，$L$代表的是损失函数，后面的$Φ$是正则化项（regularizer）或者叫惩罚项（penalty term）,它可以是$L_1$，也可以是$L_2$等其他的正则函数。整个式子表示的意思是找到使目标函数最小时的$\theta$值。下面列出集中常见的损失函数。</p><h2 id="一、对数损失函数（逻辑回归）"><a href="#一、对数损失函数（逻辑回归）" class="headerlink" title="一、对数损失函数（逻辑回归）"></a>一、对数损失函数（逻辑回归）</h2><p>有些人可能觉得逻辑回归的损失函数就是平方损失，其实并不是。平方损失函数可以通过线性回归在假设样本是高斯分布的条件下推导得到，而逻辑回归得到的并不是平方损失。在逻辑回归的推导中，它假设样本服从伯努利分布（0-1分布），然后求得满足该分布的似然函数，接着取对数求极值等等。而逻辑回归并没有求似然函数的极值，而是把极大化当做是一种思想，进而推导出它的经验风险函数为：最小化负的似然函数（即$max F(y, f(x)) —&gt; min -F(y, f(x))$)。从损失函数的视角来看，它就成了log损失函数了。</p><p>Log损失函数的标准形式：</p><script type="math/tex; mode=display">L(Y,P(Y|X))=-logP(Y|X)</script><p>刚刚说到，取对数是为了方便计算极大似然估计，因为在MLE中，直接求导比较困难，所以通常都是先取对数再求导找极值点。损失函数$L(Y.P(Y|X))$表达的是样本在分类$Y$的情况下，使概率$P(Y|X)$达到最大值（换言之，就是利用已知的样本分布，找到最有可能（即最大概率）导致这种分布的参数值；或者什么样的参数才能使我们观测到目前这组数据的概率最大）。因为log函数是单调递增的，所以$logP(Y|X)$也会达到最大值，因此在前面加上负号之后，最大化$P(Y|X)$就等价于最小化$L$了。</p><p>logistic回归的$P(y|x)$表达式如下（为了将类别标签y统一为1和0，下面将表达式分开表示）：</p><script type="math/tex; mode=display">P\left(Y=y^{\left(i\right)}|x^{\left(i\right)};\theta\right)=\left\{\begin{array}{l}    h_{\theta}\left(x^{\left(i\right)}\right)=\frac{1}{1+e^{-\theta^Tx}},\,\,y^{\left(i\right)}=1\\    1-h_{\theta}\left(x^{\left(i\right)}\right)=\frac{e^{-\theta^Tx}}{1+e^{-\theta^Tx}},\,\,y^{\left(i\right)}=0\\\end{array}\right.</script><p>将上面的公式合并在一起，可得到第$i$个样本正确预测的概率：</p><script type="math/tex; mode=display">P(y^{(i)}|x^{(i)};\theta)=(h_\theta(x^{(i)}))^{y(i)}·(1-h_\theta(x^{(i)}))^{1-y(i)}</script><p>上式是对一个样本进行建模的数据表达。对于所有的样本，假设每条样本生成过程独立，在整个样本空间中（N个样本）的概率分布为：</p><script type="math/tex; mode=display">P\left(Y\ | \ X;\theta\right)=\prod_{i=1}^N{\left(\left(h_{\theta}\left(x^{\left(i\right)}\right)\right)^{y^{\left(i\right)}}\left(1-h_{\theta}\left(x^{\left(i\right)}\right)\right)^{1-y^{\left(i\right)}}\right)}</script><p>将上式代入到对数损失函数中，得到最终的损失函数为：</p><script type="math/tex; mode=display">J(\theta) = -\frac{1}{N}\sum_{i=1}^N{y^{\left(i\right)}\log\left(h_{\theta}\left(x^{\left(i\right)}\right)\right)+\left(1-y^{\left(i\right)}\right)\log\left(1-h_{\theta}\left(x^{\left(i\right)}\right)\right)}</script><p>之所以有人认为逻辑回归是平方损失，是因为在使用梯度下降来求最优解的时候，它的迭代式子与平方损失求导后的式子非常相似，从而给人一种直观上的错觉。</p><h2 id="二、平方损失函数（最小二乘法，Ordinary-Least-Squares）"><a href="#二、平方损失函数（最小二乘法，Ordinary-Least-Squares）" class="headerlink" title="二、平方损失函数（最小二乘法，Ordinary Least Squares）"></a>二、平方损失函数（最小二乘法，Ordinary Least Squares）</h2><p>最小二乘法是线性回归的一种，OLS将问题转化成了一个凸优化问题。在线性回归中，它假设样本和噪声都服从高斯分布（为什么假设成高斯分布呢？其实这里隐藏了一个小知识点，就是中心极限定理，可以参考【central limit theorem】），最后通过极大似然估计（MLE）可以推导出最小二乘式子。最小二乘的基本原则是：最优拟合直线应该是使各点到回归直线的距离和最小的直线，即平方和最小。换言之，OLS是基于距离的，而这个距离就是我们用的最多的欧几里得距离。为什么它会选择使用欧式距离作为误差度量呢（即Mean squared error， MSE），主要有以下几个原因：</p><ul><li>简单，计算方便；</li><li>欧氏距离是一种很好的相似性度量标准；</li><li>在不同的表示域变换后特征性质不变。</li></ul><p>平方损失（Square loss）的标准形式如下：<script type="math/tex">L(Y,f(X))=(Y-f(x))^2</script>当样本个数为n时，此时的损失函数变为：$$L(Y,f(X))=\sum_{i=1}^n(Y-f(X))^2$$$Y-f(X)$表示的是残差，整个式子表示的是残差的平方和，而我们的目的就是最小化这个目标函数值（注：该式子未加入正则项），也就是最小化残差的平方和（residual sum of squares，RSS）。</p><p>而在实际应用中，通常会使用均方差（MSE）作为一项衡量指标，公式如下：</p><script type="math/tex; mode=display">MSE=\frac{1}{N}\sum_{i=1}^N(\tilde{Y_i}-Y_i)^2</script><p>上面提到了线性回归，这里额外补充一句，我们通常说的线性有两种情况，一种是因变量y是自变量x的线性函数，一种是因变量y是参数α的线性函数。在机器学习中，通常指的都是后一种情况。</p><h2 id="三、指数损失函数（Adaboost）"><a href="#三、指数损失函数（Adaboost）" class="headerlink" title="三、指数损失函数（Adaboost）"></a>三、指数损失函数（Adaboost）</h2><p>学过Adaboost算法的人都知道，它是前向分步加法算法的特例，是一个加和模型，损失函数就是指数函数。在Adaboost中，经过m此迭代之后，可以得到$f_m(x)$:</p><script type="math/tex; mode=display">f_m(x)=f_{m-1}(x)+a_mG_m(x)</script><p>Adaboost每次迭代时的目的是为了找到最小化下列式子时的参数$a$和G：</p><script type="math/tex; mode=display">arg\underset{a,G}{min}=\sum_{i=1}^Nexp[-y_i(f_{m-1}(x_i)+aG(x_i))]</script><p>而指数损失函数(exp-loss）的标准形式如下:</p><script type="math/tex; mode=display">L(y,f(x))=exp[-yf(x)]</script><p>可以看出，Adaboost的目标式子就是指数损失，在给定N个样本的情况下，Adaboost的损失函数为：</p><script type="math/tex; mode=display">L(y,f(x))=\frac{1}{N}\sum_{i=1}^nexp[-y_if(x_i)]</script><h2 id="四、Hinge损失函数（SVM）"><a href="#四、Hinge损失函数（SVM）" class="headerlink" title="四、Hinge损失函数（SVM）"></a>四、Hinge损失函数（SVM）</h2><h3 id="4-1-Hinge损失函数（SVM）"><a href="#4-1-Hinge损失函数（SVM）" class="headerlink" title="4.1 Hinge损失函数（SVM）"></a>4.1 Hinge损失函数（SVM）</h3><p>线性支持向量机学习除了原始最优化问题，还有另外一种解释，就是最优化以下目标函数：</p><script type="math/tex; mode=display">\sum_i^{N}[1-y_i(w·x_i+b)]_++\lambda||w||^2</script><p>目标函数的第一项是经验损失或经验风险，函数</p><script type="math/tex; mode=display">L(y·(w·x+b))=[1-y(w·x+b)]_+</script><p>称为合页损失函数（hinge loss function）。下标”+”表示以下取正值的函数：</p><script type="math/tex; mode=display">\left[z\right]_+=\left\{\begin{array}{l}    z\ ,\ z>0\\    0\ ,\ z\le 0\\\end{array}\right.</script><p>这就是说，当样本点$(x_i,y_i)$被正确分类且函数间隔（确信度）$y_i(w·x_i+b)$大于1时，损失是0，否则损失是$1-y_i(w·x_i+b)$。目标函数的第二项是系数为$\lambda$的$w$的$L_2$范数，是正则化项。</p><p>接下来证明线性支持向量机原始最优化问题：</p><script type="math/tex; mode=display">\underset{w,b,\xi}{\min}\ \frac{1}{2}||w||^2+C\sum_{i=1}^N{\xi _i}</script><script type="math/tex; mode=display">s.t.\ \ y_i\left( w·x_i+b \right) \geqslant 1-\xi _i\ ,\ i=1,2,···,N</script><script type="math/tex; mode=display">\xi _i\geqslant 0,\ i=1,2,···\mathrm{，}N</script><p>等价于最优化问题</p><script type="math/tex; mode=display">\underset{w,b}{min }\sum_i^{N}[1-y_i(w·x_i+b)]_++\lambda||w||^2</script><p>先令$[1-y_i(w·x_i+b)]_+=\xi_i$，则$\xi_i≥0$，第二个约束条件成立；由$[1-y_i(w·x_i+b)]_+=\xi_i$，当$1-y_i(w·x_i+b)&gt;0$时，有$y_i(w·x_i+b)=1-\xi_i$;当$1-y_i(w·x_i+b)≤0$时，$\xi_i=0$，有$y_i(w·x_i+b)≥1-\xi_i$，所以第一个约束条件成立。所以两个约束条件都满足，最优化问题可以写作</p><script type="math/tex; mode=display">\underset{w,b}{min}\sum_{i=1}^N\xi_i+\lambda||w||^2</script><p>若取$\lambda =\frac{1}{2C}$则</p><script type="math/tex; mode=display">\underset{w,b}{min} \frac{1}{C}(\frac{1}{2} ||w||^2+C\sum_{i=1}^N \xi_i)</script><p>与原始最优化问题等价。</p><p>合页损失函数图像如图所示，横轴是函数间隔$y(w·x+b)$，纵轴是损失。由于函数形状像一个合页，故名合页损失函数。</p><p>图中还画出了0-1损失函数，可以认为它是一个二类分类问题的真正的损失函数，而合页损失函数是0-1损失函数的上界。由于0-1损失函数不是连续可导的，直接优化其构成的目标函数比较困难，可以认为线性支持向量机是优化由0-1损失函数的上界（合页损失函数）构成的目标函数。这时的上界损失函数又称为代理损失函数（surrogate function）。<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-08 下午6.11.53.png" alt="屏幕快照 2017-07-08 下午6.11.53"><br>图中虚线显示的是感知机的损失函数$[-y_i(w·x_i+b)]_+$。这时当样本点$(x_i,y_i)$被正确分类时，损失是0，否则损失是$-y_i(w·x_i+b)$，相比之下，合页损失函数不仅要分类正确，而且确信度足够高时损失才是0，也就是说，合页损失函数对学习有更高的要求</p><h3 id="4-2-逻辑斯谛回归和SVM的损失函数对比"><a href="#4-2-逻辑斯谛回归和SVM的损失函数对比" class="headerlink" title="4.2 逻辑斯谛回归和SVM的损失函数对比"></a>4.2 逻辑斯谛回归和SVM的损失函数对比</h3><p>我们先来看一下带松弛变量的 SVM 和正则化的逻辑回归它们的损失函数：<img src="http://omu7tit09.bkt.clouddn.com/14995092441592.png" alt="">其中 $g(z)=(1+exp(−z))^{−1}$<br>可以将两者统一起来:</p><p><img src="http://omu7tit09.bkt.clouddn.com/14995093179927.png" alt=""><br><img src="http://omu7tit09.bkt.clouddn.com/14995093274307.png" alt=""><br>这两个损失函数的目的都是增加对分类影响较大的数据点的权重，减少与分类关系较小的数据点的权重。SVM的处理方法是只考虑support vectors，也就是和分类最相关的少数点，去学习分类器。而逻辑回归通过非线性映射，大大减小了离分类平面较远的点的权重，相对提升了与分类最相关的数据点的权重,两者的根本目的都是一样的。</p><p>svm考虑局部（支持向量），而logistic回归考虑全局，就像大学里的辅导员和教师间的区别。</p><p>辅导员关心的是挂科边缘的人，常常找他们谈话，告诫他们一定得好好学习，不要浪费大好青春，挂科了会拿不到毕业证、学位证等等，相反，对于那些相对优秀或者良好的学生，他们却很少去问，因为辅导员相信他们一定会按部就班的做好分内的事；而大学里的教师却不是这样的，他们关心的是班里的整体情况，大家是不是基本都理解了，平均分怎么样，至于某个人的分数是59还是61，他们倒不是很在意。</p><p>总结：</p><ol><li>LR采用log损失，SVM采用合页损失。</li></ol><ul><li>LR对异常值敏感，SVM对异常值不敏感。</li><li>在训练集较小时，SVM较适用，而LR需要较多的样本。</li><li>LR模型找到的那个超平面，是尽量让所有点都远离他，而SVM寻找的那个超平面，是只让最靠近中间分割线的那些点尽量远离，即只用到那些支持向量的样本。</li><li>对非线性问题的处理方式不同，LR主要靠特征构造，必须组合交叉特征，特征离散化。SVM也可以这样，还可以通过kernel。</li><li>svm 更多的属于非参数模型，而logistic regression 是参数模型，本质不同。其区别就可以参考参数模型和非参模型的区别</li></ul><p>那怎么根据特征数量和样本量来选择SVM和LR模型呢？Andrew NG的课程中给出了以下建议：</p><ol><li>如果Feature的数量很大，跟样本数量差不多，这时候选用LR或者是Linear Kernel的SVM</li><li>如果Feature的数量比较小，样本数量一般，不算大也不算小，选用SVM+Gaussian Kernel</li><li>如果Feature的数量比较小，而样本数量很多，需要手工添加一些feature变成第一种情况。(LR和不带核函数的SVM比较类似。)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;损失函数（loss function）是用来估量模型的预测值f(x)与真实值$Y$不一致的程度，它是一个非负实数值函数，通常使用$L(Y,f(x))$来表示，损失函数越小，模型的鲁棒性就越好。损失函数是经验风险函数的核心部分，也是结构风险函数的重要组成部分。模型的结构风险函数包括了经验风险项和正则项，通常可以表示成如下的式子：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;\theta^* = argmin_\theta \frac{1}{N}\sum_{i=1}^NL(y_i,f(x_i;\theta))+\lambda Φ(θ)&lt;/script&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="损失函数" scheme="http://yoursite.com/tags/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习算法系列（23）：TF-IDF与余弦相似度</title>
    <link href="http://yoursite.com/2017/07/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%8823%EF%BC%89%EF%BC%9ATF-IDF%E4%B8%8E%E4%BD%99%E5%BC%A6%E7%9B%B8%E4%BC%BC%E5%BA%A6/"/>
    <id>http://yoursite.com/2017/07/07/机器学习算法系列（23）：TF-IDF与余弦相似度/</id>
    <published>2017-07-07T15:14:45.000Z</published>
    <updated>2017-12-26T08:03:44.936Z</updated>
    
    <content type="html"><![CDATA[<p>TF-IDF(term frequency=inverse document frequency)是一种用于资讯检索与文本挖掘的常用加权技术。TF-IDF是一种统计方法，用以评估一字词对于一个文件集或一个语料库中的其中一份文件的重要程度。字词的重要性随着它在文件中出现的次数成正比增加，但同时会随着它在语料库中出现的频率成反比下降。TF-IDF加权的各种形式常备搜索引擎应用，作为文件与用户查询之间相关程度的度量或评级。</p><a id="more"></a><h2 id="一、原理"><a href="#一、原理" class="headerlink" title="一、原理"></a>一、原理</h2><p>设想现在我们正在阅读新闻，如何最快速的了解新闻的主旨？毫无疑问——关键词。TF-IDF就具有这样的能力：提取关键词。</p><h3 id="1-1-TF"><a href="#1-1-TF" class="headerlink" title="1.1 TF"></a>1.1 TF</h3><p>假设一个词在一篇文章中出现的次数越多，那么它就越”紧扣主题”。以本文为例，我们可以统计词频(TF)，不难发现“TF-IDF”,“应用”、“原理”是出现频率很高的词，后文称keywords。这符合我们的假设，但是有些词却出现的次数更多，如：的、是、有等。这类词语没有明确意义，我们称为停顿词(Stopwords)。</p><p>如果单纯按照词频算关键词，你会发现几乎所有的文章都是stopwords的词频最高。换句话说，像这种”万金油”，是没有区分度的词语，不能很好的起到将文章分类的作用。</p><p>此外，抛开停用词，如果该文档中的几个词出现的频率一样，也不意味着，作为关键词，它们的重要性是一致的。比如这篇文档中，“TF-IDF”、“意义”、“文档”这三个词的词频出现的次数一样多，但因为“意义”是很常见的词，相对而言，“TF-IDF”、“文档”不那么常见。即使它们的词频一样，我们也有理由认为，“TF-IDF”和“文档”的重要性大于“意义”，也就是使，在关键词排序上，“TF-IDF”和“文档”也应该排在“意义”的前面。</p><p>所以，我们需要一个重要性调整系数，衡量一个词是不是常见词。如果某个词比较少见，但是它在这篇文章中多次出现，那么它很可能就反映了这篇文章的特性，正是我们所需要的关键词。这时就需要祭出逆文档频率(IDF)来解决词语权重的问题。</p><h2 id="1-2-IDF"><a href="#1-2-IDF" class="headerlink" title="1.2 IDF"></a>1.2 IDF</h2><p>用统计学语言表达，就是在词频的基础上，要对每个词分配一个”重要性”权重。最常见的词（”的”、”是”、”在”）给予最小的权重，较常见的词（”中国”）给予较小的权重，较少见的词（”蜜蜂”、”养殖”）给予较大的权重。这个权重叫做”逆文档频率”（Inverse Document Frequency，缩写为IDF），它的大小与一个词的常见程度成反比。</p><p>知道了”词频”（TF）和”逆文档频率”（IDF）以后，将这两个值相乘，就得到了一个词的TF-IDF值。某个词对文章的重要性越高，它的TF-IDF值就越大。所以，排在最前面的几个词，就是这篇文章的关键词。</p><h2 id="1-3-公式化表达"><a href="#1-3-公式化表达" class="headerlink" title="1.3 公式化表达"></a>1.3 公式化表达</h2><p>对于在某一特定文件里的词语$t_i$来说，它的重要性可表示为：</p><script type="math/tex; mode=display">TF_{i,j}=\frac{n_{i,j}}{\sum_kn_{k,j}}</script><p>以上式子中$n_{i,j}$是该词在文件$d_{j}$中的出现次数而分母则是在文件$d_j$中所有字词的出现次数之和。</p><p>逆向文件频率（inverse document frequency，idf）是一个词语普遍重要性的度量。某一特定词语的idf，可以由总文件数目除以包含该词语之文件的数目，再将得到的商取对数得到：</p><script type="math/tex; mode=display">IDF_i=log\frac{|D|}{|{j:t_i\in d_j}|}</script><p>其中</p><ul><li>$|D|$：语料库中的文件总数</li><li>$|{j:t_i\in d_j}|$：包含词语$t_i$的文件数目（即$n_{i,j}≠0的文件数目$）如果该词语不在语料库中，就会导致分母为零，因此一般情况下使用$1+|{j:t_i\in d_j}|$</li></ul><p>然后</p><script type="math/tex; mode=display">TF-IDF = TF_{i,j}\times IDF _i</script><p>某一特定文件内的高词语频率，以及该词语在整个文件集合中的低文件频率，可以产生出高权重的tf-idf。因此，tf-idf倾向于过滤掉常见的词语，保留重要的词语。</p><h2 id="1-4-应用"><a href="#1-4-应用" class="headerlink" title="1.4 应用"></a>1.4 应用</h2><p>我们通过Google搜索结果数为例，将含有中文“的”结果数15.8亿作为整个语料库大小，计算一些关键词和停用词的TF-IDF值。为了计算简便，假设全文分词后一共500词，则结果如下：<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-07 上午9.19.11.png" alt="屏幕快照 2017-07-07 上午9.19.11"></p><p>TF-IDF的优点是计算简单，利于理解，性价比极高。但是它也有缺陷，首先单纯依据文章中的TF来衡量重要性，忽略了位置信息。如段首，句首一般权重更高；其次，有的文章可能关键词只出现1-2次，但可能通篇都是围绕其进行阐述和解释，所以单纯靠TF仍然不能解决所有的情况。</p><h2 id="二、余弦相似度"><a href="#二、余弦相似度" class="headerlink" title="二、余弦相似度"></a>二、余弦相似度</h2><p>余弦相似性通过测量两个向量的夹角的余弦值来度量它们之间的相似性。0度角的余弦值是1，而其他任何角度的余弦值都不大于1；并且其最小值是-1。从而两个向量之间的角度的余弦值确定两个向量是否大致指向相同的方向。两个向量有相同的指向时，余弦相似度的值为1；两个向量夹角为90°时，余弦相似度的值为0；两个向量指向完全相反的方向时，余弦相似度的值为-1。这结果是与向量的长度无关的，仅仅与向量的指向方向相关。余弦相似度通常用于正空间，因此给出的值为0到1之间。</p><p>注意这上下界对任何维度的向量空间中都适用，而且余弦相似性最常用于高维正空间。例如在信息检索中，每个词项被赋予不同的维度，而一个文档由一个向量表示，其各个维度上的值对应于该词项在文档中出现的频率。余弦相似度因此可以给出两篇文档在其主题方面的相似度。</p><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p>两个向量间的余弦值可以通过使用欧几里得点积公式求出：</p><script type="math/tex; mode=display">a·b=|a|·|b|\ cos \theta</script><p>给定两个属性向量$A$和$B$，其余相似性$\theta$由点积和向量长度给出，如下所示：</p><script type="math/tex; mode=display">similarity = cos(\theta)=\frac{A·B}{|A||B|}=\frac{\sum_{i=1}^nA_i\times B_i}{\sqrt{\sum_{i=1}^n(A_i)^2}\times \sqrt{\sum_{i=1}^n(B_i)^2}}</script><p>这里的$A_i$和$B_i$分别代表向量$A$和$B$的各分量。</p><p>给出的相似性范围从-1到1：-1意味着两个向量指向的方向正好截然相反，1表示它们的指向是完全相同的，0通常表示它们之间是独立的，而在这之间的值则表示中间的相似性或相异性。</p><p>对于文本匹配，属性向量A 和B 通常是文档中的词频向量。余弦相似性，可以被看作是在比较过程中把文件长度正规化的方法。</p><p>在信息检索的情况下，由于一个词的频率（TF-IDF权）不能为负数，所以这两个文档的余弦相似性范围从0到1。并且，两个词的频率向量之间的角度不能大于90°。</p><p>由此，我们就得到了”找出相似文章”的一种算法：</p><ul><li>1）使用TF-IDF算法，找出两篇文章的关键词；</li><li>2）每篇文章各取出若干个关键词（比如20个），合并成一个集合，计算每篇文章对于这个集合中的词的词频（为了避免文章长度的差异，可以使用相对词频）；</li><li>3）生成两篇文章各自的词频向量；</li><li>4）计算两个向量的余弦相似度，值越大就表示越相似。</li></ul><p>“余弦相似度”是一种非常有用的算法，只要是计算两个向量的相似程度，都可以采用它。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TF-IDF(term frequency=inverse document frequency)是一种用于资讯检索与文本挖掘的常用加权技术。TF-IDF是一种统计方法，用以评估一字词对于一个文件集或一个语料库中的其中一份文件的重要程度。字词的重要性随着它在文件中出现的次数成正比增加，但同时会随着它在语料库中出现的频率成反比下降。TF-IDF加权的各种形式常备搜索引擎应用，作为文件与用户查询之间相关程度的度量或评级。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="TF-IDF" scheme="http://yoursite.com/tags/TF-IDF/"/>
    
      <category term="余弦相似度" scheme="http://yoursite.com/tags/%E4%BD%99%E5%BC%A6%E7%9B%B8%E4%BC%BC%E5%BA%A6/"/>
    
      <category term="文档检索" scheme="http://yoursite.com/tags/%E6%96%87%E6%A1%A3%E6%A3%80%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>机器学习算法系列（22）：主成分分析</title>
    <link href="http://yoursite.com/2017/07/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%8822%EF%BC%89%EF%BC%9A%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2017/07/03/机器学习算法系列（22）：主成分分析/</id>
    <published>2017-07-03T15:14:45.000Z</published>
    <updated>2017-12-26T08:03:40.515Z</updated>
    
    <content type="html"><![CDATA[<p>PCA（Principal Component Analysis）是一种常用的数据分析方法。PCA通过线性变换将原始数据变换为一组各维度线性无关的表示，可用于提取数据的主要特征分量，常用于高维数据的降维。</p><a id="more"></a><h2 id="一、数据的向量表示及降维问题"><a href="#一、数据的向量表示及降维问题" class="headerlink" title="一、数据的向量表示及降维问题"></a>一、数据的向量表示及降维问题</h2><p>一般情况下，在数据挖掘和机器学习中，数据被表示为向量。例如某个淘宝店2012年全年的流量及交易情况可以看成一组记录的集合，其中每一天的数据是一条记录，格式如下：</p><blockquote><p>(日期, 浏览量, 访客数, 下单数, 成交数, 成交金额)</p></blockquote><p>其中“日期”是一个记录标志而非度量值，而数据挖掘关心的大多是度量值，因此如果我们忽略日期这个字段后，我们得到一组记录，每条记录可以被表示为一个五维向量，其中一条看起来大约是这个样子：</p><script type="math/tex; mode=display">(500,240,25,13,2312.15)^𝖳</script><p>注意这里用了转置，因为习惯上使用列向量表示一条记录（后面会看到原因），本文后面也会遵循这个准则。不过为了方便有时会省略转置符号，但我们说到向量默认都是指列向量。</p><p>我们当然可以对这一组五维向量进行分析和挖掘，不过我们知道，很多机器学习算法的复杂度和数据的维数有着密切关系，甚至与维数呈指数级关联。当然，这里区区五维的数据，也许还无所谓，但是实际机器学习中处理成千上万甚至几十万维的情况也并不罕见，在这种情况下，机器学习的资源消耗是不可接受的，因此我们必须对数据进行降维。</p><p>降维当然意味着信息的丢失，不过鉴于实际数据本身常常存在的相关性，我们可以想办法在降维的同时将信息的损失尽量降低。</p><p>举个例子，假如某学籍数据有两列M和F，其中M列的取值是如何此学生为男性取值1，为女性取值0；而F列是学生为女性取值1，男性取值0。此时如果我们统计全部学籍数据，会发现对于任何一条记录来说，当M为1时F必定为0，反之当M为0时F必定为1。在这种情况下，我们将M或F去掉实际上没有任何信息的损失，因为只要保留一列就可以完全还原另一列。</p><p>当然上面是一个极端的情况，在现实中也许不会出现，不过类似的情况还是很常见的。例如上面淘宝店铺的数据，从经验我们可以知道，“浏览量”和“访客数”往往具有较强的相关关系，而“下单数”和“成交数”也具有较强的相关关系。这里我们非正式的使用“相关关系”这个词，可以直观理解为“当某一天这个店铺的浏览量较高（或较低）时，我们应该很大程度上认为这天的访客数也较高（或较低）”。后面的章节中我们会给出相关性的严格数学定义。</p><p>这种情况表明，如果我们删除浏览量或访客数其中一个指标，我们应该期待并不会丢失太多信息。因此我们可以删除一个，以降低机器学习算法的复杂度。</p><p>上面给出的是降维的朴素思想描述，可以有助于直观理解降维的动机和可行性，但并不具有操作指导意义。例如，我们到底删除哪一列损失的信息才最小？亦或根本不是单纯删除几列，而是通过某些变换将原始数据变为更少的列但又使得丢失的信息最小？到底如何度量丢失信息的多少？如何根据原始数据决定具体的降维操作步骤？</p><p>要回答上面的问题，就要对降维问题进行数学化和形式化的讨论。而PCA是一种具有严格数学基础并且已被广泛采用的降维方法。下面我不会直接描述PCA，而是通过逐步分析问题，让我们一起重新“发明”一遍PCA。</p><h2 id="二、向量的表示及基变换"><a href="#二、向量的表示及基变换" class="headerlink" title="二、向量的表示及基变换"></a>二、向量的表示及基变换</h2><p>既然我们面对的数据被抽象为一组向量，那么下面有必要研究一些向量的数学性质。而这些数学性质将成为后续导出PCA的理论基础。</p><h3 id="2-1-内积与投影"><a href="#2-1-内积与投影" class="headerlink" title="2.1 内积与投影"></a>2.1 内积与投影</h3><p>下面先来看一个高中就学过的向量运算：内积。两个维数相同的向量的内积被定义为：</p><script type="math/tex; mode=display">(a_1,a_2,⋯,a_n)^𝖳⋅(b_1,b_2,⋯,b_n)𝖳=a_1b_1+a_2b_2+⋯+a_nb_n</script><p>内积运算将两个向量映射为一个实数。其计算方式非常容易理解，但是其意义并不明显。下面我们分析内积的几何意义。</p><p>假设A和B是两个n维向量，我们知道n维向量可以等价表示为n维空间中的一条从原点发射的有向线段，为了简单起见我们假设A和B均为二维向量，则$A=(x_1,y_1)$，$B=(x_2,y_2)$。则在二维平面上A和B可以用两条发自原点的有向线段表示，见下图：<br><img src="http://omu7tit09.bkt.clouddn.com/14992470618968.png" alt=""><br>现在我们从A点向B所在直线引一条垂线。我们知道垂线与B的交点叫做A在B上的投影，再设A与B的夹角是a，则投影的矢量长度为$|A|cos(a)|A|cos(a)$，其中$|A|=\sqrt{x^2_1+y^2_1}$是向量A的模，也就是A线段的标量长度。</p><p>注意这里我们专门区分了矢量长度和标量长度，标量长度总是大于等于0，值就是线段的长度；而矢量长度可能为负，其绝对值是线段长度，而符号取决于其方向与标准方向相同或相反。</p><p>到这里还是看不出内积和这东西有什么关系，不过如果我们将内积表示为另一种我们熟悉的形式：</p><script type="math/tex; mode=display">A⋅B=|A||B|cos(a)</script><p>A与B的内积等于A到B的投影长度乘以B的模。再进一步，如果我们假设B的模为1，即让$|B|=1$，那么就变成了：</p><script type="math/tex; mode=display">A⋅B=|A|cos(a)</script><p>也就是说，设向量B的模为1，则A与B的内积值等于A向B所在直线投影的矢量长度！这就是内积的一种几何解释，也是我们得到的第一个重要结论。</p><h3 id="2-2-基"><a href="#2-2-基" class="headerlink" title="2.2 基"></a>2.2 基</h3><p>下面我们继续在二维空间内讨论向量。上文说过，一个二维向量可以对应二维笛卡尔直角坐标系中从原点出发的一个有向线段。例如下面这个向量：<br><img src="http://omu7tit09.bkt.clouddn.com/14992473264569.png" alt=""></p><p>在代数表示方面，我们经常用线段终点的点坐标表示向量，例如上面的向量可以表示为(3,2)，这是我们再熟悉不过的向量表示。</p><p>不过我们常常忽略，只有一个(3,2)本身是不能够精确表示一个向量的。我们仔细看一下，这里的3实际表示的是向量在x轴上的投影值是3，在y轴上的投影值是2。也就是说我们其实隐式引入了一个定义：以x轴和y轴上正方向长度为1的向量为标准。那么一个向量(3,2)实际是说在x轴投影为3而y轴的投影为2。注意投影是一个矢量，所以可以为负。</p><p>更正式的说，向量(x,y)实际上表示线性组合：</p><script type="math/tex; mode=display">x(1,0)^T+y(0,1)^T</script><p>不难证明所有二维向量都可以表示为这样的线性组合。此处（1，0）和（0，1）叫做二维空间中的一组基。<br><img src="http://omu7tit09.bkt.clouddn.com/14992474414800.png" alt=""></p><p>所以，要准确描述向量，首先要确定一组基，然后给出在基所在的各个直线上的投影值，就可以了。只不过我们经常省略第一步，而默认以(1,0)和(0,1)为基。</p><p>我们之所以默认选择$(1,0)$和$(0,1)$为基，当然是比较方便，因为它们分别是x和y轴正方向上的单位向量，因此就使得二维平面上点坐标和向量一一对应，非常方便。但实际上任何两个线性无关的二维向量都可以成为一组基，所谓线性无关在二维平面内可以直观认为是两个不在一条直线上的向量。</p><p>例如，$(1,1)$和$(-1,1)$也可以成为一组基。一般来说，我们希望基的模是1，因为从内积的意义可以看到，如果基的模是1，那么就可以方便的用向量点乘基而直接获得其在新基上的坐标了！实际上，对应任何一个向量我们总可以找到其同方向上模为1的向量，只要让两个分量分别除以模就好了。例如，上面的基可以变为$(\frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}})$和$-\frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}}$。</p><p>现在，我们想获得$(3,2)$在新基上的坐标，即在两个方向上的投影矢量值，那么根据内积的几何意义，我们只要分别计算(3,2)和两个基的内积，不难得到新的坐标为$(\frac{5}{\sqrt{2}},−\frac{1}{\sqrt{2}}$。下图给出了新的基以及(3,2)在新基上坐标值的示意图：</p><p><img src="http://omu7tit09.bkt.clouddn.com/14992476980092.png" alt=""></p><p>另外这里要注意的是，我们列举的例子中基是正交的（即内积为0，或直观说相互垂直），但可以成为一组基的唯一要求就是线性无关，非正交的基也是可以的。不过因为正交基有较好的性质，所以一般使用的基都是正交的。</p><h3 id="2-3-基变换的矩阵表示"><a href="#2-3-基变换的矩阵表示" class="headerlink" title="2.3 基变换的矩阵表示"></a>2.3 基变换的矩阵表示</h3><p>下面我们找一种简便的方式来表示基变换。还是拿上面的例子，想一下，将$(3,2)$变换为新基上的坐标，就是用$(3,2)$与第一个基做内积运算，作为第一个新的坐标分量，然后用(3,2)与第二个基做内积运算，作为第二个新坐标的分量。实际上，我们可以用矩阵相乘的形式简洁的表示这个变换：</p><script type="math/tex; mode=display">\left[\begin{matrix}    \frac{1}{\sqrt{2}}&        \frac{1}{\sqrt{2}}\\    -\frac{1}{\sqrt{2}}&        \frac{1}{\sqrt{2}}\\\end{matrix}\right]\left[\begin{array}{c}    3\\    2\\\end{array}\right]=\left[\begin{array}{c}    \frac{5}{\sqrt{2}}\\    -\frac{1}{\sqrt{2}}\\\end{array}\right]</script><p>其中矩阵的两行分别为两个基，乘以原向量，其结果刚好为新基的坐标。可以稍微推广一下，如果我们有m个二维向量，只要将二维向量按列排成一个两行m列矩阵，然后用“基矩阵”乘以这个矩阵，就得到了所有这些向量在新基下的值。例如(1,1)，(2,2)，(3,3)，想变换到刚才那组基上，则可以这样表示：</p><script type="math/tex; mode=display">\left[\begin{matrix}    \frac{1}{\sqrt{2}}&        \frac{1}{\sqrt{2}}\\    -\frac{1}{\sqrt{2}}&        \frac{1}{\sqrt{2}}\\\end{matrix}\right]\left[\begin{matrix}    1&        2&        3\\    1&        2&        3\\\end{matrix}\right]=\left[\begin{matrix}    \frac{2}{\sqrt{2}}&        \frac{4}{\sqrt{2}}&        \frac{6}{\sqrt{2}}\\    0&        0&        0\\\end{matrix}\right]</script><p>于是一组向量的基变换被干净的表示为矩阵的相乘。</p><p>一般的，如果我们有M个N维向量，想将其变换为由R个N维向量表示的新空间中，那么首先将R个基按行组成矩阵A，然后将向量按列组成矩阵B，那么两矩阵的乘积AB就是变换结果，其中AB的第m列为A中第m列变换后的结果。</p><p>数学表示为：</p><script type="math/tex; mode=display">\left[\begin{array}{c}    p_1\\    p_2\\    ···\\    p_r\\\end{array}\right]\left[\begin{matrix}    a_1&        a_2&        ···&        a_M\\\end{matrix}\right]=\left[\begin{matrix}    p_1a_1&        p_1a_2&        ···&        p_1a_M\\    p_2a_1&        p_2a_2&        ···&        p_2a_M\\    ···&        ···&        ···&        ···\\    p_ra_1&        p_ra_2&        ···&        p_ra_M\\\end{matrix}\right]</script><p>其中$p_i$是一个行向量，表示第$i$个基，$a_j$是一个列向量，表示第$j$个原始数据记录。</p><p>特别要注意的是，这里R可以小于N，而R决定了变换后数据的维数。也就是说，我们可以将一N维数据变换到更低维度的空间中去，变换后的维度取决于基的数量。因此这种矩阵相乘的表示也可以表示降维变换。</p><p>最后，上述分析同时给矩阵相乘找到了一种物理解释：两个矩阵相乘的意义是将右边矩阵中的每一列列向量变换到左边矩阵中每一行行向量为基所表示的空间中去。更抽象的说，一个矩阵可以表示一种线性变换。很多同学在学线性代数时对矩阵相乘的方法感到奇怪，但是如果明白了矩阵相乘的物理意义，其合理性就一目了然了。</p><h2 id="三、协方差矩阵及优化目标"><a href="#三、协方差矩阵及优化目标" class="headerlink" title="三、协方差矩阵及优化目标"></a>三、协方差矩阵及优化目标</h2><p>上面我们讨论了选择不同的基可以对同样一组数据给出不同的表示，而且如果基的数量少于向量本身的维数，则可以达到降维的效果。但是我们还没有回答一个最最关键的问题：如何选择基才是最优的。或者说，如果我们有一组N维向量，现在要将其降到K维（K小于N），那么我们应该如何选择K个基才能最大程度保留原有的信息？</p><p>要完全数学化这个问题非常繁杂，这里我们用一种非形式化的直观方法来看这个问题。</p><p>为了避免过于抽象的讨论，我们仍以一个具体的例子展开。假设我们的数据由五条记录组成，将它们表示成矩阵形式：</p><script type="math/tex; mode=display">\left[\begin{matrix}    1&        1&        2&        4&        2\\    1&        3&        3&        4&        4\\\end{matrix}\right]</script><p>其中每一列为一条数据记录，而一行为一个字段。为了后续处理方便，我们首先将每个字段内所有值都减去字段均值，其结果是将每个字段都变为均值为0（这样做的道理和好处后面会看到）。</p><p>我们看上面的数据，第一个字段均值为2，第二个字段均值为3，所以变换后：</p><script type="math/tex; mode=display">\left[\begin{matrix}    -1&        -1&        0&        2&        0\\    -2&        0&        0&        1&        1\\\end{matrix}\right]</script><p>我们可以看下五条数据在平面直角坐标系内的样子：<br><img src="http://omu7tit09.bkt.clouddn.com/14992501725051.png" alt=""></p><p>现在问题来了：如果我们必须使用一维来表示这些数据，又希望尽量保留原始的信息，你要如何选择？</p><p>通过上一节对基变换的讨论我们知道，这个问题实际上是要在二维平面中选择一个方向，将所有数据都投影到这个方向所在直线上，用投影值表示原始记录。这是一个实际的二维降到一维的问题。</p><p>那么如何选择这个方向（或者说基）才能尽量保留最多的原始信息呢？一种直观的看法是：希望投影后的投影值尽可能分散。</p><p>以上图为例，可以看出如果向x轴投影，那么最左边的两个点会重叠在一起，中间的两个点也会重叠在一起，于是本身四个各不相同的二维点投影后只剩下两个不同的值了，这是一种严重的信息丢失，同理，如果向y轴投影最上面的两个点和分布在x轴上的两个点也会重叠。所以看来x和y轴都不是最好的投影选择。我们直观目测，如果向通过第一象限和第三象限的斜线投影，则五个点在投影后还是可以区分的。</p><p>下面，我们用数学方法表述这个问题。</p><h3 id="3-1-方差"><a href="#3-1-方差" class="headerlink" title="3.1 方差"></a>3.1 方差</h3><p>上文说到，我们希望投影后投影值尽可能分散，而这种分散程度，可以用数学上的方差来表述。此处，一个字段的方差可以看做是每个元素与字段均值的差的平方和的均值，即：</p><script type="math/tex; mode=display">Var(a)=\frac{1}{m}\sum^m_{i=1}(a_i-\mu)^2</script><p>由于上面我们已经将每个字段的均值都化为0了，因此方差可以直接用每个元素的平方和除以元素个数表示：</p><script type="math/tex; mode=display">Var(a)=\frac{1}{m}\sum^m_{i=1}a_i^2</script><p>于是上面的问题被形式化表述为：寻找一个一维基，使得所有数据变换为这个基上的坐标表示后，方差值最大。</p><h3 id="3-2-协方差"><a href="#3-2-协方差" class="headerlink" title="3.2 协方差"></a>3.2 协方差</h3><p>对于上面二维降成一维的问题来说，找到那个使得方差最大的方向就可以了。不过对于更高维，还有一个问题需要解决。考虑三维降到二维问题。与之前相同，首先我们希望找到一个方向使得投影后方差最大，这样就完成了第一个方向的选择，继而我们选择第二个投影方向。</p><p>如果我们还是单纯只选择方差最大的方向，很明显，这个方向与第一个方向应该是“几乎重合在一起”，显然这样的维度是没有用的，因此，应该有其他约束条件。从直观上说，让两个字段尽可能表示更多的原始信息，我们是不希望它们之间存在（线性）相关性的，因为相关性意味着两个字段不是完全独立，必然存在重复表示的信息。</p><p>数学上可以用两个字段的协方差表示其相关性，由于已经让每个字段均值为0，则：</p><script type="math/tex; mode=display">Cov(a,b) = \frac{1}{m}\sum_{i=1}^ma_ib_i</script><p>可以看到，在字段均值为0的情况下，两个字段的协方差简洁的表示为其内积除以元素数m。</p><p>当协方差为0时，表示两个字段完全独立。为了让协方差为0，我们选择第二个基时只能在与第一个基正交的方向上选择。因此最终选择的两个方向一定是正交的。</p><p>至此，我们得到了降维问题的优化目标：将一组N维向量降为K维（K大于0，小于N），其目标是选择K个单位（模为1）正交基，使得原始数据变换到这组基上后，各字段两两间协方差为0，而字段的方差则尽可能大（在正交的约束下，取最大的K个方差）。</p><h3 id="3-3-协方差矩阵"><a href="#3-3-协方差矩阵" class="headerlink" title="3.3 协方差矩阵"></a>3.3 协方差矩阵</h3><p>上面我们导出了优化目标，但是这个目标似乎不能直接作为操作指南（或者说算法），因为它只说要什么，但根本没有说怎么做。所以我们要继续在数学上研究计算方案。</p><p>我们看到，最终要达到的目的与字段内方差及字段间协方差有密切关系。因此我们希望能将两者统一表示，仔细观察发现，两者均可以表示为内积的形式，而内积又与矩阵相乘密切相关。于是我们来了灵感：</p><p>假设我们只有a和b两个字段，那么我们将它们按行组成矩阵X：</p><script type="math/tex; mode=display">X=\left[\begin{matrix}    a_1&        a_1&        ···&        a_m\\    b_1&        b_2&        ···&        b_m\\\end{matrix}\right]</script><p>然后我们用X乘以X的转置，并乘上系数$1/m$：</p><script type="math/tex; mode=display">\frac{1}{m}XX^T = \left[\begin{matrix}    \frac{1}{m}\sum_{i=1}^ma_i^2&        \frac{1}{m}\sum_{i=1}^ma_ib_i\\    \frac{1}{m}\sum_{i=1}^ma_ib_i&        \frac{1}{m}\sum_{i=1}^mb_i^2\\\end{matrix}\right]</script><p>奇迹出现了！这个对角线上的两个元素分别是两个字段的方差，而其它元素是a和b的协方差。两者被统一到了一个矩阵的。</p><p>根据矩阵相乘的运算法则，这个结论很容易被推广到一般情况：设我们有m个n维数据记录，将其按列排成n乘m的矩阵X，设￥$C=\frac{1}{m}XX^𝖳$，则C是一个对称矩阵，其对角线分别个各个字段的方差，而第i行j列和j行i列元素相同，表示i和j两个字段的协方差。</p><h3 id="3-4-协方差矩阵对角化"><a href="#3-4-协方差矩阵对角化" class="headerlink" title="3.4 协方差矩阵对角化"></a>3.4 协方差矩阵对角化</h3><p>根据上述推导，我们发现要达到优化条件，等价于将协方差对角化：即除对角线外的其它元素化为0，并且在对角线上将元素按大小从上到下排列，这样我们就达到了优化目的。这样说可能还不是很明晰，我们进一步看下原矩阵与基变换后矩阵协方差矩阵的关系：</p><p>设原始数据矩阵X对应的协方差矩阵为C，而P是一组基按行组成的矩阵，设$Y=PX$，则Y为X对P做基变换后的数据。设Y的协方差矩阵为D，我们推导一下D与C的关系：</p><script type="math/tex; mode=display">D = \frac{1}{m}YY^T\\ =\frac{1}{m}(PX)(PX)^T\\ =\frac{1}{m}PXX^TP\\=PCP^T</script><p>现在事情很明白了，我们要找的$P$不是别的，而是能让原始协方差矩阵对角化的$P$。换句话说，优化目标变成了寻找一个矩阵$P$，满足$PCP^T$是一个对角矩阵，并且对角元素按从小到大依次排列，那么$P$的前$K$行就是要寻找的基，用$P$的前$K$行组成的矩阵乘以$X$就使得$X$从$N$维降到了$K$维并满足上述优化条件。</p><p>至此，我们离“发明”PCA还有仅一步之遥！</p><p>现在所有焦点都聚焦在了协方差矩阵对角化问题上，有时，我们真应该感谢数学家的先行，因为矩阵对角化在线性代数领域已经属于被玩烂了的东西，所以这在数学上根本不是问题。</p><p>由上文知道，协方差矩阵C是一个是对称矩阵，在线性代数上，实对称矩阵有一系列非常好的性质：</p><ul><li>1）实对称矩阵不同特征值对应的特征向量必然正交。</li><li>2）设特征向量λλ重数为r，则必然存在r个线性无关的特征向量对应于λλ，因此可以将这r个特征向量单位正交化。</li></ul><p>由上面两条可知，一个n行n列的实对称矩阵一定可以找到n个单位正交特征向量，设这n个特征向量为$e_1,e_2,⋯,e_n$，我们将其按列组成矩阵：</p><script type="math/tex; mode=display">E = (e_1\ e_2 \ ··· \ e_n)</script><p>则对协方差矩阵$C$有如下结论：</p><script type="math/tex; mode=display">E^TCE =\varLambda\ =\left[\begin{matrix}    \lambda_1&        &        &        \\    &        \lambda_2&        &        \\    &        &        ···&        \\    &        &        &        \lambda_n\\\end{matrix}\right]</script><p>其中Λ为对角矩阵，其对角元素为各特征向量对应的特征值（可能有重复）。以上结论不再给出严格的数学证明，对证明感兴趣的朋友可以参考线性代数书籍关于“实对称矩阵对角化”的内容。</p><p>到这里，我们发现我们已经找到了需要的矩阵P：P是协方差矩阵的特征向量单位化后按行排列出的矩阵，其中每一行都是C的一个特征向量。如果设P按照ΛΛ中特征值的从大到小，将特征向量从上到下排列，则用P的前K行组成的矩阵乘以原始数据矩阵X，就得到了我们需要的降维后的数据矩阵Y。</p><p>至此我们完成了整个PCA的数学原理讨论。在下面的一节，我们将给出PCA的一个实例。</p><h2 id="四、算法及实例"><a href="#四、算法及实例" class="headerlink" title="四、算法及实例"></a>四、算法及实例</h2><p>为了巩固上面的理论，我们在这一节给出一个具体的PCA实例。</p><h3 id="4-1-PCA算法"><a href="#4-1-PCA算法" class="headerlink" title="4.1 PCA算法"></a>4.1 PCA算法</h3><p>总结一下PCA的算法步骤：<br>设有m条n维数据。</p><ul><li>1）将原始数据按列组成n行m列矩阵X</li><li>2）将X的每一行（代表一个属性字段）进行零均值化，即减去这一行的均值</li><li>3）求出协方差矩阵$C=\frac{1}{m}XX^T$</li><li>4）求出协方差矩阵的特征值及对应的特征向量</li><li>5）将特征向量按对应特征值大小从上到下按行排列成矩阵，取前K行组成矩阵P</li><li>6）$Y=PX$即为降维到K维后的数据</li></ul><h3 id="4-2-实例"><a href="#4-2-实例" class="headerlink" title="4.2 实例"></a>4.2 实例</h3><p>这里以上文提到的</p><script type="math/tex; mode=display">\left[\begin{matrix}    -1&        -1&        0&        2&        0\\    -2&        0&        0&        1&        1\\\end{matrix}\right]</script><p>为例，我们用PCA方法将这组二维数据降到一维。</p><p>因为这个矩阵的每行已经是零均值，这里我们直接求协方差矩阵：</p><script type="math/tex; mode=display">C=\frac{1}{5}\left[\begin{matrix}    -1&        -1&        0&        2&        0\\    -2&        0&        0&        1&        1\\\end{matrix}\right]\left[\begin{matrix}    -1&        -2\\    -1&        0\\    0&             0\\    2&             1\\    0&            1\\\end{matrix}\right]=\left[\begin{matrix}    \frac{6}{5}&        \frac{4}{5} \\    \frac{4}{5}&      \frac{6}{5} \\ \end{matrix}\right]</script><p>然后求其特征值和特征向量，具体求解方法不再详述。求解后特征值为：</p><script type="math/tex; mode=display">\lambda_1=2 , \lambda_2 =\frac{2}{5}</script><p>其对应的特征向量分别是：</p><script type="math/tex; mode=display">c_1\left[\begin{matrix}            -2\\    0\\\end{matrix}\right],c_2\left[\begin{matrix}            -1\\    1\\\end{matrix}\right]</script><p>其中对应的特征向量分别是一个通解，$c_1$和$c_2$可取任意实数。那么标准化后的特征向量为：</p><script type="math/tex; mode=display">\left[\begin{matrix}            \frac{1}{\sqrt{2}}\\    \frac{1}{\sqrt{2}}\\\end{matrix}\right],\left[\begin{matrix}            -\frac{1}{\sqrt{2}}\\    \frac{1}{\sqrt{2}}\\\end{matrix}\right]</script><p>因此我们的矩阵P是：</p><script type="math/tex; mode=display">P=\left[\begin{matrix}            \frac{1}{\sqrt{2}}&\frac{1}{\sqrt{2}} \\    -\frac{1}{\sqrt{2}}&\frac{1}{\sqrt{2}}\\\end{matrix}\right]</script><p>可以验证协方差矩阵C的对角化：</p><script type="math/tex; mode=display">PCP^T=\left[\begin{matrix}            \frac{1}{\sqrt{2}}&\frac{1}{\sqrt{2}} \\    -\frac{1}{\sqrt{2}}&\frac{1}{\sqrt{2}}\\\end{matrix}\right]\left[\begin{matrix}    \frac{6}{5}&        \frac{4}{5} \\    \frac{4}{5}&      \frac{6}{5} \\ \end{matrix}\right]\left[\begin{matrix}            \frac{1}{\sqrt{2}}&-\frac{1}{\sqrt{2}} \\    \frac{1}{\sqrt{2}}&\frac{1}{\sqrt{2}}\\\end{matrix}\right]=\left[\begin{matrix}            2&0\\    0&\frac{2}{5}\\\end{matrix}\right]</script><p>最后我们用P的第一行乘以数据矩阵，就得到了降维后的表示：</p><script type="math/tex; mode=display">Y =\left[\begin{matrix}            \frac{1}{\sqrt{2}}&\frac{1}{\sqrt{2}}\\\end{matrix}\right] \left[\begin{matrix}            -1&-1&0&2&0\\            -2&0&0&1&1\\\end{matrix}\right]=\left[\begin{matrix}            -\frac{3}{\sqrt{2}}&\frac{1}{\sqrt{2}}&0&\frac{3}{\sqrt{2}}&-\frac{1}{2}\\\end{matrix}\right]</script><p>降维投影结果如下图：<br><img src="http://omu7tit09.bkt.clouddn.com/14992688265732.png" alt=""></p><h2 id="五、理论意义"><a href="#五、理论意义" class="headerlink" title="五、理论意义"></a>五、理论意义</h2><p>PCA将n个特征降维到k个，可以用来进行数据压缩，如果100维的向量最后可以用10维来表示，那么压缩率为90%。同样图像处理领域的KL变换使用PCA做图像压缩。但PCA要保证降维后，还要保证数据的特性损失最小。再看回顾一下PCA的效果。经过PCA处理后，二维数据投影到一维上可以有以下几种情况：<br><img src="http://omu7tit09.bkt.clouddn.com/14993039151739.png" alt=""></p><p>我们认为左图好，一方面是投影后方差最大，一方面是点到直线的距离平方和最小，而且直线过样本点的中心点。为什么右边的投影效果比较差？直觉是因为坐标轴之间相关，以至于去掉一个坐标轴，就会使得坐标点无法被单独一个坐标轴确定。</p><p>PCA得到的k个坐标轴实际上是k个特征向量，由于协方差矩阵对称，因此k个特征向量正交。</p><p>得到的新的样例矩阵$Y=PX$就是m个样例到k个特征向量的投影，也是这k个特征向量的线性组合。P中e之间是正交的。从矩阵乘法中可以看出，PCA所做的变换是将原始样本点（n维），投影到k个正交的坐标系中去，丢弃其他维度的信息。举个例子，假设宇宙是n维的（霍金说是11维的），我们得到银河系中每个星星的坐标（相对于银河系中心的n维向量），然而我们想用二维坐标去逼近这些样本点，假设算出来的协方差矩阵的特征向量分别是图中的水平和竖直方向，那么我们建议以银河系中心为原点的x和y坐标轴，所有的星星都投影到x和y上，得到下面的图片。然而我们丢弃了每个星星离我们的远近距离等信息。</p><h2 id="六、进一步讨论"><a href="#六、进一步讨论" class="headerlink" title="六、进一步讨论"></a>六、进一步讨论</h2><p>根据上面对PCA的数学原理的解释，我们可以了解到一些PCA的能力和限制。PCA本质上是将方差最大的方向作为主要特征，并且在各个正交方向上将数据“离相关”，也就是让它们在不同正交方向上没有相关性。</p><p>因此，PCA也存在一些限制，例如它可以很好的解除线性相关，但是对于高阶相关性就没有办法了，对于存在高阶相关性的数据，可以考虑Kernel PCA，通过Kernel函数将非线性相关转为线性相关，关于这点就不展开讨论了。另外，PCA假设数据各主特征是分布在正交方向上，如果在非正交方向上存在几个方差较大的方向，PCA的效果就大打折扣了。</p><p>PCA技术的一个很大的优点是，它是完全无参数限制的。在PCA的计算过程中完全不需要人为的设定参数或是根据任何经验模型对计算进行干预，最后的结果只与数据相关，与用户是独立的。 </p><p>但是，这一点同时也可以看作是缺点。如果用户对观测对象有一定的先验知识，掌握了数据的一些特征，却无法通过参数化等方法对处理过程进行干预，可能会得不到预期的效果，效率也不高。</p><p><img src="http://omu7tit09.bkt.clouddn.com/14993021431867.gif" alt="">上图中黑色点表示采样数据，排列成转盘的形状。容易想象，该数据的主元是$(P_1,P_2)$或是旋转角$\theta$。在这里PCA找出的主元将是$(P_1,P_2 )$。但是这显然不是最优和最简化的主元。$(P_1,P_2 )$之间存在着非线性的关系。根据先验的知识可知旋转角$\theta$是最优的主元（类比极坐标）。则在这种情况下，PCA就会失效。但是，如果加入先验的知识，对数据进行某种划归，就可以将数据转化为以$\theta$为线性的空间中。这类根据先验知识对数据预先进行非线性转换的方法就成为kernel-PCA，它扩展了PCA能够处理的问题的范围，又可以结合一些先验约束，是比较流行的方法。</p><p>有时数据的分布并不是满足高斯分布。如图表 5所示，在非高斯分布的情况下，PCA方法得出的主元可能并不是最优的。在寻找主元时不能将方差作为衡量重要性的标准。要根据数据的分布情况选择合适的描述完全分布的变量，然后根据概率分布式</p><script type="math/tex; mode=display">P(y_1,y_2)=P(y_1)P(y_2 )</script><p>来计算两个向量上数据分布的相关性。等价的，保持主元间的正交假设，寻找的主元同样要使$P(y_1,y_2)=0$。这一类方法被称为独立主元分解(ICA)。<br><img src="http://omu7tit09.bkt.clouddn.com/14993037124980.gif" alt=""><br>数据的分布并不满足高斯分布，呈明显的十字星状。这种情况下，方差最大的方向并不是最优主元方向。另外PCA还可以用于预测矩阵中缺失的元素。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PCA（Principal Component Analysis）是一种常用的数据分析方法。PCA通过线性变换将原始数据变换为一组各维度线性无关的表示，可用于提取数据的主要特征分量，常用于高维数据的降维。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="PCA" scheme="http://yoursite.com/tags/PCA/"/>
    
      <category term="降维" scheme="http://yoursite.com/tags/%E9%99%8D%E7%BB%B4/"/>
    
      <category term="非监督学习" scheme="http://yoursite.com/tags/%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习算法系列（21）：SVD</title>
    <link href="http://yoursite.com/2017/07/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%8821%EF%BC%89%EF%BC%9ASVD%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3%E5%8F%8A%E5%85%B6%E6%84%8F%E4%B9%89/"/>
    <id>http://yoursite.com/2017/07/01/机器学习算法系列（21）：SVD奇异值分解及其意义/</id>
    <published>2017-07-01T15:14:45.000Z</published>
    <updated>2017-12-26T08:32:29.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>SVD实际上是数学专业内容，但它现在已经深入到不同的领域中。SVD的过程不是很好理解，因为它不够直观，但它对矩阵分解的效果却非常好。比如，Netflix（一个提供在线电影租赁的公司）曾经就悬赏100万美金，如果谁能提高他的电影推荐系统评分预测率10%的话。令人惊讶的是，这个目标充满了挑战，来自世界各地的团队运用了各种不同的技术。最终的获胜队伍“BellKor’s Pragmatic Chaos”采用的核心算法就是基于SVD。</p><a id="more"></a><p>SVD提供了一种非常便捷的矩阵分解方式，能够发现数据中十分有意思的潜在模式，在这篇文章中，我们将会提供对SVD集合上的理解和一些简单的应用实例。</p><h3 id="1-1-几何意义"><a href="#1-1-几何意义" class="headerlink" title="1.1 几何意义"></a>1.1 几何意义</h3><p>奇异值分解就是把一个线性变换分解成两个线性变换，一个线性变化代表旋转，另一个代表拉伸。</p><p>线性代数中最让人印象深刻的一点是，要将矩阵和空间中的线性变化视为同样的事物。比如对角矩阵$M$作用在任何一个向量上$$<br>\left[\begin{matrix}<br>    3&amp;        0\\<br>    0&amp;        1\\<br>\end{matrix}\right]\left[\begin{array}{c}<br>    x\\<br>    y\\<br>\end{array}\right]=\left[\begin{array}{c}<br>    3x\\<br>    y\\<br>\end{array}\right]</p><script type="math/tex; mode=display">其几何意义为在水平$x$方向上拉伸3倍，$y$方向保持不变的线性变换。换言之对角矩阵起到作用是将水平垂直网格作水平拉伸（或者反射后水平拉伸）的线性变换。![](http://omu7tit09.bkt.clouddn.com/14990677634208.jpg)如果$M$不是对角矩阵。而是一个对称矩阵：</script><p>M=\left[\begin{matrix}<br>    2&amp;        1\\<br>    1&amp;        2\\<br>\end{matrix}\right]</p><script type="math/tex; mode=display">那么我们也总能找到一组网格线，使得矩阵作用在该网格上仅仅表现为（反射）拉伸变换，而没有发生旋转变换。这个矩阵产生的变换效果如下图所示![](http://omu7tit09.bkt.clouddn.com/14992394690344.jpg)考虑一下更一般的非对称矩阵</script><p>M=\left[\begin{matrix}<br>    1&amp;        1\\<br>    0&amp;        1\\<br>\end{matrix}\right]</p><script type="math/tex; mode=display">很遗憾，此时我们再也找不到一组网格，使得矩阵作用在该网格之后只有拉伸变换（找不到背后的数学原因就是对一般非对称矩阵无法保证在实数域上可对角化）。我们退而求其次，找到一组网格，使得矩阵作用在该网格之后允许有拉伸变换和旋转变换，但要保证变换后的网格依旧互相垂直。这是可以做到的![](http://omu7tit09.bkt.clouddn.com/14992307483348.jpg)下面我们就可以自然过渡到奇异值分解的引入。奇异值分解的几何含义为：对于任何的一个矩阵，我们要找到一组两两正交单位向量序列，使得矩阵作用在此向量序列上后得到新的向量序列保持两两正交。下面我们要说明的是，奇异值的几何含义为：这组变换后的新的向量序列的长度。![屏幕快照 2017-07-05 下午1.04.29](http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-05 下午1.04.29.png)当矩阵$M$作用在正交单位向量$v_1$和$v_2$上之后，得到$Mv_1$和$Mv_2$也是正交的。令$u_1$和$u_2$分别是$Mv_1$和$Mv_2$方向上的单位向量，即$Mv_1 = \sigma_1u_1$，$Mv_2 = \sigma _2 u_2$，写在一起就是$M[v_1,v_2] = [\sigma_1 u_1 \ \sigma_2 u_2]$，整理得到</script><p>M=M\left[v_1\ v_2\right]\left[\begin{array}{c}<br>    v_{1}^{T}\\<br>    v_{2}^{T}\\<br>\end{array}\right]=\left[\sigma_1u_1 \ \sigma_2u_2\right]\left[\begin{array}{c}<br>    v_{1}^{T}\\<br>    v_{2}^{T}\\<br>\end{array}\right]=\left[u_1\ u_2\right]\left[\begin{matrix}<br>    \sigma_1&amp;        0\\<br>    0&amp;        \sigma_2\\<br>\end{matrix}\right]\left[\begin{array}{c}<br>    v_{1}^{T}\\<br>    v_{2}^{T}\\<br>\end{array}\right]</p><script type="math/tex; mode=display">这样就得到矩阵$M$的奇异值分解。奇异值$\sigma_1$和$\sigma_2$分别是$Mv_1$和$Mv_2$的长度。很容易可以把结论推广到一般$n$维的情况## 二、、奇异值分解### 2.1 特征值分解如果方阵对某个向量只产生伸缩，而不产生旋转效果，那么这个向量就称为矩阵的特征向量，伸缩的比例就是对应的特征值。$$Ax=\lambda x</script><p><img src="http://omu7tit09.bkt.clouddn.com/14990727044929.png" alt=""></p><p>所以这其实是在平面上对一个轴进行的拉伸变换（如蓝色的箭头所示），在图中，蓝色的箭头是一个最主要的变化（变化方向可能不止一个），如果我们想要描述好一个变换，那我们描述好这个变换主要的变化方向就好了。反过来看看之前特征值分解的式子，分解得到的$\Sigma$矩阵是一个对角阵，里面的特征值是由大到小排列的，这些特征值所对应的特征向量就是描述这个矩阵变化的方向（从主要的变化到次要的变化排列）。</p><p>当矩阵是高维的情况下，那么这个矩阵就是高维空间下的一个线性变换，这个线性变化可能没法通过图片来表示，但是可以想象，这个变换也同样有很多的变换方向，我们通过特征值分解得到的前N个特征向量，那么就对应了这个矩阵最主要的N个变化方向。我们利用这前N个变化方向，就可以近似这个矩阵变换。也就是之前受的：提取这个矩阵最重要的特征。总结一下，特征值分解可以得到特征值与特征向量，特征值表示的是这个特征到底有多重要，而特征向量表示这个特征是什么，可以将每一个特征向量理解为一个线性的子空间，我们可以利用这些线性的子空间敢很多的事情。不过，特征值分解也有很多的局限，比如说变换的矩阵必须是方阵。</p><p>学线性代数的时候，我们应该都学过这样一个定理：</p><blockquote><p>若A为n阶实对称阵（方阵），则存在由特征值组成的对角阵$\varLambda$和特征向量组成的正交阵$Q$，使得：</p><script type="math/tex; mode=display">A=Q\varLambda Q^T</script></blockquote><p>这就是我们所说的特征值分解（Eigenvalue decomposition: EVD）（$R^n → R^n$），而奇异值分解其实可以看做是特征值分解在任意矩阵$m\times n$上的推广形式($R^n →R^m$)。只有对方阵才有特征值的概念，所以对于任意的矩阵，我们引入了奇异值。</p><h3 id="2-2-奇异值分解"><a href="#2-2-奇异值分解" class="headerlink" title="2.2 奇异值分解"></a>2.2 奇异值分解</h3><p>上面的特征值分解是一个提取矩阵特征很不错的方法，当它只是对方阵而言的，在现实的世界中，我们看到的大部分都不是方阵，比如说有N个学生，每个学生有M科成绩，这样形成的一个$N\times M$的矩阵就不可能是方阵！那么现在就来分析：对于任意的$m\times n$的矩阵，能否找到一组正交基使得经过它变换后还是正交基？答案是肯定的，它就是SVD分解的精髓所在。</p><p>下面我们从特征值分解出发，导出奇异值分解。</p><p>首先我们注意到$A^T A$为$n$阶对称矩阵，我们可以对它做特征值分解。</p><script type="math/tex; mode=display">A^T A = VDV^T</script><p>这个时候我们可以得到一组正交基，$\{v_1,v_2,···v_n\}$：</p><script type="math/tex; mode=display">(A^T A)v_i=\lambda _i v_i</script><script type="math/tex; mode=display">(Av_i,Av_j) = (Av_i)^T(Av_j) = v_i^TA^TAv_j= v_i^T(\lambda_jv_j)= \lambda_jv_i^Tv_j= 0</script><p>由$r(A^T A)=r(A)=r$，这个时候我们得到了一组正交基，$\{Av_1,Av_2,···,Av_r\}$，先将其标准化，令：</p><script type="math/tex; mode=display">u_i = \frac{Av_i}{|Av_i|}=\frac{1}{\sqrt{\lambda _i}}Av_i\Rightarrow Av_i = \sqrt {\lambda _i} u_i = \delta_iu_i</script><p>其中</p><script type="math/tex; mode=display">|Av_i|^2=(Av_i,Av_i)=\lambda_iv_i^Tv_i=\lambda_i \Rightarrow |Av_i| = \sqrt {\lambda _i}=\delta _i(奇异值)</script><p>将向量组$\{u_1,u_2,···,u_r\}$扩充为$R^m$中的标准正交基$\{u_1,u_2,···,u_r,···,u_m$，则：</p><script type="math/tex; mode=display">AV =A(v_1v_2···v_n) =(Av_1 \ Av_2 \ ···\ Av_r\  0 ··· \ 0)\\=(\delta _1u_1  \ \delta_2u_2 ··· \delta _r u_r \ 0 ··· \ 0=U\Sigma\\\Rightarrow A =U\Sigma V^T</script><p>我们可以从下图中直观的感受奇异值分解的矩阵相乘。<br><img src="http://omu7tit09.bkt.clouddn.com/14991419233249.png" alt=""><br>任意的矩阵$A$是可以分解成三个矩阵。其中$V$表示了原始域的标准正交基，$U$表示经过A变化后的$co-domain$的标准正交基，$\Sigma$表示了$V$中的向量与$U$中相对应向量之间的关系。</p><p>在很多情况下，前10%甚至1%的奇异值的和就占了全部分奇异值之和的99%以上了。也就是说，我们也可以用前$r$大的奇异值来近似描述矩阵，这里定义一下部分奇异值分解：</p><script type="math/tex; mode=display">A_{m\times n}≈ U_{m\times r} \Sigma_{r\times r}V^T_{r\times n}</script><p>$r$是一个远小于$m、n$的数，这样矩阵的乘法看起来像是下面的样子：<img src="http://omu7tit09.bkt.clouddn.com/14991423029453.png" alt=""><br>右边的三个矩阵相乘的结果将会是一个接近于A的矩阵，在这儿，$r$越接近于n，则相乘的结果越接近于A。而这三个矩阵的面积之和（早存储观点来说，矩阵面积越小，存储量就越小）要远远小于原始的矩阵A，我们如果想要压缩空间来表示原矩阵A，我们存下这里的三个矩阵:$U、\Sigma、V$就好了。</p><h2 id="三、应用实例"><a href="#三、应用实例" class="headerlink" title="三、应用实例"></a>三、应用实例</h2><h3 id="3-1-推荐系统"><a href="#3-1-推荐系统" class="headerlink" title="3.1 推荐系统"></a>3.1 推荐系统</h3><p>我们现在有一批高尔夫球手对九个不同hole的所需挥杆次数数据，我们希望基于这些数据建立模型，来预测选手对于某个给定hole的挥杆次数。（这个例子来自于： Singular Value Decomposition (SVD) Tutorial，强烈建议大家都去看看）<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-04 上午10.49.41.png" alt="屏幕快照 2017-07-04 上午10.49.41"></p><p>最简单的一个思路，我们队每个hole设立一个难度指标HoleDifficulty，对每位选手的能力也设立一个评价指标PlayAbility，实际的得分取决于这俩者的乘积：</p><script type="math/tex; mode=display">PredictedScore = HoleDifficulty · PlayerAbility</script><p>我们可以简单地把每位选手的Ability都设为1，那么：</p><p><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-04 上午10.50.25.png" alt="屏幕快照 2017-07-04 上午10.50.25"><br>接着我们将HoleDifficulty 和 PlayAbility这两个向量标准化，可以得到如下的关系：<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-04 上午10.51.26.png" alt="屏幕快照 2017-07-04 上午10.51.26"></p><p>好熟悉，这不就是传说中的SVD吗，这样就出来了。</p><p>这里面蕴含了一个非常有趣的思想，也是SVD这么有用的核心：</p><p>最开始高尔夫球员和Holes之间是没有直接联系的，我们通过feature把它们联系在一起：不同的Hole进洞难度是不一样的，每个球手对进度难度的把控也是不一样的，那么我们就可以通过进洞难度这个feature将它们联系在一起，将它们乘起来就得到了我们想要的挥杆次数。</p><p>这个思想很重要，对于我们理解LSI和SVD再推荐系统中的应用相当重要。</p><p>SVD分解其实就是利用隐藏的Feature建立起矩阵行与列之间的联系。</p><p>大家可能注意到，上面那个矩阵秩为1，所以我们很容易就能将其分解，但是在实际问题中我们就得依靠SVD分解，这个时候的隐藏特征往往也不止一个了。</p><p>我们将上面的数据稍作修改：<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-04 上午10.57.19.png" alt="屏幕快照 2017-07-04 上午10.57.19"><br>进行奇异值分解，可以得到：<br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-04 上午10.57.51.png" alt="屏幕快照 2017-07-04 上午10.57.51"><br>隐藏特征的重要性是与其对应的奇异值大小成正比的，也就是奇异值越大，其所对应的隐藏特征也越重要。</p><p>我们将这个思想推广一下</p><p>在推荐系统中，用户和物品之间没有直接联系。但是我们可以通过feature把它们联系在一起。对于电影来说，这样的特征可以是：喜剧还是悲剧，是动作片还是爱情片。用户和这样的feature之间是有关系的，比如某个用户喜欢看爱情片，另外一个用户喜欢看动作片；物品和feature之间也是有关系的，比如某个电影是喜剧，某个电影是悲剧。那么通过和feature之间的联系，我们就找到了用户和物品之间的关系。<br><img src="http://omu7tit09.bkt.clouddn.com/14991374078248.png" alt=""></p><h3 id="3-2-数据压缩"><a href="#3-2-数据压缩" class="headerlink" title="3.2 数据压缩"></a>3.2 数据压缩</h3><p>矩阵的奇异值是一个数学意义上的概念，一般是由奇异值分解（Singular Value Decomposition，简称SVD分解）得到。如果要问奇异值表示什么物理意义，那么就必须考虑在不同的实际工程应用中奇异值所对应的含义。下面先尽量避开严格的数学符号推导，直观的从一张图片出发，让我们来看看奇异值代表什么意义。</p><p>这是女神上野树里（Ueno Juri）的一张照片，像素为$450\times 333$<img src="http://omu7tit09.bkt.clouddn.com/14991425195362.jpg" alt=""><br>我们都知道，图片实际上对应着一个矩阵，矩阵的大小就是像素大小，比如这张图对应的矩阵阶数就是450*333，矩阵上每个元素的数值对应着像素值。我们记这个像素矩阵为 AA 。<br>现在我们对矩阵 AA 进行奇异值分解。直观上，奇异值分解将矩阵分解成若干个秩一矩阵之和，用公式表示就是：</p><script type="math/tex; mode=display">A = \sigma_1u_1v_1^T+\sigma_2u_2v_2^T+···+\sigma_ru_rv_r^T</script><p>其中等式右边每一项前的系数$\sigma$就是奇异值，$u$和$v$分别表示列向量，秩一矩阵的意思是秩为1的矩阵。注意到每一项$uv^T$都是秩为1的矩阵。我们假定奇异值满足</p><script type="math/tex; mode=display">\sigma_1≥\sigma_2≥···≥\sigma_r＞0</script><p>（奇异值大于0是个重要的性质，但这里先别在意），如果不满足的话重新排列顺序即可，这无非是编号顺序的问题。</p><p>既然奇异值有从大到小排列的顺序，我们自然要问，如果只保留大的奇异值，舍去较小的奇异值，这样(1)式里的等式自然不再成立，那会得到怎样的矩阵——也就是图像？</p><p>令 $A_1=σ_1u_1v^T_1$ ，这只保留(1)中等式右边第一项，然后作图<img src="http://omu7tit09.bkt.clouddn.com/14991456788688.jpg" alt=""><br>结果就是完全看不清是啥···我们试着多增加几项进来：</p><script type="math/tex; mode=display">A_5=σ_1μ_1v^T_1+σ_2μ_2v^T_2+...+σ_5μ_5v^T_5</script><p>再作图<img src="http://omu7tit09.bkt.clouddn.com/14991457633850.jpg" alt=""><br>隐约可以辨别这是短发伽椰子的脸……但还是很模糊，毕竟我们只取了5个奇异值而已。下面我们取20个奇异值试试，也就是(1)式等式右边取前20项构成 A20。<br>虽然还有些马赛克般的模糊，但我们总算能辨别出这是Juri酱的脸。当我们取到(1)式等式右边前50项时：<br><img src="http://omu7tit09.bkt.clouddn.com/14991457842537.jpg" alt=""><br>我们得到和原图差别不大的图像。也就是说当k从1不断增大时，A_k不断的逼近A。让我们回到公式</p><script type="math/tex; mode=display">A=σ_1μ_1v^T_1+σ_2μ_2v^T_2+...+σ_rμ_rv^T_r</script><p>矩阵表示一个$450\times333$的矩阵，需要保存$450\times 333=149850$个元素的值。等式右边和分别是$450\times 1$和$333\times1$的向量，每一项有个元素。如果我们要存储很多高清的图片，而又受限于存储空间的限制，在尽可能保证图像可被识别的精度的前提下，我们可以保留奇异值较大的若干项，舍去奇异值较小的项即可。例如在上面的例子中，如果我们只保留奇异值分解的前50项，则需要存储的元素为，和存储原始矩阵相比，存储量仅为后者的26%。</p><p>奇异值往往对应着矩阵中隐含的重要信息，且重要性和奇异值大小正相关。每个矩阵A都可以表示为一系列秩为1的“小矩阵”之和，而奇异值则衡量了这些“小矩阵”对于A的权重。</p><p>奇异值分解也可以高效地表示数据。例如，假设我们想传送下列图片，包含$15 \times 25 $个黑色或者白色的像素阵列<br><img src="http://omu7tit09.bkt.clouddn.com/14991461869150.jpg" alt=""><br>因为在图像中只有三种类型的列（如下）,它可以以更紧凑的形式被表示。<img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-05 下午1.43.30.png" alt="屏幕快照 2017-07-05 下午1.43.30"><br>就保留主要样本数据来看，该过程跟PCA( principal component analysis)技术有一些联系，PCA也使用了SVD去检测数据间依赖和冗余信息.<img src="http://omu7tit09.bkt.clouddn.com/14992334554512.gif" alt=""><br>如果对M进行奇异值分解的话，我们只会得到三个非零的奇异值。</p><script type="math/tex; mode=display">\sigma _1 =14.72 \  \sigma_2 =5.22  \sigma _3 =3.31</script><p>因此，矩阵可以如下表示</p><script type="math/tex; mode=display">M=u_1σ_1v_1^T+ u_2σ_2v_2^T + u_3σ_3 v_3^T</script><p>我们有三个包含15个元素的向量$v_i$，三个包含25个元素的向量$u_i$，以及三个奇异值$\sigma _i$，这意味着我们可以只用123个数字就能表示这个矩阵而不是出现在矩阵中的375个元素。在这种方式下，我们看到在矩阵中有三个线性独立的列，也就是说矩阵的秩是3。</p><h3 id="3-3-图像去噪"><a href="#3-3-图像去噪" class="headerlink" title="3.3 图像去噪"></a>3.3 图像去噪</h3><p>在图像处理领域，奇异值不仅可以应用在数据压缩上，还可以对图像去噪。如果一副图像包含噪声，我们有理由相信那些较小的奇异值就是由于噪声引起的。当我们强行令这些较小的奇异值为0时，就可以去除图片中的噪声。如下是一张$25*15$的图像（本例来源于[1]）<br><img src="http://omu7tit09.bkt.clouddn.com/14991461869150.jpg" alt=""></p><p>但往往我们只能得到如下带有噪声的图像（和无噪声图像相比，下图的部分白格子中带有灰色）：<br><img src="http://omu7tit09.bkt.clouddn.com/14991462671332.jpg" alt=""></p><p>通过奇异值分解，我们发现矩阵的奇异值从大到小分别为：14.15，4.67，3.00，0.21，……，0.05。除了前3个奇异值较大以外，其余奇异值相比之下都很小。强行令这些小奇异值为0，然后只用前3个奇异值构造新的矩阵，得到<br><img src="http://omu7tit09.bkt.clouddn.com/14991463079178.jpg" alt=""><br>可以明显看出噪声减少了（白格子上灰白相间的图案减少了）。</p><h3 id="3-4-数据分析"><a href="#3-4-数据分析" class="headerlink" title="3.4 数据分析"></a>3.4 数据分析</h3><p>我们搜集的数据中总是存在噪声：无论采用的设备多精密，方法有多好，总是会存在一些误差的。如果你们还记得上文提到的，大的奇异值对应了矩阵中的主要信息的话，运用SVD进行数据分析，提取其中的主要部分的话，还是相当合理的。</p><p>作为例子，假如我们搜集的数据如下所示：<br><img src="http://omu7tit09.bkt.clouddn.com/14992328641320.gif" alt=""></p><p>我们将数据用矩阵的形式表示：<br><img src="http://omu7tit09.bkt.clouddn.com/14992328943042.jpg" alt=""><br>经过奇异值分解后，得到</p><script type="math/tex; mode=display">\sigma_1 = 6.04  \  \sigma _2 =0.22</script><p>由于第一个奇异值远比第二个要大，数据中有包含一些噪声，第二个奇异值在原始矩阵分解相对应的部分可以忽略。经过SVD分解后，保留了主要样本点如图所示<br><img src="http://omu7tit09.bkt.clouddn.com/14992329639516.gif" alt=""><br>就保留主要样本数据来看，该过程跟PCA( principal component analysis)技术有一些联系，PCA也使用了SVD去检测数据间依赖和冗余信息.</p><h3 id="3-5-潜在语义索引LSI"><a href="#3-5-潜在语义索引LSI" class="headerlink" title="3.5 潜在语义索引LSI"></a>3.5 潜在语义索引LSI</h3><p> 潜在语义索引（Latent Semantic Indexing）与PCA不太一样，至少不是实现了SVD就可以直接用的，不过LSI也是一个严重依赖于SVD的算法，之前吴军老师在矩阵计算与文本处理中的分类问题中谈到：</p><blockquote><p> “三个矩阵有非常清楚的物理含义。第一个矩阵X中的每一行表示意思相关的一类词，其中的每个非零元素表示这类词中每个词的重要性（或者说相关性），数值越大越相关。最后一个矩阵Y中的每一列表示同一主题一类文章，其中每个元素表示这类文章中每篇文章的相关性。中间的矩阵则表示类词和文章之间的相关性。因此，我们只要对关联矩阵A进行一次奇异值分解，我们就可以同时完成了近义词分类和文章的分类。（同时得到每类文章和每类词的相关性）。”</p></blockquote><p> 上面这段话可能不太容易理解，不过这就是LSI的精髓内容，我下面举一个例子来说明一下，下面的例子来自LSA tutorial：<br> <img src="http://omu7tit09.bkt.clouddn.com/14992368804491.png" alt=""></p><p>这就是一个矩阵，不过不太一样的是，这里的一行表示一个词在哪些title中出现了（一行就是之前说的一维feature），一列表示一个title中有哪些词，（这个矩阵其实是我们之前说的那种一行是一个sample的形式的一种转置，这个会使得我们的左右奇异向量的意义产生变化，但是不会影响我们计算的过程）。比如说T1这个title中就有guide、investing、market、stock四个词，各出现了一次，我们将这个矩阵进行SVD，得到下面的矩阵：<br><img src="http://omu7tit09.bkt.clouddn.com/14992369530915.png" alt=""><br>左奇异向量表示词的一些特性，右奇异向量表示文档的一些特性，中间的奇异值矩阵表示左奇异向量的一行与右奇异向量的一列的重要程序，数字越大越重要。</p><p>继续看这个矩阵还可以发现一些有意思的东西，首先，左奇异向量的第一列表示每一个词的出现频繁程度，虽然不是线性的，但是可以认为是一个大概的描述，比如book是0.15对应文档中出现的2次，investing是0.74对应了文档中出现了9次，rich是0.36对应文档中出现了3次；</p><p>其次，右奇异向量中一的第一行表示每一篇文档中的出现词的个数的近似，比如说，T6是0.49，出现了5个词，T2是0.22，出现了2个词。</p><p>然后我们反过头来看，我们可以将左奇异向量和右奇异向量都取后2维（之前是3维的矩阵），投影到一个平面上，可以得到：<br><img src="http://omu7tit09.bkt.clouddn.com/14992372618471.png" alt=""></p><p>在图上，每一个红色的点，都表示一个词，每一个蓝色的点，都表示一篇文档，这样我们可以对这些词和文档进行聚类，比如说stock 和 market可以放在一类，因为他们老是出现在一起，real和estate可以放在一类，dads，guide这种词就看起来有点孤立了，我们就不对他们进行合并了。按这样聚类出现的效果，可以提取文档集合中的近义词，这样当用户检索文档的时候，是用语义级别（近义词集合）去检索了，而不是之前的词的级别。这样一减少我们的检索、存储量，因为这样压缩的文档集合和PCA是异曲同工的，二可以提高我们的用户体验，用户输入一个词，我们可以在这个词的近义词的集合中去找，这是传统的索引无法做到的。</p><h3 id="3-6-主成分分析"><a href="#3-6-主成分分析" class="headerlink" title="3.6 主成分分析"></a>3.6 主成分分析</h3><p>PCA的问题其实是一个基的变换，使得变换后的数据有着最大的方差。方差的大小描述的是一个变量的信息量，我们在讲一个东西的稳定性的时候，往往说要减小方差，如果一个模型的方差很大，那就说明模型不稳定了。但是对于我们用于机器学习的数据（主要是训练数据），方差大才有意义，不然输入的数据都是同一个点，那方差就为0了，这样输入的多个数据就等同于一个数据了。以下面这张图为例子：<br><img src="http://omu7tit09.bkt.clouddn.com/14992353583255.png" alt=""></p><p>这个假设是一个摄像机采集一个物体运动得到的图片，上面的点表示物体运动的位置，假如我们想要用一条直线去拟合这些点，那我们会选择什么方向的线呢？当然是图上标有signal的那条线。如果我们把这些点单纯的投影到x轴或者y轴上，最后在x轴与y轴上得到的方差是相似的（因为这些点的趋势是在45度左右的方向，所以投影到x轴或者y轴上都是类似的），如果我们使用原来的xy坐标系去看这些点，容易看不出来这些点真正的方向是什么。但是如果我们进行坐标系的变化，横轴变成了signal的方向，纵轴变成了noise的方向，则就很容易发现什么方向的方差大，什么方向的方差小了。</p><p>一般来说，方差大的方向是信号的方向，方差小的方向是噪声的方向，我们在数据挖掘中或者数字信号处理中，往往要提高信号与噪声的比例，也就是信噪比。对上图来说，如果我们只保留signal方向的数据，也可以对原数据进行不错的近似了。</p><p> PCA的全部工作简单点说，就是对原始的空间中顺序地找一组相互正交的坐标轴，第一个轴是使得方差最大的，第二个轴是在与第一个轴正交的平面中使得方差最大的，第三个轴是在与第1、2个轴正交的平面中方差最大的，这样假设在N维空间中，我们可以找到N个这样的坐标轴，我们取前r个去近似这个空间，这样就从一个N维的空间压缩到r维的空间了，但是我们选择的r个坐标轴能够使得空间的压缩使得数据的损失最小。</p><p> 还是假设我们矩阵每一行表示一个样本，每一列表示一个feature，用矩阵的语言来表示，将一个m * n的矩阵A的进行坐标轴的变化，P就是一个变换的矩阵从一个N维的空间变换到另一个N维的空间，在空间中就会进行一些类似于旋转、拉伸的变化。</p><script type="math/tex; mode=display">A_{m\times n}P_{n\times n}=\tilde{A}_{m\times n}</script><p>而将一个$m\times n$的矩阵$A$变换成一个$m\times r$的矩阵，这样就会使本来有$n$个feature的，变成了有$r$个feature了（r&lt;n），这r个其实就是对n个feature的一种提炼，我们就把这个称为feature的压缩。用数学语言表示就是：</p><script type="math/tex; mode=display">A_{m\times n}P_{n\times r}=\tilde{A}_{m\times r}</script><p>但是这个和SCD扯上关系的呢？之前谈到，SVD得出的奇异向量也是从奇异值由大到小排列的，按照PCA的观点来看，就是方差最大的坐标轴就是第一个奇异向量，方差次大的坐标轴就是第二个奇异向量。之前得到的SVD式子如下：</p><script type="math/tex; mode=display">A_{m\times n}≈ U_{m\times r} \Sigma_{r\times r}V^T_{r\times n}</script><p>在矩阵的两边同时乘上一个矩阵$V$，由于$V$是一个正交的矩阵，所以转置乘以$V$得到单位阵$I$，所以可以化成后面的式子：</p><script type="math/tex; mode=display">A_{m\times n}V_{r\times n}≈ U_{m\times r} \Sigma_{r\times r}V^T_{r\times n}V_{r\times n}=U_{m\times r} \Sigma_{r\times r}</script><p>将后面的式子与$A\times P $那个$m\times n$矩阵变换为$m\times r$的矩阵的式子对照看看，在这里，其实$V$就是$P$，也就是一个变化的向量。这里将一个$m\times n$的矩阵压缩到一个$m \ times r$的矩阵，也就是对列进行压缩。</p><p>如果我们想对行进行压缩（在PCA的观点下，对行进行业所可以理解为，讲一些相似的sample合并在一起，或者将一些没有太大价值的sample去掉），同样我们写出一个通用的行压缩例子：</p><script type="math/tex; mode=display">P_{r\times m}A_{m\times n}=\tilde{A}_{r\times n}</script><p>这样从一个$m$行的矩阵压缩到一个$r$行的矩阵了，对SVD来说也是一样的，我们对SVD分解的式子两边乘以一个转置$U$得到：</p><script type="math/tex; mode=display">U^T_{r\times m}A_{m\times n}≈ U^T_{r\times m}U_{m\times r} \Sigma_{r\times r}V^T_{r\times n}= \Sigma_{r\times r}V^T_{r\times n}</script><p> 这样我们就得到了对行进行压缩的式子。可以看出，其实PCA几乎可以说是对SVD的一个包装，如果我们实现了SVD，那也就实现了PCA了，而且更好的地方是，有了SVD，我们就可以得到两个方向的PCA，如果我们对A’A进行特征值的分解，只能得到一个方向的PCA。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h2&gt;&lt;p&gt;SVD实际上是数学专业内容，但它现在已经深入到不同的领域中。SVD的过程不是很好理解，因为它不够直观，但它对矩阵分解的效果却非常好。比如，Netflix（一个提供在线电影租赁的公司）曾经就悬赏100万美金，如果谁能提高他的电影推荐系统评分预测率10%的话。令人惊讶的是，这个目标充满了挑战，来自世界各地的团队运用了各种不同的技术。最终的获胜队伍“BellKor’s Pragmatic Chaos”采用的核心算法就是基于SVD。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="SVD" scheme="http://yoursite.com/tags/SVD/"/>
    
  </entry>
  
  <entry>
    <title>笑忘录（8）：茶卡盐湖-青海湖之行</title>
    <link href="http://yoursite.com/2017/06/26/%E7%AC%91%E5%BF%98%E5%BD%95%EF%BC%888%EF%BC%89%EF%BC%9A%E8%8C%B6%E5%8D%A1%E7%9B%90%E6%B9%96-%E9%9D%92%E6%B5%B7%E6%B9%96%E4%B9%8B%E8%A1%8C/"/>
    <id>http://yoursite.com/2017/06/26/笑忘录（8）：茶卡盐湖-青海湖之行/</id>
    <published>2017-06-26T15:14:45.000Z</published>
    <updated>2017-12-26T06:42:40.922Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是第一次去西北。</p></blockquote><a id="more"></a><p><img src="http://orsw4brg1.bkt.clouddn.com/FullSizeRender%202.jpg" alt="FullSizeRender 2"> </p><blockquote><p>四天的行程，印象最深还是它的天，干净到不忍心去增添一点点其余的色彩，生怕破坏了它原本的样子。</p></blockquote><p><img src="http://orsw4brg1.bkt.clouddn.com/FullSizeRender%204.jpg" alt="FullSizeRender 4"></p><blockquote><p>这个废旧的火车头安详地躺在轨道上，依傍着茶卡盐湖，携带着机械复制时代内燃机车独有的刚毅在湖畔守候着，迎接着这个世纪的人，等待他们挥扬双手、露出笑容和它留下一张张合影。</p></blockquote><p><img src="http://orsw4brg1.bkt.clouddn.com/FullSizeRender%207.jpg" alt="FullSizeRender 7"></p><blockquote><p>置身这片广袤的土地，被它的空气包裹，只想安静地闭上眼睛，感受这个神奇世界的馈赠。</p></blockquote><p><img src="http://orsw4brg1.bkt.clouddn.com/IMG_3747.JPG" alt="IMG_3747"></p><blockquote><p>火车头底下铺着五十多米长的铁轨、垫着被岁月勾兑地五黑而厚重的木枕木，枕木中间均匀散落茶卡盐湖的结晶盐，像一道白色的光，顺着火车头，向后延展。</p></blockquote><p><img src="http://orsw4brg1.bkt.clouddn.com/IMG_2012.JPG" alt="IMG_2012"></p><blockquote><p>依旧是火车头，衣服的搭配和它看起来很契合，便在此处快门了好几十次。多么想把这轨道揉进苍茫的大地，它横在那里，丝毫没有感受到来自东方神域的呼喊，反而与四处来的人打成了一片。</p></blockquote><p><img src="http://orsw4brg1.bkt.clouddn.com/IMG_3751.JPG" alt="IMG_3751"></p><p><img src="http://orsw4brg1.bkt.clouddn.com/%E5%A4%A9%E7%A9%BA%E4%B9%8B%E9%95%9C%C2%B7%E9%93%81%E7%9A%AE%E8%BD%A6.jpg" alt="天空之镜·铁皮车"></p><p><img src="http://orsw4brg1.bkt.clouddn.com/%E5%A4%A9%E7%A9%BA%E4%B9%8B%E9%95%9C%C2%B7%E7%AC%91%E9%9D%A5.jpg" alt="天空之镜·笑靥"></p><p><img src="http://orsw4brg1.bkt.clouddn.com/%E5%A4%A9%E7%A9%BA%E4%B9%8B%E9%95%9C%C2%B7%E5%BA%9F%E7%81%AB%E8%BD%A6.jpg" alt="天空之镜·废火车"></p><p><img src="http://orsw4brg1.bkt.clouddn.com/FullSizeRender.jpg" alt="FullSizeRende"></p><blockquote><p>那天风很疾，打在脸上，来不及躲闪。<br>坐在长凳子上，望着远处的山，它们似乎离自己很近，仅有的修饰就是顶上的那层雪，它不懂得如何变得招人喜欢，大自然给予它什么，它就接受什么样的。<br>我需要你冷静的表情。</p></blockquote><p><img src="http://orsw4brg1.bkt.clouddn.com/%E5%A4%A9%E7%A9%BA%E4%B9%8B%E9%95%9C%C2%B7%E6%B8%AF%E5%B2%9B%E5%A6%B9%E5%A6%B9.jpg" alt="天空之镜·港岛妹妹"></p><p><img src="http://omu7tit09.bkt.clouddn.com/FullSizeRender 5.jpg" alt="FullSizeRender 5"></p><blockquote><p>云层慢慢变厚了</p></blockquote><p><img src="http://orsw4brg1.bkt.clouddn.com/%E5%A4%A9%E7%A9%BA%E4%B9%8B%E9%95%9C%C2%B7%E5%90%AC%E4%BA%91.jpg" alt="天空之镜·听云"></p><blockquote><p>春天是什么样子的？</p></blockquote><p><img src="http://orsw4brg1.bkt.clouddn.com/IMG_3396.jpg" alt="IMG_3396"></p><blockquote><p>丹霞地貌，它的土是暗红色的。</p></blockquote><p><img src="http://orsw4brg1.bkt.clouddn.com/IMG_3992.jpg" alt="IMG_3992"><br><img src="http://omu7tit09.bkt.clouddn.com/IMG_1906.JPG" alt="IMG_1906"></p><blockquote><p>阳光洒下来，透过你，穿过镜头，直抵我眼眶</p></blockquote><p><img src="http://omu7tit09.bkt.clouddn.com/IMG_3660.JPG" alt="IMG_3660"></p><blockquote><p>一大波风景照向你袭来</p></blockquote><p><img src="http://omu7tit09.bkt.clouddn.com/IMG_3493.JPG" alt="IMG_3493"></p><p><img src="http://omu7tit09.bkt.clouddn.com/IMG_4047.JPG" alt="IMG_4047"><br><img src="http://omu7tit09.bkt.clouddn.com/IMG_4052.JPG" alt="IMG_4052"><br><img src="http://omu7tit09.bkt.clouddn.com/IMG_3965.JPG" alt="IMG_3965"></p><p><img src="http://omu7tit09.bkt.clouddn.com/IMG_1877.JPG" alt="IMG_1877"><br><img src="http://omu7tit09.bkt.clouddn.com/IMG_3943.JPG" alt="IMG_3943"></p><p><img src="http://omu7tit09.bkt.clouddn.com/IMG_3484.JPG" alt="IMG_3484"><br><img src="http://omu7tit09.bkt.clouddn.com/IMG_3464.JPG" alt="IMG_3464"><br><img src="http://omu7tit09.bkt.clouddn.com/IMG_1835.JPG" alt="IMG_1835"></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=484732973&auto=1&height=66"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这是第一次去西北。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="笑忘录" scheme="http://yoursite.com/categories/%E7%AC%91%E5%BF%98%E5%BD%95/"/>
    
    
      <category term="茶卡盐湖" scheme="http://yoursite.com/tags/%E8%8C%B6%E5%8D%A1%E7%9B%90%E6%B9%96/"/>
    
      <category term="青海湖" scheme="http://yoursite.com/tags/%E9%9D%92%E6%B5%B7%E6%B9%96/"/>
    
  </entry>
  
  <entry>
    <title>机器学习算法系列（20）：机器学习模型优化四要素</title>
    <link href="http://yoursite.com/2017/06/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%8820%EF%BC%89%EF%BC%9A%E9%A1%B9%E7%9B%AE%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8C%96%E5%9B%9B%E8%A6%81%E7%B4%A0/"/>
    <id>http://yoursite.com/2017/06/16/机器学习算法系列（20）：项目模型优化四要素/</id>
    <published>2017-06-16T15:14:45.000Z</published>
    <updated>2017-12-26T08:03:31.715Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自<a href="http://tech.meituan.com/machine-learning-model-optimization.html" target="_blank" rel="noopener">美团点评技术团队博客</a>，该文以业界视角介绍了机器学习如何发挥其实际价值。作者胡淏，目前是美团算法工程师，毕业于哥伦比亚大学。先后在携程、支付宝、美团从事算法开发工作。了解风控、基因、旅游、即时物流相关问题的行业领先算法方案与流程。</p><a id="more"></a><h2 id="一、机器学习工程师的知识图谱"><a href="#一、机器学习工程师的知识图谱" class="headerlink" title="一、机器学习工程师的知识图谱"></a>一、机器学习工程师的知识图谱</h2><p><img src="http://orsw4brg1.bkt.clouddn.com/image_1bgvc1hi3led5tl1hb0n1i1hhm9.png" alt="image_1bgvc1hi3led5tl1hb0n1i1hh"><br>图1 机器学习工程师的知识图谱</p><p>上图列出了我认为一个成功的机器学习工程师需要关注和积累的点。机器学习实践中，我们平时都在积累自己的“弹药库”：分类、回归、无监督模型、Kaggle上特征变换的黑魔法、样本失衡的处理办法、缺失值填充……这些大概可以归类成模型和特征两个点。我们需要参考成熟的做法、论文，并自己实现，此外还需要多反思自己方法上是否还可以改进。如果模型和特征这俩个点都已经做的很好了，你就拥有了一张绿卡，能跨过在数据相关行业发挥模型技术价值的准入门槛。</p><p>在这个时候，比较关键的一步，就是搞笑的技术变现能力。</p><p>所谓高效，就是解决业务核心问题的专业能力。本文将描述这些专业能力，也就是模型优化的四个要素：模型、数据、特征、业务，还有更重要的，就是他们在模型项目中的优先级。</p><h2 id="二、模型项目推进的四要素"><a href="#二、模型项目推进的四要素" class="headerlink" title="二、模型项目推进的四要素"></a>二、模型项目推进的四要素</h2><p>项目推进过程中，四个要素相互之间的优先级大致是：业务&gt;特征&gt;数据&gt;模型。<br><img src="http://orsw4brg1.bkt.clouddn.com/image_1bgvc94uuh0c1o0sj9d1urb19d2m.png" alt="image_1bgvc94uuh0c1o0sj9d1urb19d2"><br>图2 四要素解决问题细分+优先级</p><h3 id="2-1-业务"><a href="#2-1-业务" class="headerlink" title="2.1 业务"></a>2.1 业务</h3><p>一个模型项目有好的技术选型、完备的特征体系、高质量的数据一定是很加分的，不过真正决定项目好与坏还有一个大前提，就是在这个项目的技术目标是否在解决当下核心业务问题。</p><p>业务问题包含两个方面：业务KPI和Deadline。举个例子，业务问题在两周之内降低目前手机丢失带来的支付宝销赃风险。这时如果你的方案是研发手机丢失的核心特征，比如改密是否合理，基本上就死的很惨，因为两周根本完不成，改密合理性也未必是模型优化好的切入点；反之，如果你的方案是和运营同学看bad case，梳理现阶段的作案通用手段，并通过分析上线一个简单模型或者业务规则的补丁，就明智很多。如果上线之后，案件量真掉下来了，就算你的方案准确率很糟糕、方法很low，但你解决了业务问题，这才是最重要的。</p><p>虽然业务目标很关键，不过一般讲，业务运营同学真的不太懂得如何和技术有效的沟通业务目标，比如：</p><ul><li>我们想做一个线下门店风险评级的项目，希望运营通过反作弊模型角度帮我们给门店打个分，这个分数包含的问题有：风险是怎么定义的、为什么要做风险评级、更大的业务目标是什么、怎么排期的、这个风险和我们反作弊模型之间的腋窝你是怎么看的？</li><li>做一个区域未来10min的配送时间预估模型。我们想通过运营的模型衡量在恶劣天气的时候每个区域的运力是否被击穿（业务现状和排期？运力被击穿可以扫下盲吗？运力击穿和配送时间之间是个什么业务逻辑、时间预估是刻画运力紧张度的最有效手段么？业务的关键场景是恶劣天气的话，我们仅仅训练恶劣天气场景的时间预估模型是否就好了？）</li></ul><p>为了保证整个技术项目没有做偏，项目一开始一定要和业务聊清楚三件事情：</p><ul><li><p><strong>业务核心问题、关键场景是什么。</strong></p></li><li><p><strong>如何评估该项目的成功，指标是什么。</strong></p></li><li><p><strong>通过项目输出什么关键信息给到业务，业务如何运营这个信息从而达到业务目标。</strong></p></li></ul><p>项目过程中，也要时刻回到业务，检查项目的健康度。</p><h3 id="2-2-数据与特征"><a href="#2-2-数据与特征" class="headerlink" title="2.2 数据与特征"></a>2.2 数据与特征</h3><p>要说正确的业务理解和切入，在为技术项目保驾护航，数据、特征便是一个模型项目性能方面的天花板。garbage in， garbage out 就在说这个问题。</p><p>这两天有位听众微信问我一个很难回答的问题，大概意思是，数据是特征拼起来构成的集合嘛，所以这不是两个要素。从逻辑上面讲，数据的确是一列一列的特征，不过数据与特征在概念层面是不同的：数据是已经采集的信息，特征是以兼容模型、最优化为目标对数据进行加工。就比如通过word2vec将非结构化数据结构化，就是将数据转化为特征的过程。</p><p>所以，我更认为特征工程是基于数据的一个非常精细、刻意的加工过程。从传统的特征转换、交互，到embedding、word2vec、高维分类变量数值化，最终目的都是更好的去利用现有的数据。之前有聊到的将推荐算法引入有监督学习模型优化中的做法，就是在把两个本不可用的高维ID类变量变成可用的数值变量。</p><p>观察到自己和童鞋们在特征工程中会遇到一些普遍问题，比如，特征设计不全面，没有耐心把现有特征做得细致……也整理出来一套方法论，仅供参考：</p><p><img src="http://orsw4brg1.bkt.clouddn.com/image_1bgvcqct213oq6ingm1v1c1eti13.png" alt="image_1bgvcqct213oq6ingm1v1c1eti13"><br>图3 变量体系、研发流程</p><p>在特征设计的时候，有两个点可以帮助我们把特征想的更全面：</p><ul><li><p><strong>现有的基础数据</strong></p></li><li><p><strong>业务“二维图”</strong></p></li></ul><p>这两个方面的整合，就是一个变量的体系。变量（特征），从技术层面是加工数据，而从业务层面实际在反应RD的业务理解和数据刻画业务能力。“二维图”，实际上未必是二维的，更重要的是我们需要把业务整个流程抽象成几个核心的维度，举几个例子：</p><p>这两个方面的整合，就是一个变量的体系。变量（特征），从技术层面是加工数据，而从业务层面实际在反应RD的业务理解和数据刻画业务能力。“二维图”，实际上未必是二维的，更重要的是我们需要把业务整个流程抽象成几个核心的维度，举几个例子：</p><p>外卖配送时间业务（维度甲：配送的环节，骑手到点、商家出餐、骑手配送、交付用户；维度乙：颗粒度，订单粒度、商家粒度、区域城市粒度；维度丙：配送类型，众包、自营……）。</p><p>反作弊变量体系（维度甲：作弊环节，登录、注册、实名、转账、交易、参与营销活动、改密……；维度乙：作弊介质，账户、设备、IP、WiFi、银行卡……）。</p><p>通过这些维度，你就可以展开一个“二维图”，把现有你可以想到的特征填上去，你一定会发现很多空白，比如下图，那么哪里还是特征设计的盲点就一目了然：</p><p><img src="http://orsw4brg1.bkt.clouddn.com/image_1bgvcvkkqo0q1kgt15qjdv54jm1g.png" alt="image_1bgvcvkkqo0q1kgt15qjdv54jm1g"><br>图4 账户维度在转账、红包方面的特征很少；没有考虑WiFi这个媒介；客满与事件数据没考虑</p><p>数据和特征决定了模型性能的天花板。deep learning当下在图像、语音、机器翻译、自动驾驶等领域非常火，但是 deep learning在生物信息、基因学这个领域就不是热词：这背后是因为在前者，我们已经知道数据从哪里来，怎么采集，这些数据带来的信息基本满足了模型做非常准确的识别；而后者，即便有了上亿个人体碱基构成的基因编码，技术选型还是不能长驱直入——超高的数据采集成本，人后天的行为数据的获取壁垒等一系列的问题，注定当下这个阶段在生物信息领域，人工智能能发出的声音很微弱，更大的舞台留给了生物学、临床医学、统计学。</p><h3 id="2-3-模型"><a href="#2-3-模型" class="headerlink" title="2.3 模型"></a>2.3 模型</h3><p><img src="http://orsw4brg1.bkt.clouddn.com/image_1bgvd7gs41k9e1g0s1d016dmdq1t.png" alt="image_1bgvd7gs41k9e1g0s1d016dmdq1t"><br>图5 满房开房的技术选型、特征工程roadmap</p><p>模型这件事儿，许多时候追求的不仅仅是准确率，通常还有业务这一层更大的约束。如果你在做一些需要强业务可解释的模型，比如定价和反作弊，那实在没必要上一个黑箱模型来为难业务。这时候，统计学习模型就很有用。</p><p>这种情况下，比拼性能的话，我觉得下面这个不等式通常成立：<code>Glmnet&gt;LASSO&gt;=Ridge&gt;LR/Logistic</code>。相比最基本的LR/Logistic，ridge通过正则化约束缓解了LR在过拟合方面的问题，lasso更是通过L1约束做类似变量选择的工作。</p><p>不过两个算法的痛点是很难决定最优的约束强度，Glmnet是Stanford给出的一套非常高效的解决方案。所以目前，我认为线性结构的模型，Glmnet的痛点是最少的，而且在R、Python、Spark上面都开源了。</p><p>如果我们开发复杂模型，通常成立第二个不等式 <code>RF（Random Forest，随机森林）&lt;= GBDT &lt;= XGBoost</code> 。拿数据说话，29个Kaggle公开的winner solution里面，17个使用了类似GBDT这样的Boosting框架，其次是 DNN（Deep Neural Network，深度神经网络），RF的做法在Kaggle里面非常少见。</p><p>RF和GBDT两个算法的雏形是CART（Classification And Regression Trees），由L Breiman和J Friedman两位作者在1984年合作推出。但是在90年代在发展模型集成思想the ensemble的时候，两位作者代表着两个至今也很主流的派系：stacking/ Bagging &amp; Boosting。</p><p>一种是把相互独立的CART（randomized variables，bootstrap samples）水平铺开，一种是深耕的Boosting，在拟合完整体后更有在局部长尾精细刻画的能力。同时，GBDT模型相比RF更加简单，内存占用小，这都是业界喜欢的性质。XGBoost在模型的轻量化和快速训练上又做了进一步的工作，也是目前我们比较喜欢尝试的模型。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自&lt;a href=&quot;http://tech.meituan.com/machine-learning-model-optimization.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;美团点评技术团队博客&lt;/a&gt;，该文以业界视角介绍了机器学习如何发挥其实际价值。作者胡淏，目前是美团算法工程师，毕业于哥伦比亚大学。先后在携程、支付宝、美团从事算法开发工作。了解风控、基因、旅游、即时物流相关问题的行业领先算法方案与流程。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="业务" scheme="http://yoursite.com/tags/%E4%B8%9A%E5%8A%A1/"/>
    
      <category term="特征" scheme="http://yoursite.com/tags/%E7%89%B9%E5%BE%81/"/>
    
      <category term="数据" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE/"/>
    
      <category term="模型" scheme="http://yoursite.com/tags/%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>kaggle系列（4）：Rental Listing Inquiries（三）：XGBoost调参指南</title>
    <link href="http://yoursite.com/2017/06/14/kaggle%E7%B3%BB%E5%88%97%EF%BC%884%EF%BC%89%EF%BC%9ARental%20Listing%20Inquiries%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AXGBoost%E8%B0%83%E5%8F%82%E7%BB%8F%E9%AA%8C/"/>
    <id>http://yoursite.com/2017/06/14/kaggle系列（4）：Rental Listing Inquiries（三）：XGBoost调参经验/</id>
    <published>2017-06-14T15:14:45.000Z</published>
    <updated>2017-12-26T06:39:24.949Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章翻译自<a href="https://www.analyticsvidhya.com/blog/2016/03/complete-guide-parameter-tuning-xgboost-with-codes-python/" target="_blank" rel="noopener">Complete Guide to Parameter Tuning in XGBoost (with codes in Python)</a>，它详细介绍了XGBoost中参数的含义，然后在一个实例中对参数调整进行了实验。</p><a id="more"></a><h2 id="一、Introduction"><a href="#一、Introduction" class="headerlink" title="一、Introduction"></a>一、Introduction</h2><p>如果你的预测模型效果不怎么好，使用XGBoost吧。XGBoost已经成为许多数据科学家的终极武器了！这是一个内部实现高度复杂的算法，在处理各种不规范的数据时有足够强大的表现。</p><p>利用XGBoost建立模型很简单，但是因为它使用了很多参数，以致使用XGBoost来提升预测效果比较有难度。为提高模型的预测能力，调参是必须要做的一步。但仍然有很多现实的挑战——哪些参数是我们需要调整的？每个参数的最佳值又应该是多少呢？</p><p>这篇文章最适合刚刚接触XGBoost的人，在这篇文章中，我们将会介绍一些XGBoost相关的知识，同时了解一些XGBoost参数调整技艺。最后使用Python对一个数据集实践XGBoost。</p><h2 id="二、What-should-you-know"><a href="#二、What-should-you-know" class="headerlink" title="二、What should you know ?"></a>二、What should you know ?</h2><p>XGBoost(eXtreme Gradient Boosting)是Gradient Boosting算法的一个优化的版本。因为我在前一篇文章，<a href="https://www.analyticsvidhya.com/blog/2016/02/complete-guide-parameter-tuning-gradient-boosting-gbm-python/" target="_blank" rel="noopener">基于Python的Gradient Boosting算法参数调整完全指南</a>，里面已经涵盖了Gradient Boosting算法的很多细节了。我强烈建议大家在读本篇文章之前，把那篇文章好好读一遍。它会帮助你对Boosting算法有一个宏观的理解，同时也会对GBM的参数调整有更好的体会。</p><p>特别鸣谢：我个人十分感谢Mr Sudalai Rajkumar (aka SRK)大神的支持，目前他在AV Rank中位列第二。如果没有他的帮助，就没有这篇文章。在他的帮助下，我们才能给无数的数据科学家指点迷津。给他一个大大的赞！</p><h2 id="三、Table-of-Contents"><a href="#三、Table-of-Contents" class="headerlink" title="三、Table of Contents"></a>三、Table of Contents</h2><h3 id="3-1-The-XGBoost-Advantage"><a href="#3-1-The-XGBoost-Advantage" class="headerlink" title="3.1 The XGBoost Advantage"></a>3.1 The XGBoost Advantage</h3><p>XGBoost算法可以给预测模型带来能力的提升。当我对它的表现有更多了解的时候，当我对它的高准确率背后的原理有更多了解的时候，我发现它具有很多优势：</p><ul><li><p>正则化<br>标准GBM的实现没有像XGBoost这样的正则化步骤。正则化对减少过拟合也是有帮助的。实际上，XGBoost以“正则化提升(regularized boosting)”技术而闻名。</p></li><li><p>并行处理<br>不过，众所周知，Boosting算法是顺序处理的，它怎么可能并行呢？每一课树的构造都依赖于前一棵树，那具体是什么让我们能用多核处理器去构造一个树呢？我希望你理解了这句话的意思。如果你希望了解更多，点击这个链接。<br>XGBoost 也支持Hadoop实现。</p></li><li><p>高度的灵活性<br>XGBoost 允许用户定义自定义优化目标和评价标准<br>它对模型增加了一个全新的维度，所以我们的处理不会受到任何限制。</p></li><li><p>缺失值处理<br>XGBoost内置处理缺失值的规则。用户需要提供一个和其它样本不同的值，然后把它作为一个参数传进去，以此来作为缺失值的取值。XGBoost在不同节点遇到缺失值时采用不同的处理方法，并且会学习未来遇到缺失值时的处理方法。</p></li><li><p>剪枝<br>当分裂时遇到一个负损失时，GBM会停止分裂。因此GBM实际上是一个贪心算法。<br>XGBoost会一直分裂到指定的最大深度(max_depth)，然后回过头来剪枝。如果某个节点之后不再有正值，它会去除这个分裂。<br>这种做法的优点，当一个负损失（如-2）后面有个正损失（如+10）的时候，就显现出来了。GBM会在-2处停下来，因为它遇到了一个负值。但是XGBoost会继续分裂，然后发现这两个分裂综合起来会得到+8，因此会保留这两个分裂。</p></li><li><p>内置交叉验证<br>XGBoost允许在每一轮boosting迭代中使用交叉验证。因此，可以方便地获得最优boosting迭代次数。而GBM使用网格搜索，只能检测有限个值。</p></li><li><p>在已有的模型基础上继续<br>XGBoost可以在上一轮的结果上继续训练。这个特性在某些特定的应用上是一个巨大的优势。<br>sklearn中的GBM的实现也有这个功能，两种算法在这一点上是一致的。</p></li></ul><p>相信你已经对XGBoost强大的功能有了点概念。注意这是我自己总结出来的几点，你如果有更多的想法，尽管在下面评论指出，我会更新这个列表的！<br>你的胃口被我吊起来了吗？棒棒哒！如果你想更深入了解相关信息，可以参考下面这些文章：</p><p><a href="http://xgboost.readthedocs.io/en/latest/model.html" target="_blank" rel="noopener">XGBoost Guide - Introduce to Boosted Trees </a></p><p><a href="https://www.youtube.com/watch?v=X47SGnTMZIU" target="_blank" rel="noopener">Words from the Auther of XGBoost </a></p><h3 id="3-2-Understanding-XGBoost-Parameters"><a href="#3-2-Understanding-XGBoost-Parameters" class="headerlink" title="3.2 Understanding XGBoost Parameters"></a>3.2 Understanding XGBoost Parameters</h3><p>XGBoost的作者把所有参数分成了三类：</p><ul><li>通用参数：宏观函数控制。</li><li>Booster参数：控制每一步的Booster（tree/regression）</li><li>学习目标参数：控制训练目标的表现</li></ul><p>在这里我会类比GBM来讲解，所以作为一种基础知识，强烈推荐先阅读<a href="https://www.analyticsvidhya.com/blog/2016/02/complete-guide-parameter-tuning-gradient-boosting-gbm-python/" target="_blank" rel="noopener">这篇文章</a>。</p><h4 id="3-2-1-通用参数（General-Parameters）"><a href="#3-2-1-通用参数（General-Parameters）" class="headerlink" title="3.2.1 通用参数（General Parameters）"></a>3.2.1 通用参数（General Parameters）</h4><p>这些参数用来控制XGBoost的宏观功能。</p><ul><li><p><strong>booster[默认gbtree]</strong>：选择每次迭代的模型，有两种选择： </p><ul><li>gbtree：基于树的模型 </li><li>gbliner：线性模型</li></ul></li><li><p><strong>silent[默认0]</strong>：</p><ul><li>当这个参数值为1时，静默模式开启，不会输出任何信息。一般这个参数就保持默认的0，因为这样能帮我们更好地理解模型。</li></ul></li><li><p><strong>nthread[默认值为最大可能的线程数]</strong>：</p><ul><li>这个参数用来进行多线程控制，应当输入系统的核数。如果你希望使用CPU全部的核，那就不要输入这个参数，算法会自动检测它。</li></ul></li></ul><p>还有两个参数，XGBoost会自动设置，目前你不用管它。接下来咱们一起看booster参数。</p><h4 id="3-2-2-Booster参数（Booster-Parameters）"><a href="#3-2-2-Booster参数（Booster-Parameters）" class="headerlink" title="3.2.2 Booster参数（Booster Parameters）"></a>3.2.2 Booster参数（Booster Parameters）</h4><p>尽管有两种booster可供选择，我这里只介绍tree booster，因为它的表现远远胜过linear booster，所以linear booster很少用到。</p><ul><li><p><strong>eta[默认0.3]：</strong></p><ul><li>和GBM中的 learning rate 参数类似。通过减少每一步的权重，可以提高模型的鲁棒性。典型值为0.01-0.2。</li></ul></li><li><p><strong>min_child_weight[默认1]</strong>：</p><ul><li>决定最小叶子节点样本权重和。和GBM的min_child_leaf 参数类似，但不完全一样。XGBoost的这个参数是最小样本权重的和，而GBM参数是最小样本总数。这个参数用于避免过拟合。当它的值较大时，可以避免模型学习到局部的特殊样本。但是如果这个值过高，会导致欠拟合。这个参数需要使用CV来调整。</li></ul></li><li><p><strong>max_depth[默认6]：</strong></p><ul><li>和GBM中的参数相同，这个值为树的最大深度。这个值也是用来避免过拟合的。max_depth越大，模型会学到更具体更局部的样本。需要使用CV函数来进行调优。典型值：3-10</li></ul></li><li><p><strong>max_leaf_nodes：</strong></p><ul><li>树上最大的节点或叶子的数量。可以替代max_depth的作用。因为如果生成的是二叉树，一个深度为n的树最多生成 $n^2$ 个叶子。如果定义了这个参数，GBM会忽略max_depth参数。</li></ul></li><li><p><strong>gamma[默认0]：</strong></p><ul><li>在节点分裂时，只有分裂后损失函数的值下降了，才会分裂这个节点。Gamma指定了节点分裂所需的最小损失函数下降值。这个参数的值越大，算法越保守。这个参数的值和损失函数息息相关，所以是需要调整的。</li></ul></li><li><p><strong>max_delta_step[默认0]：</strong></p><ul><li>这参数限制每棵树权重改变的最大步长。如果这个参数的值为0，那就意味着没有约束。如果它被赋予了某个正值，那么它会让这个算法更加保守。</li><li>通常，这个参数不需要设置。但是当各类别的样本十分不平衡时，它对逻辑回归是很有帮助的。</li><li>这个参数一般用不到，但是你可以挖掘出来它更多的用处。</li></ul></li><li><p><strong>subsample[默认1]：</strong></p><ul><li>和GBM中的subsample参数一模一样。这个参数控制对于每棵树，随机采样的比例。减小这个参数的值，算法会更加保守，避免过拟合。但是，如果这个值设置得过小，它可能会导致欠拟合。典型值：0.5-1。</li></ul></li><li><p><strong>colsample_bytree[默认1]：</strong></p><ul><li>和GBM里面的max_features参数类似。用来控制每棵随机采样的列数的占比(每一列是一个特征)。典型值：0.5-1</li></ul></li><li><p><strong>colsample_bylevel[默认1]：</strong></p><ul><li>用来控制树的每一级的每一次分裂，对列数的采样的占比。我个人一般不太用这个参数，因为subsample参数和colsample_bytree参数可以起到相同的作用。但是如果感兴趣，可以挖掘这个参数更多的用处。</li></ul></li><li><p><strong>lambda[默认1]</strong></p><ul><li>权重的L2正则化项。(和Ridge regression类似)。这个参数是用来控制XGBoost的正则化部分的。虽然大部分数据科学家很少用到这个参数，但是这个参数在减少过拟合上还是可以挖掘出更多用处的。</li></ul></li><li><p><strong>alpha[默认1]：</strong></p><ul><li>权重的L1正则化项。(和Lasso regression类似)。可以应用在很高维度的情况下，使得算法的速度更快。</li></ul></li><li><p><strong>scale_pos_weight[默认1]：</strong></p><ul><li>在各类别样本十分不平衡时，把这个参数设定为一个正值，可以使算法更快收敛。</li></ul></li></ul><h4 id="3-2-3-学习目标参数"><a href="#3-2-3-学习目标参数" class="headerlink" title="3.2.3 学习目标参数"></a>3.2.3 学习目标参数</h4><p>这个参数用来控制理想的优化目标和每一步结果的度量方法。</p><ul><li><strong>objective[默认reg:linear]：</strong>这个参数定义需要被最小化的损失函数。最常用的值有： <ul><li>binary:logistic 二分类的逻辑回归，返回预测的概率(不是类别)。</li><li>multi:softmax 使用softmax的多分类器，返回预测的类别(不是概率)。在这种情况下，你还需要多设一个参数：num_class(类别数目)。</li><li>multi:softprob 和multi:softmax参数一样，但是返回的是每个数据属于各个类别的概率。</li></ul></li><li><strong>eval_metric[默认值取决于objective参数的取值]：</strong>对于有效数据的度量方法。对于回归问题，默认值是rmse，对于分类问题，默认值是error。典型值有： <ul><li>rmse 均方根误差( ∑Ni=1ϵ2N−−−−−−√ )</li><li>mae 平均绝对误差( ∑Ni=1|ϵ|N )</li><li>logloss 负对数似然函数值</li><li>error 二分类错误率(阈值为0.5)</li><li>merror 多分类错误率</li><li>mlogloss 多分类logloss损失函数</li><li>auc 曲线下面积</li></ul></li><li><strong>seed(默认0)：</strong>随机数的种子。设置它可以复现随机数据的结果，也可以用于调整参数</li></ul><p>如果你之前用的是Scikit-learn,你可能不太熟悉这些参数。但是有个好消息，python的XGBoost模块有一个sklearn包，XGBClassifier。这个包中的参数是按sklearn风格命名的。会改变的函数名是：</p><ul><li>eta -&gt;learning_rate </li><li>lambda-&gt;reg_lambda </li><li>alpha-&gt;reg_alpha </li></ul><p>你肯定在疑惑为啥咱们没有介绍和GBM中的<code>n_estimators</code>类似的参数。XGBClassifier中确实有一个类似的参数，但是，是在标准XGBoost实现中调用拟合函数时，把它作为<code>num_boosting_rounds</code>参数传入。 </p><p>XGBoost Guide 的一些部分是我强烈推荐大家阅读的，通过它可以对代码和参数有一个更好的了解：</p><p><a href="http://xgboost.readthedocs.io/en/latest/parameter.html#general-parameters" target="_blank" rel="noopener">XGBoost Parameters (official guide) </a></p><p><a href="https://github.com/dmlc/xgboost/tree/master/demo/guide-python" target="_blank" rel="noopener">XGBoost Demo Codes (xgboost GitHub repository)</a></p><p><a href="http://xgboost.readthedocs.io/en/latest/python/python_api.html" target="_blank" rel="noopener">Python API Reference (official guide)</a></p><h3 id="3-3-Tuning-Parameters-with-Example"><a href="#3-3-Tuning-Parameters-with-Example" class="headerlink" title="3.3 Tuning Parameters (with Example)"></a>3.3 Tuning Parameters (with Example)</h3><ul><li>未完待续······</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章翻译自&lt;a href=&quot;https://www.analyticsvidhya.com/blog/2016/03/complete-guide-parameter-tuning-xgboost-with-codes-python/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Complete Guide to Parameter Tuning in XGBoost (with codes in Python)&lt;/a&gt;，它详细介绍了XGBoost中参数的含义，然后在一个实例中对参数调整进行了实验。&lt;/p&gt;
    
    </summary>
    
      <category term="Kaggle" scheme="http://yoursite.com/categories/Kaggle/"/>
    
    
      <category term="kaggle" scheme="http://yoursite.com/tags/kaggle/"/>
    
      <category term="XGBoost" scheme="http://yoursite.com/tags/XGBoost/"/>
    
      <category term="调参" scheme="http://yoursite.com/tags/%E8%B0%83%E5%8F%82/"/>
    
  </entry>
  
  <entry>
    <title>kaggle系列（3）：Rental Listing Inquiries（二）：XGBoost</title>
    <link href="http://yoursite.com/2017/06/13/kaggle%E7%B3%BB%E5%88%97%EF%BC%883%EF%BC%89%EF%BC%9ARental%20Listing%20Inquiries%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AXGBoost/"/>
    <id>http://yoursite.com/2017/06/13/kaggle系列（3）：Rental Listing Inquiries（二）：XGBoost/</id>
    <published>2017-06-13T15:14:45.000Z</published>
    <updated>2017-12-26T06:39:14.969Z</updated>
    
    <content type="html"><![CDATA[<p>上一节我们对数据集进行了初步的探索，并将其可视化，对数据有了初步的了解。这样我们有了之前数据探索的基础之后，就有了对其建模的基础feature，结合目标变量，即可进行模型训练了。我们使用交叉验证的方法来判断线下的实验结果，也就是把训练集分成两部分，一部分是训练集，用来训练分类器，另一部分是验证集，用来计算损失评估模型的好坏。</p><a id="more"></a><p>在Kaggle的希格斯子信号识别竞赛中，XGBoost因为出众的效率与较高的预测准确度在比赛论坛中引起了参赛选手的广泛关注，在1700多支队伍的激烈竞争中占有一席之地。随着它在Kaggle社区知名度的提高，最近也有队伍借助XGBoost在比赛中夺得第一。其次，因为它的效果好，计算复杂度不高，也在工业界中有大量的应用。</p><p>今天，我们就先来跑一个XGBoost版的Base Model。先回顾一下XGBoost的原理吧：<a href="https://plushunter.github.io/2017/01/26/机器学习算法系列（8）：XgBoost/" target="_blank" rel="noopener">机器学习算法系列（8）：XgBoost</a></p><h2 id="一、-准备工作"><a href="#一、-准备工作" class="headerlink" title="一、 准备工作"></a>一、 准备工作</h2><p>首先我们导入需要的包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> sys </div><div class="line"><span class="keyword">import</span> operator</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> sparse</div><div class="line"><span class="keyword">import</span> xgboost <span class="keyword">as</span> xgb</div><div class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> model_selection,preprocessing,ensemble</div><div class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> log_loss</div><div class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfVectorizer,CountVectorizer</div></pre></td></tr></table></figure><p>其中一些包的用途会在之后具体用到的时候进行讲解。</p><p>导入我们的数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">data_path = <span class="string">'../data/'</span></div><div class="line">train_file = data_path + <span class="string">"train.json"</span></div><div class="line">test_file = data_path +<span class="string">"test.json"</span></div><div class="line">train_df = pd.read_json(train_file)</div><div class="line">test_df = pd.read_json(test_file)</div><div class="line"><span class="keyword">print</span> train_df.shape</div><div class="line"><span class="keyword">print</span> test_df.shape</div><div class="line"></div><div class="line">(<span class="number">49352</span>, <span class="number">15</span>)</div><div class="line">(<span class="number">74659</span>, <span class="number">14</span>)</div></pre></td></tr></table></figure><p>查看一下前两行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">train_df.head(<span class="number">2</span>)</div></pre></td></tr></table></figure><p><img src="http://orsw4brg1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-19%20%E4%B8%8B%E5%8D%884.48.02.png" alt="屏幕快照 2017-06-19 下午4.48.02"><br><img src="http://orsw4brg1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-19%20%E4%B8%8B%E5%8D%884.48.20.png" alt="屏幕快照 2017-06-19 下午4.48.20"></p><h2 id="二、特征构建"><a href="#二、特征构建" class="headerlink" title="二、特征构建"></a>二、特征构建</h2><p>我们不需要对数值型数据进行任何的预处理，所以首先建立一个数值型特征的列表，纳入features_to_use</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">features_to_use = [<span class="string">"bathrooms"</span>,<span class="string">"bedrooms"</span>,<span class="string">"latitude"</span>,<span class="string">"longitude"</span>,<span class="string">"price"</span>]</div></pre></td></tr></table></figure><p>现在让我们根据已有的一些特征来构建一些新的特征：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 照片数量(num_photos)</span></div><div class="line">train_df[<span class="string">'num_photos'</span>]=train_df[<span class="string">'photos'</span>].apply(len)</div><div class="line">test_df[<span class="string">'num_photos'</span>]=train_df[<span class="string">'photos'</span>].apply(len)</div><div class="line"></div><div class="line"><span class="comment"># 特征数量</span></div><div class="line">train_df[<span class="string">'num_features'</span>]=train_df[<span class="string">'features'</span>].apply(len)</div><div class="line">test_df[<span class="string">'num_features'</span>]=test_df[<span class="string">'features'</span>].apply(len)</div><div class="line"></div><div class="line"><span class="comment"># 描述词汇数量</span></div><div class="line">train_df[<span class="string">'num_description_words'</span>] = train_df[<span class="string">'description'</span>].apply(<span class="keyword">lambda</span> x: len(x.split(<span class="string">" "</span>)))</div><div class="line">test_df[<span class="string">'num_description_words'</span>] = test_df[<span class="string">'description'</span>].apply(<span class="keyword">lambda</span> x: len(x.split(<span class="string">" "</span>)))</div><div class="line"></div><div class="line"><span class="comment">#把创建的时间分解为多个特征        </span></div><div class="line">train_df[<span class="string">'created'</span>]=pd.to_datetime(train_df[<span class="string">'created'</span>])</div><div class="line">test_df[<span class="string">'created'</span>]=pd.to_datetime(test_df[<span class="string">'created'</span>])</div><div class="line"> </div><div class="line"><span class="comment">#让我们从时间中分解出一些特征，比如年，月，日，时</span></div><div class="line"><span class="comment">#年</span></div><div class="line">train_df[<span class="string">'created_year'</span>] = train_df[<span class="string">'created'</span>].dt.year</div><div class="line">test_df[<span class="string">'created_year'</span>] = test_df[<span class="string">'created'</span>].dt.year</div><div class="line"><span class="comment">#月</span></div><div class="line">train_df[<span class="string">'created_month'</span>] = train_df[<span class="string">'created'</span>].dt.month</div><div class="line">test_df[<span class="string">'created_month'</span>] = test_df[<span class="string">'created'</span>].dt.month</div><div class="line"><span class="comment">#日</span></div><div class="line">train_df[<span class="string">'created_day'</span>] = train_df[<span class="string">'created'</span>].dt.day</div><div class="line">test_df[<span class="string">'created_day'</span>] = test_df[<span class="string">'created'</span>].dt.day</div><div class="line"><span class="comment">#时</span></div><div class="line">train_df[<span class="string">'created_hour'</span>] = train_df[<span class="string">'created'</span>].dt.hour</div><div class="line">test_df[<span class="string">'created_hour'</span>] = test_df[<span class="string">'created'</span>].dt.hour</div><div class="line"></div><div class="line"><span class="comment">#把这些特征都放到所需特征列表中（上面已经创建，并加入了数值型特征） </span></div><div class="line">features_to_use.extend([<span class="string">"num_photos"</span>,<span class="string">"num_features"</span>,<span class="string">"num_description_words"</span>,<span class="string">"created_year"</span>,<span class="string">"created_month"</span>,<span class="string">"created_day"</span>,<span class="string">"created_hour"</span>,<span class="string">"listing_id"</span>])</div></pre></td></tr></table></figure><p>我们有四个分类型的特征：</p><ul><li>display_address</li><li>manager_id</li><li>building_id</li><li>street_address</li></ul><p>可以对它们分别进行特征编码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">categorical = [<span class="string">"display_address"</span>,<span class="string">"manager_id"</span>,<span class="string">'building_id'</span>,<span class="string">"street_address"</span>]</div><div class="line"><span class="keyword">for</span> f <span class="keyword">in</span> categorical:</div><div class="line">    <span class="keyword">if</span> train_df[f].dtype == <span class="string">'object'</span>:</div><div class="line">        lbl = preprocessing.LabelEncoder()</div><div class="line">        lbl.fit(list(train_df[f].values)+list(test_df[f].values))</div><div class="line">        train_df[f] = lbl.transform(list(train_df[f].values))</div><div class="line">        test_df[f] = lbl.transform(list(test_df[f].values))</div><div class="line">        features_to_use.append(f)</div></pre></td></tr></table></figure><p>还有一些字符串类型的特征，可以先把它们合并起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">train_df[&quot;features&quot;] = train_df[&quot;features&quot;].apply(lambda x:&quot; &quot;.join([&quot;_&quot;.join(i.split(&quot; &quot;))for i in x]))</div><div class="line">print train_df[&apos;features&apos;].head(2)</div><div class="line">test_df[&apos;features&apos;] = test_df[&quot;features&quot;].apply(lambda x: &quot; &quot;.join([&quot;_&quot;.join(i.split(&quot; &quot;))for i in x]))</div><div class="line">print test_df[&apos;features&apos;].head(2)</div></pre></td></tr></table></figure><p>得到的字符串结果如下：</p><p>10000     Doorman Elevator Fitness_Center Cats_Allowed D…<br>100004    Laundry_In_Building Dishwasher Hardwood_Floors…</p><p>然后CountVectorizer类来计算TF-IDF权重</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">tfidf = CountVectorizer(stop_words =&quot;english&quot;,max_features=200)</div><div class="line">tr_sparse = tfidf.fit_transform(train_df[&quot;features&quot;])</div><div class="line">te_sparse = tfidf.transform(test_df[&quot;features&quot;])</div></pre></td></tr></table></figure><p>这里我们需要提一点，对数据集进行特征变换时，必须同时对训练集和测试集进行操作。现在把这些处理过的特征放到一个集合中（横向合并）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">train_X = sparse.hstack([train_df[features_to_use],tr_sparse]).tocsr()</div><div class="line">test_X = sparse.hstack([test_df[features_to_use],te_sparse]).tocsr()</div></pre></td></tr></table></figure><p>然后把目标变量转换为0、1、2，如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">target_num_map = &#123;<span class="string">'high'</span>:<span class="number">0</span> , <span class="string">'medium'</span>:<span class="number">1</span> , <span class="string">'low'</span>:<span class="number">2</span>&#125;</div><div class="line">train_y = np.array(train_df[<span class="string">'interest_level'</span>].apply(<span class="keyword">lambda</span> x: target_num_map[x]))</div><div class="line"><span class="keyword">print</span> train_X.shape,test_X.shape</div><div class="line"></div><div class="line">(<span class="number">49352</span>, <span class="number">217</span>) (<span class="number">74659</span>, <span class="number">217</span>)</div></pre></td></tr></table></figure><p>可以看到，经过上面一系列的变量构造之后，其数量已经达到了217个。</p><p>接下来就可以进行建模啦。</p><h2 id="三、XGB建模"><a href="#三、XGB建模" class="headerlink" title="三、XGB建模"></a>三、XGB建模</h2><p>先写一个通用的XGB模型的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">runXGB</span><span class="params">(train_X,train_y,test_X,test_y=None,feature_names=None,seed_val=<span class="number">0</span>,num_rounds=<span class="number">1000</span>)</span>:</span></div><div class="line">    <span class="comment">#参数设定</span></div><div class="line">    param = &#123;&#125;</div><div class="line">    param[<span class="string">'objective'</span>] = <span class="string">'multi:softprob'</span><span class="comment">#多分类、输出概率值</span></div><div class="line">    param[<span class="string">'eta'</span>] = <span class="number">0.1</span><span class="comment">#学习率</span></div><div class="line">    param[<span class="string">'max_depth'</span>] = <span class="number">6</span><span class="comment">#最大深度，越大越容易过拟合</span></div><div class="line">    param[<span class="string">'silent'</span>] = <span class="number">1</span><span class="comment">#打印提示信息</span></div><div class="line">    param[<span class="string">'num_class'</span>] = <span class="number">3</span><span class="comment">#三个类别</span></div><div class="line">    param[<span class="string">'eval_metric'</span>]= <span class="string">"mlogloss"</span><span class="comment">#对数损失</span></div><div class="line">    param[<span class="string">'min_child_weight'</span>]=<span class="number">1</span><span class="comment">#停止条件，这个参数非常影响结果，控制叶子节点中二阶导的和的最小值，该参数值越小，越容易 overfitting。</span></div><div class="line">    param[<span class="string">'subsample'</span>] =<span class="number">0.7</span><span class="comment">#随机采样训练样本</span></div><div class="line">    param[<span class="string">'colsample_bytree'</span>] = <span class="number">0.7</span><span class="comment"># 生成树时进行的列采样</span></div><div class="line">    param[<span class="string">'seed'</span>] = seed_val<span class="comment">#随机数种子</span></div><div class="line">    num_rounds = num_rounds<span class="comment">#迭代次数</span></div><div class="line">    </div><div class="line">    plst = list(param.items())</div><div class="line">    xgtrain = xgb.DMatrix(train_X,label=train_y)</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> test_y <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">        xgtest = xgb.DMatrix(test_X,label=test_y)</div><div class="line">        watchlist = [(xgtrain,<span class="string">'train'</span>),(xgtest,<span class="string">'test'</span>)]</div><div class="line">        model = xgb.train(plst,xgtrain,num_rounds,watchlist,early_stopping_rounds=<span class="number">20</span>)</div><div class="line">      <span class="comment">#  early_stopping_rounds 当设置的迭代次数较大时，early_stopping_rounds 可在一定的迭代次数内准确率没有提升就停止训练</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        xgtest = xgb.DMatrix(test_X)</div><div class="line">        model = xgb.train(plst,xgtrain,num_rounds)</div><div class="line">    pred_test_y = model.predict(xgtest)</div><div class="line">    <span class="keyword">return</span> pred_test_y,model</div></pre></td></tr></table></figure><p>函数返回的是预测值和模型。</p><p>5折交叉验证将训练集划分为五份，其中的一份作为验证集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">cv_scores = []</div><div class="line">kf = model_selection.KFold(n_splits=<span class="number">5</span>,shuffle=<span class="keyword">True</span>,random_state=<span class="number">2016</span>)</div><div class="line"></div><div class="line"><span class="keyword">for</span> dev_index,val_index <span class="keyword">in</span> kf.split(range(train_X.shape[<span class="number">0</span>])):</div><div class="line">    dev_X,val_X = train_X[dev_index,:],train_X[val_index,:]</div><div class="line">    dev_y,val_y = train_y[dev_index],train_y[val_index]</div><div class="line">    pred,model = runXGB(dev_X,dev_y,val_X,val_y)</div><div class="line">    cv_scores.append(log_loss(val_y,preds))</div><div class="line">    <span class="keyword">print</span> cv_scores</div><div class="line">    <span class="keyword">break</span></div></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">[0]train-mlogloss:1.04135test-mlogloss:1.04229</div><div class="line">Multiple eval metrics have been passed: 'test-mlogloss' will be used for early stopping.</div><div class="line"></div><div class="line">Will train until test-mlogloss hasn't improved in 20 rounds.</div><div class="line">[1]train-mlogloss:0.989004test-mlogloss:0.99087</div><div class="line">[2]train-mlogloss:0.944233test-mlogloss:0.947047</div><div class="line">[3]train-mlogloss:0.90536test-mlogloss:0.908933</div><div class="line">[4]train-mlogloss:0.872054test-mlogloss:0.876526</div><div class="line">[5]train-mlogloss:0.841783test-mlogloss:0.847383</div><div class="line">[6]train-mlogloss:0.815921test-mlogloss:0.822307</div><div class="line">[7]train-mlogloss:0.793337test-mlogloss:0.800476</div><div class="line">[8]train-mlogloss:0.773562test-mlogloss:0.781413</div><div class="line">[9]train-mlogloss:0.754927test-mlogloss:0.76381</div><div class="line">[10]train-mlogloss:0.738299test-mlogloss:0.747959</div><div class="line"></div><div class="line">······</div><div class="line">······</div><div class="line">[367]train-mlogloss:0.348196test-mlogloss:0.548011</div><div class="line">[368]train-mlogloss:0.347768test-mlogloss:0.547992</div><div class="line">[369]train-mlogloss:0.347303test-mlogloss:0.548021</div><div class="line">[370]train-mlogloss:0.346807test-mlogloss:0.548065</div><div class="line">[371]train-mlogloss:0.346514test-mlogloss:0.548079</div><div class="line">[372]train-mlogloss:0.34615test-mlogloss:0.548097</div><div class="line">[373]train-mlogloss:0.345859test-mlogloss:0.548111</div><div class="line">[374]train-mlogloss:0.345377test-mlogloss:0.548081</div><div class="line">[375]train-mlogloss:0.344961test-mlogloss:0.548068</div><div class="line">[376]train-mlogloss:0.344493test-mlogloss:0.548024</div><div class="line">[377]train-mlogloss:0.344086test-mlogloss:0.547975</div><div class="line">Stopping. Best iteration:</div><div class="line">[357]train-mlogloss:0.352182test-mlogloss:0.547867</div></pre></td></tr></table></figure><p>迭代357次之后，在训练集上的对数损失为0.352182，在验证集上的损失为0.5478。</p><p>然后在对测试集进行预测：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">preds,model=runXGB(train_X,train_y,test_X,num_rounds=<span class="number">400</span>)</div></pre></td></tr></table></figure><p>把结果按照比赛规定的格式写入csv文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">out_df = pd.DataFrame(preds)</div><div class="line">out_df.columns = [<span class="string">"high"</span>, <span class="string">"medium"</span>, <span class="string">"low"</span>]</div><div class="line">out_df[<span class="string">"listing_id"</span>] = test_df.listing_id.values</div><div class="line">out_df.to_csv(<span class="string">"xgb_starter2.csv"</span>, index=<span class="keyword">False</span>)</div></pre></td></tr></table></figure><p>看一下最后的结果：<br><img src="http://orsw4brg1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-20%20%E4%B8%8A%E5%8D%8810.50.42.png" alt="屏幕快照 2017-06-20 上午10.50.42"><br>提交到kaggle上，这样我们整个建模的过程就完成了。</p><p>接下来两节中，我们重点讲一讲关于XGBoost的调参经验以及使用SK-learn计算TF-IDF。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一节我们对数据集进行了初步的探索，并将其可视化，对数据有了初步的了解。这样我们有了之前数据探索的基础之后，就有了对其建模的基础feature，结合目标变量，即可进行模型训练了。我们使用交叉验证的方法来判断线下的实验结果，也就是把训练集分成两部分，一部分是训练集，用来训练分类器，另一部分是验证集，用来计算损失评估模型的好坏。&lt;/p&gt;
    
    </summary>
    
      <category term="Kaggle" scheme="http://yoursite.com/categories/Kaggle/"/>
    
    
      <category term="kaggle" scheme="http://yoursite.com/tags/kaggle/"/>
    
      <category term="XGBoost" scheme="http://yoursite.com/tags/XGBoost/"/>
    
      <category term="特征工程" scheme="http://yoursite.com/tags/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>kaggle系列（2）：Rental Listing Inquiries（一）：EDA</title>
    <link href="http://yoursite.com/2017/06/13/kaggle%E7%B3%BB%E5%88%97%EF%BC%882%EF%BC%89%EF%BC%9ARental%20Listing%20Inquiries%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AEDA/"/>
    <id>http://yoursite.com/2017/06/13/kaggle系列（2）：Rental Listing Inquiries（一）：EDA/</id>
    <published>2017-06-13T12:14:45.000Z</published>
    <updated>2017-12-26T06:38:57.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、比赛简介"><a href="#一、比赛简介" class="headerlink" title="一、比赛简介"></a>一、比赛简介</h2><h3 id="1-1-比赛目的"><a href="#1-1-比赛目的" class="headerlink" title="1.1 比赛目的"></a>1.1 比赛目的</h3><p>这个kaggle比赛是由Sigma和RentHop两家公司共同推出的比赛。比赛的数据来自于RentHop的租房信息，大概的思路就是根据出租房的一系列特征，比如地理位置（经纬度、街道地址）、发布时间、房间设施（浴室、卧室数量）、描述信息、发布的图片信息、价格等来预测消费者对出租房的喜好程度。</p><p>这样可以帮助RentHop公司更好地处理欺诈事件，让房主和中介更加理解租客的需求与偏好，做出更加合理的决策。</p><a id="more"></a><h3 id="1-2-数据集"><a href="#1-2-数据集" class="headerlink" title="1.2 数据集"></a>1.2 数据集</h3><p>在这个比赛中，房源的数据来自于renthop网站，这些公寓都位于纽约市。其目的之前已经提到过了，就是基于一系列特征预测公寓房源的受欢迎程度，其目标变量是：<code>interest_level</code>，它是指从在网站上发布房源起始的时间内，房源的询问次数。</p><p>其中，比赛一共给了五个数据文件，分别是：</p><ul><li>train.json：训练集</li><li>test.json：测试集</li><li>sample_submission.csv：格式正确的提交示例</li><li>images_sample.zip：租房图片集（只抽取了100个图片集）</li><li>kaggle-renthop.7z：所有的租房图片集，一共有78.5GB的压缩文件。</li></ul><p>给出的特征的含义：</p><ul><li>bathrooms: 浴室的数量</li><li>bedrooms: 卧室的数量</li><li>building_id：</li><li>created：发布时间</li><li>description：一些描述</li><li>display_address：展出地址</li><li>features: 公寓的一些特征</li><li>latitude：纬度</li><li>listing_id</li><li>longitude：经度</li><li>manager_id：管理ID</li><li>photos: 租房图片集</li><li>price: 美元</li><li>street_address：街道地址</li><li>interest_level: 目标变量，受欢迎程度. 有三个类: ‘high’, ‘medium’, ‘low’</li></ul><h3 id="1-3-提交要求"><a href="#1-3-提交要求" class="headerlink" title="1.3 提交要求"></a>1.3 提交要求</h3><p>这个比赛使用的是多分类对数似然损失函数来评价模型。因为每一个房源都有一个对应的最准确的类别，对每一个房源，需要提交它属于每一类的概率值，它的计算公式如下：</p><script type="math/tex; mode=display">\log loss=-\frac{1}{N}\sum_{i=1}^N{\sum_{j=1}^M{y_{ij}\log\left(p_{ij}\right)}}</script><p>其中$N$是测试集中的样本数量，$M$是类别的数量（3类：high、medium、low）,$log$是自然对数，$y_{ij}$表示样本$i$属于$j$类则为1，否则为0.$p_{ij}$表示样本$i$属于类别$j$的预测概率值。</p><p>一个样本的属于三个类别的预测可能性不需要加和为1，因为已经预先归一化了。为避免对数函数的极端情况，预测概率被替代为$max(min(p,1-10^{-15}),10^{-15})$</p><p>最后提交的文件为csv格式，它包含对每一类的预测概率值，行的顺序没有要求，文件必须要有一个表头，看起来像下面的示例：</p><div class="table-container"><table><thead><tr><th>listing_id</th><th>high</th><th>medium</th><th>low</th></tr></thead><tbody><tr><td>7065104</td><td>0.07743</td><td>0.23002</td><td>0.69254</td></tr><tr><td>7089035</td><td>0.0</td><td>1.0</td><td>0.0</td><td></td></tr></tbody></table></div><h2 id="二、Exploratory-Data-Analysis"><a href="#二、Exploratory-Data-Analysis" class="headerlink" title="二、Exploratory Data Analysis"></a>二、Exploratory Data Analysis</h2><p>在进行建模之前，我们都会对原始数据进行一些可视化探索，以便更快地熟悉数据，更有效进行之后的特征工程和建模。</p><p>我们先导入一些EDA过程中所需要的包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</div><div class="line"><span class="keyword">import</span> json</div><div class="line">color = sns.color_palette() <span class="comment"># 调色板</span></div><div class="line"></div><div class="line">%matplotlib inline</div><div class="line"></div><div class="line">pd.options.mode.chained_assignment = <span class="keyword">None</span> <span class="comment"># default = 'warn'</span></div></pre></td></tr></table></figure><p>其中numpy和pandas是数据分析处理中最流行的包，matplotlib和seaborn两个包用来绘制可视化图像，使用%matplotlib命令可以将matplotlib的图表直接嵌入到Notebook之中（%是魔术命令）。</p><h3 id="2-1-数据初探"><a href="#2-1-数据初探" class="headerlink" title="2.1 数据初探"></a>2.1 数据初探</h3><p>使用pandas打开训练集文件train.json，取前两行观测：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">train_df = pd.read_json(<span class="string">'data/train.json'</span>)</div><div class="line">train_df.head(<span class="number">8</span>)</div></pre></td></tr></table></figure><p><img src="http://orsw4brg1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-19%20%E4%B8%8B%E5%8D%884.48.02.png" alt="屏幕快照 2017-06-19 下午4.48.02"><br><img src="http://orsw4brg1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-19%20%E4%B8%8B%E5%8D%884.48.20.png" alt="屏幕快照 2017-06-19 下午4.48.20"></p><p>我们可以看到给定的数据中包含各种类型的特征，按照其特征可以分为以下几个类别：</p><div class="table-container"><table><thead><tr><th>特征类型</th><th>特征</th></tr></thead><tbody><tr><td>数值型</td><td>bathrooms、bedrooms、price</td></tr><tr><td>高势集类别</td><td>building_id、display_address、manager_id、street_address</td></tr><tr><td>时间型</td><td>created</td></tr><tr><td>地理位置型特征</td><td>longitude、latitude</td></tr><tr><td>文本</td><td>description</td></tr><tr><td>稀疏特征</td><td>features</td></tr><tr><td>id型特征</td><td>listing_id、index</td></tr></tbody></table></div><p>看一下训练集和测试集分别有多少</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> <span class="string">"Train Rows:"</span>,train_df.shape[<span class="number">0</span>]</div><div class="line"><span class="keyword">print</span> <span class="string">"Test Rows:"</span>,test_df.shape[<span class="number">0</span>]</div></pre></td></tr></table></figure><p>Train Rows: 49352<br>Test Rows: 74659</p><p>训练集有49352个样例，测试集有74659个样例。</p><p>接下来我们一一对这些特征进行探索。</p><h3 id="2-2-目标变量"><a href="#2-2-目标变量" class="headerlink" title="2.2 目标变量"></a>2.2 目标变量</h3><p>在深入探索之前，我们先看看目标变量Interest level</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int_level = train_df[<span class="string">'interest_level'</span>].value_counts()</div><div class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">5</span>))</div><div class="line">sns.barplot(int_level.index,int_level.values,alpha=<span class="number">0.8</span>,color=color[<span class="number">2</span>])</div><div class="line">plt.xlabel(<span class="string">"number of occurrences"</span>,fontsize = <span class="number">12</span>)</div><div class="line">plt.ylabel(<span class="string">"Interest Level"</span>,fontsize=<span class="number">12</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="http://orsw4brg1.bkt.clouddn.com/fsvg.png" alt="fsvg"></p><p>兴趣度在大多数情况下都是低的，其次是中等，只有少部分的样例为高分。</p><h3 id="2-3-数值型特征"><a href="#2-3-数值型特征" class="headerlink" title="2.3 数值型特征"></a>2.3 数值型特征</h3><h4 id="2-3-1-浴室（bathrooms）"><a href="#2-3-1-浴室（bathrooms）" class="headerlink" title="2.3.1 浴室（bathrooms）"></a>2.3.1 浴室（bathrooms）</h4><p>先看看浴室的数量分布<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cnt_srs = train_df[<span class="string">'bathrooms'</span>].value_counts()</div><div class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">5</span>))</div><div class="line">sns.barplot(cnt_srs.index,cnt_srs.values,alpha=<span class="number">0.8</span>,color=color[<span class="number">2</span>])</div><div class="line">plt.xlabel(<span class="string">"number of occurrences"</span>,fontsize = <span class="number">12</span>)</div><div class="line">plt.ylabel(<span class="string">"bathrooms"</span>,fontsize=<span class="number">12</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure></p><p><img src="http://orsw4brg1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-19%20%E4%B8%8B%E5%8D%885.23.17.png" alt="屏幕快照 2017-06-19 下午5.23.17"></p><p>可以看到绝大多数的样例的浴室数量为1，其次为2个浴室。</p><p>再看看不同兴趣程度的浴室数量分布，运用小提琴图来呈现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#浴室数量大于3的记为3</span></div><div class="line">train_df[<span class="string">'bathrooms'</span>].loc[train_df[<span class="string">'bathrooms'</span>]&gt;<span class="number">3</span>]=<span class="number">3</span></div><div class="line"></div><div class="line">plt.figure(figsize=(<span class="number">12</span>,<span class="number">6</span>))</div><div class="line">sns.violinplot(x = <span class="string">'interest_level'</span>,y = <span class="string">'bathrooms'</span>,data= train_df,alpha=<span class="number">0.8</span>)</div><div class="line">plt.xlabel(<span class="string">"interest level"</span>,fontsize = <span class="number">12</span>)</div><div class="line">plt.ylabel(<span class="string">"bathrooms"</span>,fontsize=<span class="number">12</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="http://orsw4brg1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-19%20%E4%B8%8B%E5%8D%885.24.02.png" alt="屏幕快照 2017-06-19 下午5.24.02"></p><p>可以看到在不同的兴趣程度上，浴室数量的分布差不多。</p><h4 id="2-3-2-卧室（bedrooms）"><a href="#2-3-2-卧室（bedrooms）" class="headerlink" title="2.3.2 卧室（bedrooms）"></a>2.3.2 卧室（bedrooms）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cnt_bedrooms = train_df[<span class="string">'bedrooms'</span>].value_counts()</div><div class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">5</span>))</div><div class="line">sns.barplot(cnt_bedrooms.index,cnt_bedrooms.values,alpha=<span class="number">0.8</span>,color=color[<span class="number">3</span>])</div><div class="line">plt.ylabel(<span class="string">"number of occurrences"</span>,fontsize = <span class="number">12</span>)</div><div class="line">plt.xlabel(<span class="string">"bedrooms"</span>,fontsize=<span class="number">12</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="http://orsw4brg1.bkt.clouddn.com/dfrgv.png" alt="dfrgv"></p><p>卧室数量基本集中在1和2，也有不少没有卧室，3个卧室的房子也不少。</p><p>看看不同兴趣程度的卧室数量分布，同样也用小提琴图来呈现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">plt.figure(figsize=(<span class="number">12</span>,<span class="number">6</span>))</div><div class="line">sns.countplot(x=<span class="string">'bedrooms'</span>,hue=<span class="string">'interest_level'</span>,data=train_df)</div><div class="line">plt.ylabel(<span class="string">"number of occurrences"</span>,fontsize = <span class="number">12</span>)</div><div class="line">plt.xlabel(<span class="string">"bedrooms"</span>,fontsize=<span class="number">12</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="http://orsw4brg1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-19%20%E4%B8%8B%E5%8D%885.30.15.png" alt="屏幕快照 2017-06-19 下午5.30.15"></p><h4 id="2-3-3-价格（price）"><a href="#2-3-3-价格（price）" class="headerlink" title="2.3.3 价格（price）"></a>2.3.3 价格（price）</h4><p>对价格排序，看一下价格的分布：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">5</span>))</div><div class="line">plt.scatter(range(train_df.shape[<span class="number">0</span>]),np.sort(train_df.price.values))</div><div class="line">plt.xlabel(<span class="string">'index'</span>,fontsize=<span class="number">12</span>)</div><div class="line">plt.ylabel(<span class="string">'price'</span>,fontsize=<span class="number">12</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="http://orsw4brg1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-19%20%E4%B8%8B%E5%8D%885.37.33.png" alt="屏幕快照 2017-06-19 下午5.37.33"></p><p>可以观察到有几个价格格外的高，视为异常值，我们把它们移除掉，然后再绘制分布直方图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#99%分位数</span></div><div class="line">ulimit = np.percentile(train_df.price.values,<span class="number">99</span>)</div><div class="line">train_df[<span class="string">'price'</span>].loc[train_df[<span class="string">'price'</span>]&gt;ulimit]=ulimit</div><div class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">5</span>))</div><div class="line">sns.distplot(train_df.price.values,bins=<span class="number">50</span>,kde=<span class="keyword">True</span>,color=color[<span class="number">3</span>])</div><div class="line">plt.xlabel(<span class="string">'price'</span>,fontsize=<span class="number">12</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="http://orsw4brg1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-19%20%E4%B8%8B%E5%8D%885.42.29.png" alt="屏幕快照 2017-06-19 下午5.42.29"></p><p>可以观察到分布略微有点右偏。</p><h3 id="2-4-地理位置型"><a href="#2-4-地理位置型" class="headerlink" title="2.4 地理位置型"></a>2.4 地理位置型</h3><h4 id="2-4-1-纬度（latitude）"><a href="#2-4-1-纬度（latitude）" class="headerlink" title="2.4.1 纬度（latitude）"></a>2.4.1 纬度（latitude）</h4><p>先看看纬度的分布情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#避免极端情况</span></div><div class="line">llimit = np.percentile(train_df.latitude.values,<span class="number">1</span>)</div><div class="line">ulimit = np.percentile(train_df.latitude.values,<span class="number">99</span>)</div><div class="line"></div><div class="line">train_df[<span class="string">'latitude'</span>].loc[train_df[<span class="string">'latitude'</span>]&lt;llimit]=llimit</div><div class="line">train_df[<span class="string">'latitude'</span>].loc[train_df[<span class="string">'latitude'</span>]&gt;ulimit]=ulimit</div><div class="line"></div><div class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">5</span>))</div><div class="line">sns.distplot(train_df.latitude.values,bins=<span class="number">50</span>,kde=<span class="keyword">True</span>,color=color[<span class="number">3</span>])</div><div class="line">plt.xlabel(<span class="string">'latitude'</span>,fontsize=<span class="number">12</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="http://orsw4brg1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-19%20%E4%B8%8B%E5%8D%889.07.07.png" alt="屏幕快照 2017-06-19 下午9.07.07"></p><p>由图可知，纬度基本上介于40.6到40.9之间</p><h4 id="2-4-2-经度（longitude）"><a href="#2-4-2-经度（longitude）" class="headerlink" title="2.4.2 经度（longitude）"></a>2.4.2 经度（longitude）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#避免极端情况</span></div><div class="line">llimit = np.percentile(train_df.longitude.values,<span class="number">1</span>)</div><div class="line">ulimit = np.percentile(train_df.longitude.values,<span class="number">99</span>)</div><div class="line"></div><div class="line">train_df[<span class="string">'longitude'</span>].loc[train_df[<span class="string">'longitude'</span>]&lt;llimit]=llimit</div><div class="line">train_df[<span class="string">'longitude'</span>].loc[train_df[<span class="string">'longitude'</span>]&gt;ulimit]=ulimit</div><div class="line"></div><div class="line">plt.figure(figsize=(<span class="number">12</span>,<span class="number">6</span>))</div><div class="line">sns.distplot(train_df.longitude.values,bins=<span class="number">50</span>)</div><div class="line">plt.xlabel(<span class="string">'longitude'</span>,fontsize=<span class="number">14</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="http://orsw4brg1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-19%20%E4%B8%8B%E5%8D%889.10.31.png" alt="屏幕快照 2017-06-19 下午9.10.31"></p><p>经度介于-73.8和-74.02之间。<br>接下来，我们尝试把经纬度对应到地图上，绘制成热图，也就是房源在地理位置上的分布密度图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> mpl_toolkits.basemap <span class="keyword">import</span> Basemap</div><div class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> cm</div><div class="line">west,south,east,north =<span class="number">-74.02</span>,<span class="number">40.64</span>,<span class="number">-73.85</span>,<span class="number">40.86</span></div><div class="line">fig =plt.figure(figsize=(<span class="number">16</span>,<span class="number">12</span>))</div><div class="line">ax = fig.add_subplot(<span class="number">111</span>)</div><div class="line">m=Basemap(projection=<span class="string">'merc'</span>,</div><div class="line">          llcrnrlat=south,urcrnrlat=north,</div><div class="line">          llcrnrlon=west,urcrnrlon=east,</div><div class="line">          lat_ts=south,resolution=<span class="string">'i'</span>)</div><div class="line">x,y=m(train_df[<span class="string">'longitude'</span>].values,train_df[<span class="string">'latitude'</span>].values)</div><div class="line">m.hexbin(x,y,gridsize=<span class="number">200</span>,bins=<span class="string">'log'</span>,cmap=cm.YlOrRd_r)</div></pre></td></tr></table></figure><p><img src="http://orsw4brg1.bkt.clouddn.com/%E4%B8%8B%E8%BD%BD.png" alt="下载"><br>基本和纽约市的城市热图相匹配。</p><h3 id="2-5-时间型"><a href="#2-5-时间型" class="headerlink" title="2.5 时间型"></a>2.5 时间型</h3><h4 id="2-5-1-发布时间（Created）"><a href="#2-5-1-发布时间（Created）" class="headerlink" title="2.5.1 发布时间（Created）"></a>2.5.1 发布时间（Created）</h4><p>先看一下不同时间的分布状况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">train_df[<span class="string">'created'</span>]=pd.to_datetime(train_df[<span class="string">'created'</span>])</div><div class="line">train_df[<span class="string">'date_created'</span>]=train_df[<span class="string">'created'</span>].dt.date</div><div class="line">cnt_srs = train_df[<span class="string">'date_created'</span>].value_counts()</div><div class="line"></div><div class="line">plt.figure(figsize=(<span class="number">14</span>,<span class="number">7</span>))</div><div class="line">ax = plt.subplot(<span class="number">111</span>)</div><div class="line">ax.bar(cnt_srs.index,cnt_srs.values,alpha=<span class="number">0.8</span>)</div><div class="line">ax.xaxis_date()</div><div class="line">plt.xticks(rotation=<span class="string">'vertical'</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="http://orsw4brg1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-19%20%E4%B8%8B%E5%8D%889.21.21.png" alt="屏幕快照 2017-06-19 下午9.21.21"></p><p>从图中观察到发布时间是从2016年的4月至6月，当然这是训练集的情况，对应的，再看看测试集的发布时间状况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">test_df[<span class="string">'created'</span>]=pd.to_datetime(test_df[<span class="string">'created'</span>])</div><div class="line">test_df[<span class="string">'date_created'</span>]=test_df[<span class="string">'created'</span>].dt.date</div><div class="line">cnt_srs = test_df[<span class="string">'date_created'</span>].value_counts()</div><div class="line"></div><div class="line">plt.figure(figsize=(<span class="number">12</span>,<span class="number">6</span>))</div><div class="line">ax = plt.subplot(<span class="number">111</span>)</div><div class="line">ax.bar(cnt_srs.index,cnt_srs.values,alpha=<span class="number">0.8</span>)</div><div class="line">ax.xaxis_date()</div><div class="line">plt.xticks(rotation=<span class="string">'vertical'</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="http://orsw4brg1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-19%20%E4%B8%8B%E5%8D%889.24.59.png" alt="屏幕快照 2017-06-19 下午9.24.59"></p><p>可知，测试集的时间分布和训练集类似。</p><p>再看看不同时刻的样本分布情况：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">train_df[<span class="string">'hour_created'</span>] = train_df[<span class="string">'created'</span>].dt.hour</div><div class="line">cnt_srs = train_df[<span class="string">'hour_created'</span>].value_counts()</div><div class="line"></div><div class="line">plt.figure(figsize=(<span class="number">14</span>,<span class="number">7</span>))</div><div class="line">sns.barplot(cnt_srs.index,cnt_srs.values,alpha=<span class="number">0.8</span>,color=color[<span class="number">4</span>])</div><div class="line">plt.xticks(rotation=<span class="string">'vertical'</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="http://orsw4brg1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-19%20%E4%B8%8B%E5%8D%889.25.37.png" alt="屏幕快照 2017-06-19 下午9.25.37"></p><p>看起来像是一天中比较早的几个小时创建的比较多。可能是那个时候流量不拥挤，数据就更新了。</p><h3 id="2-6-其他类型特征"><a href="#2-6-其他类型特征" class="headerlink" title="2.6 其他类型特征"></a>2.6 其他类型特征</h3><h4 id="2-6-1-展示地址（Display-Address）"><a href="#2-6-1-展示地址（Display-Address）" class="headerlink" title="2.6.1 展示地址（Display Address）"></a>2.6.1 展示地址（Display Address）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cnt_srs = train_df.groupby(<span class="string">'display_address'</span>)[<span class="string">'display_address'</span>].count()</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">2</span>,<span class="number">10</span>,<span class="number">50</span>,<span class="number">100</span>,<span class="number">500</span>]:</div><div class="line">    <span class="keyword">print</span> <span class="string">"Display_address that appear less than &#123;&#125; \</span></div><div class="line">    times:&#123;&#125;%".format(i,round((cnt_srs&lt;i).mean()*<span class="number">100</span>,<span class="number">2</span>))</div></pre></td></tr></table></figure><p>上述代码中（cnt_srs&lt;i）返回的是布尔值True | False。再求一个<br>得到的结果为：<br>Display_address that appear less than 2     times:63.22%<br>Display_address that appear less than 10     times:89.6%<br>Display_address that appear less than 50     times:97.73%<br>Display_address that appear less than 100     times:99.26%<br>Display_address that appear less than 500     times:100.0%</p><p>绘制展示地址频次分布直方图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">plt.figure(figsize=(<span class="number">12</span>,<span class="number">6</span>))</div><div class="line">plt.hist(cnt_srs.values,bins=<span class="number">150</span>,log=<span class="keyword">True</span>,alpha=<span class="number">0.9</span>)</div><div class="line">plt.xlabel(<span class="string">'Number of times display_adress appeared'</span>,fontsize=<span class="number">12</span>)</div><div class="line">plt.ylabel(<span class="string">'log(Count)'</span>,fontsize=<span class="number">12</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="http://orsw4brg1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-19%20%E4%B8%8B%E5%8D%8810.03.35.png" alt="屏幕快照 2017-06-19 下午10.03.35"></p><p>大部分的展览地址出现次数在给定的数据集中少于100次。没有超过500次的。</p><p>再看看展示地址的词云图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># wordcloud for display address</span></div><div class="line">plt.figure(figsize=(<span class="number">12</span>,<span class="number">6</span>))</div><div class="line">wordcloud = WordCloud(background_color=<span class="string">'white'</span>, width=<span class="number">600</span>, height=<span class="number">300</span>, max_font_size=<span class="number">50</span>, max_words=<span class="number">40</span>).generate(text_da)</div><div class="line">wordcloud.recolor(random_state=<span class="number">0</span>)</div><div class="line">plt.imshow(wordcloud)</div><div class="line">plt.title(<span class="string">"Wordcloud for Display Address"</span>, fontsize=<span class="number">30</span>)</div><div class="line">plt.axis(<span class="string">"off"</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="http://orsw4brg1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-19%20%E4%B8%8B%E5%8D%8810.01.10.png" alt="屏幕快照 2017-06-19 下午10.01.10"></p><h4 id="2-6-2-照片数量（Photos）"><a href="#2-6-2-照片数量（Photos）" class="headerlink" title="2.6.2 照片数量（Photos）"></a>2.6.2 照片数量（Photos）</h4><p>这个比赛也有巨大的照片数据。让我们先看看照片的数量:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">train_df[<span class="string">"num_photos"</span>] = train_df[<span class="string">"photos"</span>].apply(len)</div><div class="line">cnt_srs = train_df[<span class="string">'num_photos'</span>].value_counts()</div><div class="line"></div><div class="line">plt.figure(figsize=(<span class="number">14</span>,<span class="number">7</span>))</div><div class="line">sns.barplot(x=cnt_srs.index,y=cnt_srs.values,alpha=<span class="number">0.8</span>)</div><div class="line">plt.xlabel(<span class="string">"number of photos"</span>,fontsize=<span class="number">14</span>)</div><div class="line">plt.ylabel(<span class="string">'number of occurrences'</span>,fontsize=<span class="number">14</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="http://orsw4brg1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-19%20%E4%B8%8B%E5%8D%889.52.55.png" alt="屏幕快照 2017-06-19 下午9.52.55"></p><p>大多数样例的照片数量集中在3~8张。</p><p>再来看看不同兴趣程度下的照片数量分布：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">train_df[<span class="string">'num_photos'</span>].loc[train_df[<span class="string">'num_photos'</span>]&gt;<span class="number">12</span>]=<span class="number">12</span></div><div class="line">plt.figure(figsize=(<span class="number">14</span>,<span class="number">7</span>))</div><div class="line">sns.violinplot(x=<span class="string">'num_photos'</span>,y=<span class="string">'interest_level'</span>,data=train_df,order=[<span class="string">'low'</span>,<span class="string">'medium'</span>,<span class="string">'high'</span>])</div><div class="line">plt.xlabel(<span class="string">'Number of photos'</span>,fontsize=<span class="number">12</span>)</div><div class="line">plt.ylabel(<span class="string">"Interest Level"</span>,fontsize=<span class="number">12</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="http://orsw4brg1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-19%20%E4%B8%8B%E5%8D%889.55.02.png" alt="屏幕快照 2017-06-19 下午9.55.02"></p><h4 id="2-6-3-描述特征的数量（features）"><a href="#2-6-3-描述特征的数量（features）" class="headerlink" title="2.6.3 描述特征的数量（features）"></a>2.6.3 描述特征的数量（features）</h4><p>每一个房源都对应一个features列，它描述了该样例的特征，比如位于市中心呀、能养猫呀、可以肆意遛狗，类似于这种亲民的特点。有的时候，这种利民条件越多，或许会提高消费者的兴趣，当然也不一定，可以先来看看特征数量的分布：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">train_df[<span class="string">'num_features'</span>] = train_df[<span class="string">'features'</span>].apply(len)</div><div class="line">cnt_srs = train_df[<span class="string">'num_features'</span>].value_counts()</div><div class="line"></div><div class="line">plt.figure(figsize=(<span class="number">14</span>,<span class="number">7</span>))</div><div class="line">sns.barplot(x=cnt_srs.index,y=cnt_srs.values,alpha=<span class="number">0.8</span>)</div><div class="line">plt.ylabel(<span class="string">'Number of Occurrences'</span>,fontsize=<span class="number">12</span>)</div><div class="line">plt.xlabel(<span class="string">'Number of features'</span>,fontsize=<span class="number">12</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure></p><p><img src="http://orsw4brg1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-19%20%E4%B8%8B%E5%8D%889.57.13.png" alt="屏幕快照 2017-06-19 下午9.57.13"></p><p>再看看不同兴趣程度下的描述特征数量分布：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#避免极端情况</span></div><div class="line">train_df[<span class="string">'num_features'</span>].loc[train_df[<span class="string">'num_features'</span>]&gt;<span class="number">17</span>]=<span class="number">17</span></div><div class="line"></div><div class="line">plt.figure(figsize=(<span class="number">14</span>,<span class="number">7</span>))</div><div class="line">sns.violinplot(y=<span class="string">'num_features'</span>,x=<span class="string">'interest_level'</span>,\</div><div class="line">               data=train_df,order=[<span class="string">'low'</span>,<span class="string">'medium'</span>,<span class="string">'high'</span>])</div><div class="line">plt.xlabel(<span class="string">'Interest Level'</span>,fontsize=<span class="number">12</span>)</div><div class="line">plt.ylabel(<span class="string">'Number of features'</span>,fontsize=<span class="number">12</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="http://orsw4brg1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-19%20%E4%B8%8B%E5%8D%889.59.05.png" alt="屏幕快照 2017-06-19 下午9.59.05"></p><p>也可以看看描述特征的词云：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud</div><div class="line">text = <span class="string">''</span></div><div class="line">text_da = <span class="string">''</span></div><div class="line"><span class="keyword">for</span> index,row <span class="keyword">in</span> train_df.iterrows():</div><div class="line">    <span class="keyword">for</span> feature <span class="keyword">in</span> row[<span class="string">'features'</span>]:</div><div class="line">        text = <span class="string">' '</span>.join([text,<span class="string">"_"</span>.join(feature.strip().split(<span class="string">" "</span>))])</div><div class="line">        text_da = <span class="string">" "</span>.join([text_da,<span class="string">"_"</span>.join(row[<span class="string">'display_address'</span>].strip().split(<span class="string">" "</span>))])</div><div class="line">text = text.strip()</div><div class="line">text_da = text_da.strip()</div><div class="line">plt.figure(figsize=(<span class="number">14</span>,<span class="number">7</span>))</div><div class="line">wordcloud = WordCloud(background_color=<span class="string">'white'</span>,width=<span class="number">600</span>,                     height=<span class="number">300</span>,max_font_size=<span class="number">50</span>,max_words=<span class="number">40</span>).generate(text)</div><div class="line">wordcloud.recolor(random_state=<span class="number">0</span>)</div><div class="line">plt.imshow(wordcloud)</div><div class="line">plt.title(<span class="string">"Wordcloud for features"</span>,fontsize=<span class="number">30</span>)</div><div class="line">plt.axis(<span class="string">"off"</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="http://orsw4brg1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-19%20%E4%B8%8B%E5%8D%8810.00.21.png" alt="屏幕快照 2017-06-19 下午10.00.21"></p><p>以上这些探索性分析只是对原始数据初步的认识与了解，完了就可以建立一个base model。随着之后的特征工程对其进行更深层次的探索挖掘，不断迭代，使得我们的模型的预测效果越来越好。下一篇就开始着手建立一些base model。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、比赛简介&quot;&gt;&lt;a href=&quot;#一、比赛简介&quot; class=&quot;headerlink&quot; title=&quot;一、比赛简介&quot;&gt;&lt;/a&gt;一、比赛简介&lt;/h2&gt;&lt;h3 id=&quot;1-1-比赛目的&quot;&gt;&lt;a href=&quot;#1-1-比赛目的&quot; class=&quot;headerlink&quot; title=&quot;1.1 比赛目的&quot;&gt;&lt;/a&gt;1.1 比赛目的&lt;/h3&gt;&lt;p&gt;这个kaggle比赛是由Sigma和RentHop两家公司共同推出的比赛。比赛的数据来自于RentHop的租房信息，大概的思路就是根据出租房的一系列特征，比如地理位置（经纬度、街道地址）、发布时间、房间设施（浴室、卧室数量）、描述信息、发布的图片信息、价格等来预测消费者对出租房的喜好程度。&lt;/p&gt;
&lt;p&gt;这样可以帮助RentHop公司更好地处理欺诈事件，让房主和中介更加理解租客的需求与偏好，做出更加合理的决策。&lt;/p&gt;
    
    </summary>
    
      <category term="Kaggle" scheme="http://yoursite.com/categories/Kaggle/"/>
    
    
      <category term="kaggle" scheme="http://yoursite.com/tags/kaggle/"/>
    
      <category term="EDA" scheme="http://yoursite.com/tags/EDA/"/>
    
      <category term="可视化" scheme="http://yoursite.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="特征工程" scheme="http://yoursite.com/tags/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>数据分析系列（3）：数据倾斜</title>
    <link href="http://yoursite.com/2017/06/11/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%883%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C/"/>
    <id>http://yoursite.com/2017/06/11/数据分析系列（3）：数据倾斜/</id>
    <published>2017-06-11T15:14:45.000Z</published>
    <updated>2017-12-26T10:52:42.832Z</updated>
    
    <content type="html"><![CDATA[<p>数据倾斜是大数据领域绕不开的拦路虎，当你所需处理的数据量到达了上亿甚至是千亿条的时候，数据倾斜将是横在你面前一道巨大的坎。很可能有几周甚至几月都要头疼于数据倾斜导致的各类诡异的问题。</p><a id="more"></a><p>数据倾斜是指：mapreduce程序执行时，reduce节点大部分执行完毕，但是有一个或者几个reduce节点运行很慢，导致整个程序的处理时间很长，这是因为某一个key的条数比其他key多很多（有时是百倍或者千倍之多），这条key所在的reduce节点所处理的数据量比其他节点就大很多，从而导致某几个节点迟迟运行不完。Hive的执行是分阶段的，map处理数据量的差异取决于上一个stage的reduce输出，所以如何将数据均匀的分配到各个reduce中，就是解决数据倾斜的根本所在。</p><p>以下是一些常见的数据倾斜情形：<br><img src="http://orsw4brg1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-30%20%E4%B8%8B%E5%8D%889.07.31.png" alt=""></p><h2 id="一、Group-by-倾斜"><a href="#一、Group-by-倾斜" class="headerlink" title="一、Group by 倾斜"></a>一、Group by 倾斜</h2><p>group by造成的倾斜相对来说比较容易解决。hive提供两个参数可以解决：</p><h3 id="1-1-hive-map-aggr"><a href="#1-1-hive-map-aggr" class="headerlink" title="1.1 hive.map.aggr"></a>1.1 hive.map.aggr</h3><p>一个是hive.map.aggr，默认值已经为true，他的意思是做map aggregation，也就是在mapper里面做聚合。这个方法不同于直接写mapreduce的时候可以实现的combiner，但是却实现了类似combiner的效果。事实上各种基于mr的框架如pig，cascading等等用的都是map aggregation（或者叫partial aggregation）而非combiner的策略，也就是在mapper里面直接做聚合操作而不是输出到buffer给combiner做聚合。对于map aggregation，hive还会做检查，如果aggregation的效果不好，那么hive会自动放弃map aggregation。判断效果的依据就是经过一小批数据的处理之后，检查聚合后的数据量是否减小到一定的比例，默认是0.5，由hive.map.aggr.hash.min.reduction这个参数控制。所以如果确认数据里面确实有个别取值倾斜，但是大部分值是比较稀疏的，这个时候可以把比例强制设为1，避免极端情况下map aggr失效。hive.map.aggr还有一些相关参数，比如map aggr的内存占用等，具体可以参考<a href="http://dev.bizo.com/2013/02/map-side-aggregations-in-apache-hive.html" target="_blank" rel="noopener">这篇文章</a>。</p><h3 id="1-2-hive-groupby-skewindata"><a href="#1-2-hive-groupby-skewindata" class="headerlink" title="1.2 hive.groupby.skewindata"></a>1.2 hive.groupby.skewindata</h3><p>另一个参数是hive.groupby.skewindata。这个参数的意思是做reduce操作的时候，拿到的key并不是所有相同值给同一个reduce，而是随机分发，然后reduce做聚合，做完之后再做一轮MR，拿前面聚合过的数据再算结果。所以这个参数其实跟hive.map.aggr做的是类似的事情，只是拿到reduce端来做，而且要额外启动一轮job，所以其实不怎么推荐用，效果不明显。</p><h3 id="1-3-count-distinct-改写"><a href="#1-3-count-distinct-改写" class="headerlink" title="1.3 count distinct 改写"></a>1.3 count distinct 改写</h3><p>另外需要注意的是count distinct操作往往需要改写SQL，可以按照下面这么做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/*改写前*/</div><div class="line">select a, count(distinct b) as c from tbl group by a;</div><div class="line"></div><div class="line">/*改写后*/</div><div class="line">select a, count(*) as c from (select a, b from tbl group by a, b) group by a;</div></pre></td></tr></table></figure><h2 id="二、Join倾斜"><a href="#二、Join倾斜" class="headerlink" title="二、Join倾斜"></a>二、Join倾斜</h2><h3 id="2-1-skew-join"><a href="#2-1-skew-join" class="headerlink" title="2.1 skew join"></a>2.1 skew join</h3><p>join造成的倾斜，常见情况是不能做map join的两个表(能做map join的话基本上可以避免倾斜)，其中一个是行为表，另一个应该是属性表。比如我们有三个表，一个用户属性表users，一个商品属性表items，还有一个用户对商品的操作行为表日志表logs。假设现在需要将行为表关联用户表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select * from logs a join users b on a.user_id = b.user_id;</div></pre></td></tr></table></figure><p>其中logs表里面会有一个特殊用户user_id = 0，代表未登录用户，假如这种用户占了相当的比例，那么个别reduce会收到比其他reduce多得多的数据，因为它要接收所有user_id = 0的记录进行处理，使得其处理效果会非常差，其他reduce都跑完很久了它还在运行。</p><p>hive给出的解决方案叫skew join，其原理把这种user_id = 0的特殊值先不在reduce端计算掉，而是先写入hdfs，然后启动一轮map join专门做这个特殊值的计算，期望能提高计算这部分值的处理速度。当然你要告诉hive这个join是个skew join，即：set </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hive.optimize.skewjoin = true;</div></pre></td></tr></table></figure><p>还有要告诉hive如何判断特殊值，根据hive.skewjoin.key设置的数量hive可以知道，比如默认值是100000，那么超过100000条记录的值就是特殊值。总结起来，skew join的流程可以用下图描述：</p><p><img src="http://orsw4brg1.bkt.clouddn.com/skew_join.jpg" alt=""></p><h3 id="2-2-特殊值分开处理法"><a href="#2-2-特殊值分开处理法" class="headerlink" title="2.2 特殊值分开处理法"></a>2.2 特殊值分开处理法</h3><p>不过，上述方法还要去考虑阈值之类的情况，其实也不够通用。所以针对join倾斜的问题，一般都是通过改写sql解决。对于上面这个问题，我们已经知道user_id = 0是一个特殊key，那么可以把特殊值隔离开来单独做join，这样特殊值肯定会转化成map join，非特殊值就是没有倾斜的普通join了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">select *</div><div class="line">from (select * from logs where user_id = 0)  a </div><div class="line">join (select * from users where user_id = 0) b </div><div class="line">on a.user_id =  b.user_id</div><div class="line">union all</div><div class="line">select * </div><div class="line">from logs a join users b</div><div class="line">on a.user_id &lt;&gt; 0 and a.user_id = b.user_id;</div></pre></td></tr></table></figure><h3 id="2-3-随机数分配法"><a href="#2-3-随机数分配法" class="headerlink" title="2.3 随机数分配法"></a>2.3 随机数分配法</h3><p>上面这种个别key倾斜的情况只是一种倾斜情况。最常见的倾斜是因为数据分布本身就具有长尾性质，比如我们将日志表和商品表关联：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select * from logs a join items b on a.item_id = b.item_id;</div></pre></td></tr></table></figure><p>这个时候，分配到热门商品的reducer就会很慢，因为热门商品的行为日志肯定是最多的，而且我们也很难像上面处理特殊user那样去处理item。这个时候就会用到加随机数的方法，也就是在join的时候增加一个随机数，随机数的取值范围n相当于将item给分散到n个reducer：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">select a.*, b.*</div><div class="line">from (select *, cast(rand() * 10 as int) as r_id from logs)a</div><div class="line">join (select *, r_id from items </div><div class="line">lateral view explode(range_list(1,10)) rl as r_id)b</div><div class="line">on a.item_id = b.item_id and a.r_id = b.r_id</div></pre></td></tr></table></figure><p>上面的写法里，对行为表的每条记录生成一个1-10的随机整数，对于item属性表，每个item生成10条记录，随机key分别也是1-10，这样就能保证行为表关联上属性表。其中range_list(1,10)代表用udf实现的一个返回1-10整数序列的方法。这个做法是一个解决join倾斜比较根本性的通用思路，就是如何用随机数将key进行分散。当然，可以根据具体的业务场景做实现上的简化或变化。</p><h3 id="2-4-业务设计"><a href="#2-4-业务设计" class="headerlink" title="2.4 业务设计"></a>2.4 业务设计</h3><p>除了上面两类情况，还有一类情况是因为业务设计导致的问题，也就是说即使行为日志里面join key的数据分布本身并不明显倾斜，但是业务设计导致其倾斜。比如对于商品item_id的编码，除了本身的id序列，还人为的把item的类型也作为编码放在最后两位，这样如果类型1（电子产品）的编码是00，类型2（家居产品）的编码是01，并且类型1是主要商品类，将会造成以00为结尾的商品整体倾斜。这时，如果reduce的数量恰好是100的整数倍，会造成partitioner把00结尾的item_id都hash到同一个reducer，引爆问题。这种特殊情况可以简单的设置合适的reduce值来解决，但是这种坑对于不了解业务的情况下就会比较隐蔽。</p><h2 id="三、典型的业务场景"><a href="#三、典型的业务场景" class="headerlink" title="三、典型的业务场景"></a>三、典型的业务场景</h2><h3 id="3-1-空值产生的数据倾斜"><a href="#3-1-空值产生的数据倾斜" class="headerlink" title="3.1 空值产生的数据倾斜"></a>3.1 空值产生的数据倾斜</h3><p>场景：如日志中，常会有信息丢失的问题，比如日志中的 user_id，如果取其中的 user_id 和 用户表中的user_id 关联，会碰到数据倾斜的问题。</p><ul><li>解决方法1： user_id为空的不参与关联（红色字体为修改后）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">select * from log a</div><div class="line">  join users b</div><div class="line">  on a.user_id is not null</div><div class="line">  and a.user_id = b.user_id</div><div class="line">union all</div><div class="line">select * from log a</div><div class="line">  where a.user_id is null;</div></pre></td></tr></table></figure><ul><li>解决方法2 ：赋与空值分新的key值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">select *</div><div class="line">  from log a</div><div class="line">  left outer join users b</div><div class="line">  on case when a.user_id is null then concat(‘hive’,rand() ) else a.user_id end = b.user_id;</div></pre></td></tr></table></figure><p>结论：方法2比方法1效率更好，不但io少了，而且作业数也少了。解决方法1中 log读取两次，jobs是2。解决方法2 job数是1 。这个优化适合无效 id (比如 -99 , ’’, null 等) 产生的倾斜问题。把空值的 key 变成一个字符串加上随机数，就能把倾斜的数据分到不同的reduce上 ,解决数据倾斜问题。</p><h3 id="3-2-不同数据类型关联产生数据倾斜"><a href="#3-2-不同数据类型关联产生数据倾斜" class="headerlink" title="3.2 不同数据类型关联产生数据倾斜"></a>3.2 不同数据类型关联产生数据倾斜</h3><p>场景：用户表中user_id字段为int，log表中user_id字段既有string类型也有int类型。当按照user_id进行两个表的Join操作时，默认的Hash操作会按int型的id来进行分配，这样会导致所有string类型id的记录都分配到一个Reducer中。</p><p>解决方法：把数字类型转换成字符串类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select * from users a</div><div class="line">  left outer join logs b</div><div class="line">  on a.usr_id = cast(b.user_id as string)</div></pre></td></tr></table></figure><h3 id="3-3-小表不小不大，怎么用-map-join-解决倾斜问题"><a href="#3-3-小表不小不大，怎么用-map-join-解决倾斜问题" class="headerlink" title="3.3 小表不小不大，怎么用 map join 解决倾斜问题"></a>3.3 小表不小不大，怎么用 map join 解决倾斜问题</h3><p>使用 map join 解决小表(记录数少)关联大表的数据倾斜问题，这个方法使用的频率非常高，但如果小表很大，大到map join会出现bug或异常，这时就需要特别的处理。 以下例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select * from log a</div><div class="line">  left outer join users b</div><div class="line">  on a.user_id = b.user_id;</div></pre></td></tr></table></figure><p>users 表有 600w+ 的记录，把 users 分发到所有的 map 上也是个不小的开销，而且 map join 不支持这么大的小表。如果用普通的 join，又会碰到数据倾斜的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">select /*+mapjoin(x)*/* from log a</div><div class="line">  left outer join (</div><div class="line">    select  /*+mapjoin(c)*/d.*</div><div class="line">      from ( select distinct user_id from log ) c</div><div class="line">      join users d</div><div class="line">      on c.user_id = d.user_id</div><div class="line">    ) x</div><div class="line">  on a.user_id = b.user_id;</div></pre></td></tr></table></figure><p>假如，log里user_id有上百万个，这就又回到原来map join问题。所幸，每日的会员uv不会太多，有交易的会员不会太多，有点击的会员不会太多，有佣金的会员不会太多等等。所以这个方法能解决很多场景下的数据倾斜问题。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>使map的输出数据更均匀的分布到reduce中去，是我们的最终目标。由于Hash算法的局限性，按key Hash会或多或少的造成数据倾斜。大量经验表明数据倾斜的原因是人为的建表疏忽或业务逻辑可以规避的。在此给出较为通用的步骤：</p><ul><li>1）采样log表，哪些user_id比较倾斜，得到一个结果表tmp1。由于对计算框架来说，所有的数据过来，他都是不知道数据分布情况的，所以采样是并不可少的。</li><li>2）数据的分布符合社会学统计规则，贫富不均。倾斜的key不会太多，就像一个社会的富人不多，奇特的人不多一样。所以tmp1记录数会很少。把tmp1和users做map join生成tmp2,把tmp2读到distribute file cache。这是一个map过程。</li><li>3）map读入users和log，假如记录来自log,则检查user_id是否在tmp2里，如果是，输出到本地文件a,否则生成<user_id,value>的key,value对，假如记录来自member,生成<user_id,value>的key,value对，进入reduce阶段。</user_id,value></user_id,value></li><li>4）最终把a文件，把Stage3 reduce阶段输出的文件合并起写到hdfs。</li></ul><p>如果确认业务需要这样倾斜的逻辑，考虑以下的优化方案：</p><ul><li>1）对于join，在判断小表不大于1G的情况下，使用map join</li><li>2）对于group by或distinct，设定 hive.groupby.skewindata=true</li><li>3）尽量使用上述的SQL语句调节进行优化</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据倾斜是大数据领域绕不开的拦路虎，当你所需处理的数据量到达了上亿甚至是千亿条的时候，数据倾斜将是横在你面前一道巨大的坎。很可能有几周甚至几月都要头疼于数据倾斜导致的各类诡异的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="数据分析" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="数据倾斜" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C/"/>
    
      <category term="Hive" scheme="http://yoursite.com/tags/Hive/"/>
    
  </entry>
  
  <entry>
    <title>数据分析系列（2）：卡方检验</title>
    <link href="http://yoursite.com/2017/06/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%882%EF%BC%89%EF%BC%9A%E5%8D%A1%E6%96%B9%E6%A3%80%E9%AA%8C/"/>
    <id>http://yoursite.com/2017/06/10/数据分析系列（2）：卡方检验/</id>
    <published>2017-06-10T15:14:45.000Z</published>
    <updated>2017-12-26T06:39:35.980Z</updated>
    
    <content type="html"><![CDATA[<p>$\chi^2$检验（chi-square test）或称卡方检验，是一种用途较广的假设检验方法，，主要是比较两个及两个以上样本率( 构成比）以及两个分类变量的关联性分析。其根本思想就是在于比较理论频数和实际频数的吻合程度或拟合优度问题。</p><a id="more"></a><p>它的发明者卡尔·皮尔逊是一位历史上罕见的百科全书式的学者，研究领域涵盖了生物、历史、宗教、哲学、法律。在文本分类中可以用卡方值做特征选择（降维），也可以用卡方检验做异常用户的检测。</p><h2 id="一、四格表资料的卡方检验"><a href="#一、四格表资料的卡方检验" class="headerlink" title="一、四格表资料的卡方检验"></a>一、四格表资料的卡方检验</h2><p>两组大白鼠在不同致癌剂作用下的发癌率如下表，问两组发癌率有无差别？<br><img src="http://omu7tit09.bkt.clouddn.com/14993074249833.png" alt=""></p><p>这四格资料表就专称四格表（fourfold table），或称2行2列表（2×2 contingency table）。从该资料算出的两组发癌率分别为73.24%和92.86%，两者的差别可能是抽样误差所致，亦可能是两组发癌率（总体率）确有所不同。这里可通过卡方检验来区别其差异有无统计学意义，检验的基本公式为：</p><script type="math/tex; mode=display">\chi^2=\sum \frac{(A-T)^2}{T}</script><p>式中A为实际数，以上四格表的四个数据就是实际数。T为理论数，是根据检验假设推断出来的；即假设这两组的发癌率本无不同，差别仅是由抽样误差所致。这里可将两组合计发癌率作为理论上的发癌率，即91/113=80.3%，以此为依据便可推算出四格表中相应的四格的理论数。以表1资料为例检验如下。</p><p>检验步骤：</p><ul><li>1）建立检验假设：$H_0:\ n_1=n_2 \ H_1 : n_1 ≠n_2;$</li><li>2）计算理论数（TRC）,计算公式为：<script type="math/tex; mode=display">TRC = \frac{n_r\times n_c}{n}</script>式中$TRC$是表示第R行C列格子的理论数，$n_r$是与理论数同行的合计数，$n_c$是与理论数同列的合计数，$n$为总例数。</li></ul><p>第1行1列： 71×91/113=57.18<br>第1行2列： 71×22/113=13.82<br>第2行1列： 42×91/113=33.82<br>第2行2列： 42×22/113=8.18</p><p>以推算结果，可与原四项实际数并列成下表：<br><img src="http://omu7tit09.bkt.clouddn.com/14993078536823.png" alt=""><br>因为上表每行和每列合计数都是固定的，所以只要用TRC式求得其中一项理论数（例如T1.1=57.18），则其余三项理论数都可用同行或同列合计数相减，直接求出。</p><ul><li>3）计算卡方值按公式代入<script type="math/tex; mode=display">\chi^2 = \frac{(52-57.18)^2}{57.18}···+ \frac{(3-8.18)^2}{8.18}=6.48</script></li><li>4）查卡方值表求$P$值</li></ul><p>在查表之前应知本题自由度。按卡方检验的自由度v=（行数-1）（列数-1），则该题的自由度v=（2-1）（2-1）=1，查卡方界值表，找到$\chi^2_{0.05}(1)=3.85$，而本题卡方=6.48即卡方＞$\chi^2_{0.05}(1)$，P＜0.05，差异有显著统计学意义，按α=0.05水准，拒绝H0，可以认为两组发癌率有差别。</p><p>通过实例计算，读者对卡方的基本公式有如下理解：若各理论数与相应实际数相差越小，卡方值越小；如两者相同，则卡方值必为零，而卡方永远为正值。又因为每一对理论数和实际数都加入卡方值中，分组越多，即格子数越多，卡方值也会越大，因而每考虑卡方值大小的意义时同时要考虑到格子数。因此自由度大时，卡方的界值也相应增大。</p><h2 id="二、四格表卡方值的校正"><a href="#二、四格表卡方值的校正" class="headerlink" title="二、四格表卡方值的校正"></a>二、四格表卡方值的校正</h2><p>卡方值表是数理统计根据正态分布中$\chi^2 = \sum (\frac{x_i-\mu }{\sigma})^2$的定义计算出来的。是一种近似。在自由度大于1、理论数皆大于5时，这种近似很好；当自由度为1时，尤其当1＜T＜5，而n＞40时，应用以下校正公式：</p><script type="math/tex; mode=display">\chi^2 = \frac{\sum{(|A-T|-0.5)^2}}{T}</script><p>例2.某医师用甲、乙两疗法治疗小儿单纯性消化不良，结果小表试比较两种疗法效果有无差异？</p><p><img src="http://omu7tit09.bkt.clouddn.com/14993090223178.png" alt=""><br>从表可见，T1.2和T2.2数值都＜5，且总例数大于40，故宜用校正公式检验。步骤如下：</p><ul><li><p>1）检验假设：$H_0：π1=π2；H_1：π1≠π2；α=0.05$</p></li><li><p>2）计算理论数：（已完成列入四格表括弧中）</p></li><li><p>3）计算卡方值：应用校正公式运算如下：</p><script type="math/tex; mode=display">\chi^2 = \frac{\sum{(|A-T|-0.5)^2}}{T}=2.746</script><p>查卡方界值表$\chi^2_{0.05}(1)=3.84$，，故卡方＜$\chi^2_{0.05}(1)$，P＞0.05。按α=0.05水准，接受H0，两种疗效差异无统计学意义。 </p></li></ul><p>如果不采用校正公式，而用原基本公式，算得的结果卡方=4.068，则结论就不同了。</p><p>如果观察资料的T＜1或n＜40时，四格表资料用上述校正法也不行，可参考预防医学专业用的医学统计学教材中的Fisher精确检验法直接计算概率以作判断。</p><h2 id="三、行列表的卡方检验"><a href="#三、行列表的卡方检验" class="headerlink" title="三、行列表的卡方检验"></a>三、行列表的卡方检验</h2><p>适用于两个组以上的率或百分比差别的显著性检验。其检验步骤与上述相同，简单计算公式如下：</p><script type="math/tex; mode=display">\chi^2 = n(\sum \frac{A^2}{n_rn_c}-1 )</script><p>式中n为总例数；A为各观察值；$n_r$和$n_c$为与各A值相应的行和列合计的总数。</p><p>例3.北方冬季日照短而南移，居宅设计如何适应以获得最大日照量，增强居民体质，减少小儿佝偻病，实属重要。胡氏等1986年在北京进行住宅建筑日照卫生标准的研究，对214幢楼房居民的婴幼儿712人体检，检出轻度佝偻病333例，比较了居室朝向与患病的关系。现将该资料归纳如表4作行列检验。</p><p>该表资料由2行4列组成，称2×4表，可用行×列卡方公式检验。</p><ul><li>1）检验假设：H0：四类朝向居民婴幼儿佝偻病患病率相同；H1：四类朝向居民婴幼儿佝偻病患率不同；α=0.05</li><li>2）计算卡方值：<script type="math/tex; mode=display">\chi^2 = 712(\frac{180^2}{379\times 380 }+···+\frac{33^2}{333\times 98}-1)=15.079</script></li><li>3）确定P值和分析：本题v=（2-1)（4-3）=3，据此查卡方界值表：$\chi^2_{0.05}(3)=7.81$，本题卡方=15.08，卡方＞ $\chi^2_{0.05}(3)$，P＜0.05，拒绝$H_0$，可以认为居室朝向不同的居民，婴幼儿佝偻病患病率有差异。</li></ul><p>一般认为行列表中不宜有1/5以上格子的理论数小于5，或有小于1的理论数。当理论数太小可采取下列方法处理：①增加样本含量以增大理论数；②删去上述理论数太小的行和列；③将太小理论数所在行或列与性质相近的邻行邻列中的实际数合并，使重新计算的理论数增大。由于后两法可能会损失信息，损害样本的随机性，不同的合并方式有可能影响推断结论，故不宜作常规方法。另外，不能把不同性质的实际数合并，如研究血型时，不能把不同的血型资料合并。</p><p>如检验结果拒绝检验假设，只能认为各总体率或总体构成比之间总的来说有差别，但不能说明它们彼此之间都有差别，或某两者间有差别。</p><h2 id="四、应用场景"><a href="#四、应用场景" class="headerlink" title="四、应用场景"></a>四、应用场景</h2><p>卡方检验的一个典型应用场景是衡量特定条件下的分布是否与理论分布一致，比如：特定用户某项指标的分布与大盘的分布是否差异很大，这时通过临界概率可以合理又科学的筛选异常用户。</p><p>另外，x2值描述了自变量与因变量之间的相关程度：x2值越大，相关程度也越大，所以很自然的可以利用x2值来做降维，保留相关程度大的变量。再回到刚才新闻分类的场景，如果我们希望获取和娱乐类别相关性最强的100个词，以后就按照标题是否包含这100个词来确定新闻是否归属于娱乐类，怎么做？很简单，对娱乐类新闻标题所包含的每个词按上述步骤计算x2值，然后按x2值排序，取x2值最大的100个词。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;$\chi^2$检验（chi-square test）或称卡方检验，是一种用途较广的假设检验方法，，主要是比较两个及两个以上样本率( 构成比）以及两个分类变量的关联性分析。其根本思想就是在于比较理论频数和实际频数的吻合程度或拟合优度问题。&lt;/p&gt;
    
    </summary>
    
      <category term="数据分析" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="卡方检验" scheme="http://yoursite.com/tags/%E5%8D%A1%E6%96%B9%E6%A3%80%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>数据分析系列（1）：SQL查询执行顺序</title>
    <link href="http://yoursite.com/2017/06/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%881%EF%BC%89%EF%BC%9ASQL%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <id>http://yoursite.com/2017/06/09/数据分析系列（1）：SQL查询执行顺序/</id>
    <published>2017-06-09T15:14:45.000Z</published>
    <updated>2017-12-26T06:39:31.366Z</updated>
    
    <content type="html"><![CDATA[<p>SQL语句有一个让大部分人都感到困惑的特性，就是：SQL语句的执行顺序跟其语句的语法顺序并不一致。SQL语句的执行顺序是：</p><a id="more"></a><ol><li>FROM</li><li>ON</li><li>JOIN</li><li>WHERE</li><li>GROUP BY</li><li>HAVING</li><li>SELECT</li><li>DISTINCT</li><li>UNION</li><li>ORDER BY</li><li>LIMIT</li></ol><h2 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h2><p>这里的测试操作都是在MySQL数据库上完成的。</p><h3 id="1-1-新建数据库"><a href="#1-1-新建数据库" class="headerlink" title="1.1 新建数据库"></a>1.1 新建数据库</h3><p>首先我们新建一个测试数据库TestDB</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">create database TestDB;</div></pre></td></tr></table></figure><h3 id="1-2-创建测试集table1和table2"><a href="#1-2-创建测试集table1和table2" class="headerlink" title="1.2 创建测试集table1和table2"></a>1.2 创建测试集table1和table2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE table1</div><div class="line"> (</div><div class="line">     customer_id VARCHAR(10) NOT NULL,</div><div class="line">     city VARCHAR(10) NOT NULL,</div><div class="line">     PRIMARY KEY(customer_id)</div><div class="line"> )ENGINE=INNODB DEFAULT CHARSET=UTF8;</div><div class="line"></div><div class="line"> CREATE TABLE table2</div><div class="line"> (</div><div class="line">     order_id INT NOT NULL auto_increment,</div><div class="line">     customer_id VARCHAR(10),</div><div class="line">     PRIMARY KEY(order_id)</div><div class="line"> )ENGINE=INNODB DEFAULT CHARSET=UTF8;</div></pre></td></tr></table></figure><h3 id="1-3-插入测试数据"><a href="#1-3-插入测试数据" class="headerlink" title="1.3 插入测试数据"></a>1.3 插入测试数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">INSERT INTO table1(customer_id,city) VALUES(&apos;163&apos;,&apos;hangzhou&apos;);</div><div class="line"> INSERT INTO table1(customer_id,city) VALUES(&apos;9you&apos;,&apos;shanghai&apos;);</div><div class="line"> INSERT INTO table1(customer_id,city) VALUES(&apos;tx&apos;,&apos;hangzhou&apos;);</div><div class="line"> INSERT INTO table1(customer_id,city) VALUES(&apos;baidu&apos;,&apos;hangzhou&apos;);</div><div class="line"></div><div class="line"> INSERT INTO table2(customer_id) VALUES(&apos;163&apos;);</div><div class="line"> INSERT INTO table2(customer_id) VALUES(&apos;163&apos;);</div><div class="line"> INSERT INTO table2(customer_id) VALUES(&apos;9you&apos;);</div><div class="line"> INSERT INTO table2(customer_id) VALUES(&apos;9you&apos;);</div><div class="line"> INSERT INTO table2(customer_id) VALUES(&apos;9you&apos;);</div><div class="line"> INSERT INTO table2(customer_id) VALUES(&apos;tx&apos;);</div><div class="line"> INSERT INTO table2(customer_id) VALUES(NULL);</div></pre></td></tr></table></figure><p>准备工作做完以后，table1和table2看起来应该像下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select * from table1;</div><div class="line">+-------------+----------+</div><div class="line">| customer_id | city     |</div><div class="line">+-------------+----------+</div><div class="line">| 163         | hangzhou |</div><div class="line">| 9you        | shanghai |</div><div class="line">| baidu       | hangzhou |</div><div class="line">| tx          | hangzhou |</div><div class="line">+-------------+----------+</div><div class="line">4 rows in set (0.00 sec)</div><div class="line"></div><div class="line">mysql&gt; select * from table2;</div><div class="line">+----------+-------------+</div><div class="line">| order_id | customer_id |</div><div class="line">+----------+-------------+</div><div class="line">|        1 | 163         |</div><div class="line">|        2 | 163         |</div><div class="line">|        3 | 9you        |</div><div class="line">|        4 | 9you        |</div><div class="line">|        5 | 9you        |</div><div class="line">|        6 | tx          |</div><div class="line">|        7 | NULL        |</div><div class="line">+----------+-------------+</div><div class="line">7 rows in set (0.00 sec)</div></pre></td></tr></table></figure><h3 id="1-4-准备SQL查询语句"><a href="#1-4-准备SQL查询语句" class="headerlink" title="1.4 准备SQL查询语句"></a>1.4 准备SQL查询语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">SELECT a.customer_id, COUNT(b.order_id) as total_orders</div><div class="line"> FROM table1 AS a</div><div class="line"> LEFT JOIN table2 AS b</div><div class="line"> ON a.customer_id = b.customer_id</div><div class="line"> WHERE a.city = &apos;hangzhou&apos;</div><div class="line"> GROUP BY a.customer_id</div><div class="line"> HAVING count(b.order_id) &lt; 2</div><div class="line"> ORDER BY total_orders DESC;</div></pre></td></tr></table></figure><p>这些测试表和测试数据均来自《MySQL技术内幕：SQL编程》，接下来根据这个语句来详细地讲述SQL逻辑查询语句的执行顺序。</p><h2 id="二、SQL查询语句执行顺序"><a href="#二、SQL查询语句执行顺序" class="headerlink" title="二、SQL查询语句执行顺序"></a>二、SQL查询语句执行顺序</h2><p>现在，我们先给出一个查询语句的执行顺序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(7)     SELECT </div><div class="line">(8)     DISTINCT &lt;select_list&gt;</div><div class="line">(1)     FROM &lt;left_table&gt;</div><div class="line">(3)     &lt;join_type&gt; JOIN &lt;right_table&gt;</div><div class="line">(2)     ON &lt;join_condition&gt;</div><div class="line">(4)     WHERE &lt;where_condition&gt;</div><div class="line">(5)     GROUP BY &lt;group_by_list&gt;</div><div class="line">(6)     HAVING &lt;having_condition&gt;</div><div class="line">(9)     ORDER BY &lt;order_by_condition&gt;</div><div class="line">(10)    LIMIT &lt;limit_number&gt;</div></pre></td></tr></table></figure><p>在这些SQL语句的执行过程中，都会产生一个虚拟表，用来保存SQL语句的执行结果（这是重点），现在就追踪这个虚拟表的变化，得到最终的查询结果的过程，来分析整个SQL逻辑查询的执行顺序和过程。</p><h3 id="2-1-执行FROM语句"><a href="#2-1-执行FROM语句" class="headerlink" title="2.1 执行FROM语句"></a>2.1 执行FROM语句</h3><p>第一步，执行<code>FROM</code>语句。我们首先需要知道最开始从哪个表开始的，这就是<code>FROM</code>告诉我们的。现在有了<code>left table</code>和<code>right table</code>两个表，我们到底从哪个表开始，还是会从两个表进行某种联系以后再开始呢？它们之间如何产生联系呢？——笛卡尔积<br>，笛卡尔积是所有可能的有序对组成的集合，其中有序对的第一个对象是X的成员，第二个对象是Y的成员。</p><p>经过<code>FROM</code>语句对两个表执行笛卡尔积，会得到一个虚拟表，暂且叫VT1(vitual table 1)，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">+-------------+----------+----------+-------------+</div><div class="line">| customer_id | city     | order_id | customer_id |</div><div class="line">+-------------+----------+----------+-------------+</div><div class="line">| 163         | hangzhou |        1 | 163         |</div><div class="line">| 9you        | shanghai |        1 | 163         |</div><div class="line">| baidu       | hangzhou |        1 | 163         |</div><div class="line">| tx          | hangzhou |        1 | 163         |</div><div class="line">| 163         | hangzhou |        2 | 163         |</div><div class="line">| 9you        | shanghai |        2 | 163         |</div><div class="line">| baidu       | hangzhou |        2 | 163         |</div><div class="line">| tx          | hangzhou |        2 | 163         |</div><div class="line">| 163         | hangzhou |        3 | 9you        |</div><div class="line">| 9you        | shanghai |        3 | 9you        |</div><div class="line">| baidu       | hangzhou |        3 | 9you        |</div><div class="line">| tx          | hangzhou |        3 | 9you        |</div><div class="line">| 163         | hangzhou |        4 | 9you        |</div><div class="line">| 9you        | shanghai |        4 | 9you        |</div><div class="line">| baidu       | hangzhou |        4 | 9you        |</div><div class="line">| tx          | hangzhou |        4 | 9you        |</div><div class="line">| 163         | hangzhou |        5 | 9you        |</div><div class="line">| 9you        | shanghai |        5 | 9you        |</div><div class="line">| baidu       | hangzhou |        5 | 9you        |</div><div class="line">| tx          | hangzhou |        5 | 9you        |</div><div class="line">| 163         | hangzhou |        6 | tx          |</div><div class="line">| 9you        | shanghai |        6 | tx          |</div><div class="line">| baidu       | hangzhou |        6 | tx          |</div><div class="line">| tx          | hangzhou |        6 | tx          |</div><div class="line">| 163         | hangzhou |        7 | NULL        |</div><div class="line">| 9you        | shanghai |        7 | NULL        |</div><div class="line">| baidu       | hangzhou |        7 | NULL        |</div><div class="line">| tx          | hangzhou |        7 | NULL        |</div><div class="line">+-------------+----------+----------+-------------+</div></pre></td></tr></table></figure><p>总共有28（table1的记录数*table2的记录总数）条记录。这就是VT1的结果，接下来的操作就在VT!的基础上进行。</p><h3 id="2-2-执行ON过滤"><a href="#2-2-执行ON过滤" class="headerlink" title="2.2 执行ON过滤"></a>2.2 执行ON过滤</h3><p>执行完笛卡尔积以后，接着就进行<code>ON a.customer_id = b.customer_id</code>条件过滤，根据<code>ON</code>中指定的条件，去掉那些不符合条件的数据，得到VT2表，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">+-------------+----------+----------+-------------+</div><div class="line">| customer_id | city     | order_id | customer_id |</div><div class="line">+-------------+----------+----------+-------------+</div><div class="line">| 163         | hangzhou |        1 | 163         |</div><div class="line">| 163         | hangzhou |        2 | 163         |</div><div class="line">| 9you        | shanghai |        3 | 9you        |</div><div class="line">| 9you        | shanghai |        4 | 9you        |</div><div class="line">| 9you        | shanghai |        5 | 9you        |</div><div class="line">| tx          | hangzhou |        6 | tx          |</div><div class="line">+-------------+----------+----------+-------------+</div></pre></td></tr></table></figure><p>VT2就是经过<code>ON</code>条件筛选以后得到的有用数据，而接下来的操作将在VT2的基础上继续进行。</p><h3 id="2-3-添加外部行"><a href="#2-3-添加外部行" class="headerlink" title="2.3 添加外部行"></a>2.3 添加外部行</h3><p>这一步只有在连接类型为<code>OUTER JOIN</code>时才发生，如<code>LEFT OUTER JOIN</code>、<code>RIGHT OUTER JOIN</code>和<code>FULL OUTER JOIN</code>。在大多数的时候，我们都是会省略掉<code>OUTER</code>关键字的，但<code>OUTER</code>表示的就是外部行的概念。</p><p><code>LEFT OUTER JOIN</code>把左表记为保留表，得到的结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">+-------------+----------+----------+-------------+</div><div class="line">| customer_id | city     | order_id | customer_id |</div><div class="line">+-------------+----------+----------+-------------+</div><div class="line">| 163         | hangzhou |        1 | 163         |</div><div class="line">| 163         | hangzhou |        2 | 163         |</div><div class="line">| 9you        | shanghai |        3 | 9you        |</div><div class="line">| 9you        | shanghai |        4 | 9you        |</div><div class="line">| 9you        | shanghai |        5 | 9you        |</div><div class="line">| tx          | hangzhou |        6 | tx          |</div><div class="line">| baidu       | hangzhou |     NULL | NULL        |</div><div class="line">+-------------+----------+----------+-------------+</div></pre></td></tr></table></figure><p><code>RIGHT OUTER JOIN</code>把右表记为保留表，得到的结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">+-------------+----------+----------+-------------+</div><div class="line">| customer_id | city     | order_id | customer_id |</div><div class="line">+-------------+----------+----------+-------------+</div><div class="line">| 163         | hangzhou |        1 | 163         |</div><div class="line">| 163         | hangzhou |        2 | 163         |</div><div class="line">| 9you        | shanghai |        3 | 9you        |</div><div class="line">| 9you        | shanghai |        4 | 9you        |</div><div class="line">| 9you        | shanghai |        5 | 9you        |</div><div class="line">| tx          | hangzhou |        6 | tx          |</div><div class="line">| NULL        | NULL     |        7 | NULL        |</div><div class="line">+-------------+----------+----------+-------------+</div></pre></td></tr></table></figure><p><code>FULL OUTER JOIN</code>把左右表都作为保留表，得到的结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">+-------------+----------+----------+-------------+</div><div class="line">| customer_id | city     | order_id | customer_id |</div><div class="line">+-------------+----------+----------+-------------+</div><div class="line">| 163         | hangzhou |        1 | 163         |</div><div class="line">| 163         | hangzhou |        2 | 163         |</div><div class="line">| 9you        | shanghai |        3 | 9you        |</div><div class="line">| 9you        | shanghai |        4 | 9you        |</div><div class="line">| 9you        | shanghai |        5 | 9you        |</div><div class="line">| tx          | hangzhou |        6 | tx          |</div><div class="line">| baidu       | hangzhou |     NULL | NULL        |</div><div class="line">| NULL        | NULL     |        7 | NULL        |</div><div class="line">+-------------+----------+----------+-------------+</div></pre></td></tr></table></figure><p>添加外部行的工作就是在VT2表的基础上添加保留表中被过滤条件过滤掉的数据，非保留表中的数据被赋予了NULL值，最后生成虚拟表VT3。</p><p>由于在准备的测试SQL查询逻辑语句中使用的是<code>LEFT JOIN</code>，过滤掉了以下这条数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">| baidu       | hangzhou |</div></pre></td></tr></table></figure><p>现在就把这条数据添加到VT2表中，得到的VT3表如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">+-------------+----------+----------+-------------+</div><div class="line">| customer_id | city     | order_id | customer_id |</div><div class="line">+-------------+----------+----------+-------------+</div><div class="line">| 163         | hangzhou |        1 | 163         |</div><div class="line">| 163         | hangzhou |        2 | 163         |</div><div class="line">| 9you        | shanghai |        3 | 9you        |</div><div class="line">| 9you        | shanghai |        4 | 9you        |</div><div class="line">| 9you        | shanghai |        5 | 9you        |</div><div class="line">| tx          | hangzhou |        6 | tx          |</div><div class="line">| baidu       | hangzhou |     NULL | NULL        |</div><div class="line">+-------------+----------+----------+-------------+</div></pre></td></tr></table></figure><p>接下里的操作都会在该VT3表上进行。</p><h3 id="2-4-执行WHERE过滤"><a href="#2-4-执行WHERE过滤" class="headerlink" title="2.4 执行WHERE过滤"></a>2.4 执行WHERE过滤</h3><p>对添加外部行得到的VT3进行WHERE过滤，只有符合<where_condition>的记录才会输出到虚拟表VT4中。当我们执行<code>WHERE a.city = &#39;hangzhou&#39;</code>的时候，就会得到以下内容，并存在虚拟表VT4中：</where_condition></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+-------------+----------+----------+-------------+</div><div class="line">| customer_id | city     | order_id | customer_id |</div><div class="line">+-------------+----------+----------+-------------+</div><div class="line">| 163         | hangzhou |        1 | 163         |</div><div class="line">| 163         | hangzhou |        2 | 163         |</div><div class="line">| tx          | hangzhou |        6 | tx          |</div><div class="line">| baidu       | hangzhou |     NULL | NULL        |</div><div class="line">+-------------+----------+----------+-------------+</div></pre></td></tr></table></figure><p>但是在使用WHERE字句时，需要注意以下两点：</p><ul><li><ol><li>由于数据还没有分组，因此还不能在WHERE过滤器中使用<code>where_condition =MIN(col)</code>这类分组统计的过滤；</li></ol></li><li><ol><li>由于还没有进行列的选取操作，因此在WHERE中使用列的别名也是不被允许的，如：<code>SELECT city AS c FROM t WHERE c=&#39;shanghai&#39;;</code>是不允许出现的。</li></ol></li></ul><h3 id="2-5-执行GROUP-BY分组"><a href="#2-5-执行GROUP-BY分组" class="headerlink" title="2.5 执行GROUP BY分组"></a>2.5 执行GROUP BY分组</h3><p><code>GROUP BY</code>子句主要是对使用<code>WHERE</code>子句得到的虚拟表进行分组操作。即“根据(by)一定的规则进行分组(Group)”。它的作用是通过一定的规则将一个数据集划分成若干个小的区域，然后针对若干个小区域进行数据处理。我们执行测试语句中的<code>GROUP BY a.customer_id</code>，就是对VT4按照<code>a.customer_id</code>进行了分组，这里就得到了以下三个组别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">第一组</div><div class="line">+-------------+----------+----------+-------------+</div><div class="line">| customer_id | city     | order_id | customer_id |</div><div class="line">+-------------+----------+----------+-------------+</div><div class="line">| 163         | hangzhou |        1 | 163         |</div><div class="line">| 163         | hangzhou |        2 | 163         |</div><div class="line">第二组</div><div class="line">| tx          | hangzhou |        6 | tx          |</div><div class="line">第三组</div><div class="line">| baidu       | hangzhou |     NULL | NULL        |</div><div class="line">+-------------+----------+----------+-------------+</div></pre></td></tr></table></figure><p>得到的内容会存入虚拟表VT5中，此时，我们就得到了一个VT5虚拟表，接下来的操作都会在该表上完成。</p><h3 id="2-6-执行HAVING过滤"><a href="#2-6-执行HAVING过滤" class="headerlink" title="2.6 执行HAVING过滤"></a>2.6 执行HAVING过滤</h3><p>HAVING字句主要和<code>GROUP BY</code>字句配合使用，对分组得到的VT5虚拟表进行条件过滤。当我执行测试语句中的<code>HAVING COUNT(b.order_id)&lt;2</code>时，将得到以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">+-------------+----------+----------+-------------+</div><div class="line">| customer_id | city     | order_id | customer_id |</div><div class="line">+-------------+----------+----------+-------------+</div><div class="line">| baidu       | hangzhou |     NULL | NULL        |</div><div class="line">| tx          | hangzhou |        6 | tx          |</div><div class="line">+-------------+----------+----------+-------------+</div></pre></td></tr></table></figure><p>这就是虚拟表6</p><h3 id="2-7-SELECT列表"><a href="#2-7-SELECT列表" class="headerlink" title="2.7 SELECT列表"></a>2.7 SELECT列表</h3><p>现在才会执行到SELECT子句，不要以为<code>SELECT</code>子句被写在第一行，就是第一个被执行的。</p><p>执行测试语句中的<code>SELECT a.customer_id ,COUNT(b.oredr_id) as total_orders</code>，我们从虚拟表VT6中选择我们需要的内容。我们将得到以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">+-------------+--------------+</div><div class="line">| customer_id | total_orders |</div><div class="line">+-------------+--------------+</div><div class="line">| baidu       |            0 |</div><div class="line">| tx          |            1 |</div><div class="line">+-------------+--------------+</div></pre></td></tr></table></figure><h3 id="2-8-执行DISTINCT子句"><a href="#2-8-执行DISTINCT子句" class="headerlink" title="2.8 执行DISTINCT子句"></a>2.8 执行DISTINCT子句</h3><p>如果在查询中指定了<code>DISTINCT</code>子句，则会创建一张内存临时表（如果内存放不下，就需要存放在硬盘了）。这张临时表的表结构和上一步产生的虚拟表VT7是一样的，不同的是对进行DISTINCT操作的列增加了一个唯一索引，以此来去除重复数据。</p><p>由于测试SQL语句中并没有使用DISTINCT，所以，在该查询中，这一步不会生成一个虚拟表。</p><h3 id="2-9-执行ORDER-BY子句"><a href="#2-9-执行ORDER-BY子句" class="headerlink" title="2.9 执行ORDER BY子句"></a>2.9 执行ORDER BY子句</h3><p>对虚拟表中的内容按照指定的列进行排序，然后返回一个新的虚拟表，我们执行测试SQL语句中的<code>ORDER BY total_orders DESC</code>，就会得到以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">+-------------+--------------+</div><div class="line">| customer_id | total_orders |</div><div class="line">+-------------+--------------+</div><div class="line">| tx          |            1 |</div><div class="line">| baidu       |            0 |</div><div class="line">+-------------+--------------+</div></pre></td></tr></table></figure></p><p>可以看到这是对<code>total_orders</code>列进行降序排列。上述结果会存储在VT8中。</p><h3 id="2-10执行LIMIT子句"><a href="#2-10执行LIMIT子句" class="headerlink" title="2.10执行LIMIT子句"></a>2.10执行LIMIT子句</h3><p><code>LIMIT</code>子句从上一步得到的VT8虚拟表中选出从指定位置开始的指定行数据。对于没有营养ORDER BY的LIMIT子句，得到的结果同样是无序的，所以，很多时候，我们都会看到LIMIT子句会和ORDER BY子句一起使用。</p><p>MYSQL数据库的LIMIT支持如下形式的选择：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LIMIT n, m</div></pre></td></tr></table></figure></p><p>表示从第n条记录开始选择m条记录。而很多开发人员喜欢使用该语句来解决分页问题。对于小数据，使用LIMIT子句没有任何问题，当数据量非常大的时候，使用LIMIT n, m是非常低效的。因为LIMIT的机制是每次都是从头开始扫描，如果需要从第60万行开始，读取3条数据，就需要先扫描定位到60万行，然后再进行读取，而扫描的过程是一个非常低效的过程。所以，对于大数据处理时，是非常有必要在应用层建立一定的缓存机制</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SQL语句有一个让大部分人都感到困惑的特性，就是：SQL语句的执行顺序跟其语句的语法顺序并不一致。SQL语句的执行顺序是：&lt;/p&gt;
    
    </summary>
    
      <category term="数据分析" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="SQL" scheme="http://yoursite.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Kaggle系列（1）：Kaggle 数据挖掘比赛经验分享</title>
    <link href="http://yoursite.com/2017/06/05/Kaggle%E7%B3%BB%E5%88%97%EF%BC%881%EF%BC%89%EF%BC%9AKaggle%20%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%AF%94%E8%B5%9B%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    <id>http://yoursite.com/2017/06/05/Kaggle系列（1）：Kaggle 数据挖掘比赛经验分享/</id>
    <published>2017-06-05T15:14:45.000Z</published>
    <updated>2017-12-26T06:38:51.364Z</updated>
    
    <content type="html"><![CDATA[<p>转载自知乎：<a href="https://zhuanlan.zhihu.com/p/26820998" target="_blank" rel="noopener">Kaggle 数据挖掘比赛经验分享</a> 作者是陈成龙，目前在腾讯社交与效果广告部任职数据挖掘工程师，负责 Lookalike 相似人群扩展相关工作。曾在 Kaggle 数据科学家排行榜排名全球第十，国内第一。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Kaggle 于 2010 年创立，专注于开展数据科学、机器学习相关的竞赛，是全球最大的数据科学社区和数据竞赛平台。笔者从 2013 年开始，陆续参加了多场 Kaggle上面举办的比赛，相继获得了 CrowdFlower 搜索相关性比赛第一名（1326支队伍）和 HomeDepot 商品搜索相关性比赛第三名（2125支队伍），曾在 Kaggle 数据科学家排行榜排名全球第十，国内第一。笔者目前在腾讯社交与效果广告部任职数据挖掘工程师，负责 Lookalike 相似人群扩展相关工作。此文分享笔者在参加数据挖掘比赛过程中的一点心得体会。</p><a id="more"></a><h2 id="一、Kaggle基本介绍"><a href="#一、Kaggle基本介绍" class="headerlink" title="一、Kaggle基本介绍"></a>一、Kaggle基本介绍</h2><p>Kaggle 于 2010 年创立，专注于开展数据科学、机器学习相关的竞赛，是全球最大的数据科学社区和数据竞赛平台。在 Kaggle 上，企业或者研究机构发布商业和科研难题，悬赏吸引全球的数据科学家，通过众包的方式解决建模问题。而参赛者可以接触到丰富的真实数据，解决实际问题，角逐名次，赢取奖金。诸如 Google，Facebook，Microsoft 等知名科技公司均在 Kaggle 上面举办过数据挖掘比赛。2017年3月，Kaggle 被 Google CloudNext 收购。</p><h3 id="1-1-参赛方式"><a href="#1-1-参赛方式" class="headerlink" title="1.1 参赛方式"></a>1.1 参赛方式</h3><p>可以以个人或者组队的形式参加比赛。组队人数一般没有限制，但需要在 Merger Deadline 前完成组队。为了能参与到比赛中，需要在 Entry Deadline 前进行至少一次有效提交。最简单地，可以直接提交官方提供的 Sample Submission。关于组队，建议先单独个人进行数据探索和模型构建，以个人身份进行比赛，在比赛后期（譬如离比赛结束还有 2~3 周）再进行组队，以充分发挥组队的效果（类似于模型集成，模型差异性越大，越有可能有助于效果的提升，超越单模型的效果）。当然也可以一开始就组好队，方便分工协作，讨论问题和碰撞火花。</p><p>Kaggle 对比赛的公正性相当重视。在比赛中，每个人只允许使用一个账号进行提交。在比赛结束后 1~2 周内，Kaggle 会对使用多账号提交的 Cheater 进行剔除（一般会对 Top 100 的队伍进行 Cheater Detection）。在被剔除者的 Kaggle 个人页面上，该比赛的成绩也会被删除，相当于该选手从没参加过这个比赛。此外，队伍之间也不能私自分享代码或者数据，除非在论坛上面公开发布。</p><p>比赛一般只提交测试集的预测结果，无需提交代码。每人（或每个队伍）每天有提交次数的限制，一般为2次或者5次，在 Submission 页面会有提示。</p><h3 id="1-2-比赛获奖"><a href="#1-2-比赛获奖" class="headerlink" title="1.2 比赛获奖"></a>1.2 比赛获奖</h3><p>Kaggle 比赛奖金丰厚，一般前三名均可以获得奖金。在最近落幕的第二届 National Data Science Bowl 中，总奖金池高达 100W 美刀，其中第一名可以获得 50W 美刀的奖励，即使是第十名也能收获 2.5W 美刀的奖金。获奖的队伍需要在比赛结束后 1~2 周内，准备好可执行的代码以及 README，算法说明文档等提交给 Kaggle 来进行获奖资格的审核。Kaggle 会邀请获奖队伍在 Kaggle Blog 中发表 Interview，来分享比赛故事和经验心得。对于某些比赛，Kaggle 或者主办方会邀请获奖队伍进行电话/视频会议，获奖队伍进行 Presentation，并与主办方团队进行交流。</p><h3 id="1-3-比赛类型"><a href="#1-3-比赛类型" class="headerlink" title="1.3 比赛类型"></a>1.3 比赛类型</h3><p>从 Kaggle 提供的官方分类来看，可以划分为以下类型（如下图1所示）：<br><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-14%20%E4%B8%8B%E5%8D%884.28.58.png" alt="屏幕快照 2017-06-14 下午4.28.58"></p><ul><li>Featured：商业或科研难题，奖金一般较为丰厚；</li><li>Recruitment：比赛的奖励为面试机会；</li><li>Research：科研和学术性较强的比赛，也会有一定的奖金，一般需要较强的领域和专业知识；</li><li>Playground：提供一些公开的数据集用于尝试模型和算法；</li><li>Getting Started：提供一些简单的任务用于熟悉平台和比赛；</li><li>In Class：用于课堂项目作业或者考试。</li></ul><p>从领域归属划分：包含搜索相关性，广告点击率预估，销量预估，贷款违约判定，癌症检测等。<br> 从任务目标划分：包含回归，分类（二分类，多分类，多标签），排序，混合体（分类+回归）等。<br> 从数据载体划分：包含文本，语音，图像和时序序列等。<br> 从特征形式划分：包含原始数据，明文特征，脱敏特征（特征的含义不清楚）等。</p><h3 id="1-4-比赛流程"><a href="#1-4-比赛流程" class="headerlink" title="1.4 比赛流程"></a>1.4 比赛流程</h3><p>一个数据挖掘比赛的基本流程如下图2所示，具体的模块我将在下一章进行展开陈述。<img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-14%20%E4%B8%8B%E5%8D%884.30.58.png" alt="屏幕快照 2017-06-14 下午4.30.58"></p><p>这里想特别强调的一点是，Kaggle 在计算得分的时候，有Public Leaderboard (LB)和 Private LB 之分。具体而言，参赛选手提交整个测试集的预测结果，Kaggle 使用测试集的一部分计算得分和排名，实时显示在 Public LB上，用于给选手提供及时的反馈和动态展示比赛的进行情况；测试集的剩余部分用于计算参赛选手的最终得分和排名，此即为 Private LB，在比赛结束后会揭晓。用于计算 Public LB 和 Private LB 的数据有不同的划分方式，具体视比赛和数据的类型而定，一般有随机划分，按时间划分或者按一定规则划分。</p><p>这个过程可以概括如下图3所示，其目的是避免模型过拟合，以得到泛化能力好的模型。如果不设置 Private LB（即所有的测试数据都用于计算 Public LB），选手不断地从 Public LB（即测试集）中获得反馈，进而调整或筛选模型。这种情况下，测试集实际上是作为验证集参与到模型的构建和调优中来。Public LB上面的效果并非是在真实未知数据上面的效果，不能可靠地反映模型的效果。划分 Public LB 和 Private LB 这样的设置，也在提醒参赛者，我们建模的目标是要获得一个在未知数据上表现良好的模型，而并非仅仅是在已知数据上效果好。</p><h2 id="二、数据挖掘比赛流程"><a href="#二、数据挖掘比赛流程" class="headerlink" title="二、数据挖掘比赛流程"></a>二、数据挖掘比赛流程</h2><p>从上面图2可以看到，做一个数据挖掘比赛，主要包含了数据分析，数据清洗，特征工程，模型训练和验证等四个大的模块，以下来一一对其进行介绍。</p><h3 id="2-1-数据分析"><a href="#2-1-数据分析" class="headerlink" title="2.1 数据分析"></a>2.1 数据分析</h3><p>数据分析可能涉及以下方面：</p><ul><li><p>分析特征变量的分布</p><ul><li>特征变量为连续值：如果为长尾分布并且考虑使用线性模型，可以对变量进行幂变换或者对数变换。</li><li>特征变量为离散值：观察每个离散值的频率分布，对于频次较低的特征，可以考虑统一编码为“其他”类别。</li></ul></li><li><p>分析目标变量的分布</p><ul><li>目标变量为连续值：查看其值域范围是否较大，如果较大，可以考虑对其进行对数变换，并以变换后的值作为新的目标变量进行建模（在这种情况下，需要对预测结果进行逆变换）。一般情况下，可以对连续变量进行Box-Cox变换。通过变换可以使得模型更好的优化，通常也会带来效果上的提升。</li><li>目标变量为离散值：如果数据分布不平衡，考虑是否需要上采样/下采样；如果目标变量在某个ID上面分布不平衡，在划分本地训练集和验证集的时候，需要考虑分层采样（Stratified Sampling）。</li></ul></li><li>分析变量之间两两的分布和相关度<ul><li>可以用于发现高相关和共线性的特征。</li></ul></li></ul><p>通过对数据进行探索性分析（甚至有些情况下需要肉眼观察样本），还可以有助于启发数据清洗和特征抽取，譬如缺失值和异常值的处理，文本数据是否需要进行拼写纠正等。</p><h3 id="2-2-数据清洗"><a href="#2-2-数据清洗" class="headerlink" title="2.2 数据清洗"></a>2.2 数据清洗</h3><p>数据清洗是指对提供的原始数据进行一定的加工，使得其方便后续的特征抽取。其与特征抽取的界限有时也没有那么明确。常用的数据清洗一般包括：</p><ul><li>数据的拼接<ul><li>提供的数据散落在多个文件，需要根据相应的键值进行数据的拼接。</li></ul></li><li><p>特征缺失值的处理</p><ul><li>特征值为连续值：按不同的分布类型对缺失值进行补全：偏正态分布，使用均值代替，可以保持数据的均值；偏长尾分布，使用中值代替，避免受 outlier 的影响；  </li><li>特征值为离散值：使用众数代替</li></ul></li><li><p>文本数据的清洗</p><ul><li>在比赛当中，如果数据包含文本，往往需要进行大量的数据清洗工作。如去除HTML 标签，分词，拼写纠正, 同义词替换，去除停词，抽词干，数字和单位格式统一等。     </li></ul></li></ul><h3 id="2-3-特征工程"><a href="#2-3-特征工程" class="headerlink" title="2.3 特征工程"></a>2.3 特征工程</h3><p>有一种说法是，特征决定了效果的上限，而不同模型只是以不同的方式或不同的程度来逼近这个上限。这样来看，好的特征输入对于模型的效果至关重要，正所谓”Garbage in, garbage out”。要做好特征工程，往往跟领域知识和对问题的理解程度有很大的关系，也跟一个人的经验相关。特征工程的做法也是Case by Case，以下就一些点，谈谈自己的一些看法。</p><h4 id="2-3-1-特征变换"><a href="#2-3-1-特征变换" class="headerlink" title="2.3.1 特征变换"></a>2.3.1 特征变换</h4><p>主要针对一些长尾分布的特征，需要进行幂变换或者对数变换，使得模型（LR或者DNN）能更好的优化。需要注意的是，Random Forest 和 GBDT 等模型对单调的函数变换不敏感。其原因在于树模型在求解分裂点的时候，只考虑排序分位点。</p><h4 id="2-3-2-特征编码"><a href="#2-3-2-特征编码" class="headerlink" title="2.3.2 特征编码"></a>2.3.2 特征编码</h4><p>对于离散的类别特征，往往需要进行必要的特征转换/编码才能将其作为特征输入到模型中。常用的编码方式有 LabelEncoder，OneHotEncoder（sklearn里面的接口）。譬如对于”性别”这个特征（取值为男性和女性），使用这两种方式可以分别编码为$\{0,1\}$和$\{[1,0], [0,1]\}$。</p><p>对于取值较多（如几十万）的类别特征（ID特征），直接进行OneHotEncoder编码会导致特征矩阵非常巨大，影响模型效果。可以使用如下的方式进行处理：</p><ul><li>统计每个取值在样本中出现的频率，取 Top N 的取值进行 One-hot 编码，剩下的类别分到“其他“类目下，其中 N 需要根据模型效果进行调优；</li><li>统计每个 ID 特征的一些统计量（譬如历史平均点击率，历史平均浏览率）等代替该 ID 取值作为特征，具体可以参考 Avazu 点击率预估比赛第二名的获奖方案；</li><li>参考 word2vec 的方式，将每个类别特征的取值映射到一个连续的向量，对这个向量进行初始化，跟模型一起训练。训练结束后，可以同时得到每个ID的Embedding。具体的使用方式，可以参考 Rossmann 销量预估竞赛第三名的获奖方案(<a href="https://github.com/entron/entity-embedding-rossmann" target="_blank" rel="noopener">entron/entity-embedding-rossmann</a>)</li></ul><p>对于 Random Forest 和 GBDT 等模型，如果类别特征存在较多的取值，可以直接使用 LabelEncoder 后的结果作为特征。</p><h3 id="2-4-模型训练与验证"><a href="#2-4-模型训练与验证" class="headerlink" title="2.4 模型训练与验证"></a>2.4 模型训练与验证</h3><h4 id="2-4-1-模型选择"><a href="#2-4-1-模型选择" class="headerlink" title="2.4.1 模型选择"></a>2.4.1 模型选择</h4><p>在处理好特征后，我们可以进行模型的训练和验证。</p><ul><li>对于稀疏型特征（如文本特征，One-hot的ID类特征），我们一般使用线性模型，譬如 Linear Regression 或者 Logistic Regression。Random Forest 和 GBDT 等树模型不太适用于稀疏的特征，但可以先对特征进行降维（如PCA，SVD/LSA等），再使用这些特征。稀疏特征直接输入 DNN 会导致网络 weight 较多，不利于优化，也可以考虑先降维，或者对 ID 类特征使用 Embedding 的方式；</li><li>对于稠密型特征，推荐使用 XGBoost 进行建模，简单易用效果好；</li><li>数据中既有稀疏特征，又有稠密特征，可以考虑使用线性模型对稀疏特征进行建模，将其输出与稠密特征一起再输入 XGBoost/DNN 建模，具体可以参考2.5.2节 Stacking 部分。</li></ul><h4 id="2-4-2-调参和模型验证"><a href="#2-4-2-调参和模型验证" class="headerlink" title="2.4.2 调参和模型验证"></a>2.4.2 调参和模型验证</h4><p>对于选定的特征和模型，我们往往还需要对模型进行超参数的调优，才能获得比较理想的效果。调参一般可以概括为以下三个步骤：</p><ul><li><p>训练集和验证集的划分。根据比赛提供的训练集和测试集，模拟其划分方式对训练集进行划分为本地训练集和本地验证集。划分的方式视具体比赛和数据而定，常用的方式有：</p><ul><li>随机划分：譬如随机采样 70% 作为训练集，剩余的 30% 作为测试集。在这种情况下，本地可以采用 KFold 或者 Stratified KFold 的方法来构造训练集和验证集。</li><li>按时间划分：一般对应于时序序列数据，譬如取前 7 天数据作为训练集，后 1 天数据作为测试集。这种情况下，划分本地训练集和验证集也需要按时间先后划分。常见的错误方式是随机划分，这种划分方式可能会导致模型效果被高估。</li><li>按某些规则划分：在 HomeDepot 搜索相关性比赛中，训练集和测试集中的 Query 集合并非完全重合，两者只有部分交集。而在另外一个相似的比赛中（CrowdFlower 搜索相关性比赛），训练集和测试集具有完全一致的 Query 集合。对于 HomeDepot 这个比赛中，训练集和验证集数据的划分，需要考虑 Query 集合并非完全重合这个情况，其中的一种方法可以参考<a href="https://github.com/ChenglongChen/Kaggle_HomeDepot" target="_blank" rel="noopener">第三名的获奖方案</a>。</li></ul></li><li>指定参数空间。在指定参数空间的时候，需要对模型参数以及其如何影响模型的效果有一定的了解，才能指定出合理的参数空间。譬如DNN或者XGBoost中学习率这个参数，一般就选 0.01 左右就 OK 了（太大可能会导致优化算法错过最优化点，太小导致优化收敛过慢）。再如 Random Forest，一般设定树的棵数范围为 100~200 就能有不错的效果，当然也有人固定数棵数为 500，然后只调整其他的超参数。</li></ul><ul><li>按照一定的方法进行参数搜索。常用的参数搜索方法有，Grid Search，Random Search以及一些自动化的方法（如 Hyperopt）。其中，Hyperopt 的方法，根据历史已经评估过的参数组合的效果，来推测本次评估使用哪个参数组合更有可能获得更好的效果。有关这些方法的介绍和对比，可以参考文献 [2]。</li></ul><h4 id="2-4-3-适当利用Public-LB的反馈"><a href="#2-4-3-适当利用Public-LB的反馈" class="headerlink" title="2.4.3 适当利用Public LB的反馈"></a>2.4.3 适当利用Public LB的反馈</h4><p>在2.4.2节中我们提到本地验证（Local Validation）结果，当将预测结果提交到 Kaggle 上时，我们还会接收到 Public LB 的反馈结果。如果这两个结果的变化趋势是一致的，如 Local Validation 有提升，Public LB 也有提升，我们可以借助 Local Validation 的变化来感知模型的演进情况，而无需靠大量的 Submission。如果两者的变化趋势不一致，需要考虑2.4.2节中提及的本地训练集和验证集的划分方式，是否跟训练集和测试集的划分方式一致。</p><p>另外，在以下一些情况下，往往 Public LB 反馈亦会提供有用信息，适当地使用这些反馈也许会给你带来优势。如图4所示，(a)和(b)表示数据与时间没有明显的关系（如图像分类），(c)和(d)表示数据随时间变化（如销量预估中的时序序列）。(a)和(b)的区别在于，训练集样本数相对于 Public LB 的量级大小，其中(a)中训练集样本数远超于 Public LB 的样本数，这种情况下基于训练集的 Local Validation 更可靠；而(b)中，训练集数目与 Public LB 相当，这种情况下，可以结合 Public LB 的反馈来指导模型的选择。一种融合的方式是根据 Local Validation 和 Public LB 的样本数目，按比例进行加权。譬如评估标准为正确率，Local Validation 的样本数为$N_l$，正确率为$A_l$；Public LB 的样本数为 $N_p$，正确率为 $A_p$。则可以使用融合后的指标：$（N_l <em> A_l + N_p </em> A_p）/(N_l + N_p)$，来进行模型的筛选。对于(c)和(d)，由于数据分布跟时间相关，很有必要使用 Public LB 的反馈来进行模型的选择，尤其对于(c)图所示的情况。</p><p><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-14%20%E4%B8%8B%E5%8D%885.17.50.png" alt="屏幕快照 2017-06-14 下午5.17.50"><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-14%20%E4%B8%8B%E5%8D%885.17.59.png" alt="屏幕快照 2017-06-14 下午5.17.59"></p><h3 id="2-5-模型集成"><a href="#2-5-模型集成" class="headerlink" title="2.5 模型集成"></a>2.5 模型集成</h3><p>如果想在比赛中获得名次，几乎都要进行模型集成（组队也是一种模型集成）。关于模型集成的介绍，已经有比较好的博文了，可以参考 [3]。在这里，我简单介绍下常用的方法，以及个人的一些经验。</p><h4 id="2-5-1-Averaging-和-Voting"><a href="#2-5-1-Averaging-和-Voting" class="headerlink" title="2.5.1 Averaging 和 Voting"></a>2.5.1 Averaging 和 Voting</h4><p>直接对多个模型的预测结果求平均或者投票。对于目标变量为连续值的任务，使用平均；对于目标变量为离散值的任务，使用投票的方式。</p><h4 id="2-5-2-Stacking"><a href="#2-5-2-Stacking" class="headerlink" title="2.5.2 Stacking"></a>2.5.2 Stacking</h4><p><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-14%20%E4%B8%8B%E5%8D%885.26.44.png" alt="屏幕快照 2017-06-14 下午5.26.44"><br>图5展示了使用 5-Fold 进行一次 Stacking 的过程（当然在其上可以再叠加 Stage 2, Stage 3 等）。其主要的步骤如下：</p><ul><li><strong>数据集划分</strong>。将训练数据按照5-Fold进行划分（如果数据跟时间有关，需要按时间划分，更一般的划分方式请参考3.4.2节，这里不再赘述）；</li><li><strong>基础模型训练 I</strong>（如图5第一行左半部分所示）。按照交叉验证（Cross Validation）的方法，在训练集（Training Fold）上面训练模型（如图灰色部分所示），并在验证集（Validation Fold）上面做预测，得到预测结果（如图黄色部分所示）。最后综合得到整个训练集上面的预测结果（如图第一个黄色部分的CV Prediction所示）。</li><li><strong>基础模型训练 II</strong>（如图5第二和三行左半部分所示）。在全量的训练集上训练模型（如图第二行灰色部分所示），并在测试集上面做预测，得到预测结果（如图第三行虚线后绿色部分所示）。</li><li><strong>Stage 1 模型集成训练 I</strong>（如图5第一行右半部分所示）。将步骤 2 中得到的 CV Prediction 当作新的训练集，按照步骤 2 可以得到 Stage 1模型集成的 CV Prediction。</li><li><strong>Stage 1 模型集成训练 II</strong>（如图5第二和三行右半部分所示）。将步骤 2 中得到的 CV Prediction 当作新的训练集和步骤 3 中得到的 Prediction 当作新的测试集，按照步骤 3 可以得到 Stage 1 模型集成的测试集 Prediction。此为 Stage 1 的输出，可以提交至 Kaggle 验证其效果。</li></ul><p>在图5中，基础模型只展示了一个，而实际应用中，基础模型可以多种多样，如SVM，DNN，XGBoost 等。也可以相同的模型，不同的参数，或者不同的样本权重。重复4和5两个步骤，可以相继叠加 Stage 2, Stage 3 等模型。</p><h4 id="2-5-3-Blending"><a href="#2-5-3-Blending" class="headerlink" title="2.5.3 Blending"></a>2.5.3 Blending</h4><p>Blending 与 Stacking 类似，但单独留出一部分数据（如 20%）用于训练 Stage X 模型。</p><h4 id="2-5-4-Bagging-Ensemble-Selection"><a href="#2-5-4-Bagging-Ensemble-Selection" class="headerlink" title="2.5.4 Bagging Ensemble Selection"></a>2.5.4 Bagging Ensemble Selection</h4><p>Bagging Ensemble Selection [5] 是我在 CrowdFlower 搜索相关性比赛中使用的方法，其主要的优点在于可以以优化任意的指标来进行模型集成。这些指标可以是可导的（如 LogLoss 等）和不可导的（如正确率，AUC，Quadratic Weighted Kappa等）。它是一个前向贪婪算法，存在过拟合的可能性，作者在文献 [5] 中提出了一系列的方法（如 Bagging）来降低这种风险，稳定集成模型的性能。使用这个方法，需要有成百上千的基础模型。为此，在 CrowdFlower 的比赛中，我把在调参过程中所有的中间模型以及相应的预测结果保留下来，作为基础模型。这样做的好处是，不仅仅能够找到最优的单模型（Best Single Model），而且所有的中间模型还可以参与模型集成，进一步提升效果。</p><h3 id="2-6-自动化框架"><a href="#2-6-自动化框架" class="headerlink" title="2.6 自动化框架"></a>2.6 自动化框架</h3><p>从上面的介绍可以看到，做一个数据挖掘比赛涉及到的模块非常多，若有一个较自动化的框架会使得整个过程更加的高效。在 CrowdFlower 比赛较前期，我对整一个项目的代码架构进行了重构，抽象出来特征工程，模型调参和验证，以及模型集成等三大模块，极大的提高了尝试新特征，新模型的效率，也是我最终能斩获名次的一个有利因素。这份代码开源在 Github 上面，目前是 Github 有关 Kaggle 竞赛解决方案的 Most Stars，<a href="ChenglongChen/Kaggle_CrowdFlower">地址链接</a>。</p><p>其主要包含以下部分：</p><ul><li>模块化特征工程<ul><li>接口统一，只需写少量的代码就能够生成新的特征；</li><li>自动将单独的特征拼接成特征矩阵。</li></ul></li><li>自动化模型调参和验证<ul><li>自定义训练集和验证集的划分方法；</li><li>使用 Grid Search / Hyperopt 等方法，对特定的模型在指定的参数空间进行调优，并记录最佳的模型参数以及相应的性能。 </li></ul></li><li>自动化模型集成 <ul><li>对于指定的基础模型，按照一定的方法（如Averaging/Stacking/Blending 等）生成集成模型。 </li></ul></li></ul><h2 id="三、Kaggle竞赛方案盘点"><a href="#三、Kaggle竞赛方案盘点" class="headerlink" title="三、Kaggle竞赛方案盘点"></a>三、Kaggle竞赛方案盘点</h2><h3 id="3-1-图像分类"><a href="#3-1-图像分类" class="headerlink" title="3.1 图像分类"></a>3.1 图像分类</h3><p>到目前为止，Kaggle 平台上面已经举办了大大小小不同的赛事，覆盖图像分类，销量预估，搜索相关性，点击率预估等应用场景。在不少的比赛中，获胜者都会把自己的方案开源出来，并且非常乐于分享比赛经验和技巧心得。这些开源方案和经验分享对于广大的新手和老手来说，是入门和进阶非常好的参考资料。以下笔者结合自身的背景和兴趣，对不同场景的竞赛开源方案作一个简单的盘点，总结其常用的方法和工具，以期启发思路。</p><h4 id="3-1-1-图像分类"><a href="#3-1-1-图像分类" class="headerlink" title="3.1.1 图像分类"></a>3.1.1 图像分类</h4><p>National Data Science Bowl</p><h4 id="3-1-2-任务详情"><a href="#3-1-2-任务详情" class="headerlink" title="3.1.2 任务详情"></a>3.1.2 任务详情</h4><p>随着深度学习在视觉图像领域获得巨大成功，Kaggle 上面出现了越来越多跟视觉图像相关的比赛。这些比赛的发布吸引了众多参赛选手，探索基于深度学习的方法来解决垂直领域的图像问题。NDSB就是其中一个比较早期的图像分类相关的比赛。这个比赛的目标是利用提供的大量的海洋浮游生物的二值图像，通过构建模型，从而实现自动分类。</p><h4 id="3-1-3-获奖方案"><a href="#3-1-3-获奖方案" class="headerlink" title="3.1.3 获奖方案"></a>3.1.3 获奖方案</h4><p><strong>1st place:</strong>Cyclic Pooling + Rolling Feature Maps + Unsupervised and Semi-Supervised Approaches。值得一提的是，这个队伍的主力队员也是Galaxy Zoo行星图像分类比赛的第一名，其也是Theano中基于FFT的Fast Conv的开发者。在两次比赛中，使用的都是 Theano，而且用的非常溜。方案链接：<a href="http://benanne.github.io/2015/03/17/plankton.html" target="_blank" rel="noopener">Classifying plankton with deep neural networks</a></p><p><strong>2nd place：</strong>Deep CNN designing theory + VGG-like model + RReLU。这个队伍阵容也相当强大，有前MSRA 的研究员Xudong Cao，还有大神Tianqi Chen，Naiyan Wang，Bing XU等。Tianqi 等大神当时使用的是 CXXNet（MXNet 的前身），也在这个比赛中进行了推广。Tianqi 大神另外一个大名鼎鼎的作品就是 XGBoost，现在 Kaggle 上面几乎每场比赛的 Top 10 队伍都会使用。方案链接：<a href="https://www.kaggle.com/c/datasciencebowl/discussion/13166" target="_blank" rel="noopener">National Data Science Bowl</a></p><p><strong>17th place：</strong>Realtime data augmentation + BN + PReLU。方案链接：ChenglongChen/caffe-windows</p><h4 id="3-1-4-常用工具"><a href="#3-1-4-常用工具" class="headerlink" title="3.1.4 常用工具"></a>3.1.4 常用工具</h4><ul><li>Theano: Welcome – <a href="http://deeplearning.net/software/theano/" target="_blank" rel="noopener">Theano 0.9.0 documentation</a></li><li>Keras: <a href="https://keras.io/" target="_blank" rel="noopener">Keras Documentation</a></li><li>Cuda-convnet2: <a href="https://github.com/akrizhevsky/cuda-convnet2" target="_blank" rel="noopener">akrizhevsky/cuda-convnet2</a></li><li>Caffe: <a href="http://caffe.berkeleyvision.org/" target="_blank" rel="noopener">Caffe | Deep Learning Framework</a></li><li>CXXNET: <a href="https://github.com/dmlc/cxxnet" target="_blank" rel="noopener">dmlc/cxxnet</a></li><li>MXNet: <a href="https://github.com/dmlc/mxnet" target="_blank" rel="noopener">dmlc/mxnet</a></li></ul><h3 id="3-2-销量估计"><a href="#3-2-销量估计" class="headerlink" title="3.2 销量估计"></a>3.2 销量估计</h3><h4 id="3-2-1-任务名称"><a href="#3-2-1-任务名称" class="headerlink" title="3.2.1 任务名称"></a>3.2.1 任务名称</h4><p>Walmart Recruiting – Store Sales Forecasting</p><h4 id="3-2-2-任务详情"><a href="#3-2-2-任务详情" class="headerlink" title="3.2.2 任务详情"></a>3.2.2 任务详情</h4><p>Walmart 提供 2010-02-05 到 2012-11-01 期间的周销售记录作为训练数据，需要参赛选手建立模型预测 2012-11-02 到 2013-07-26 周销售量。比赛提供的特征数据包含：Store ID, Department ID, CPI，气温，汽油价格，失业率，是否节假日等。</p><h4 id="3-2-3-获奖方案"><a href="#3-2-3-获奖方案" class="headerlink" title="3.2.3 获奖方案"></a>3.2.3 获奖方案</h4><p><strong>1st place：</strong>Time series forecasting method: stlf + arima + ets。主要是基于时序序列的统计方法，大量使用了 Rob J Hyndman 的 forecast R 包。方案链接：<a href="https://www.kaggle.com/c/walmart-recruiting-store-sales-forecasting/discussion/8125" target="_blank" rel="noopener">Walmart Recruiting – Store Sales Forecasting</a><br><strong>2nd place：</strong>Time series forecasting + ML: arima + RF + LR + PCR。时序序列的统计方法+传统机器学习方法的混合，方案链接：<a href="https://www.kaggle.com/c/walmart-recruiting-store-sales-forecasting/discussion/8023" target="_blank" rel="noopener">Walmart Recruiting – Store Sales Forecasting</a><br><strong>16th place</strong>Feature engineering + GBM。方案链接：<a href="https://github.com/ChenglongChen/Kaggle_Walmart-Recruiting-Store-Sales-Forecasting" target="_blank" rel="noopener">ChenglongChen/Kaggle_Walmart-Recruiting-Store-Sales-Forecasting</a></p><h4 id="3-2-4-常用工具"><a href="#3-2-4-常用工具" class="headerlink" title="3.2.4 常用工具"></a>3.2.4 常用工具</h4><ul><li>R forecast package: <a href="https://cran.r-project.org/web/packages/forecast/index.html" target="_blank" rel="noopener">https://cran.r-project.org/web/packages/forecast/index.html</a></li><li>R GBM package: <a href="https://cran.r-project.org/web/packages/gbm/index.html" target="_blank" rel="noopener">https://cran.r-project.org/web/packages/gbm/index.html</a></li></ul><h3 id="3-3-搜索相关性"><a href="#3-3-搜索相关性" class="headerlink" title="3.3 搜索相关性"></a>3.3 搜索相关性</h3><h4 id="3-3-1-任务名称"><a href="#3-3-1-任务名称" class="headerlink" title="3.3.1 任务名称"></a>3.3.1 任务名称</h4><p>CrowdFlower Search Results Relevance</p><h4 id="3-3-2-任务详情"><a href="#3-3-2-任务详情" class="headerlink" title="3.3.2 任务详情"></a>3.3.2 任务详情</h4><p>比赛要求选手利用约几万个 (query, title, description) 元组的数据作为训练样本，构建模型预测其相关性打分 {1, 2, 3, 4}。比赛提供了 query, title和description的原始文本数据。比赛使用 Quadratic Weighted Kappa 作为评估标准，使得该任务有别于常见的回归和分类任务。</p><h4 id="3-3-3-获奖方案"><a href="#3-3-3-获奖方案" class="headerlink" title="3.3.3 获奖方案"></a>3.3.3 获奖方案</h4><p><strong>1st place：</strong>Data Cleaning + Feature Engineering + Base Model + Ensemble。对原始文本数据进行清洗后，提取了属性特征，距离特征和基于分组的统计特征等大量的特征，使用了不同的目标函数训练不同的模型（回归，分类，排序等），最后使用模型集成的方法对不同模型的预测结果进行融合。方案链接：<a href="https://github.com/ChenglongChen/Kaggle_CrowdFlower" target="_blank" rel="noopener">ChenglongChen/Kaggle_CrowdFlower</a></p><h4 id="3-3-4-常用工具"><a href="#3-3-4-常用工具" class="headerlink" title="3.3.4 常用工具"></a>3.3.4 常用工具</h4><ul><li>NLTK: <a href="http://www.nltk.org/" target="_blank" rel="noopener">Natural Language Toolkit</a></li><li>Gensim: <a href="https://radimrehurek.com/gensim/" target="_blank" rel="noopener">gensim: topic modelling for humans</a></li><li>XGBoost: <a href="https://github.com/dmlc/xgboost" target="_blank" rel="noopener">dmlc/xgboost</a></li><li>RGF: <a href="https://github.com/baidu/fast_rgf" target="_blank" rel="noopener">baidu/fast_rgf</a></li></ul><h3 id="3-4-点击率预估I"><a href="#3-4-点击率预估I" class="headerlink" title="3.4 点击率预估I"></a>3.4 点击率预估I</h3><h4 id="3-4-1-任务名称"><a href="#3-4-1-任务名称" class="headerlink" title="3.4.1 任务名称"></a>3.4.1 任务名称</h4><p>Criteo Display Advertising Challenge</p><h4 id="3-4-2-任务详情"><a href="#3-4-2-任务详情" class="headerlink" title="3.4.2 任务详情"></a>3.4.2 任务详情</h4><p>经典的点击率预估比赛。该比赛中提供了7天的训练数据，1 天的测试数据。其中有13 个整数特征，26 个类别特征，均脱敏，因此无法知道具体特征含义。</p><h4 id="3-4-3-获奖方案"><a href="#3-4-3-获奖方案" class="headerlink" title="3.4.3 获奖方案"></a>3.4.3 获奖方案</h4><p><strong>1st place：</strong>GBDT 特征编码 + FFM。台大的队伍，借鉴了Facebook的方案 [6]，使用 GBDT 对特征进行编码，然后将编码后的特征以及其他特征输入到 Field-aware Factorization Machine（FFM） 中进行建模。方案链接：<a href="https://www.kaggle.com/c/criteo-display-ad-challenge/discussion/10555" target="_blank" rel="noopener">Display Advertising Challenge | Kaggle</a></p><p><strong>3rd place：</strong>Quadratic Feature Generation + FTRL。传统特征工程和 FTRL 线性模型的结合。方案链接：<a href="https://www.kaggle.com/c/criteo-display-ad-challenge/discussion/10534" target="_blank" rel="noopener">Display Advertising Challenge | Kaggle</a></p><p><strong>4th place：</strong>Feature Engineering + Sparse DNN</p><h4 id="3-4-4-常用工具"><a href="#3-4-4-常用工具" class="headerlink" title="3.4.4 常用工具"></a>3.4.4 常用工具</h4><ul><li>Vowpal Wabbit: <a href="https://github.com/JohnLangford/vowpal_wabbit" target="_blank" rel="noopener">JohnLangford/vowpal_wabbit</a></li><li>XGBoost: <a href="https://github.com/dmlc/xgboost" target="_blank" rel="noopener">dmlc/xgboost</a></li><li>LIBFFM: <a href="http://www.csie.ntu.edu.tw/~r01922136/libffm/" target="_blank" rel="noopener">LIBFFM: A Library for Field-aware Factorization Machines</a></li></ul><h3 id="3-5-点击率预估II"><a href="#3-5-点击率预估II" class="headerlink" title="3.5 点击率预估II"></a>3.5 点击率预估II</h3><h4 id="3-5-1-任务名称"><a href="#3-5-1-任务名称" class="headerlink" title="3.5.1 任务名称"></a>3.5.1 任务名称</h4><p>Avazu Click-Through Rate Prediction</p><h4 id="3-5-2-任务详情"><a href="#3-5-2-任务详情" class="headerlink" title="3.5.2 任务详情"></a>3.5.2 任务详情</h4><p>点击率预估比赛。提供了 10 天的训练数据，1 天的测试数据，并且提供时间，banner 位置，site, app, device 特征等，8个脱敏类别特征。</p><h4 id="3-5-3-获奖方案"><a href="#3-5-3-获奖方案" class="headerlink" title="3.5.3 获奖方案"></a>3.5.3 获奖方案</h4><p><strong>1st place：</strong>Feature Engineering + FFM + Ensemble。还是台大的队伍，这次比赛，他们大量使用了 FFM，并只基于 FFM 进行集成。方案链接：<a href="https://www.kaggle.com/c/avazu-ctr-prediction/discussion/12608" target="_blank" rel="noopener">Click-Through Rate Prediction | Kaggle</a></p><p><strong>2nd place：</strong>Feature Engineering + GBDT 特征编码 + FFM + Blending。Owenzhang（曾经长时间雄霸 Kaggle 排行榜第一）的竞赛方案。Owenzhang 的特征工程做得非常有参考价值。方案链接：<a href="https://github.com/owenzhang/kaggle-avazu" target="_blank" rel="noopener">owenzhang/kaggle-avazu</a></p><h4 id="3-5-4-常用工具"><a href="#3-5-4-常用工具" class="headerlink" title="3.5.4 常用工具"></a>3.5.4 常用工具</h4><ul><li>LIBFFM: LIBFFM: A Library for Field-aware Factorization Machines</li><li>XGBoost: dmlc/xgboost</li></ul><h2 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、参考资料</h2><p>[1] Owenzhang 的分享： Tips for Data Science Competitions</p><p>[2] Algorithms for Hyper-Parameter Optimization</p><p>[3] MLWave博客：Kaggle Ensembling Guide</p><p>[4] Jeong-Yoon Lee 的分享：Winning Data Science Competitions</p><p>[5] Ensemble Selection from Libraries of Models</p><p>[6] Practical Lessons from Predicting Clicks on Ads at Facebook</p><h2 id="五、结语"><a href="#五、结语" class="headerlink" title="五、结语"></a>五、结语</h2><p>作为曾经的学生党，十分感激和庆幸有 Kaggle 这样的平台，提供了不同领域极具挑战的任务以及丰富多样的数据。让我这种空有满（yi）腔（xie）理（wai）论（li）的数据挖掘小白，可以在真实的问题场景和业务数据中进行实操练手，提升自己的数据挖掘技能，一不小心，还能拿名次，赢奖金。如果你也跃跃欲试，不妨选一个合适的任务，开启数据挖掘之旅吧。</p><p>转载自知乎：<a href="https://zhuanlan.zhihu.com/p/26820998" target="_blank" rel="noopener">Kaggle 数据挖掘比赛经验分享</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自知乎：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/26820998&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kaggle 数据挖掘比赛经验分享&lt;/a&gt; 作者是陈成龙，目前在腾讯社交与效果广告部任职数据挖掘工程师，负责 Lookalike 相似人群扩展相关工作。曾在 Kaggle 数据科学家排行榜排名全球第十，国内第一。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Kaggle 于 2010 年创立，专注于开展数据科学、机器学习相关的竞赛，是全球最大的数据科学社区和数据竞赛平台。笔者从 2013 年开始，陆续参加了多场 Kaggle上面举办的比赛，相继获得了 CrowdFlower 搜索相关性比赛第一名（1326支队伍）和 HomeDepot 商品搜索相关性比赛第三名（2125支队伍），曾在 Kaggle 数据科学家排行榜排名全球第十，国内第一。笔者目前在腾讯社交与效果广告部任职数据挖掘工程师，负责 Lookalike 相似人群扩展相关工作。此文分享笔者在参加数据挖掘比赛过程中的一点心得体会。&lt;/p&gt;
    
    </summary>
    
      <category term="Kaggle" scheme="http://yoursite.com/categories/Kaggle/"/>
    
    
      <category term="EDA" scheme="http://yoursite.com/tags/EDA/"/>
    
      <category term="特征工程" scheme="http://yoursite.com/tags/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="Kaggle" scheme="http://yoursite.com/tags/Kaggle/"/>
    
      <category term="Voting" scheme="http://yoursite.com/tags/Voting/"/>
    
      <category term="Stacking" scheme="http://yoursite.com/tags/Stacking/"/>
    
      <category term="Blending" scheme="http://yoursite.com/tags/Blending/"/>
    
  </entry>
  
  <entry>
    <title>机器学习算法系列（19）：机器学习性能评价指标</title>
    <link href="http://yoursite.com/2017/05/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%8819%EF%BC%89%EF%BC%9A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%80%A7%E8%83%BD%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/"/>
    <id>http://yoursite.com/2017/05/24/机器学习算法系列（19）：机器学习性能评价指标/</id>
    <published>2017-05-24T15:14:45.000Z</published>
    <updated>2017-12-26T08:03:24.976Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、分类问题的评价指标"><a href="#一、分类问题的评价指标" class="headerlink" title="一、分类问题的评价指标"></a>一、分类问题的评价指标</h2><h3 id="1-1-混淆矩阵"><a href="#1-1-混淆矩阵" class="headerlink" title="1.1 混淆矩阵"></a>1.1 混淆矩阵</h3><p>对一个二分类问题，将实例分成正类（postive）或者负类（negative），但在实际分类中，会出现以下四种情况：</p><ul><li>True Positive（真正，TP）：将正类预测为正类数</li><li>True Negative（真负，TN）：将负类预测为负类数</li><li>False Positive（假正，FP）：将负类预测为正类数</li><li>False  Negative（假负，FN）：将正类预测为负类数</li></ul><a id="more"></a><p>从下图可以直观的看出四者的关系：<br><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-29%20%E4%B8%8B%E5%8D%885.10.54.png" alt="屏幕快照 2017-03-29 下午5.10.54"></p><p>混淆矩阵（Confusion matrix）又被称为错误矩阵，它是一种特定的矩阵来呈现算法性能的可视化呈现。其每一列代表预测值，每一行代表的是实际的类别，这个名字来源于他是否可以非常容易的表明多个类别是否有混淆（也就是一个class被预测为另一个class）混淆矩阵的$i$行$j$列是列别$i$被分为类别$j$的样本个数。</p><p><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-30%20%E4%B8%8A%E5%8D%8810.06.48.png" alt="屏幕快照 2017-05-30 上午10.06.48"></p><h3 id="1-2-精确率、召回率与F1值"><a href="#1-2-精确率、召回率与F1值" class="headerlink" title="1.2 精确率、召回率与F1值"></a>1.2 精确率、召回率与F1值</h3><p> 精确率（precision rate）定义为：</p><script type="math/tex; mode=display">P=\frac{TP}{TP+FP}</script><p> 这里需要注意的是精确率（precision）和准确率（accuracy）是不一样的</p><script type="math/tex; mode=display">ACC=\frac{TP+TN}{TP+TN+FP+FN}</script><p> 在非平衡数据的情况下，准确率这个评价指标有很大的缺陷。比如在互联网广告里面，点击的数量是很少的，一般只有千分之几，如果用Accuracy，即使全部预测成负类（不点击），ACC也达到了99%以上，这就没有意义了。</p><p>召回率（Recall rate）定义为：</p><script type="math/tex; mode=display">R=\frac{TP}{TP+FN}</script><p>此外，还有F1值，它是精确率和召回率的调和均值，即</p><script type="math/tex; mode=display">\frac{2}{F_1}=\frac{1}{P}+\frac{1}{R}</script><script type="math/tex; mode=display">F_1=\frac{2TP}{2TP+FP+FN}</script><p>精确率与召回率都很高时，$F_1$值也会很高。</p><h3 id="1-4-通俗理解"><a href="#1-4-通俗理解" class="headerlink" title="1.4 通俗理解"></a>1.4 通俗理解</h3><p>通俗来讲，精确率是针对我们的预测结果而言的，他表示的是预测为正的样本中有多少是对的，那么预测为正就有两种可能了，一种就是把正类预测为正类（TP），另一种就是把负类预测为正类（FP）。</p><p>而召回率是针对我们原来的样本而言的，它表示的是样本中的正例有多少被预测正确了。那也有两种可能，一种是把原来的正类预测成正类（TP），另一种就是把原来的正类预测为负类（FN）。</p><p><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-29%20%E4%B8%8B%E5%8D%888.44.11.png" alt="屏幕快照 2017-05-29 下午8.44.11"></p><p>在信息搜索领域，精确率和召回率又被称为查准率和查全率</p><script type="math/tex; mode=display">查准率=\frac{检索出的相关信息量}{检索出的信息总量}</script><script type="math/tex; mode=display">查全率=\frac{检索出的相关信息量}{系统中的相关信息总量}</script><h3 id="1-5-ROC曲线"><a href="#1-5-ROC曲线" class="headerlink" title="1.5 ROC曲线"></a>1.5 ROC曲线</h3><p>ROC曲线首先是由二战中的电子工程师和雷达工程师发明的，用来侦测战场上的敌军载具（飞机、船舰），也就是信号检测理论。之后很快就被引入了心理学来进行信号的知觉检测。数十年来，ROC分析被用于医学、无线电、生物学、犯罪心理学领域中，而且最近在机器学习（machine learning）和数据挖掘（data mining）领域也得到了很好的发展。</p><p>下图是一个ROC曲线的示例图。</p><p><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-30%20%E4%B8%8A%E5%8D%8811.53.33.png" alt="屏幕快照 2017-05-30 上午11.53.33"></p><p>在这个ROC曲线的示例图中，横坐标为false<br> positive rate(FPR)，纵坐标为true positive rate（TPR）。由混淆矩阵可得到横纵轴的计算公式。</p><ul><li>1）$TPR=\frac{TP}{TP+FN}$ 代表分类器预测的正类中实际正实例占所有正实例的比例。直观上代表能将正例分对的概率。</li><li>2）$FPR=\frac{FP}{FP+TN}$ 代表分类器预测的正类中实际负实例占所有负实例的比例。直观上代表将负类错分为正例的概率。</li></ul><p>假设采用逻辑回归分类器，其给出针对每个实例为正类的概率，那么通过设定一个阈值如0.6，概率大于等于0.6的为正类，小于0.6的为负类。对应的就可以算出一组(FPR,TPR)，随着阈值的逐渐减小，越来越多的实例被划分为正类，但是这些正类中同样也掺杂着更多的负实例，即TPR和FPR会同时增大。阈值最大时，对应坐标点（0，0），阈值最小时，对应坐标点（1，1）。</p><p>接下来我们考虑ROC曲线图中的四个点和一条线。第一个点，(0,1)，即FPR=0, TPR=1，这意味着FN（false negative）=0，并且FP（false positive）=0。这是一个完美的分类器，它将所有的样本都正确分类。第二个点，(1,0)，即FPR=1，TPR=0，类似地分析可以发现这是一个最糟糕的分类器，因为它成功避开了所有的正确答案。第三个点，(0,0)，即FPR=TPR=0，即FP（false positive）=TP（true positive）=0，可以发现该分类器预测所有的样本都为负样本（negative）。类似的，第四个点（1,1），分类器实际上预测所有的样本都为正样本。经过以上的分析，我们可以断言，ROC曲线越接近左上角，该分类器的性能越好。</p><p>下面考虑ROC曲线图中的虚线y=x上的点。这条对角线上的点其实表示的是一个采用随机猜测策略的分类器的结果，例如(0.5,0.5)，表示该分类器随机对于一半的样本猜测其为正样本，另外一半的样本为负样本。</p><p>如何绘制ROC曲线呢？</p><p>假设已经得出一系列样本被划分为正类的概率，然后按照大小排序，下图是一个示例，图中共有20个测试样本，“class”一栏表示每个测试样本真正的标签（P表示正样本，n表示负样本），“Score”表示每个测试样本属于正样本的概率。</p><p><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-30%20%E4%B8%8A%E5%8D%8811.53.51.png" alt="屏幕快照 2017-05-30 上午11.53.51"></p><p>接下来，我们从高到低，依次将“Score”值作为阈值的threshold，当测试样本属于正样本的概率大于或等于这个threshold时，我们认为它为正样本，否则为负样本。举例来说，对于图中的第四个样本，其“Score”值为0.6，那么样本1，2，3，4都被认为是正样本，因为它们的“Score”值都大于等于0.6，而其他样本则都认为是负样本。每次选取一个不同的threshold，我们就可以得到一组FPR和TPR，即ROC曲线上的一点。这样一来，我们一共得到了20组FPR和TPR的值，将它们画在ROC曲线的结果如下图：</p><p><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-30%20%E4%B8%8A%E5%8D%8811.54.03.png" alt="屏幕快照 2017-05-30 上午11.54.03"></p><h3 id="1-6-AUC"><a href="#1-6-AUC" class="headerlink" title="1.6 AUC"></a>1.6 AUC</h3><p>AUC（Area under Curve）指的是ROC曲线下的面积，介于0和1之间。AUC作为数值可以直观地评价分类器的好坏，值越大越好。</p><blockquote><p>The AUC value is equivalent to the probability that a randomly chosen positive example is ranked higher than a randomly chosen negative example.</p></blockquote><p>首先AUC是一个概率值，当你随机挑选一个正样本以及负样本，当前的分类算法根据计算得到的Score值将这个正样本排在负样本前面的概率就是AUC值，AUC值越大，当前分类算法越有可能将正样本排在负样本前面，从而能够更好地分类。</p><p>以下是根据AUC判断分类器优劣的标准：</p><ul><li>1）AUC=1，是完美分类器，采用这个预测模型时，存在至少一个阈值能得出完美预测。绝大多数场合，不存在完美的分类器。</li><li>2）0.5&lt;AUC&lt;1，优于随机猜测。这个分类器妥善设定阈值的话，能有预测价值。</li><li>3）AUC=0.5，跟随机猜测一样（如丢硬币），模型没有预测价值。</li><li>4）AUC&lt;0.5，比随机猜测还差；但只要总是反预测而行，就优于随机猜测。<br><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-30%20%E4%B8%8A%E5%8D%8811.54.13.png" alt="屏幕快照 2017-05-30 上午11.54.13"></li></ul><p>那我们为什么使用ROC曲线呢？</p><p>既然已经有那么多的评价标准，为何还要使用ROC和AUC曲线呢？因为ROC曲线有个很好的特性：当测试集中的正负样本的分布变化的时候，ROC曲线能够保持不变。在实际的数据集中经常会出现非平衡数据的现象，即负样本比正样本多很多（或者相反），而且测试数据中的正负样本的分布也可能随着时间变化。下图是ROC曲线和Precision-Recall曲线的对比：<img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-30%20%E4%B8%8A%E5%8D%8811.54.26.png" alt="屏幕快照 2017-05-30 上午11.54.26"></p><p>在上图中，a和c为ROC曲线，b和d为Precision-Recall曲线。a和b展示的是分类器在原始测试集（正负样本分布平衡）的结果，c和d是将测试集中负样本的数量增加到原来的10倍后，分类器的结果。可以明显的看出，ROC曲线基本保持原貌，而Precision-Recall则变化较大。</p><h2 id="二、回归问题的评价指标"><a href="#二、回归问题的评价指标" class="headerlink" title="二、回归问题的评价指标"></a>二、回归问题的评价指标</h2><h3 id="2-1-平均绝对误差"><a href="#2-1-平均绝对误差" class="headerlink" title="2.1 平均绝对误差"></a>2.1 平均绝对误差</h3><p>平均绝对误差MAE（Mean Absolute Reeor）又被称为L1范数损失（L1-norm loss）：</p><script type="math/tex; mode=display">{\rm MAE}(y, \hat{y})=\frac{1}{n_{\rm samples}}\sum\limits_{i=1}^{n_{\rm samples}}|y_i-\hat{y}_i|</script><h3 id="2-2-平均平方误差"><a href="#2-2-平均平方误差" class="headerlink" title="2.2 平均平方误差"></a>2.2 平均平方误差</h3><p>平均平方误差MSE（Mean Squared Error）又被称为L2范数损失（L2-norm loss）:</p><script type="math/tex; mode=display">{\rm MSE}(y, \hat{y})=\frac{1}{n_{\rm samples}}\sum\limits_{i=1}^{n_{\rm samples}}(y_i-\hat{y}_i)^2</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、分类问题的评价指标&quot;&gt;&lt;a href=&quot;#一、分类问题的评价指标&quot; class=&quot;headerlink&quot; title=&quot;一、分类问题的评价指标&quot;&gt;&lt;/a&gt;一、分类问题的评价指标&lt;/h2&gt;&lt;h3 id=&quot;1-1-混淆矩阵&quot;&gt;&lt;a href=&quot;#1-1-混淆矩阵&quot; class=&quot;headerlink&quot; title=&quot;1.1 混淆矩阵&quot;&gt;&lt;/a&gt;1.1 混淆矩阵&lt;/h3&gt;&lt;p&gt;对一个二分类问题，将实例分成正类（postive）或者负类（negative），但在实际分类中，会出现以下四种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;True Positive（真正，TP）：将正类预测为正类数&lt;/li&gt;
&lt;li&gt;True Negative（真负，TN）：将负类预测为负类数&lt;/li&gt;
&lt;li&gt;False Positive（假正，FP）：将负类预测为正类数&lt;/li&gt;
&lt;li&gt;False  Negative（假负，FN）：将正类预测为负类数&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="评价指标" scheme="http://yoursite.com/tags/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/"/>
    
      <category term="精确率" scheme="http://yoursite.com/tags/%E7%B2%BE%E7%A1%AE%E7%8E%87/"/>
    
      <category term="召回率" scheme="http://yoursite.com/tags/%E5%8F%AC%E5%9B%9E%E7%8E%87/"/>
    
      <category term="ROC" scheme="http://yoursite.com/tags/ROC/"/>
    
      <category term="AUC" scheme="http://yoursite.com/tags/AUC/"/>
    
  </entry>
  
  <entry>
    <title>深度学习系列（12）：pytorch实现卷积神经网络</title>
    <link href="http://yoursite.com/2017/05/21/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%EF%BC%8812%EF%BC%89%EF%BC%9Apytorch%E5%AE%9E%E7%8E%B0%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>http://yoursite.com/2017/05/21/深度学习系列（12）：pytorch实现卷积神经网络/</id>
    <published>2017-05-21T13:14:45.000Z</published>
    <updated>2017-12-26T10:44:32.507Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-载入模块"><a href="#1-载入模块" class="headerlink" title="1.载入模块"></a>1.载入模块</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> torch </div><div class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</div><div class="line"><span class="keyword">import</span> torchvision.datasets <span class="keyword">as</span> dsets</div><div class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</div><div class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</div></pre></td></tr></table></figure><p>其中torchvision.transforms 用于数据预处理，torchvision.datasets加载内置数据集</p><a id="more"></a><h2 id="2-设置参数"><a href="#2-设置参数" class="headerlink" title="2.设置参数"></a>2.设置参数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">num_epochs = <span class="number">5</span></div><div class="line">batch_size = <span class="number">100</span></div><div class="line">learning_rate = <span class="number">0.001</span></div></pre></td></tr></table></figure><p> 迭代次数num_epochs设置为5；批处理样本数batch_size设置为100；学习率learning_rate设置为0.001。</p><h2 id="3-加载数据集"><a href="#3-加载数据集" class="headerlink" title="3.加载数据集"></a>3.加载数据集</h2><p>加载训练集，将MNIST数据集自动从网上下载并解压，train=true表示取出训练集部分，并变换为张量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">train_dataset = dsets.MNIST(root=<span class="string">'../data/'</span>,</div><div class="line">                            train=<span class="keyword">True</span>, </div><div class="line">                            transform=transforms.ToTensor(),</div><div class="line">                            download=<span class="keyword">True</span>)</div></pre></td></tr></table></figure><p>加载测试集，train=False即表示取出测试集部分，并变换为张量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">test_dataset = dsets.MNIST(root=<span class="string">'../data/'</span>,</div><div class="line">                           train=<span class="keyword">False</span>, </div><div class="line">                           transform=transforms.ToTensor())</div></pre></td></tr></table></figure><p>将训练集的60000张图片划分成600份，每份100张图，用于mini-batch输入。同时将测试集的10000张图片分成100份，每份100张图。shffule=True在表示不同批次的数据遍历时，打乱顺序，反之则不打乱顺序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">train_loader = torch.utils.data.DataLoader(dataset=train_dataset,</div><div class="line">                                           batch_size=batch_size, </div><div class="line">                                           shuffle=<span class="keyword">True</span>)</div><div class="line">test_loader = torch.utils.data.DataLoader(dataset=test_dataset,</div><div class="line">                                          batch_size=batch_size, </div><div class="line">                                          shuffle=<span class="keyword">False</span>)</div></pre></td></tr></table></figure><h2 id="4-CNN模型（两个卷积层）"><a href="#4-CNN模型（两个卷积层）" class="headerlink" title="4.CNN模型（两个卷积层）"></a>4.CNN模型（两个卷积层）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CNN</span><span class="params">(nn.Module)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        super(CNN, self).__init__()</div><div class="line">        self.layer1 = nn.Sequential(</div><div class="line">            nn.Conv2d(<span class="number">1</span>, <span class="number">16</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>),<span class="comment">#卷积：1 input image channel, 16 output channels, 5x5 square convolution kernel，2 zero padding）</span></div><div class="line">            nn.BatchNorm2d(<span class="number">16</span>),<span class="comment">#归一化</span></div><div class="line">            nn.ReLU(),<span class="comment">#非线性激活函数ReLU</span></div><div class="line">            nn.MaxPool2d(<span class="number">2</span>))<span class="comment">#池化层</span></div><div class="line">        self.layer2 = nn.Sequential(</div><div class="line">            nn.Conv2d(<span class="number">16</span>, <span class="number">32</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>),</div><div class="line">            nn.BatchNorm2d(<span class="number">32</span>),</div><div class="line">            nn.ReLU(),</div><div class="line">            nn.MaxPool2d(<span class="number">2</span>))</div><div class="line">        self.fc = nn.Linear(<span class="number">7</span>*<span class="number">7</span>*<span class="number">32</span>, <span class="number">10</span>)<span class="comment">#全连接层，in_features, out_features, bias=True</span></div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></div><div class="line">        out = self.layer1(x)</div><div class="line">        out = self.layer2(out)</div><div class="line">        out = out.view(out.size(<span class="number">0</span>), <span class="number">-1</span>)</div><div class="line">        out = self.fc(out)</div><div class="line">        <span class="keyword">return</span> out</div><div class="line"><span class="comment"># 正常情况下, 我们都会用类进行封装一个网络        </span></div><div class="line">cnn = CNN()</div></pre></td></tr></table></figure><h2 id="5-损失函数与优化方法"><a href="#5-损失函数与优化方法" class="headerlink" title="5.损失函数与优化方法"></a>5.损失函数与优化方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">criterion = nn.CrossEntropyLoss()<span class="comment">#损失函数，这里为交叉熵</span></div><div class="line">optimizer = torch.optim.Adam(cnn.parameters(), lr=learning_rate)<span class="comment">#优化方法，这里使用Adam</span></div></pre></td></tr></table></figure><h2 id="6-训练模型"><a href="#6-训练模型" class="headerlink" title="6.训练模型"></a>6.训练模型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(num_epochs):</div><div class="line">    <span class="keyword">for</span> i, (images, labels) <span class="keyword">in</span> enumerate(train_loader):</div><div class="line">        <span class="comment"># wrap them in Variable</span></div><div class="line">        images = Variable(images)</div><div class="line">        labels = Variable(labels)</div><div class="line">        </div><div class="line">        <span class="comment"># Forward + Backward + Optimize</span></div><div class="line">        optimizer.zero_grad()</div><div class="line">        outputs = cnn(images)</div><div class="line">        loss = criterion(outputs, labels)</div><div class="line">        loss.backward()</div><div class="line">        optimizer.step()</div><div class="line">        <span class="comment"># print statistics</span></div><div class="line">        <span class="keyword">if</span> (i+<span class="number">1</span>) % <span class="number">100</span> == <span class="number">0</span>:</div><div class="line">            <span class="keyword">print</span> (<span class="string">'Epoch [%d/%d], Iter [%d/%d] Loss: %.4f'</span> </div><div class="line">                   %(epoch+<span class="number">1</span>, num_epochs, i+<span class="number">1</span>, len(train_dataset)//batch_size, loss.data[<span class="number">0</span>]))</div></pre></td></tr></table></figure><pre><code>Epoch [1/5], Iter [100/600] Loss: 0.1363Epoch [1/5], Iter [200/600] Loss: 0.0487Epoch [1/5], Iter [300/600] Loss: 0.0688Epoch [1/5], Iter [400/600] Loss: 0.1273Epoch [1/5], Iter [500/600] Loss: 0.0283Epoch [1/5], Iter [600/600] Loss: 0.0375Epoch [2/5], Iter [100/600] Loss: 0.0398Epoch [2/5], Iter [200/600] Loss: 0.0595Epoch [2/5], Iter [300/600] Loss: 0.0793Epoch [2/5], Iter [400/600] Loss: 0.0166Epoch [2/5], Iter [500/600] Loss: 0.0235Epoch [2/5], Iter [600/600] Loss: 0.0128Epoch [3/5], Iter [100/600] Loss: 0.0273Epoch [3/5], Iter [200/600] Loss: 0.0507Epoch [3/5], Iter [300/600] Loss: 0.0384Epoch [3/5], Iter [400/600] Loss: 0.0150Epoch [3/5], Iter [500/600] Loss: 0.0086Epoch [3/5], Iter [600/600] Loss: 0.0616Epoch [4/5], Iter [100/600] Loss: 0.0243Epoch [4/5], Iter [200/600] Loss: 0.0112Epoch [4/5], Iter [300/600] Loss: 0.0391Epoch [4/5], Iter [400/600] Loss: 0.0140Epoch [4/5], Iter [500/600] Loss: 0.0324Epoch [4/5], Iter [600/600] Loss: 0.0053Epoch [5/5], Iter [100/600] Loss: 0.0358Epoch [5/5], Iter [200/600] Loss: 0.0109Epoch [5/5], Iter [300/600] Loss: 0.0066Epoch [5/5], Iter [400/600] Loss: 0.0028Epoch [5/5], Iter [500/600] Loss: 0.0380Epoch [5/5], Iter [600/600] Loss: 0.0518</code></pre><h2 id="7-模型测试"><a href="#7-模型测试" class="headerlink" title="7.模型测试"></a>7.模型测试</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">cnn.eval()</div><div class="line">correct = <span class="number">0</span></div><div class="line">total = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> images,labels <span class="keyword">in</span> test_loader:</div><div class="line">    images = Variable(images)</div><div class="line">    outputs = cnn(images)</div><div class="line">    _,predicted = torch.max(outputs.data,<span class="number">1</span>)</div><div class="line">    total += labels.size(<span class="number">0</span>)</div><div class="line">    correct += (predicted == labels).sum()</div><div class="line"></div><div class="line"><span class="keyword">print</span> (<span class="string">'Test Accuracy of model on the 10000 test images:%d %%'</span>%(<span class="number">100</span>*correct/total))</div></pre></td></tr></table></figure><pre><code>Test Accuracy of model on the 10000 test images:99 %</code></pre><h2 id="8-保存模型"><a href="#8-保存模型" class="headerlink" title="8.保存模型"></a>8.保存模型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.save(cnn.state_dict(),<span class="string">'cnn.pkl'</span>)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-载入模块&quot;&gt;&lt;a href=&quot;#1-载入模块&quot; class=&quot;headerlink&quot; title=&quot;1.载入模块&quot;&gt;&lt;/a&gt;1.载入模块&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; torch &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; torch.nn &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; nn&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; torchvision.datasets &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; dsets&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; torchvision.transforms &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; transforms&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; torch.autograd &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Variable&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中torchvision.transforms 用于数据预处理，torchvision.datasets加载内置数据集&lt;/p&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="CNN" scheme="http://yoursite.com/tags/CNN/"/>
    
      <category term="pytorch" scheme="http://yoursite.com/tags/pytorch/"/>
    
  </entry>
  
  <entry>
    <title>深度学习系列（11）：神经网络防止过拟合的方法</title>
    <link href="http://yoursite.com/2017/05/20/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%EF%BC%8811%EF%BC%89%EF%BC%9A%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E9%98%B2%E6%AD%A2%E8%BF%87%E6%8B%9F%E5%90%88%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2017/05/20/深度学习系列（11）：神经网络防止过拟合的方法/</id>
    <published>2017-05-20T15:14:45.000Z</published>
    <updated>2017-12-26T10:33:34.290Z</updated>
    
    <content type="html"><![CDATA[<p>过拟合（overfitting）是指在模型参数拟合过程中的问题，由于训练数据包含抽样误差，训练时，复杂的模型将抽样误差也考虑在内，将抽样误差也进行了很好的拟合。具体表现就是最终模型在训练集上效果好，而在测试集上的效果很差，模型的泛化能力比较弱。</p><a id="more"></a><p><img src="http://omu7tit09.bkt.clouddn.com/15007371985191.png" alt=""></p><p>那为什么要解决过拟合现象呢？这是因为我们拟合的模型一般是用来预测未知的结果（不在训练集内），过你个虽然在训练集上效果很好，但在实际使用时（测试集）效果很差。同时，在很多问题上，我们无法穷尽所以状态，不可能将所有情况都包含在训练集上。所以，必须要解决过拟合问题。</p><p>之所以过拟合在机器学习中比较常见，就是因为机器学习算法为了满足尽可能复杂的任务，其模型的拟合能力一般远远高于问题复杂度，也就是说，机器学习算法有“拟合出正确规则的前提下，进一步拟合噪声”的能力。</p><p>过拟合主要是有两个原因造成的：数据太少+模型太复杂。所以，我们可以通过使用合适复杂度的模型来防止过拟合问题，让其足够拟合真正的规则，同时又不至于拟合太多抽样误差。</p><p> <img src="http://omu7tit09.bkt.clouddn.com/15007362845825.jpg" alt=""></p><p>通过上图可以看出，随着模型训练的进行，模型的复杂度会增加，此时模型在训练数据集上的训练误差会逐渐减小，但是在模型的复杂度达到一定程度时，模型在验证集上的误差反而随着模型的复杂度增加而增大。此时便发生了过拟合，即模型的复杂度升高，但是该模型在除训练集之外的数据集上却不work。</p><p>为了防止过拟合，我们需要用到一些方法，如下所示：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15007376354652.png" alt=""></p><h2 id="一、获取更多的数据"><a href="#一、获取更多的数据" class="headerlink" title="一、获取更多的数据"></a>一、获取更多的数据</h2><p>所有的过拟合无非就是训练样本的缺乏和训练参数的增加。一般要想获得更好的模型，需要大量的训练参数，这也是为什么CNN网络越来越深的原因之一，而如果训练样本缺乏多样性，那再多的训练参数也毫无意义，因为这造成了过拟合，训练的模型泛化能力相应也会很差。大量数据带来的特征多样性有助于充分利用所有的训练参数。</p><p>在数据挖掘领域流行着这样的一句话，“有时候往往拥有更多的数据胜过一个好的模型”。因为我们在使用训练数据训练模型，通过这个模型对将来的数据进行拟合，而在这之间又一个假设便是，训练数据与将来的数据是独立同分布的。即使用当前的训练数据来对将来的数据进行估计与模拟，而更多的数据往往估计与模拟地更准确。因此，更多的数据有时候更优秀。但是往往条件有限，如人力物力财力的不足，而不能收集到更多的数据，如在进行分类的任务中，需要对数据进行打标，并且很多情况下都是人工得进行打标，因此一旦需要打标的数据量过多，就会导致效率低下以及可能出错的情况。所以，往往在这时候，需要采取一些计算的方式与策略在已有的数据集上进行手脚，以得到更多的数据。通俗得讲，数据扩增即需要得到更多的符合要求的数据，即和已有的数据是独立同分布的，或者近似独立同分布的。</p><p>如何获取更多的数据，一般有以下几个方法：</p><ul><li>1）从数据源头获取更多数据：这个是容易想到的，例如物体分类，我就再多拍几张照片好了；但是，在很多情况下，大幅增加数据本身就不容易；另外，我们不清楚获取多少数据才算够；</li><li>2）根据当前数据集估计数据分布参数，使用该分布产生更多数据：这个一般不用，因为估计分布参数的过程也会代入抽样误差。</li><li>3）通过一定规则扩充数据，即数据增强（Data Augmentation）。如在物体分类问题里，物体在图像中的位置、姿态、尺度，整体图片明暗度等都不会影响分类结果。我们就可以通过图像平移、翻转、缩放、切割等手段将数据库成倍扩充，以下为具体的方案：<br><img src="http://omu7tit09.bkt.clouddn.com/15007405957596.png" alt=""></li></ul><h2 id="二、使用合适的模型"><a href="#二、使用合适的模型" class="headerlink" title="二、使用合适的模型"></a>二、使用合适的模型</h2><h3 id="2-1-限制权值-Weight-Decay"><a href="#2-1-限制权值-Weight-Decay" class="headerlink" title="2.1 限制权值 Weight Decay"></a>2.1 限制权值 Weight Decay</h3><p>常用的weight decay有L1和L2正则化，L1较L2能够获得更稀疏的参数，但L1零点不可导。在损失函数中，weight decay是放在正则项（regularization）前面的一个系数，正则项一般指示模型的复杂度，所以weight decay的作用是调节模型复杂度对损失函数的影响，若weight decay很大，则复杂的模型损失函数的值也就大。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15007404062733.png" alt=""></p><p>L1和L2正则化是很重要的过拟合方法，后边专门用一篇文章来讲。</p><h3 id="2-2-训练时间-Early-stopping"><a href="#2-2-训练时间-Early-stopping" class="headerlink" title="2.2 训练时间 Early stopping"></a>2.2 训练时间 Early stopping</h3><p>提前停止其实是另一种正则化方法，就是在训练集和验证集上，一次迭代之后计算各自的错误率，当在验证集上的错误率最小，在没开始增大之前停止训练，因为如果接着训练，训练集上的错误率一般是会继续减小的，但验证集上的错误率会上升，这就说明模型的泛化能力开始变差了，出现过拟合问题，及时停止能获得泛化更好的模型。如下图（左边是训练集错误率，右图是验证集错误率，在虚线处提前结束训练）：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15007403892957.png" alt=""></p><p>Early stopping方法的具体做法是，在每一个Epoch结束时（一个Epoch集为对所有的训练数据的一轮遍历）计算validation data的accuracy，当accuracy不再提高时，就停止训练。这种做法很符合直观感受，因为accurary都不再提高了，在继续训练也是无益的，只会提高训练的时间。那么该做法的一个重点便是怎样才认为validation accurary不再提高了呢？并不是说validation accuracy一降下来便认为不再提高了，因为可能经过这个Epoch后，accuracy降低了，但是随后的Epoch又让accuracy又上去了，所以不能根据一两次的连续降低就判断不再提高。一般的做法是，在训练的过程中，记录到目前为止最好的validation accuracy，当连续10次Epoch（或者更多次）没达到最佳accuracy时，则可以认为accuracy不再提高了。此时便可以停止迭代了（Early Stopping）。这种策略也称为“No-improvement-in-n”，n即Epoch的次数，可以根据实际情况取，如10、20、30。</p><p>在神经网络中，对于每个神经元而言，其激活函数在不同的区间的性能是不同的：<br><img src="http://omu7tit09.bkt.clouddn.com/15007381334312.png" alt=""></p><p>当网络权值较小时，神经元的激活函数工作在线性区，此时神经元的拟合能力较弱（类似线性神经元）。有了以上共识之后，就可以解释为什么训练时间（early stopping）有用：因为我们在初始化网络的时候一般都是初始为较小的权值。训练时间越长，部分网络权值可能越大。如果我们在合适时间停止训练，就可以将网络的能力限制在一定范围内。</p><h3 id="2-3-网络结构"><a href="#2-3-网络结构" class="headerlink" title="2.3 网络结构"></a>2.3 网络结构</h3><p>这个很好理解，减少网络的层数、神经元个数等均可以限制网络的拟合能力。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15007384125127.png" alt=""></p><h3 id="2-4-增加噪声"><a href="#2-4-增加噪声" class="headerlink" title="2.4 增加噪声"></a>2.4 增加噪声</h3><p>给网络加噪声也有很多方法：</p><h4 id="2-4-1-在输入中加噪声"><a href="#2-4-1-在输入中加噪声" class="headerlink" title="2.4.1 在输入中加噪声"></a>2.4.1 在输入中加噪声</h4><p>噪声会随着网络传播，按照权值的平方放大，并传播到输出层，对误差 Cost 产生影响。推导直接看 Hinton 的 PPT 吧：</p><p><img src="http://omu7tit09.bkt.clouddn.com/15007388421105.png" alt=""><br>在输入中加高斯噪声，会在输出中生成$\sum_i\sigma _i^2w_i^2$的干扰项。训练时，减小误差，同时也会对噪声产生的干扰项进行惩罚，达到减小权值的平方的目的，达到与L2 regularization类似的效果（对比公式）。</p><h4 id="2-4-2-在权值上加噪声"><a href="#2-4-2-在权值上加噪声" class="headerlink" title="2.4.2 在权值上加噪声"></a>2.4.2 在权值上加噪声</h4><p>在初始化网络的时候，用0均值的高斯分布作为初始化。Alex Graves 的手写识别 RNN 就是用了这个方法：</p><blockquote><p>Graves, Alex, et al. “A novel connectionist system for unconstrained handwriting recognition.” IEEE transactions on pattern analysis and machine intelligence 31.5 (2009): 855-868.</p></blockquote><ul><li>It may work better, especially in recurrent networks (Hinton)</li></ul><h4 id="2-4-3-对网络的响应加噪声"><a href="#2-4-3-对网络的响应加噪声" class="headerlink" title="2.4.3 对网络的响应加噪声"></a>2.4.3 对网络的响应加噪声</h4><p>如在前向传播过程中，让某些神经元的输出变为 binary 或 random。显然，这种有点乱来的做法会打乱网络的训练过程，让训练更慢，但据 Hinton 说，在测试集上效果会有显著提升 （But it does significantly better on the test set!）。</p><h2 id="三、结合多种模型"><a href="#三、结合多种模型" class="headerlink" title="三、结合多种模型"></a>三、结合多种模型</h2><p>简而言之，训练多个模型，以每个模型的平均输出作为结果。</p><p>从 N 个模型里随机选择一个作为输出的期望误差$&lt;[(t-y_i)]^2&gt;$  ，会比所有模型的平均输出的误差$&lt;[(t-\bar{y})]^2&gt;$大:<br><img src="http://omu7tit09.bkt.clouddn.com/15007395063818.png" alt=""></p><p>大概基于这个原理，就可以有很多方法了。</p><h3 id="3-1-Bagging和Boost"><a href="#3-1-Bagging和Boost" class="headerlink" title="3.1 Bagging和Boost"></a>3.1 Bagging和Boost</h3><p>简单理解，就是分段函数的概念：用不同的模型拟合不同部分的训练集。以随机森林（Rand Forests）为例，就是训练了一堆互不关联的决策树。但由于训练神经网络本身就需要耗费较多自由，所以一般不单独使用神经网络做Bagging。</p><p>bagging和boosting详细可见<a href="https://plushunter.github.io/2017/01/18/机器学习算法系列（6）：AdaBoost/" target="_blank" rel="noopener">机器学习算法系列（6）：AdaBoost</a></p><h3 id="3-2-Dropout"><a href="#3-2-Dropout" class="headerlink" title="3.2 Dropout"></a>3.2 Dropout</h3><p>正则是通过在代价函数后面加上正则项来防止模型过拟合的。而在神经网络中，有一种方法是通过修改神经网络本身结构来实现的，其名为Dropout。该方法是在对网络进行训练时用一种技巧（trick），</p><p>Dropout是hintion最近2年提出的，源于其文章Improving neural networks by preventing co-adaptation of feature detectors.中文大意为：通过阻止特征检测器的共同作用来提高神经网络的性能。</p><p><img src="http://omu7tit09.bkt.clouddn.com/15007401563802.jpg" alt=""></p><p><img src="http://omu7tit09.bkt.clouddn.com/15007402177979.png" alt=""></p><p>在训练时，每次随机（如50%概率）忽略隐层的某些节点；这样，我们相当于随机从$2^H$个模型中采样选择模型；同时，由于每个网络只见过一个训练数据（每次都是随机的新网络），所以类似 bagging 的做法，这就是我为什么将它分类到「结合多种模型」中；</p><p>此外，而不同模型之间权值共享（共同使用这 H 个神经元的连接权值），相当于一种权值正则方法，实际效果比 L2 regularization 更好。</p><p><a href="http://blog.csdn.net/u012162613/article/details/44261657" target="_blank" rel="noopener">正则化方法：L1和L2 regularization、数据集扩增、dropout</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;过拟合（overfitting）是指在模型参数拟合过程中的问题，由于训练数据包含抽样误差，训练时，复杂的模型将抽样误差也考虑在内，将抽样误差也进行了很好的拟合。具体表现就是最终模型在训练集上效果好，而在测试集上的效果很差，模型的泛化能力比较弱。&lt;/p&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="卷积神经网络" scheme="http://yoursite.com/tags/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="dropout" scheme="http://yoursite.com/tags/dropout/"/>
    
      <category term="过拟合" scheme="http://yoursite.com/tags/%E8%BF%87%E6%8B%9F%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>深度学习系列（10）：DMC—卷积神经网络分享</title>
    <link href="http://yoursite.com/2017/05/19/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%EF%BC%8810%EF%BC%89%EF%BC%9A%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%86%E4%BA%AB/"/>
    <id>http://yoursite.com/2017/05/19/深度学习系列（10）：卷积神经网络分享/</id>
    <published>2017-05-19T15:14:45.000Z</published>
    <updated>2017-12-26T10:33:25.250Z</updated>
    
    <content type="html"><![CDATA[<p>PDF链接：<a href="http://omu7tit09.bkt.clouddn.com/DMC%E2%80%94%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.pdf" target="_blank" rel="noopener">卷积神经网络</a><br>PPT链接（动图）：<a href="https://pan.baidu.com/s/1jInaGXC" target="_blank" rel="noopener">百度云</a></p><a id="more"></a><p><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-06 上午11.51.11.png" alt="屏幕快照 2017-07-06 上午11.51.11"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-06 上午11.53.35.png" alt="屏幕快照 2017-07-06 上午11.53.35"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-06 上午11.53.42.png" alt="屏幕快照 2017-07-06 上午11.53.42"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-06 上午11.53.48.png" alt="屏幕快照 2017-07-06 上午11.53.48"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-06 上午11.53.55.png" alt="屏幕快照 2017-07-06 上午11.53.55"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-06 上午11.53.59.png" alt="屏幕快照 2017-07-06 上午11.53.59"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-06 上午11.54.06.png" alt="屏幕快照 2017-07-06 上午11.54.06"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-06 上午11.54.10.png" alt="屏幕快照 2017-07-06 上午11.54.10"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-06 上午11.54.15.png" alt="屏幕快照 2017-07-06 上午11.54.15"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-06 上午11.54.20.png" alt="屏幕快照 2017-07-06 上午11.54.20"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-06 上午11.54.25.png" alt="屏幕快照 2017-07-06 上午11.54.25"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-06 上午11.54.29.png" alt="屏幕快照 2017-07-06 上午11.54.29"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-06 上午11.54.44.png" alt="屏幕快照 2017-07-06 上午11.54.44"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-06 上午11.54.50.png" alt="屏幕快照 2017-07-06 上午11.54.50"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-06 上午11.54.55.png" alt="屏幕快照 2017-07-06 上午11.54.55"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-06 上午11.55.00.png" alt="屏幕快照 2017-07-06 上午11.55.00"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-06 上午11.55.06.png" alt="屏幕快照 2017-07-06 上午11.55.06"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-06 上午11.55.45.png" alt="屏幕快照 2017-07-06 上午11.55.45"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-06 上午11.55.50.png" alt="屏幕快照 2017-07-06 上午11.55.50"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-06 上午11.55.54.png" alt="屏幕快照 2017-07-06 上午11.55.54"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-06 上午11.55.59.png" alt="屏幕快照 2017-07-06 上午11.55.59"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-06 上午11.56.07.png" alt="屏幕快照 2017-07-06 上午11.56.07"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-06 上午11.56.13.png" alt="屏幕快照 2017-07-06 上午11.56.13"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-06 上午11.56.18.png" alt="屏幕快照 2017-07-06 上午11.56.18"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-06 上午11.56.23.png" alt="屏幕快照 2017-07-06 上午11.56.23"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-06 上午11.56.30.png" alt="屏幕快照 2017-07-06 上午11.56.30"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-06 上午11.56.37.png" alt="屏幕快照 2017-07-06 上午11.56.37"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-06 上午11.56.43.png" alt="屏幕快照 2017-07-06 上午11.56.43"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-06 上午11.56.49.png" alt="屏幕快照 2017-07-06 上午11.56.49"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-06 上午11.56.54.png" alt="屏幕快照 2017-07-06 上午11.56.54"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-06 上午11.57.02.png" alt="屏幕快照 2017-07-06 上午11.57.02"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-06 上午11.57.09.png" alt="屏幕快照 2017-07-06 上午11.57.09"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-06 上午11.57.14.png" alt="屏幕快照 2017-07-06 上午11.57.14"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-06 上午11.57.21.png" alt="屏幕快照 2017-07-06 上午11.57.21"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-06 上午11.57.29.png" alt="屏幕快照 2017-07-06 上午11.57.29"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-06 上午11.57.34.png" alt="屏幕快照 2017-07-06 上午11.57.34"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-06 上午11.57.38.png" alt="屏幕快照 2017-07-06 上午11.57.38"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-06 上午11.57.43.png" alt="屏幕快照 2017-07-06 上午11.57.43"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-06 上午11.57.49.png" alt="屏幕快照 2017-07-06 上午11.57.49"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-06 上午11.57.54.png" alt="屏幕快照 2017-07-06 上午11.57.54"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-06 上午11.57.59.png" alt="屏幕快照 2017-07-06 上午11.57.59"><br><img src="http://omu7tit09.bkt.clouddn.com/屏幕快照 2017-07-06 上午11.58.03.png" alt="屏幕快照 2017-07-06 上午11.58.03"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PDF链接：&lt;a href=&quot;http://omu7tit09.bkt.clouddn.com/DMC%E2%80%94%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;卷积神经网络&lt;/a&gt;&lt;br&gt;PPT链接（动图）：&lt;a href=&quot;https://pan.baidu.com/s/1jInaGXC&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;百度云&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="卷积神经网络" scheme="http://yoursite.com/tags/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="Batch Normalization" scheme="http://yoursite.com/tags/Batch-Normalization/"/>
    
      <category term="dropout" scheme="http://yoursite.com/tags/dropout/"/>
    
      <category term="优化" scheme="http://yoursite.com/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>深度学习系列（9）：Batch Normalization</title>
    <link href="http://yoursite.com/2017/05/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%EF%BC%889%EF%BC%89%EF%BC%9ABatch%20Normalization/"/>
    <id>http://yoursite.com/2017/05/14/深度学习系列（9）：Batch Normalization/</id>
    <published>2017-05-14T15:14:45.000Z</published>
    <updated>2017-12-26T10:34:07.163Z</updated>
    
    <content type="html"><![CDATA[<p>batch normalization(Ioffe and Szegedy, 2015) 是优化深度神经网络中最激动人心的创新之一。实际上它并不是一个优化算法，而是一个自适应的重新参数化 的方法，试图解决训练非常深层模型的困难。<br>Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift<br>机器学习领域有一个很重要的假设：iid独立同分布假设，就是假设训练数据和测试数据满足相同分布，这是通过训练数据训练出来的模型能够在测试集上获得好的效果的一个基本保证。Batch Normalization就是在深度神经网络训练过程中使得每一层神经网络的输入保持相同分布。</p><a id="more"></a><h2 id="一、Internal-covariate-shift"><a href="#一、Internal-covariate-shift" class="headerlink" title="一、Internal covariate shift"></a>一、Internal covariate shift</h2><p>首先给出covariate shift的定义：模型实例集合<x,y>中的输入值X的分布总是变化，违背了idd独立通同布假设。</x,y></p><p>深度学习网络包含很多隐层的网络结构，在训练过程中参数会不断发生改变，导致后续每一层输入的分布也面临着covariate shift，也就是在训练过程中，隐层的输入分布总是发生改变，这就是所谓的Internal covariate shift，Internal指的是深层网络的隐层，covariate shift发生在深度神经网络内部，就被称作Internal covariate shift。</p><p>在DNN的实验中，对数据进行预处理时，例如白化或者zscore，甚至是简单的减均值操作都是可以加速收敛的。为什么减均值、白化可以加快训练，作如下分析：</p><p>首先，图像数据的每一维一般都是0~255之间的数字，因此数据点智慧落在第一象限，而且图像数据具有很强的相关性，比如第一个灰度值为30，比较黑，那它旁边的一个像素值一般不会超过100，否则给人的感觉就像噪声一样。由于强相关性，数据点仅会落在第一象限的小区域内，形成类似第一个图的狭长分布。</p><p>其次，神经网络模型在初始化的时候，权重W都是随机采样生成的，一般都是零均值，因此起初的拟合y=Wx+b，基本过原点附近，如图b红色虚线。因此，网络需要经过多次迭代学习才能逐步达到如紫色实线的拟合，即收敛的比较慢。更何况，这里只是个二维的演示，数据占据四个象限中的一个，但如果是几百、几千、上万维呢？而且数据在第一象限也只是占了很小的一部分区域而已，可想而知若不对数据进行预处理带来了多少运算资源的浪费，而且大量的数据外分割面在迭代时很可能会在刚进入数据中是就遇到了一个局部最优，导致overfit的问题。如果我们对输入数据先作减均值操作，如图c，数据点就不再只分布在第一象限，这是一个随机分界面落入数据分布的概率增加了$2^n$倍，大大加快学习。更进一步的，我们对数据再进行去相关操作，例如PCA和ZCA白化，数据不再是一个狭长的分布，随机分界面有效的概率就又大大增加了，使得数据更加容易区分，这样又会加快训练，如图d。 </p><p><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-16%20%E4%B8%8A%E5%8D%8811.29.37.png" alt="屏幕快照 2017-05-16 上午11.29.37"></p><p>不过计算协方差的特征值太耗时也太耗空间，一般最多只用到z-score处理，即每一维减去自身均值，再除以自身标准差，这样能使数据点在每维上具有相似的宽度，可以起到增大数据分布范围，进而使更多随机分界面有意义的作用。</p><h2 id="二、Batch-Normalization"><a href="#二、Batch-Normalization" class="headerlink" title="二、Batch Normalization"></a>二、Batch Normalization</h2><h3 id="2-1-直观解释"><a href="#2-1-直观解释" class="headerlink" title="2.1 直观解释"></a>2.1 直观解释</h3><p>Batch Normalization的基本思想其实很直观：因为深层神经网络在做非线性变换前的激活输入值（就是那个x=WU+B,U是输入）随着网络深度加深或者在训练过程中，其分布逐渐发生偏移或者变动，之所以收敛慢，一般是整体分布逐渐往非线性函数的取值区间的上下限两端靠近（对于Sigmoid函数来说，意味着激活输入值WU+B是大的负值或者正值），所以这导致反向传播的时候低层神经网络的梯度消失，这是训练深层神经网络收敛越来越慢的本质原因，而BN就是通过一定的规范化手段，对于每个隐层神经元，把逐渐向非线性函数映射后向取值区间极限饱和区靠拢的输入分布强制拉回到均值为0方差为1的比较标准的正态分布，使得非线性变换函数的输入值落入对输入比较敏感的区域，以此避免梯度消失问题。因为梯度一直都能保持比较大的状态，所以很明显对神经网络的参数调整效率比较高，就是变动大，就是说向损失函数最优值迈动的步子大，也就是说收敛地快。</p><p>但是这里有个问题，如果都通过Batch Normalization，那么不就跟把非线性函数替换成线性函数效果相同了？我们知道，如果是多层的线性函数变换，其实这个深层是没有意义的，因为多层线性网络跟一层线性网络是等价的。这意味着网络的表达能力下降了，这也意味着深度的意义就没有了。比如下图，在使用sigmoid激活函数的时候，如果把数据限制到零均值单位方差，那么相当于只使用了激活函数中近似线性的部分，这显然会降低模型的表达能力。<img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-16%20%E4%B8%8B%E5%8D%883.29.33.png" alt="屏幕快照 2017-05-16 下午3.29.33"><br>BN为了保证非线性的获得，对变换后的满足均值为0方差为1的x又进行了scale加上shift操作(y=scale*x+shift)，每个神经元增加了两个参数scale和shift参数，这两个参数是通过训练学习到的，意思是通过scale和shift把这个值从标准正态分布左移或者由移一点并长胖一点或者变瘦一点，每个实例挪动的程度不一样，这样等价于非线性函数的值从正中心周围的线性区往非线性区动了动，让因训练所需而“刻意”加入的BN能够有可能还原最初的输入。核心思想应该是想找到一个线性和非线性的较好平衡点，既能享受非线性的较强表达能力的好处，又避免太靠非线性区两头使得网络收敛速度太慢。从而保证整个网络的capacity。</p><h3 id="2-2-算法过程"><a href="#2-2-算法过程" class="headerlink" title="2.2 算法过程"></a>2.2 算法过程</h3><p>假设对于一个深层神经网络来说，其中两层结构如下：<img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-16%20%E4%B8%8B%E5%8D%883.12.17.png" alt="屏幕快照 2017-05-16 下午3.12.17"><br>要对每个隐藏神经元的激活值做BN，可以想象成每个隐层又加上了一层BN操作层，它位于X=WY+B激活值获得之后，非线性函数变换之前，其图示如下：<img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-16%20%E4%B8%8B%E5%8D%883.14.04.png" alt="屏幕快照 2017-05-16 下午3.14.04"><br>对Mini-Batch SGD来说，一次训练过程里面包含m个训练实例，其具体BN操作就是对于隐层内每个神经元的激活值来说，进行如下变换：</p><script type="math/tex; mode=display">\hat{x}^{\left(k\right)}=\frac{x^{\left(k\right)}-E\left[x^{\left(k\right)}\right]}{\sqrt{var\left[x^{\left(k\right)}\right]}}</script><p>要注意，这里t层某个神经元的$x(k)$不是指原始输入，就是说不是$t-1$层每个神经元的输出，而是$t$曾这个神经元的激活$x=WU+B$，这里的$U$才是$t-1$层神经元的输出。<br>还有一点，上述公式中用到了均值和方差，在理想情况下均值和方差是针对整个数据集的，但显然这是不现实的，因此，作者做了简化，用一个Batch的均值和方差作为对整个数据集均值和方差的估计。<br>这个变换就是：某个神经元对应的原始的激活$x$减去Mini-Batch内$m$个激活$x$求得的均值$E(x)$并除以求得的方差$Var(x)$来进行转换。</p><p>上文说过经过这个变换后某个神经元的激活$x$形成了均值为0，方差为1的正态分布，目的是把值往后续要进行的非线性变换的线性区拉动，增大梯度，增强反向传播信息流行性，加快训练收敛速度。但是这样会导致网络表达能力下降，为了防止这一点，每个神经元增加两个调节参数（scale和shift），这俩个参数是通过训练来学习的，用来对变换后的激活反变换，使得网络表达能力增强，即对变换后的激活进行如下的scle和shift操作，这其实是变换的反操作：</p><script type="math/tex; mode=display">y^{\left(k\right)}=\gamma^{\left(k\right)}\hat{x}^{\left(k\right)}+\beta^{\left(k\right)}</script><p>其整个算法流程如下：<img src="http://omu7tit09.bkt.clouddn.com/9ad70be49c408d464c71b8e9a006d141_r.jpg" alt="9ad70be49c408d464c71b8e9a006d141"></p><h3 id="2-3-推理过程"><a href="#2-3-推理过程" class="headerlink" title="2.3 推理过程"></a>2.3 推理过程</h3><p>BN在训练的时候可以根据Mini-Batch数据里可以得到的统计量，那就想其他办法来获得这个统计量，就是均值和方差。可以用从所有训练实例中获得的统计量来代替Mini-Batch里面m个训练实例获得的均值和方差统计量，因为本来就打算用全局的统计量，知识因为计算量等太大所以才会用Mini-Batch这种简化方式的，那么在推理的时候直接用全局统计量即可。</p><p>决定了获得统计量的数据范围，那么接下来的问题就是如何获得均值和方差的问题。很简单，因为每次做Mini-Batch训练时，都会有那个Mini-Batch里m个训练实例获得的均值和方差，现在要全局统计量，只要把每个Mini-batch的均值和方差统计量记住，然后对这些均值和方差求其对应的数学期望即可得出全局统计量，即：</p><script type="math/tex; mode=display">E\left[x\right]\gets E_{\beta}\left[\mu_{\beta}\right]</script><script type="math/tex; mode=display">Var\left[x\right]\gets\frac{m}{m-1}E_{\beta}\left[\sigma_{\beta}^{2}\right]</script><p>有了均值和方差，每个隐藏神经元也已经有对应训练好的Scaling参数和Shift参数，就可以在推导的时候对每个神经元的激活数据计算BN进行变换了，在推理过程中进行BN采取如下方式：</p><script type="math/tex; mode=display">y=\frac{\gamma}{\sqrt{Var\left[x\right]+\epsilon}}·x+\left(\beta -\frac{\gamma E\left[x\right]}{\sqrt{Var\left[x\right]+\epsilon}}\right)</script><p>这个公式其实和训练时</p><script type="math/tex; mode=display">y^{\left(k\right)}=\gamma^{\left(k\right)}\hat{x}^{\left(k\right)}+\beta^{\left(k\right)}</script><p>是等价的，通过简单的合并计算推导就可以得出这个结论。在实际运行时，按照这种变体形式可以减少计算量，因为对每一个隐节点来说：$\frac{\gamma}{\sqrt{Var\left[x\right]+\epsilon}}$和$\frac{\gamma E\left[x\right]}{\sqrt{Var\left[x\right]+\epsilon}}$都是固定值，这样两个值可以实现算好存起来，在推理的时候直接用就行了，比原始的公式每一步骤都少了出发的运算过程，乍一看也没少多少计算量，但是如果隐层节点个数多的话节省的计算量就比较多了。</p><h3 id="2-4-参数训练"><a href="#2-4-参数训练" class="headerlink" title="2.4 参数训练"></a>2.4 参数训练</h3><p>以上是对算法原理的讲述，在反向传导的时候，我们需要求最终的损失函数对$\gamma$和$\beta$两个参数的导数，还要求损失函数对Wx+b中x的导数，一遍使误差继续向后传播。几个主要的公式如下，主要用到了链式法则。<img src="http://omu7tit09.bkt.clouddn.com/beb44145200caafe24fe88e7480e9730_r.jpg" alt="beb44145200caafe24fe88e7480e9730"></p><h2 id="三、Experiments"><a href="#三、Experiments" class="headerlink" title="三、Experiments"></a>三、Experiments</h2><p>作者在文章中也做了很多实验对比，这里简要说明两个：</p><p>下图a说明，BN可以加速训练。图b和c分别展示了训练过程中输入数据分布的变化情况。<img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-16%20%E4%B8%8B%E5%8D%884.03.07.png" alt="屏幕快照 2017-05-16 下午4.03.07"></p><p>下表是一个实验结果的对比，需要注意的是在使用BN的过程中，算法对sigmoid激活函数的提升非常明显，解决了困扰学术界十几年的sigmoid过饱和的问题，但sigmoid在分类问题上确实没有ReLU好用，大概是因为sigmoid的中间部分太“线性”了，不像ReLU一个很大的转折，在拟合复杂非线性函数的时候可能没那么高效。<img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-16%20%E4%B8%8B%E5%8D%884.30.25.png" alt="屏幕快照 2017-05-16 下午4.30.25"></p><h3 id="四、算法优势"><a href="#四、算法优势" class="headerlink" title="四、算法优势"></a>四、算法优势</h3><p>论文中罗列了Batch Normalization的很多作用，一一列举如下：</p><ul><li>1）可以使用很高的学习率。如果每层的scale不一致，实际上每层需要的学习率是不一样的，同一层不同维度的scale往往也需要不同大小的学习率，通常需要使用最小的那个学习率才能保证损失函数有效下降，Batch Normalization</li><li>2）移除或使用较低的dropout。dropout是常用的防止overfitting的方法，而导致overfitting的位置往往在数据边界处，如果初始化权重就已经落在数据内部，overfitting现象就可以得到一定的缓解。论文中最后的模型分别使用10%、5%和0%的dropout训练模型，与之前的40%~50%相比，可以大大提高训练速度。</li><li>3） 降低L2权重衰减系数。 还是一样的问题，边界处的局部最优往往有几维的权重（斜率）较大，使用L2衰减可以缓解这一问题，现在用了Batch Normalization，就可以把这个值降低了，论文中降低为原来的5倍。<ul><li>4）取消Local Response Normalization层。 由于使用了一种Normalization，再使用LRN就显得没那么必要了。而且LRN实际上也没那么work。</li><li>5）减少图像扭曲的使用。 由于现在训练epoch数降低，所以要对输入数据少做一些扭曲，让神经网络多看看真实的数据。</li></ul></li></ul><p>说完BN的优势，自然可以知道什么时候用BN比较好。例如，在神经网络训练时遇到收敛速度很慢，或梯度爆炸等无法训练的状况时可以尝试BN来解决。另外，在一般使用情况下也可以加入BN来加快训练速度，提高模型精度。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;batch normalization(Ioffe and Szegedy, 2015) 是优化深度神经网络中最激动人心的创新之一。实际上它并不是一个优化算法，而是一个自适应的重新参数化 的方法，试图解决训练非常深层模型的困难。&lt;br&gt;Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift&lt;br&gt;机器学习领域有一个很重要的假设：iid独立同分布假设，就是假设训练数据和测试数据满足相同分布，这是通过训练数据训练出来的模型能够在测试集上获得好的效果的一个基本保证。Batch Normalization就是在深度神经网络训练过程中使得每一层神经网络的输入保持相同分布。&lt;/p&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Batch Normalization" scheme="http://yoursite.com/tags/Batch-Normalization/"/>
    
      <category term="过拟合" scheme="http://yoursite.com/tags/%E8%BF%87%E6%8B%9F%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>深度学习系列（8）：激活函数</title>
    <link href="http://yoursite.com/2017/05/12/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%EF%BC%888%EF%BC%89%EF%BC%9A%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2017/05/12/深度学习系列（8）：激活函数/</id>
    <published>2017-05-12T15:14:45.000Z</published>
    <updated>2017-12-26T09:03:43.350Z</updated>
    
    <content type="html"><![CDATA[<p>深度学习的基本原理是基于人工神经网络，信号从一个神经元进入，经过非线性的activation function，传入到下一层神经元；再经过该层神经元的activate function，继续往下传递，如此循环往复，直到输出层。其中的激活函数的主要作用是提供网络的非线性建模能力，使得神经网络有足够的capacity来抓取复杂的pattern，在各个领域取得state-of-the-art的结果。</p><a id="more"></a><p>现在假设一个神经网络中仅包含线性激励和全连接运算，那么该网络仅仅能够表达线性映射，即使增加网络的深度也依旧还是线性映射，即输出都是输入的线性组合，失去了隐藏层存在的意义，难以有效建模实际环境中非线性分布的数据。加入非线性激活函数之后，深度学习网络可以逼近任意函数，具备了分层的非线性映射学习能力。加拿大蒙特利尔大学的Bengio教授在 ICML 2016 的文章中给出了激活函数的定义：激活函数是映射 h:R→R，且几乎处处可导。从定义来看，几乎所有连续可导函数都可以用作激活函数。但目前常见的多是分段线性和具有指数形状的非线性函数。</p><p>显而易见，activation function在深度学习中举足轻重，也是很活跃的研究领域之一。目前来讲，选择怎样的activation function不在于它能否模拟真正的神经元，而在于能否便于优化整个深度神经网络。</p><h2 id="一、软饱和与硬饱和激活函数"><a href="#一、软饱和与硬饱和激活函数" class="headerlink" title="一、软饱和与硬饱和激活函数"></a>一、软饱和与硬饱和激活函数</h2><p>Bengio 教授等将具有</p><ul><li>1）在定义域内处处可导</li><li>2）两侧导数逐渐趋近于0，即$\lim_{x\rightarrow\infty}f’\left(x\right)=0$。<br>的激活函数定义为软饱和激活函数。</li></ul><p>与极限的定义类似，饱和也分为左饱和与右饱和，左侧软饱和为：</p><script type="math/tex; mode=display">\lim_{x\rightarrow -\infty}f'\left(x\right)=0</script><p>右侧软饱和为：</p><script type="math/tex; mode=display">\lim_{x\rightarrow +\infty}f'\left(x\right)=0</script><p>与软饱和激活函数相对的是硬饱和激活函数，即：</p><script type="math/tex; mode=display">f'(x)=0,   当|x|>c,c为常数</script><p>同理，应饱和也分为左饱和与右饱和，左侧硬饱和为：</p><script type="math/tex; mode=display">f'(x)=0,   当-x>c, c为正数</script><p>右侧硬饱和为：</p><script type="math/tex; mode=display">f'(x)=0,   当x>c, c为正数</script><h2 id="二、sigmoid"><a href="#二、sigmoid" class="headerlink" title="二、sigmoid"></a>二、sigmoid</h2><p>sigmoid非线性函数的数学公式为：</p><script type="math/tex; mode=display">\sigma\left(x\right)=\frac{1}{1+e^{-x}}</script><p>函数图像及梯度函数图像如下所示：<br><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-12%20%E4%B8%8B%E5%8D%884.14.47.png" alt="屏幕快照 2017-05-12 下午4.14.47"><br>它将输入实数值“挤压”到0-1范围内。更具体地说，很大的负数变成0，很大的正数变成1。它是便于求导的平滑函数，其导数为$\sigma(x)(1-\sigma(x))$，这是它的优点。sigmoid 在定义域内处处可导，且两侧导数逐渐趋近于0，即：$\lim_{x\rightarrow\infty}f’\left(x\right)=0$</p><p>然而现在sigmoid函数已经不太受欢迎，实际很少使用了，这是因为它有三个主要缺点：</p><ul><li><p>1）梯度消失。Sigmoid 的软饱和性，使得深度神经网络在二三十年里一直难以有效的训练，是阻碍神经网络发展的重要原因。具体地，我们知道优化神经网络的方法是Back Propagation，即导数的反向传递：先计算输出层对应的loss，然后将loss以导数的形式不断向上一层网络传递，修正相应的参数，达到降低loss的目的。sigmoid反向传导的梯度包含了一个f’(x) 因子（sigmoid关于输入的导数），因此一旦输入落入饱和区，f’(x) 就会变得接近于0，导致了向底层传递的梯度也变得非常小。此时，网络参数很难得到有效训练。这种现象被称为梯度消失。一般来说， sigmoid 网络在 5 层之内就会产生梯度消失现象。我们也可以在图中看出原因，主要在于两点：(1) 在上图中容易看出，当$\sigma(x)$中x较大或较小时，导数接近0，而后向传递的数学依据是微积分求导的链式法则，当前层的导数需要之前各层导数的乘积，几个小数的相乘，结果会很接近0 (2) Sigmoid导数的最大值是0.25，这意味着导数在每一层至少会被压缩为原来的1/4，通过两层后被变为1/16，…，通过10层后为1/1048576。请注意这里是“至少”，导数达到最大值这种情况还是很少见的。梯度消失问题至今仍然存在，但被新的优化方法有效缓解了，例如DBN中的分层预训练，Batch Normalization的逐层归一化，Xavier和MSRA权重初始化等代表性技术。</p></li><li><p>2）Sigmoid函数的输出不是Zero-centered的。这个性质并不是我们想要的，因为在神经网络后面层中的神经元得到的数据将不是零中心的。这一情况将影响梯度下降的运作，因为如果输入神经元的数据总是正数(比如在$f=w^Tx+b$中每个元素都x&gt;0),那么关于w的梯度在反向传播的过程中，将会要么全部是正数，要么全部是负数（具体依整个表达式f而定）。这将会导致梯度下降权重更新时出现z字型的下降（如下图所示）。然而，可以看到整个批量的数据的梯度被加起来后，对于权重的最终更新将会有不同的正负，这样就从一定程度上减轻了这个问题。因此，该问题相对于上面的神经元饱和问题来说只是个小麻烦，没有那么严重。<img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-12%20%E4%B8%8B%E5%8D%885.07.16.png" alt="屏幕快照 2017-05-12 下午5.07.16"></p></li><li><p>3）幂运算相对耗时：相对于前两项，这其实并不是一个大问题，我们目前是具备相应计算能力的，但面对深度学习中庞大的计算量，最好是能省则省。之后我们会看到，在ReLU函数中，需要做的仅仅是一个thresholding，相对于幂运算来讲会快很多。</p></li></ul><h2 id="三、tanh"><a href="#三、tanh" class="headerlink" title="三、tanh"></a>三、tanh</h2><p>tanh非线性函数的数学公式为：</p><script type="math/tex; mode=display">tanh x = \frac{e^x-e^{-x}}{e^x+e^{-x}}</script><p>函数图像及梯度函数图像如下所示：<img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-12%20%E4%B8%8B%E5%8D%886.07.46.png" alt="屏幕快照 2017-05-12 下午6.07.46"><br>如上图所示，计算可以知道：$tanh(x)=2sigmoid(2x)-1$，它其实是一个简单放大的sigmoid神经元，和sigmoid神经元一样，也具有软饱和性。但是和sigmoid神经元不同的是，它解决了zero-centered的输出问题，因此，在实际操作中，tanh非线性函数比sigmoid非线性函数更受欢迎。然而，gradient vanishing的问题和幂运算的问题仍然存在。Xavier在文献[]中分析了sigmoid与tanh的饱和现象及特点，具体见原论文。此外，文献[]中提到了tanh网络的收敛速度要比sigmoid块。因为tanh的输出均值比sigmoid更接近0，SGD会更接近natural gradient（一种二次优化技术），从而降低所需的迭代次数。</p><h2 id="四、ReLU"><a href="#四、ReLU" class="headerlink" title="四、ReLU"></a>四、ReLU</h2><p>ReLU非线性函数的数学公式为：</p><script type="math/tex; mode=display">ReLU(x)=max(0,x)</script><p>函数图像及梯度函数图像如下所示：<img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-12%20%E4%B8%8B%E5%8D%886.32.04.png" alt="屏幕快照 2017-05-12 下午6.32.04"><br>虽然2006年Hinton教授提出通过分层无监督预训练解决深层网络训练困难的问题，但是深度网络的直接监督式训练的最终突破，最主要的原因是新型激活函数ReLU。它有以下几大优点：</p><ul><li>1）解决了gradient vanishing问题：ReLU在$x<0$时硬饱和。由于$x>0$时导数为1，所以，ReLU能够在$x&gt;0$时保持梯度不衰减，从而缓解梯度消失问题。</0$时硬饱和。由于$x></li><li>2）计算速度非常快。对比sigmoid和tanh神经元含有指数运算等耗费计算资源的操作，ReLU可以简单地通过对一个矩阵进行阈值计算得到。</li><li>3）收敛速度非常快。相较于sigmoid和tanh函数，ReLU对于随机梯度下降的收敛有巨大的加速作用。下图是从 Krizhevsky 等的论文中截取的图表，指明使用ReLU比使用tanh的收敛快6倍。<br><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-12%20%E4%B8%8B%E5%8D%886.45.18.png" alt="屏幕快照 2017-05-12 下午6.45.18"></li><li>4）ReLU另外一个性质是提供神经网络的稀疏表达能力，在Bengio教授的Deep Sparse Rectifier Neural Network[6]一文中被认为是ReLU带来网络性能提升的原因之一。但后来的研究发现稀疏性并非性能提升的必要条件，文献 RReLU [9]也指明了这一点。<ul><li>PReLU[10]、ELU[7]等激活函数不具备这种稀疏性，但都能够提升网络性能。本文作者在文章[8]中给出了一些实验比较结果。首先，在cifar10上采用NIN网络，实验结果为 PReLU &gt; ELU &gt; ReLU，稀疏性并没有带来性能提升。其次，在 ImageNet上采用类似于[11] 中model E的15 层网络，实验结果则是ReLU最好。为了验证是否是稀疏性的影响，以 LReLU [12]为例进一步做了四次实验，负半轴的斜率分别为1，0.5，0.25,  0.1，需要特别说明的是，当负半轴斜率为1时，LReLU退化为线性函数，因此性能损失最大。实验结果展现了斜率大小与网络性能的一致性。综合上述实验可知，ReLU的稀疏性与网络性能之间并不存在绝对正负比关系。<img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-12%20%E4%B8%8B%E5%8D%887.41.41.png" alt="屏幕快照 2017-05-12 下午7.41.41"></li></ul></li></ul><p> ReLU也有几个缺点：</p><ul><li>1）Dead ReLU Problem。随着训练的推进，部分输入会落入硬饱和区，某些神经元可能永远不会被激活，这个ReLU单元在训练中将不可逆转的死亡，导致相应的参数永远不能被更新，使得数据多样化丢失。这种现象被称为“神经元死亡”。有两个主要原因可能导致这种情况产生: (1) 非常不幸的参数初始化，这种情况比较少见 (2) learning rate太高导致在训练过程中参数更新太大，不幸使网络进入这种状态。例如，如果学习率设置得太高，可能会发现网络中40%的神经元都会死掉（在整个训练集中这些神经元都不会被激活）。解决方法是可以采用Xavier初始化方法，以及避免将learning rate设置太大或使用adagrad等自动调节learning rate的算法。</li><li>2）偏移现象。即输出均值恒大于零。偏移现象和Dead ReLU Problem会共同影响网络的收敛性。</li></ul><p>尽管存在上述几个问题，ReLU目前仍是最常用的activation function，在搭建人工神经网络的时候推荐优先尝试！</p><h2 id="五、Leaky-ReLU"><a href="#五、Leaky-ReLU" class="headerlink" title="五、Leaky ReLU"></a>五、Leaky ReLU</h2><p>Leaky ReLU非线性函数的数学公式为：</p><script type="math/tex; mode=display">f(x)=max(0.01x,x)</script><p>函数图像及梯度函数图像如下所示：<img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-12%20%E4%B8%8B%E5%8D%887.23.31.png" alt="屏幕快照 2017-05-12 下午7.23.31"><br>人们为了解决Dead ReLU Problem，提出了将ReLU的前半段设为0.01x而非0。<br>理论上来说，Leaky ReLU拥有ReLU的所有优点，外加不会有Dead ReLU problem，但是在实际操作中，并没有完全证明Leaky ReLU总是好于ReLU。有些研究者的论文指出这个激活函数表现很不错，但是其效果并不是很稳定。</p><h2 id="六、PReLU"><a href="#六、PReLU" class="headerlink" title="六、PReLU"></a>六、PReLU</h2><p>Parametric ReLU非线性函数的数学公式为：</p><script type="math/tex; mode=display">f(x)=max(\alpha x,x)</script><p>PReLU是ReLU和LReLU的改进版本，具有非饱和性。与LReLU相比，PReLU中的负半轴斜率$\alpha$由back propagation学习而非固定。原文献建议初始化$\alpha$为0.25，不采用正则。</p><p>虽然PReLU 引入了额外的参数，但基本不需要担心过拟合。例如，在cifar10+NIN实验中， PReLU比ReLU和ELU多引入了参数，但也展现了更优秀的性能。所以实验中若发现网络性能不好，建议从其他角度寻找原因。</p><p>与ReLU相比，PReLU收敛速度更快。因为PReLU的输出更接近0均值，使得SGD更接近natural gradient。证明过程参见原文[10]。</p><h2 id="七、RReLU"><a href="#七、RReLU" class="headerlink" title="七、RReLU"></a>七、RReLU</h2><p>数学形式与PReLU类似，但RReLU[9]是一种非确定性激活函数，其参数是随机的。这种随机性类似于一种噪声，能够在一定程度上起到正则效果。作者在cifar10/100上观察到了性能提升。</p><p>综上，ReLU家族讲完了，总结如下图：<br><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-12%20%E4%B8%8B%E5%8D%888.56.35.png" alt="屏幕快照 2017-05-12 下午8.56.35"><br>其中表格为在cifar10上采用NIN网络的实验结果。</p><h2 id="八、Maxout"><a href="#八、Maxout" class="headerlink" title="八、Maxout"></a>八、Maxout</h2><p>Maxout[13]是ReLU的推广，其发生饱和是一个零测集事件（measure zero event）。正式定义为：</p><script type="math/tex; mode=display">max(w_1^Tx+b_1,w^T_2+b_2,···,w_n^Tx+b_n)</script><p>Maxout网络能够近似任意连续函数，且Maxout是对ReLU和leaky ReLU的一般化归纳，当$w_2,b_2,···,w_n,b_n$为0时，退化为ReLU。其实，Maxout的思想在视觉领域存在已久。例如，在HOG特征里有这么一个过程：计算三个通道的梯度强度，然后在每一个像素位置上，仅取三个通道中梯度强度最大的数值，最终形成一个通道。这其实就是Maxout的一种特例。</p><p>所以Maxout神经元就拥有ReLU单元的所有优点（线性操作和不饱和，能够缓解梯度消失），而没有它的缺点（死亡的ReLU单元）。然而和ReLU对比，它每个神经元的参数数量增加了一倍，这就导致整体参数的数量激增。</p><h2 id="九、ELU"><a href="#九、ELU" class="headerlink" title="九、ELU"></a>九、ELU</h2><p>ELU（Exponential Linear Units）非线性函数的数学公式为：</p><script type="math/tex; mode=display">f(x)=max(0,x)+\alpha·min(0,exp(x)-1)</script><p>函数图像及梯度函数图像如下所示：<img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-12%20%E4%B8%8B%E5%8D%889.14.25.png" alt="屏幕快照 2017-05-12 下午9.14.25"><br>ELU也是为解决ReLU存在的问题而提出，显然，ELU有ReLU的基本所有优点，并有自身的特点，罗列如下：</p><ul><li>1）右侧线性部分使得ELU能够缓解梯度消失，而左侧软饱和能够燃ELU对输入变换或噪声更加鲁棒。</li><li>2）ELU的输出均值接近于零，即zero-centered，所以收敛速度更快。经ELU的作者实验，ELU的收敛性质的确优于ReLU和PReLU。在cifar10上，ELU 网络的loss 降低速度更快；在 ImageNet上，不加 Batch Normalization 30 层以上的 ReLU 网络会无法收敛，PReLU网络在MSRA的Fan-in （caffe ）初始化下会发散，而 ELU 网络在Fan-in/Fan-out下都能收敛 。</li></ul><p>它的一个小问题在于计算量稍大，类似于Leaky ReLU，理论上虽然好于ReLU，但在实际使用中目前并没有好的证据证明ELU总是优于ReLU。</p><h2 id="十、Noisy-Activation-Functions"><a href="#十、Noisy-Activation-Functions" class="headerlink" title="十、Noisy Activation Functions"></a>十、Noisy Activation Functions</h2><p>Bengio教授在ICML2016提出了一种激活策略[1]，可用于多种软饱和激活函数，例如sigmoid和tanh。<br><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-12%20%E4%B8%8B%E5%8D%889.26.38.png" alt="屏幕快照 2017-05-12 下午9.26.38"><br><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-12%20%E4%B8%8B%E5%8D%889.28.10.png" alt="屏幕快照 2017-05-12 下午9.28.10"><br>当激活函数发生饱和时，网络参数还能够在两种动力下继续更新：正则项梯度和噪声梯度。引入适当的噪声能够扩大SGD的参数搜索范围，从而有机会跳出包河区。在激活函数中引入噪声的更早工作可追溯到[5]，但文献[5]的工作并不考虑噪声引入的时间和大小。本篇的特点在于，只在饱和区引入噪声，且噪声量与饱和程度相关（原式与泰勒展开式一次项之差$\delta$）。算法1中g表示sigmoid，用于归一化$\delta$。注意，ReLU的$\delta$恒为0，无法直接加噪声，所以作者把噪声加在了输入上。</p><h2 id="CReLU"><a href="#CReLU" class="headerlink" title="CReLU"></a>CReLU</h2><h2 id="MPELU"><a href="#MPELU" class="headerlink" title="MPELU"></a>MPELU</h2><h2 id="十一、小结"><a href="#十一、小结" class="headerlink" title="十一、小结"></a>十一、小结</h2><p>建议用ReLU非线性函数。但是要注意初始化和learning rate的设置，或许可以监控你的网络中死亡的神经元占的比例。如果单元死亡问题困扰你，就试试Leaky ReLU或者Maxout，不要再用sigmoid了。也可以试试tanh，但是其效果应该不如ReLU或者Maxout。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] Gulcehre, C., et al., Noisy Activation Functions, in ICML 2016. 2016.<br>[2] Glorot, X. and Y. Bengio. Understanding the difficulty of training deep feedforward neural networks. AISTATS 2010.<br>[3]  LeCun, Y., et al., Backpropagation applied to handwritten zip code recognition. Neural computation, 1989. 1(4): p. 541-551.<br>[4] Amari, S.-I., Natural gradient works efficiently in learning. Neural computation, 1998. 10(2): p. 251-276.<br>[5] Nair, V. and G.E. Hinton. Rectified linear units improve Restricted Boltzmann machines. ICML 2010.<br>[6] Glorot, X., A. Bordes, and Y. Bengio. Deep Sparse Rectifier Neural Networks.AISTATS 2011.<br>[7] Djork-Arné Clevert, T.U., Sepp Hochreiter. Fast and Accurate Deep Network Learning by Exponential Linear Units (ELUs). ICLR 2016.<br>[]<br>[9] Xu, B., et al. Empirical Evaluation of Rectified Activations in Convolutional Network. ICML Deep Learning Workshop 2015.<br>[10] He, K., et al. Delving Deep into Rectifiers: Surpassing Human-Level Performance on ImageNet Classification. ICCV 2015.<br>[11] He, K. and J. Sun Convolutional Neural Networks at Constrained Time Cost. CVPR 2015.<br>[12] Maas, A.L., Awni Y. Hannun, and Andrew Y. Ng. Rectifier nonlinearities improve neural network acoustic models. in ICML 2013.<br>[13] Goodfellow, I.J., et al. Maxout Networks.  ICML 2013..</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;深度学习的基本原理是基于人工神经网络，信号从一个神经元进入，经过非线性的activation function，传入到下一层神经元；再经过该层神经元的activate function，继续往下传递，如此循环往复，直到输出层。其中的激活函数的主要作用是提供网络的非线性建模能力，使得神经网络有足够的capacity来抓取复杂的pattern，在各个领域取得state-of-the-art的结果。&lt;/p&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="激活函数" scheme="http://yoursite.com/tags/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"/>
    
      <category term="ReLU" scheme="http://yoursite.com/tags/ReLU/"/>
    
  </entry>
  
  <entry>
    <title>深度学习系列（7）：神经网络的优化方法</title>
    <link href="http://yoursite.com/2017/05/11/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%EF%BC%887%EF%BC%89%EF%BC%9A%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2017/05/11/深度学习系列（7）：神经网络的优化方法/</id>
    <published>2017-05-11T15:14:45.000Z</published>
    <updated>2017-12-26T09:06:26.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Gradient-Descent-Robbins-and-Monro-1951-Kiefer-et-al-1952"><a href="#一、Gradient-Descent-Robbins-and-Monro-1951-Kiefer-et-al-1952" class="headerlink" title="一、Gradient Descent [Robbins and Monro, 1951, Kiefer et al., 1952]"></a>一、Gradient Descent [Robbins and Monro, 1951, Kiefer et al., 1952]</h2><p>机器学习中，梯度下降法常用来对相应的算法进行训练。常用的梯度下降法包含三种不同的形式，分别是BGD、SGD和MBGD，它们的不同之处在于我们在对目标函数进行梯度更新时所使用的样本量的多少。</p><a id="more"></a><p>以线性回归算法来对三种梯度下降法进行比较。<br>一般线性回归函数的假设函数为：</p><script type="math/tex; mode=display">h_{\theta}=\sum_{j=0}^n{\theta_jx_j}</script><p>（即有n个特征）对应的损失函数为</p><script type="math/tex; mode=display">L\left(\theta\right)=\frac{1}{2m}\sum_{i=1}^m{\left(h\left(x_i\right)-y_i\right)^2}</script><p>下图即为一个二维参数$\theta _0$和$\theta _1$组对应的损失函数可视化图像：<img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-06%20%E4%B8%8B%E5%8D%884.02.19.png" alt="屏幕快照 2017-05-06 下午4.02.19"></p><h3 id="1-1-BGD（Batch-Gradient-Descent）"><a href="#1-1-BGD（Batch-Gradient-Descent）" class="headerlink" title="1.1 BGD（Batch Gradient Descent）"></a>1.1 BGD（Batch Gradient Descent）</h3><p>批量梯度下降法（Batch Gradient Descent，简称BGD）是梯度下降法最原始的形式，它的具体思路是在更新每一参数时都使用所有的样本来进行更新，其数学形式如下：</p><ul><li>1）对上述的损失函数求偏导：<script type="math/tex; mode=display">\frac{\partial L\left(\theta\right)}{\partial\theta_j}=-\frac{1}{m}\sum_{i=1}^m{\left(y^{\left(i\right)}-h_{\theta}\left(x^{\left(i\right)}\right)\right)}x_{j}^{\left(i\right)}</script></li><li>2）由于是最小化损失函数，所以按照每个参数$\theta$的梯度负方向来更新每个$\theta$：<br><script type="math/tex">\theta_{j}^{'}=\theta_j+\frac{1}{m}\sum_{i=1}^m{\left(y^{\left(i\right)}-h_{\theta}\left(x^{\left(i\right)}\right)\right)x_{j}^{\left(i\right)}}</script>其伪代码如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(nb_epochs):</div><div class="line">  params_grad = evaluate_gradient(loss_function, data, params)</div><div class="line">  params = params - learning_rate * params_grad</div></pre></td></tr></table></figure><p>从上面的公式可以看到，它得到的是全局最优解，但是每迭代一步，都要用到训练集所有的数据，若样本数目$m$很大，那么迭代速度会大大降低。<br>其优缺点如下：</p><ul><li>优点：全局最优解；易于并行实现；</li><li>缺点：当样本量很大时，训练过程会很慢</li></ul><h3 id="1-2-SGD（Stochastic-Gradient-Descent）"><a href="#1-2-SGD（Stochastic-Gradient-Descent）" class="headerlink" title="1.2 SGD（Stochastic Gradient Descent）"></a>1.2 SGD（Stochastic Gradient Descent）</h3><p>由于批量梯度下降法在更新每一个参数时，都需要所有的训练样本，所以训练过程会随着样本数量的加大而变得异常缓慢。随机梯度下降法（Stochastic Gradient Descent，简称SGD）正是为了解决批量梯度下降法这一弊端而提出的。<br>对每个样本的损失函数对$\theta$求偏导得到对应的梯度，来更新$\theta$：</p><script type="math/tex; mode=display">\theta_{j}^{'}=\theta_j+\left(y^{\left(i\right)}-h_{\theta}\left(x^{\left(i\right)}\right)\right)x_{j}^{\left(i\right)}</script><p>具体的伪代码形式为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(nb_epochs):</div><div class="line">  np.random.shuffle(data)</div><div class="line">  <span class="keyword">for</span> example <span class="keyword">in</span> data:</div><div class="line">    params_grad = evaluate_gradient(loss_function, example, params)</div><div class="line">    params = params - learning_rate * params_grad</div></pre></td></tr></table></figure><p>随机梯度下降是通过每个样本来迭代更新一次，如果样本量很大的情况（例如几十万），那么可能只用其中几万条或者几千条的样本，就已将将$\theta$迭代到最优解了，对比上面的批量梯度下降，迭代一次不可能最优，如果迭代十次的话就需要遍历训练样本10次。但是，SGD伴随的一个问题是噪音较BGD要多，使得SGD并不是每次迭代都向着整体最优化方向。<br>其优缺点如下：</p><ul><li>优点：训练速度快；</li><li>缺点：准确度下降，并不是全局最优；不易于并行实现。</li></ul><p>从迭代次数上来看，SGD迭代的次数较多，在解空间的搜索过程看起来很盲目。其迭代的收敛曲线示意图表示如下：</p><p><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-06%20%E4%B8%8B%E5%8D%884.47.53.png" alt="屏幕快照 2017-05-06 下午4.47.53"></p><h3 id="1-3-MBGD（Mini-batch-Gradient-Descent）"><a href="#1-3-MBGD（Mini-batch-Gradient-Descent）" class="headerlink" title="1.3 MBGD（Mini-batch Gradient Descent）"></a>1.3 MBGD（Mini-batch Gradient Descent）</h3><p>从上述的两种梯度下降法可以看出，其各自均有优缺点，那么能否在两种方法的性能之间取得一个折中呢？即，算法的训练过程比较快，而且也要保证最终参数训练的准确率，而这正是小批量梯度下降法（Mini-batch Gradient Descent，简称MBGD）的初衷。</p><p>下面的伪代码中，我们每轮迭代的mini-batches设置为50：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(nb_epochs):</div><div class="line">  np.random.shuffle(data)</div><div class="line">  <span class="keyword">for</span> batch <span class="keyword">in</span> get_batches(data, batch_size=<span class="number">50</span>):</div><div class="line">    params_grad = evaluate_gradient(loss_function, batch, params)</div><div class="line">    params = params - learning_rate * params_grad</div></pre></td></tr></table></figure><h3 id="1-4-梯度下降算法的局限"><a href="#1-4-梯度下降算法的局限" class="headerlink" title="1.4 梯度下降算法的局限"></a>1.4 梯度下降算法的局限</h3><p>虽然梯度下降算法效果很好，并且被广泛的使用，但它存在着一些需要解决的问题：</p><ul><li>1）首先选择一个合适的学习速率很难。若学习速率过小，则会导致收敛速度很慢。如果学习速率过大，那么会阻碍收敛，即在极值点附近振荡</li><li>2）学习速率调整（又称学习速率调度，Learning rate schedules）试图在每次更新过程中，改变学习速率，如模拟退火按照预先设定的调度算法或者当相邻的迭代中目标变化小于一个阈值时候减小学习速率。但是梯度下降算法的调度和阈值需要预先设置，无法对数据集特征进行自适应。</li><li>3）模型所有的参数每次更新都是使用相同的学习速率。如果我们的数据很稀疏并且我们的特征出现的次数不同，我们可能不会希望所有的参数以某种相同的幅度进行更新，而是针对很少出现的特征进行一次大幅度更新。</li><li>4）在神经网络中常见的极小化highly non-convex error functions的一个关键挑战是避免步入大量的suboptimal local minima。Dauphin等人认为实践中的困难来自saddle points而非local minima。这些saddle points（鞍点）经常被一个相等误差的平原包围，导致SGD很难摆脱，因为梯度在所有方向都近似于0。</li></ul><h2 id="二、Momentum"><a href="#二、Momentum" class="headerlink" title="二、Momentum"></a>二、Momentum</h2><p>这是一种启发式算法。形式如下：</p><script type="math/tex; mode=display">v_t=\gamma v_{t-1}+\eta\nabla_{\theta}J\left(\theta\right)</script><script type="math/tex; mode=display">\theta =\theta -v_t</script><p>我们用物理上的动能势能转换来理解它。即物体在这一时刻的动能=物体在上一时刻的动能+上一时刻的势能差。由于有阻力和转换时的损失，所以两者都乘以一个系数。</p><p>就像一个小球从坡上向下滚，当前的速度取决于上一时刻的速度和势能的改变量。</p><p>这样在更新参数时，除了考虑到梯度以外，还考虑了上一时刻参数的历史变更幅度。例如，参数上一次更新幅度较大，并且梯度也较大，那么在更新时是不是得更加猛烈一些了。这样的启发式算法，从直观感知上确实有道理。</p><p>下面两张图直观的展示了Momentum算法，其中绿色箭头表示上一时刻参数的变更幅度，红色箭头表示梯度，两者向量叠加即得到蓝色箭头即真实的更新幅度。<img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-11%20%E4%B8%8B%E5%8D%8811.07.13.png" alt="屏幕快照 2017-05-11 下午11.07.13"><br><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-11%20%E4%B8%8B%E5%8D%8811.11.51.png" alt="屏幕快照 2017-05-11 下午11.11.51"></p><h2 id="三、NAG（Nesterov-accelerated-gradient）-Nesterov-1983"><a href="#三、NAG（Nesterov-accelerated-gradient）-Nesterov-1983" class="headerlink" title="三、NAG（Nesterov accelerated gradient） [Nesterov, 1983]"></a>三、NAG（Nesterov accelerated gradient） [Nesterov, 1983]</h2><p>还是以上面小球的例子来看，momentum方式下小球完全是盲目被动的方式滚下的。这样有个缺点就是在邻近最优点附近是控制不住速度的。我们希望小球可以预判后面的“地形”，要是后面地形还是很陡峭，那就继续坚定不移地大胆走下去，不然的话就减缓速度。</p><p>当然，小球自己也不知道真正要走到哪里，这里以</p><script type="math/tex; mode=display">\theta - \gamma v_{t-1}</script><p>作为下一个位置的近似，将动量的公式更改为：</p><script type="math/tex; mode=display">v_t=\gamma v_{t-1}+\eta\nabla_{\theta}J\left(\theta - \gamma v_{t-1}\right)</script><script type="math/tex; mode=display">\theta =\theta -v_t</script><p>相比于动量方式考虑的是上一时刻的动能和当前点的梯度，而NAG考虑的是上一时刻的梯度和近似下一点的梯度，这使得它可以先往前探探路，然后慎重前进。</p><p>Hinton的slides是这样给出的：<img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-06%20%E4%B8%8B%E5%8D%885.29.11.png" alt="屏幕快照 2017-05-06 下午5.29.11"><br>其中两个blue vectors分别理解为梯度和动能，两个向量和即为momentum方式的作用结果。</p><p>而靠左边的brown vector是动能，可以看出它那条blue vector是平行的，但它预测了下一阶段的梯度是red vector，因此向量和就是green vector，即NAG方式的作用结果。</p><p>momentum项和nesterov项都是为了使梯度更新更加灵活，对不同情况有针对性。但是，人工设置一些学习率总还是有些生硬，接下来介绍几种自适应学习率的方法</p><h2 id="四、学习率退火"><a href="#四、学习率退火" class="headerlink" title="四、学习率退火"></a>四、学习率退火</h2><p>训练深度网络的时候，可以让学习率随着时间退火。因为如果学习率很高，系统的动能就过大，参数向量就会无规律地变动，无法稳定到损失函数更深更窄的部分去。对学习率衰减的时机把握很有技巧：如果慢慢减小，可能在很长时间内只能浪费计算资源然后看着它混沌地跳动，实际进展很少；但如果快速地减少，系统可能过快地失去能量，不能到达原本可以到达的最好位置。通常，实现学习率退火有三种方式：</p><ul><li>1）随步数衰减：每进行几个周期就根据一些因素降低学习率。通常是每过5个周期就将学习率减少一半，或者每20个周期减少到之前的十分之一。这些数值的设定是严重依赖具体问题和模型的选择的。在实践中可能看见这么一种经验做法：使用一个固定的学习率来进行训练的同时观察验证集错误率，每当验证集错误率停止下降，就乘以一个常数（比如0.5）来降低学习率。</li><li>2）指数衰减。数学公式是$\alpha=\alpha_0e^{-kt}$，其中$\alpha_0,k$是超参数，$t$是迭代次数（也可以使用周期作为单位）。</li><li>3）$1/t$衰减的数学公式是$\alpha=\alpha_0/(1+kt)$，其中$\alpha_0,k$是超参数，t是迭代次数。</li></ul><p>在实践中，我们发现随步数衰减的随机失活（dropout）更受欢迎，因为它使用的超参数（衰减系数和以周期为时间单位的步数）比k更有解释性。但如果你有足够的计算资源，可以让衰减更加缓慢一些，让训练时间更长些。</p><h2 id="五、自适应学习率方法"><a href="#五、自适应学习率方法" class="headerlink" title="五、自适应学习率方法"></a>五、自适应学习率方法</h2><h3 id="5-1-Adagrad-Duchi-et-al-2011"><a href="#5-1-Adagrad-Duchi-et-al-2011" class="headerlink" title="5.1 Adagrad [Duchi et al., 2011]"></a>5.1 Adagrad [Duchi et al., 2011]</h3><p>之前的方法中所有参数在更新时均使用同一个Learning rate。而Learning rate调整是一个非常耗费计算资源的过程，所以如果能够自适应地对参数进行调整的话，就大大降低了成本。在Adagrad的每一个参数的每一次更新中都使用不同的learning rate。这样的话，令第$t$步更新时对第$i$个参数的梯度为</p><script type="math/tex; mode=display">g_{t,i}=\nabla_{\theta}J\left(\theta_j\right)</script><p>参数的更新的一般形式为：</p><script type="math/tex; mode=display">\theta_{t+1,i}=\theta_{t,i}-\eta g_{t,i}</script><p>如上所述，Adagrad的差异之处正是在于learning rate不同于其他，将learning rate改为如下：</p><script type="math/tex; mode=display">\theta_{t+1,i}=\theta_{t,i}-\frac{\eta}{\sqrt{\sum_{i=0}^t{\left(g^i\right)^2}+\epsilon}}·g_{t,i}</script><p>实质上是对学习率形成了一个约束项regularizer：$\frac{1}{\sqrt{\sum_{i=0}^t{\left(g^i\right)^2}+\epsilon}}$，${\sum_{i=0}^t{\left(g^i\right)^2}}$是对直至t次迭代的梯度平方和的累加和，$\epsilon $是一个防止分母为0的很小的平滑项。不用平方根操作，算法性能会变差很多</p><p>我们可以将到累加的梯度平方和放在一个对角矩阵中$G_t\in\mathbb{R}^{d×d}$中，其中每个对角元素$(i,i)$是参数$\theta_i$到时刻$t$为止所有时刻梯度的平方之和。由于$G_t$的对角包含着所有参数过去时刻的平方之和，我们可以通过在$G_t$和$g_t$执行element-wise matrix vector mulitiplication来向量化我们的操作：</p><script type="math/tex; mode=display">\theta_{t+1}=\theta_t-\frac{\eta}{\sqrt{G_t+\epsilon}}\odot g_t</script><ul><li><p>优点：Adagrad让学习速率自适应于参数，在前期$g_t$较小的时候，regularizer较大，能够放大梯度；后期$g_t$较大的时候，regularizer较小，能够约束梯度；因为这一点，它非常适合处理稀疏数据。Dean等人发现Adagrad大大地提高了SGD的鲁棒性并在谷歌的大规模神经网络训练中采用了它进行参数更新，其中包含了在Youtube视频中进行猫脸识别。此外，由于低频词（参数）需要更大幅度的更新，Pennington等人在GloVe word embeddings的训练中也采用了Adagrad。</p></li><li><p>缺点：由公式可以看出，仍依赖于人工设置一个全局学习率；$\eta$设置过大的话，会使得regularizer过于敏感，对梯度的调节太大；中后期，分母上梯度平方的累加将会越来越大，使得梯度为0，训练提前结束。</p></li></ul><h3 id="5-2-RMSprop-Hinton"><a href="#5-2-RMSprop-Hinton" class="headerlink" title="5.2 RMSprop [Hinton]"></a>5.2 RMSprop [Hinton]</h3><p>RMSprop是一个没有公开发表的适应性学习率方法，它是Hinton在他的课上提出的一种自适应学习速率方法。有趣的是，每个使用这个方法的人在他们的论文中都引用自Geoff Hinton的Coursera课程的<a href="http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf" target="_blank" rel="noopener">第六课的第29页PPT</a>。它用了一种很简单的方式修改了Adagrad方法，让它不过于激进而过早停止学习。具体说来就是，它使用了一个梯度平方的滑动平均，仍然是基于梯度的大小来对每个权重的学习率进行修改，效果不错。但是和Adagrad不同的是，其更新不会让学习率单调变小。</p><p>下图展示了RMSprop的计算过程，其中$\alpha$是一个超参数，常用的值是[0.9,0.99,0.999]：</p><p><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-11%20%E4%B8%8B%E5%8D%8811.40.54.png" alt="屏幕快照 2017-05-11 下午11.40.54"></p><h3 id="5-3-Adadelta-Zeiler-2012"><a href="#5-3-Adadelta-Zeiler-2012" class="headerlink" title="5.3 Adadelta [Zeiler, 2012]"></a>5.3 Adadelta [Zeiler, 2012]</h3><p>Adadelta是Adagrad的一种扩展，以缓解Adagrad学习速率单调递减问题的算法。Adadelta不是对过去所有时刻的梯度平方进行累加，而是将累加时刻限制在窗口大小为的$w$区间。</p><p>但梯度累加没有采用简单的存储前$w$个时刻的梯度平方，而是递归地定义为过去所有时刻梯度平方的decaying average$E[g^2]_t$。$t$时刻的running average仅仅依赖于之前average和当前的梯度：</p><script type="math/tex; mode=display">E\left[g^2\right]_t=\gamma E\left[g^2\right]_{t-1}+\left(1-\gamma\right)g_{t}^{2}</script><p>类似momentum term，我们将$\gamma$取值在0.9附近。简介起见，我们从参数更新向量$\Delta\theta_t$角度重写普通SGD的参数更新：</p><script type="math/tex; mode=display">\Delta\theta_t=-\eta ·g_{t,i}</script><script type="math/tex; mode=display">\theta_{t+1}=\theta_t+\Delta\theta_t</script><p>Adagrad中我们推导的参数更新向量现在就以下述形式出现：</p><script type="math/tex; mode=display">\Delta \theta_t=-\frac{\eta}{\sqrt{G_t+\epsilon}}\odot g_t</script><p>现在我们简单地将对角矩阵替换为过去时刻梯度平方的decaying average $E[g^2]_t$：</p><script type="math/tex; mode=display">\Delta \theta_t=-\frac{\eta}{\sqrt{E[g^2]_t+\epsilon}}\odot g_t</script><p>由于分母是root mean squared (RMS) error criterion of the gradient，则上面公式可以替换为：</p><script type="math/tex; mode=display">\Delta \theta_t=-\frac{\eta}{RMS[g]_t}</script><p>作者发现（和SGD，Momentum或者Adagrad一样）上述更新中的单元不匹配，即只有部分参数进行更新，也就是参数和更新应该有着相同的hypothetical units。<br>为了实现这个目的，他们首先定义了另外一个exponentially decaying average，这一次对更新参数的平方进行操作，而不只是对梯度的平方进行操作：</p><script type="math/tex; mode=display">E[\Delta\theta^2]_t=\gamma·E[\Delta\theta^2]_t+(1-\gamma)\Delta\theta^2</script><p>参数更新中的root mean squared error则为：</p><script type="math/tex; mode=display">RMS[\Delta\theta]_t=\sqrt{E[\Delta\theta^2]_t+\epsilon}</script><p>将以前的更新规则中的学习速率替换为参数更新的RMS，则得到Adadelta更新规则:</p><script type="math/tex; mode=display">\Delta\theta_t=-\frac{RMS[\Delta\theta]_t}{RMS[g]_t}·g_t$$$$\theta_{t+1}=\theta_t+\Delta\theta</script><p>由于Adadelta更新规则中没有了学习速率这一项，我们甚至都不用对学习速率进行设置。</p><h3 id="5-4-Adam-Kingma-and-Ba-2014"><a href="#5-4-Adam-Kingma-and-Ba-2014" class="headerlink" title="5.4 Adam  [Kingma and Ba, 2014]"></a>5.4 Adam  [Kingma and Ba, 2014]</h3><p>Adaptive Moment Estimation (Adam)是另外一种对每个参数进行自适应学习速率计算的方法，除了像Adadelta和RMSprop一样保存去过梯度平方和的exponentially decaying average外，Adam还保存类似momentum一样过去梯度的exponentially decaying average。它看起来像是RMSProp的动量版。</p><script type="math/tex; mode=display">m_t = \beta_1·m_{t-1}+(1-\beta)·g_t</script><script type="math/tex; mode=display">v_t = \beta_2·v_{t-1}+(1-\beta_2)·g^2_t</script><p>$m_t$和$v_t$分别是分别是梯度的一阶矩（均值）和二阶距（偏方差）的估计，由于$m_t$和$v_t$由全零的向量来初始化，Adam的作者观察到他们会被偏向0，特别是在initial time steps或decay rates很小的时候（即$\beta_1$和$\beta_2$都接近于1）,于是他们通过计算bias-corrected一阶矩和二阶矩的估计低消掉偏差。</p><script type="math/tex; mode=display">\hat{m}=\frac{m}{1-\beta_{1}^{t}}</script><script type="math/tex; mode=display">\hat{v}=\frac{v}{1-\beta_{2}^{t}}</script><p>然后使用上述项和Adadelta和RMSprop一样进行参数更新，可以得到Adam的更新规则：</p><script type="math/tex; mode=display">\theta_{t+1}=\theta_t-\frac{\eta}{\sqrt{\hat{v}+\epsilon}}\hat{m}</script><p>Adam的完整更新过程如下图所示，其中它推荐默认设置$\alpha=0.001,\beta_1=0.9,\beta_2=0.999,\epsilon=10^{-8}$，在实际操作中，推荐将Adam作为默认的算法，一般而言跑起来比RMSProp要好一些。但也可以试试SGD+Nesterov动量。<img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-11%20%E4%B8%8B%E5%8D%8811.55.37.png" alt="屏幕快照 2017-05-11 下午11.55.37"></p><h2 id="六、算法可视化"><a href="#六、算法可视化" class="headerlink" title="六、算法可视化"></a>六、算法可视化</h2><p>下面两幅动画让我们直观感受一些优化算法的优化过程。</p><p>在第一幅动图中，我们看到他们随着时间推移在损失表面的轮廓（contours of a loss surface）的移动。注意到Adagrad、Adadelta和RMSprop几乎立刻转向正确的方向并快速收敛，但是Momentum和NAG被引导偏离了轨道。这让我们感觉就像看滚下山的小球。然而，由于NAG拥有通过远眺所提高的警惕，它能够修正他的轨迹并转向极小值。<br><img src="http://omu7tit09.bkt.clouddn.com/opt1.gif" alt="opt1"></p><p>第二幅动图中为各种算法在saddle point（鞍点）上的表现。所谓saddle point也就是某个维度是positive slope，其他维度为negative lope。前文中我们已经提及了它给SGD所带来的困难。注意到SGD、Momentum和NAG很难打破对称，虽然后两者最后还是逃离了saddle point。然而Adagrad, RMSprop, and Adadelta迅速地沿着negative slope下滑。 </p><p> <img src="http://omu7tit09.bkt.clouddn.com/opt2.gif" alt="opt2"></p><h2 id="七、二阶方法"><a href="#七、二阶方法" class="headerlink" title="七、二阶方法"></a>七、二阶方法</h2><p>在深度网络背景下，第二类常用的最优化方法是基于牛顿法的，其迭代如下：</p><script type="math/tex; mode=display">\displaystyle x\leftarrow x-[Hf(x)]^{-1}\nabla f(x)</script><p>这里$Hf(x)$是Hessian矩阵，它是函数的二阶偏导数的平方矩阵。$\nabla f(x)$是梯度向量，这和梯度下降中一样。直观理解上，Hessian矩阵描述了损失函数的局部曲率，从而使得可以进行更高效的参数更新。具体来说，就是乘以Hessian转置矩阵可以让最优化过程在曲率小的时候大步前进，在曲率大的时候小步前进。需要重点注意的是，在这个公式中是没有学习率这个超参数的，这相较于一阶方法是一个巨大的优势。</p><p>然而上述更新方法很难运用到实际的深度学习应用中去，这是因为计算（以及求逆）Hessian矩阵操作非常耗费时间和空间。举例来说，假设一个有一百万个参数的神经网络，其Hessian矩阵大小就是[1,000,000 x 1,000,000]，将占用将近3,725GB的内存。这样，各种各样的拟-牛顿法就被发明出来用于近似转置Hessian矩阵。在这些方法中最流行的是L-BFGS，L-BFGS使用随时间的梯度中的信息来隐式地近似（也就是说整个矩阵是从来没有被计算的）。</p><p>然而，即使解决了存储空间的问题，L-BFGS应用的一个巨大劣势是需要对整个训练集进行计算，而整个训练集一般包含几百万的样本。和小批量随机梯度下降（mini-batch SGD）不同，让L-BFGS在小批量上运行起来是很需要技巧，同时也是研究热点。</p><p>实践时在深度学习和卷积神经网络中，使用L-BFGS之类的二阶方法并不常见。相反，基于（Nesterov的）动量更新的各种随机梯度下降方法更加常用，因为它们更加简单且容易扩展。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] Kiefer, J., Wolfowitz, J., et al. (1952). Stochastic estimation of the maximum of a regression function. The Annals of Mathematical Statistics, 23(3):462–466.<br>[2] Nesterov, Y. (1983). A method of solving a convex programming problem with convergence rate o (1/k2). In Soviet Mathematics Doklady, volume 27, pages 372–376.<br>[3] Duchi, J., Hazan, E., and Singer, Y. (2011). Adaptive subgradient methods for online learning and stochastic optimization. The Journal of Machine Learning Research, 12:2121–2159.<br>[4] Hinton. Neural    Networks for    Machine    Learning<br>[5] Zeiler, M. D. (2012). Adadelta: An adaptive learning rate method.<br>[6]  Kingma, D. and Ba, J. (2014).  Adam: A method for stochastic optimization.<br>[7]  CS231n Convolutional Neural Networks for Visual Recognition.<br>[8] Sebastian Ruder. An overview of gradient descent optimization algorithms</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、Gradient-Descent-Robbins-and-Monro-1951-Kiefer-et-al-1952&quot;&gt;&lt;a href=&quot;#一、Gradient-Descent-Robbins-and-Monro-1951-Kiefer-et-al-1952&quot; class=&quot;headerlink&quot; title=&quot;一、Gradient Descent [Robbins and Monro, 1951, Kiefer et al., 1952]&quot;&gt;&lt;/a&gt;一、Gradient Descent [Robbins and Monro, 1951, Kiefer et al., 1952]&lt;/h2&gt;&lt;p&gt;机器学习中，梯度下降法常用来对相应的算法进行训练。常用的梯度下降法包含三种不同的形式，分别是BGD、SGD和MBGD，它们的不同之处在于我们在对目标函数进行梯度更新时所使用的样本量的多少。&lt;/p&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="优化方法" scheme="http://yoursite.com/tags/%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>深度学习系列（6）：递归神经网络</title>
    <link href="http://yoursite.com/2017/04/26/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%EF%BC%886%EF%BC%89%EF%BC%9A%E9%80%92%E5%BD%92%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>http://yoursite.com/2017/04/26/深度学习系列（6）：递归神经网络/</id>
    <published>2017-04-26T15:14:45.000Z</published>
    <updated>2017-12-26T10:34:00.473Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇我们学习了循环神经网络，它可以用来处理包含序列的信息。然而，除此之外，信息往往还存在着诸如树结构、图结构等更复杂的结构。对于这种复杂的结构。循环神经网络就无能为力了。本文学习一种更为强大、复杂的神经网络：递归神经网络（Recursive Neural NetWork，RNN），以及它的训练算法BPTS（Back Propagation Through Structure）。顾名思义，递归神经网络可以处理诸如树、图这样的递归网络。</p><a id="more"></a><h2 id="一、递归神经网络的定义"><a href="#一、递归神经网络的定义" class="headerlink" title="一、递归神经网络的定义"></a>一、递归神经网络的定义</h2><p>因为神经网络的输入层单元个数是固定的，因此必须用循环或者递归的方式来处理长度可变的输入。循环神经网络实现了前者，通过将长度不定的输入分割为等长度的小块，然后再依次的输入到网络中，从而实现了神经网络对变长输入的处理。一个典型的例子是，当我们处理一句话的时候，我们可以把一句话看作是词组成的序列，然后，每次向循环神经网络输入一个词，如此循环直至整句话输入完毕，循环神经网络将产生对应的输出。如此，我们就能处理任意长度的句子了。<br>如下图所示：<img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-26%20%E4%B8%8B%E5%8D%883.25.06.png" alt="屏幕快照 2017-04-26 下午3.25.06"><br>然而，有时候把句子看作是词的序列是不够的，比如下面这句话“两个外语学院的学生”：<br><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-26%20%E4%B8%8B%E5%8D%883.26.16.png" alt="屏幕快照 2017-04-26 下午3.26.16"><br>上图显示了这句话的两个不同的语法解析树。可以看出这句话有歧义，不同的语法解析树则对应了不同的意思。一个是『两个外语学院的/学生』，也就是学生可能有许多，但他们来自于两所外语学校；另一个是『两个/外语学院的学生』，也就是只有两个学生，他们是外语学院的。为了能够让模型区分出两个不同的意思，我们的模型必须能够按照树结构去处理信息，而不是序列，这就是递归神经网络的作用。当面对按照树/图结构处理信息更有效的任务时，递归神经网络通常都会获得不错的结果。</p><p>递归神经网络可以把一个树、图结构信息编码为一个向量，也就是把信息映射到一个语义向量空间中。这个语义向量空间满足某类性质，比如语义相似的向量距离更近。也就是说，如果两句话（尽管内容不容）它的意思是相似的，那么把它们分别编码后的两个向量的距离也更近；反之，如果两句话的意思截然不同，那么编码后的距离则更远。如下图所示：<img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-26%20%E4%B8%8B%E5%8D%883.29.23.png" alt="屏幕快照 2017-04-26 下午3.29.23"></p><p>从上图我们可以看到，递归神经网络将所有的词、句都映射到一个2维向量空间中。句子“the country of my birth”和句子“the place where I was born”的意思是非常接近的，所以表示它们的两个向量在向量空间中的距离很近。另外两个词“Germany”和“France”因为表示的都是地点，它们的向量与上面两句话的向量的距离，就比另外两个表示时间的词“Monday”和“Tuesday”的向量的距离近得多。这样，通过向量的距离，就得到了一种语义的表示。</p><p>上图还显示了自然语言可组合的性质：词可以组成句、句可以组成段落、段落可以组成篇章，而更高层的语义取决于底层的语义以及它们的组合方式。递归神经网络是一种表示学习，它可以将词、句、段、篇按照他们的语义映射到同一个向量空间中，也就是把可组合（树/图结构）的信息表示为一个个有意义的向量。比如上面这个例子，递归神经网络把句子”the country of my birth”表示为二维向量[1,5]。有了这个『编码器』之后，我们就可以以这些有意义的向量为基础去完成更高级的任务（比如情感分析等）。如下图所示，递归神经网络在做情感分析时，可以比较好的处理否定句，这是胜过其他一些模型的：<br><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-26%20%E4%B8%8B%E5%8D%883.31.07.png" alt="屏幕快照 2017-04-26 下午3.31.07"><br>在上图中，蓝色表示正面评价，红色表示负面评价。每个节点是一个向量，这个向量表达了以它为根的子树的情感评价。比如”intelligent humor”是正面评价，而”care about cleverness wit or any other kind of intelligent humor”是中性评价。我们可以看到，模型能够正确的处理doesn’t的含义，将正面评价转变为负面评价。</p><p>尽管递归神经网络具有更为强大的表示能力，但是在实际应用中并不太流行。其中一个主要原因是，递归神经网络的输入是树/图结构，而这种结构需要花费很多人工去标注。想象一下，如果我们用循环神经网络处理句子，那么我们可以直接把句子作为输入。然而，如果我们用递归神经网络处理句子，我们就必须把每个句子标注为语法解析树的形式，这无疑要花费非常大的精力。很多时候，相对于递归神经网络能够带来的性能提升，这个投入是不太划算的。</p><h2 id="二、递归神经网络的前向计算"><a href="#二、递归神经网络的前向计算" class="headerlink" title="二、递归神经网络的前向计算"></a>二、递归神经网络的前向计算</h2><p>接下来，我们详细介绍一下递归神经网络是如何处理树/图结构的信息的。在这里，我们以处理树型信息为例进行介绍。</p><p>递归神经网络的输入是两个子节点（也可以是多个），输出就是将这两个子节点编码后产生的父节点，父节点的维度和每个子节点是相同的。如下图所示：<br><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-26%20%E4%B8%8B%E5%8D%883.33.43.png" alt="屏幕快照 2017-04-26 下午3.33.43"></p><p>$c_1$和$c_2$分别是表示两个子节点的向量，$p$是表示父节点的向量。子节点和父节点组成一个全连接神经网络，也就是子节点的每个神经元都和父节点的每个神经元两两相连。我们用矩阵$W$表示这些连接上的权重，它的维度将是$d×2d$，其中，$d$表示每个节点的维度。父节点的计算公式可以写成：</p><script type="math/tex; mode=display">p=\tan\textrm{h}\left(W\left[\begin{array}{c}    c_1\\    c_2\\\end{array}\right]+b\right)</script><p>在上式中，tanh是激活函数（当然也可以用其它的激活函数），是偏置项，它也是一个维度为的向量。</p><p>然后，我们把产生的父节点的向量和其他子节点的向量再次作为网络的输入，再次产生它们的父节点。如此递归下去，直至整棵树处理完毕。最终，我们将得到根节点的向量，我们可以认为它是对整棵树的表示，这样我们就实现了把树映射为一个向量。在下图中，我们使用递归神经网络处理一棵树，最终得到的向量$p_3$，就是对整棵树的表示：<img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-26%20%E4%B8%8B%E5%8D%883.37.06.png" alt="屏幕快照 2017-04-26 下午3.37.06"><br>举个例子，我们使用递归神将网络将”两个外语学校的学生”映射为一个向量，如下图所示：<br><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-26%20%E4%B8%8B%E5%8D%883.37.44.png" alt="屏幕快照 2017-04-26 下午3.37.44"><br>最后得到的向量$p_3$就是对整个句子”两个外语学校的学生”的表示。由于整个结构是递归的，不仅仅是根节点，事实上每个节点都是以其为根的子树的表示。比如，在左边的这棵树中，向量$p_2$是短语”外语学院的学生”的表示，而向量$p_1$是短语”外语学院的”的表示。</p><script type="math/tex; mode=display">p=\tan\textrm{h}\left(W\left[\begin{array}{c}    c_1\\    c_2\\\end{array}\right]+b\right)</script><p>该式就是递归神经网络的前向计算算法，它和全连接神经网络没有什么区别，只是在输入的过程中需要根据输入的树结构依次输入每个子节点。</p><p>需要特别注意的是，递归神经网络的权重$W$和偏置项$b$在所有节点都是共享的。</p><h2 id="三、递归神经网络的训练"><a href="#三、递归神经网络的训练" class="headerlink" title="三、递归神经网络的训练"></a>三、递归神经网络的训练</h2><p>递归神经网络的训练算法和循环神经网络类似，两者不同之处在于，前者需要将残差$\selta$从根节点反向传播到各个子节点，而后者是将残差$\delta$从当前时刻$t_k$反向传播到初始时刻$t_1$。</p><p>下面，我们介绍适用于递归神经网络的训练算法，也就是BPTS算法。</p><h3 id="3-1-误差项的传递"><a href="#3-1-误差项的传递" class="headerlink" title="3.1 误差项的传递"></a>3.1 误差项的传递</h3><p>首先，我们先推导将误差从父节点传递到子节点的公式，如下图：<br><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-26%20%E4%B8%8B%E5%8D%883.47.37.png" alt="屏幕快照 2017-04-26 下午3.47.37"><br>定义$\delta_p$为误差函数E相对于父节点$p$的加权输入$net_p$的导数，即：</p><script type="math/tex; mode=display">\delta_p=\frac{\partial E}{\partial net_p}</script><p>设$net_p$是父节点的加权输入，则</p><script type="math/tex; mode=display">net_p=W\left[\begin{array}{c}    c_1\\    c_2\\\end{array}\right]+b</script><p>在上述式子里，$net_p、c_1、c_2$都是向量，而$W$是矩阵。为了看清楚它们的关系，我们将其展开：</p><script type="math/tex; mode=display">\left[\begin{array}{c}    net_{p1}\\    net_{p2}\\    ···\\    net_{pn}\\\end{array}\right]=\left[\begin{matrix}    w_{p1c11}&        w_{p1c12}&        ···&        w_{p1c21}···\\    w_{p2c11}&        w_{p2c12}&        ···&        w_{p2c21}···\\    ···&        ···&        ···&        ···\\    w_{pnc11}&        w_{pnc12}&        ···&        w_{pnc21}···\\\end{matrix}\right]\left[\begin{array}{c}    net_{c11}\\    net_{c12}\\    ···\\    net_{c21}\\    net_{c22}\\    ···\\\end{array}\right]</script><p>在上面的公式中，$p_i$表示父节点$p$的第i个分量；$c_{1i}$表示子节点的第i个分量；$c_{2i}$表示$c_2$子节点的第$i$个分量；$w_{p_ic_{jk} }$表子节点$c_j$的第k个分量到父节点p的第i个分量的权重。根据上面展开后的矩阵乘法形式，我们不难看出，对于子节点$c_{jk}$来说，它会影响父节点所有的分量。因此，我们求误差函数E对$c_{jk}$的导数时，必须用到全导数公式，也就是：</p><script type="math/tex; mode=display">\frac{\partial E}{\partial c_{jk}}=\sum_i{\frac{\partial E}{\partial net_{p_i}}\frac{\partial net_{p_i}}{\partial c_{jk}}}=\sum_i{\delta_{p_i}w_{p_ic_{jk}}}</script><p>有了上式，我们就可以把它表示为矩阵形式，从而得到一个向量化表达：</p><script type="math/tex; mode=display">\frac{\partial E}{\partial c_j}=U_j\delta_p</script><p>其中，矩阵$U_j$是从矩阵$W$中提取部分元素组成的矩阵。其单元为$u_{j_{ik}}=w_{p_k}c_{ji}$上式看上出可能有点抽象，从下图，我们可以直观的看到$U_j$到底是啥。首先我们把$W$矩阵拆分为两个矩阵$W_1$和$W_2$，如下图所示：<img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-26%20%E4%B8%8B%E5%8D%884.25.28.png" alt="屏幕快照 2017-04-26 下午4.25.28"></p><p>显然，子矩阵$W_1$和$W_2$分别对应子节点$c_1$和$c_2$的到父节点$p$权重。则矩阵$U_j$为：</p><script type="math/tex; mode=display">U_j=W_j^T</script><p>也就是说，将误差项反向传递到相应子节点$c_j$的矩阵$U_j$就是其对应权重矩阵$W_j$的转置。</p><p>现在，我们设$net_{c_j}$是子节点$c_j$的加权输入，$f$是子节点$c$的激活函数，则：</p><script type="math/tex; mode=display">c_j=f(net_{c_j})</script><p>这样，我们得到：</p><script type="math/tex; mode=display">\delta_{c_j}=\frac{\partial E}{\partial net_{c_j}}=\frac{\partial E}{\partial c_j}\frac{\partial c_j}{\partial net_{c_j}}=W_{j}^{T}\delta_p°f'\left(net_{c_j}\right)</script><p>如果我们将不同子节点$c_j$对应的误差项$\delta_{c_j}$连接成一个向量</p><script type="math/tex; mode=display">\delta_c=\left[\begin{array}{c}    \delta_{c_1}\\    \delta_{c_2}\\\end{array}\right]</script><p>那么，上式可以写成</p><script type="math/tex; mode=display">\delta_c=W^T\delta_p°f'\left(net_c\right)</script><p>它就是将误差项从父节点传递到其子节点的公式。注意上式中的$net_c$也是将两个子结点的加权输入$net_{c_1}$和$net_{c_2}$连在一起的向量。<br>有了传递一层的公式，我们就不难写出逐层传递的公式。<br><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-26%20%E4%B8%8B%E5%8D%884.57.04.png" alt="屏幕快照 2017-04-26 下午4.57.04"><br>上图是在树型结构中反向传递项的全景图，反复应用上式，在已知$\delta_p^{(3)}$的情况下，我们不难算出$\delta_p^{(1)}$为：</p><script type="math/tex; mode=display">\delta^{\left(2\right)}=W^T\delta_{p}^{\left(3\right)}°f'\left(net^{\left(2\right)}\right)</script><script type="math/tex; mode=display">\delta_{p}^{\left(2\right)}=\left[\delta^{\left(2\right)}\right]_p</script><script type="math/tex; mode=display">\delta^{\left(1\right)}=W^T\delta_{p}^{\left(2\right)}°f'\left(net^{\left(1\right)}\right)</script><script type="math/tex; mode=display">\delta_{p}^{\left(1\right)}=\left[\delta^{\left(1\right)}\right]_p</script><p>在上面的公式中</p><script type="math/tex; mode=display">\delta^{\left(2\right)}=\left[\begin{array}{c}    \delta_{c}^{\left(2\right)}\\    \delta_{p}^{\left(2\right)}\\\end{array}\right]</script><p>$\left[\delta^{\left(2\right)}\right]_p$表示取向量$\delta^{(2)}$属于节点p的部分。</p><h3 id="3-2-权重梯度的计算"><a href="#3-2-权重梯度的计算" class="headerlink" title="3.2 权重梯度的计算"></a>3.2 权重梯度的计算</h3><p>根据加权输入的计算公式：</p><script type="math/tex; mode=display">net_p^{(l)}=Wc^{(l)}+b</script><p>其中，$net_p^{(l)}$表示第$l$层的父节点的加权输入，$c^{(l)}$表示第$l$层的子节点。W是权重矩阵，$b$是偏置项，将其展开可得：</p><script type="math/tex; mode=display">net_{p_j}^{l}=\sum_i{w_{ji}c_{i}^{l}}+b_j</script><p>那么，我们可以求得误差函数在第$l$层对权重的梯度为：</p><script type="math/tex; mode=display">\frac{\partial E}{\partial w_{ji}^{\left(l\right)}}=\frac{\partial E}{\partial net_{p_j}^{\left(l\right)}}\frac{\partial net_{p_j}^{\left(l\right)}}{\partial w_{ji}^{\left(l\right)}}=\delta_{p_j}^{\left(l\right)}·c_{i}^{\left(l\right)}</script><p>上式是针对一个权重项$w_{ji}$的公式，现在需要把它扩展为对所有的权重项的公式。我们可以把上式写成写成矩阵的形式（在下面的公式中，m=2n）:</p><script type="math/tex; mode=display">\frac{\partial E}{\partial W^{\left(l\right)}}=\delta^{\left(l\right)}·\left(c^{\left(l\right)}\right)^T</script><p>这就是第$l$层权重项的梯度计算公式。我们知道，由于权重$W$是在所有层共享的，所以和循环神经网络一样，递归神经网络的最终权重梯度是各个层权重梯度之和。即：</p><script type="math/tex; mode=display">\frac{\partial E}{\partial W}=\sum_l{\frac{\partial E}{\partial W^{\left(l\right)}}}</script><p>和循环神经网络一样，递归神经网络最终梯度之和是各层梯度之和。</p><p>接下来，我们求偏置项$b$的梯度计算公式。先计算误差函数对第$l$层偏置项$b^{(l)}$的梯度：</p><script type="math/tex; mode=display">\frac{\partial E}{\partial b_{j}^{\left(l\right)}}=\frac{\partial E}{\partial net_{p_j}^{\left(l\right)}}\frac{\partial net_{p_j}^{\left(l\right)}}{\partial b_{j}^{\left(l\right)}}=\delta_{p_j}^{\left(l\right)}</script><p>把上式扩展为矩阵的形式：</p><script type="math/tex; mode=display">\frac{\partial E}{\partial b^{\left(l\right)}}=\delta_{p}^{\left(l\right)}</script><p>最终的偏置项梯度是各个层偏置项梯度之和，即：</p><script type="math/tex; mode=display">\frac{\partial E}{\partial b}=\sum_l{\frac{\partial E}{\partial b^{\left(l\right)}}}</script><h3 id="3-3-权重更新"><a href="#3-3-权重更新" class="headerlink" title="3.3 权重更新"></a>3.3 权重更新</h3><p>如果使用梯度下降优化算法，那么权重更新公式为：</p><script type="math/tex; mode=display">W\gets W+\eta\frac{\partial E}{\partial W}</script><p>其中，$\eta$是学习速率常数。把之前的式子代入上式，即可完成权重的更新。同理，偏置项的更新公式为：</p><script type="math/tex; mode=display">b\gets b+\eta\frac{\partial E}{\partial b}</script><p>同样把之前求得式子代入上式，即可完成偏置项的更新。</p><p>这就是递归神经网络的训练算法BPTS。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇我们学习了循环神经网络，它可以用来处理包含序列的信息。然而，除此之外，信息往往还存在着诸如树结构、图结构等更复杂的结构。对于这种复杂的结构。循环神经网络就无能为力了。本文学习一种更为强大、复杂的神经网络：递归神经网络（Recursive Neural NetWork，RNN），以及它的训练算法BPTS（Back Propagation Through Structure）。顾名思义，递归神经网络可以处理诸如树、图这样的递归网络。&lt;/p&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="递归神经网络" scheme="http://yoursite.com/tags/%E9%80%92%E5%BD%92%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>深度学习系列（5）：长短时记忆网络（LSTM）</title>
    <link href="http://yoursite.com/2017/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%EF%BC%885%EF%BC%89%EF%BC%9A%E9%95%BF%E7%9F%AD%E6%97%B6%E8%AE%B0%E5%BF%86%E7%BD%91%E7%BB%9C%EF%BC%88LSTM%EF%BC%89/"/>
    <id>http://yoursite.com/2017/04/25/深度学习系列（5）：长短时记忆网络（LSTM）/</id>
    <published>2017-04-25T15:14:45.000Z</published>
    <updated>2017-12-26T10:33:56.894Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、长期依赖问题（Long-Term-Dependencies）"><a href="#一、长期依赖问题（Long-Term-Dependencies）" class="headerlink" title="一、长期依赖问题（Long-Term Dependencies）"></a>一、长期依赖问题（Long-Term Dependencies）</h2><p>循环神经网络（RNN）在实际应用中很难处理长距离依赖的问题。</p><p>有的时候，我们仅仅需要知道先前的信息来完成预测任务。例如，我们有一个语言模型用来基于先前的词来预测下一个词，比如我们预测“the clouds are in the sky”最后的词的时候，我们不需要任何其他的上下文，很显然下一个词就是sky。在这种情况下，相关的信息与需要预测的词位置之间的间隔很小，而RNN可以学会使用较近距离的信息。</p><a id="more"></a><p><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-24%20%E4%B8%8B%E5%8D%889.46.59.png" alt="屏幕快照 2017-04-24 下午9.46.59"></p><p>但是到了一个更加复杂的场景，假设我们试着预测“I grew up in France……I speak fluent French”中最后的词，从这句话的信息来看，下一个词很有可能是一种语言的名字，但具体到是哪种语言，我们就需要在与之距离较远的“I grew up in France”中得到。这说明相关信息与当前预测位置之间的间隔就肯定变得相当的大。</p><p>不幸的是，在这个间隔不断增大时，RNN会丧失学习到连接如此远的信息的能力。<br><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-24%20%E4%B8%8B%E5%8D%889.47.31.png" alt="屏幕快照 2017-04-24 下午9.47.31"></p><p>当然，在理论上，RNN绝对可以处理这样的长期依赖问题。人们可以通过调参来解决，但是在实践中，RNN肯定不能够成功学习到这些知识。<a href="http://www-dsi.ing.unifi.it/~paolo/ps/tnn-94-gradient.pdf" target="_blank" rel="noopener">Bengio, et al. (1994)</a>等人对该问题进行了深入的研究，它们发现一些使训练RNN变得非常困难的相当根本的原因。</p><p>既然找到了问题的原因，那我们就能解决它。从问题的定位到解决，科学家们大概花了7、8年的时间。终于有一天，Hochreiter和Schmidhuber两位科学家发明出长短时记忆网络，一举解决了这个问题。</p><h2 id="二、LSTM的核心思想"><a href="#二、LSTM的核心思想" class="headerlink" title="二、LSTM的核心思想"></a>二、LSTM的核心思想</h2><p>Long Short Term网络，一般就叫做LSTM，是一种特殊的RNN变体，它可以学习长期依赖信息。LSTM由Hochreiter和Schmidhuber在1997年提出，并在近期被Alex Graves进行了改良和推广。在很多问题上，LSTM都取得了相当巨大的成功，并得到了广泛的使用。<br>LSTM通过刻意的设计来避免长期依赖问题。记住长期的信息在实践中是LSTM的默认属性，而非需要付出很大的代价才能获得的能力！<br>所有的RNN都具有一种重复神经网络模块的链式的形式。在标准的RNN中，这个重复的模块只有一个非常简单的结构，例如一个tanh层。<br><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-24%20%E4%B8%8B%E5%8D%889.54.13.png" alt="屏幕快照 2017-04-24 下午9.54.13"><br>LSTM同样是这样的结构，但是其中重复的模块拥有一个不同的结构。不同于单一神经网络层，这里有四个以非常特殊的方式进行交互的小器件。<img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-24%20%E4%B8%8B%E5%8D%889.55.44.png" alt="屏幕快照 2017-04-24 下午9.55.44"><br>图中每一条黑线传输着一整个向量，从一个节点的输出到其他节点的输入。粉色的圈代表pointwise的操作，比如向量的和，而黄色的矩阵就是学习到的神经网络层。</p><p>LSTM的关键在于细胞（Cell），水平线在细胞内贯穿运行。细胞类似于传送带。直接在整个链上运行，只有一些少量的线性交互。信息在水平线上很容易保持不变。<br><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-24%20%E4%B8%8B%E5%8D%8810.04.47.png" alt="屏幕快照 2017-04-24 下午10.04.47"></p><p>LSTM通过精心设计“门”结构来去除或者增加信息到Cell上。门是一种让信息选择式通过的方法（过滤器）。它们包含一个sigmoid神经网络层和一个pointwise乘法操作。<br><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-24%20%E4%B8%8B%E5%8D%8810.05.53.png" alt="屏幕快照 2017-04-24 下午10.05.53"></p><p>Sigmoid层输出0到1之间的数值，描述每个部分有多少量可以通过。0代表“不许任何量通过”，1就指“允许任意量通过”</p><h2 id="三、LSTM的前向计算"><a href="#三、LSTM的前向计算" class="headerlink" title="三、LSTM的前向计算"></a>三、LSTM的前向计算</h2><p>LSTM用两个门来控制单元状态Cell的内容，一个是遗忘门（forget gate），它决定了上一时刻的单元状态$c_t-1$有多少保留到当前时刻$c_t$；另一个是输入门（input gate），他决定了当前时刻网络的输入$x_t$有多少保存到单元状态$c_t$。LSTM用输出门（output gate）来控制单元状态$c_t$有多少输出到LSTM的当前输出值$h_t$。</p><h3 id="3-1-遗忘门"><a href="#3-1-遗忘门" class="headerlink" title="3.1 遗忘门"></a>3.1 遗忘门</h3><p>我们先看一下遗忘门：</p><script type="math/tex; mode=display">f_t=\sigma(W_f·[h_{t-1,x_t}]+b_f)</script><p>上式中，$W_f$是遗忘门的权重矩阵，$[h_{t-1},x_t]$表示把两个向量连接成一个更长的向量，$b_f$是遗忘门的偏置项，$\sigma$是sigmoid函数。若输入的维度是$d_x$，隐藏层的维度是$d_h$，单元状态的维度是$d_c$（通常$d_c=d_h$），则遗忘门的权重矩阵$W_f$维度是$d_c×(d_h+d_x)$。事实上，权重矩阵$W_f$都是两个矩阵拼接而成的：一个是$W_{fh}$，它对应着输入项$h_{t-1}$，其维度为$d_c×d_h$；一个是$W_{fx}$，它对应着输入项$x_t$，其维度为$d_c×d_x$。$W_f$可以写为：</p><script type="math/tex; mode=display">\left[W_f\right]\left[\begin{array}{c}    h_{t-1}\\    x_t\\\end{array}\right]=\left[\begin{matrix}    W_{fh}&        W_{fx}\\\end{matrix}\right]\left[\begin{array}{c}    h_{t-1}\\    x_t\\\end{array}\right]=W_{fh}·h_{t-1}+W_{fx}x_t</script><p>所以总结一下，遗忘门的作用为控制有多少上一时刻的memory cell中的信息可以累积到当前时刻的memory cell中。其数学公式可以写作：</p><script type="math/tex; mode=display">f_t = sigmoid(W_{fx}·x_t+W_{fh}·h_{t-1}+b_i)</script><p>其计算图示如下：<br><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-25%20%E4%B8%8B%E5%8D%881.37.22.png" alt="屏幕快照 2017-04-25 下午1.37.22"></p><h3 id="3-2-输入门"><a href="#3-2-输入门" class="headerlink" title="3.2 输入门"></a>3.2 输入门</h3><p>接下来看输入门：</p><script type="math/tex; mode=display">i_t=\sigma(W_i·[h_{t-1},x_t]+b_i)</script><p>上式中，$W_i$是输入们的权重矩阵，$b_i$是输入门的偏置项。下图表示了输入门的计算：<img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-25%20%E4%B8%8B%E5%8D%881.48.40.png" alt="屏幕快照 2017-04-25 下午1.48.40"></p><p>接下来，我们计算用于描述当前输入的单元状态$\tilde{c}_t$，它是根据上一次的输出和本次输入来计算的：</p><script type="math/tex; mode=display">\tilde{c}_t=\tan\textrm{h}\left(W_c·\left[h_{t-1},x_t\right]+b_c\right)</script><p>下图是$\tilde{c}_t$的计算：<br><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-25%20%E4%B8%8B%E5%8D%882.01.50.png" alt="屏幕快照 2017-04-25 下午2.01.50"><br>现在，我们计算当前时刻的单元状态$c_t$。它是由上一次的单元状态$c_{t-1}$按元素乘以遗忘门$f_t$，再用当前输入的单元状态$\tilde{c}_t$按元素乘以输入门$i_t$，再将两个积加和产生的：</p><script type="math/tex; mode=display">c_t=f_t°c_{t-1}+i_t°\tilde{c}_t</script><p>下图是$c_t$的计算图示：<img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-25%20%E4%B8%8B%E5%8D%882.06.23.png" alt="屏幕快照 2017-04-25 下午2.06.23"><br>这样，我们就把LSTM关于当前的记忆$\tilde{c}_t$和长期的记忆$c_{t-1}$组合在一起，形成了新的单元状态$c_t$。由于遗忘门的控制，它可以保存很久很久之前的信息，由于输入门的控制，它又可以避免当前无关紧要的内容进入记忆。</p><h3 id="3-3-输出门"><a href="#3-3-输出门" class="headerlink" title="3.3 输出门"></a>3.3 输出门</h3><p>下面，我们要看看输入们，它控制了长期记忆对当前输出的影响：</p><script type="math/tex; mode=display">o_t=\sigma(W_o·[h_{t-1},x_t]+b_o)</script><p>下图表示输出门的计算：<br><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-25%20%E4%B8%8B%E5%8D%882.33.59.png" alt="屏幕快照 2017-04-25 下午2.33.59"><br>LSTM最终的输出，是由输出门和单元状态共同确定的：</p><script type="math/tex; mode=display">h_t=o_t°\tan\textrm{h}\left(c_t\right)</script><p>下图表示LSTM最终输出的计算：<img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-25%20%E4%B8%8B%E5%8D%882.41.32.png" alt="屏幕快照 2017-04-25 下午2.41.32"></p><h2 id="四、LSTM的训练"><a href="#四、LSTM的训练" class="headerlink" title="四、LSTM的训练"></a>四、LSTM的训练</h2><p>LSTM的训练算法仍然是反向传播算法，它主要有下面三个步骤：</p><ul><li>1）前向计算每个神经元的输出值，对于LSTM来说，即$f_t、i_t、c_t、o_t、h_t$五个向量的值。</li><li>2）反向计算每个神经元的误差项$\delta$值。与循环神经网络一样，LSTM误差项的反向传播也是包括两个方向：一个是沿着时间的反向传播，即从当前t时刻开始，计算每个时刻的误差项；一个是将误差项向上一层传播。</li><li>3）根据相应的误差项，计算每个权重的梯度。</li></ul><p>首先，我们队推导中用到的一些公式、符号做一下必要的说明。</p><p>接下来的推导中，我们设定gate的激活函数为sigmoid函数，输出的激活函数为tanh函数。它们的导数分别为：</p><script type="math/tex; mode=display">\sigma\left(z\right)=y=\frac{1}{1+e^{-z}}</script><script type="math/tex; mode=display">\sigma '\left(z\right)=y\left(1-y\right)</script><script type="math/tex; mode=display">\tan\textrm{h}\left(z\right)=y=\frac{e^z-e^{-z}}{e^z+e^{-z}}</script><script type="math/tex; mode=display">\tan\textrm{h'}\left(z\right)=1-y^2</script><p>从上面可以看出，sigmoid和tanh函数的导数都是原函数的函数。这样，我们一旦计算原函数的值，就可以用它来计算出导数的值。</p><p>LSTM需要学习的参数共有8组，分别是：遗忘门的权重矩阵$W_f$和偏置项$b_f$、输入门的权重矩阵$W_i$和偏置项$b_i$、输出门的权重矩阵$W_o$和偏置项$b_o$，以及计算单元状态的权重矩阵$W_c$和偏置项$b_c$，因为权重矩阵的两部分在反向传播中使用不同的公式，因此在后续的推导中，权重矩阵$W_f、W_i、W_c、W_o$都会被写成分开的两个矩阵：$W_{fh}、W_{fx}、W_{ih}、W_{ix}、W_{oh}、W_{ox}、W_{ch}、W_{cx}$。</p><p>我们解释一下按元素乘$o$符号。当$o$作用于两个向量时，运算如下：</p><script type="math/tex; mode=display">a°b=\left[\begin{array}{c}    a_1\\    a_2\\    ···\\    a_n\\\end{array}\right]°\left[\begin{array}{c}    b_1\\    b_2\\    ···\\    b_n\\\end{array}\right]=\left[\begin{array}{c}    a_1b_1\\    a_2b_2\\    ···\\    a_nb_n\\\end{array}\right]</script><p>当$o$作用于一个向量和一个矩阵时，运算如下：</p><script type="math/tex; mode=display">a°X=\left[\begin{array}{c}    a_1\\    a_2\\    ···\\    a_n\\\end{array}\right]°\left[\begin{matrix}    x_{11}&        x_{12}&        ···&        x_{1n}\\    x_{21}&        x_{22}&        ···&        x_{2n}\\    ···&        ···&        ···&        ···\\    x_{n1}&        x_{n2}&        ···&        x_{nn}\\\end{matrix}\right]=\left[\begin{matrix}    a_1x_{11}&        a_1x_{12}&        ···&        a_{1n}x_{1n}\\    a_2x_{21}&        a_2x_{22}&        ···&        a_2x_{2n}\\    ···&        ···&        ···&        ···\\    a_nx_{n1}&        a_nx_{n2}&        ···&        a_nx_{nn}\\\end{matrix}\right]</script><p>当$o$作用于两个矩阵时，两个矩阵对应位置的元素相乘。按元素乘可以再某些情况下简化矩阵和向量的运算。例如，当一个对角矩阵右乘一个矩阵时，相当于用对角矩阵的对角线组成的向量按元素乘那个矩阵：$diag[a]·X=a °X$当一个行向量右乘一个对角矩阵时，相当于这个行向量按元素乘那个矩阵对角线组成的向量：</p><script type="math/tex; mode=display">a^T·diag[b]=a°b</script><p>上面这俩点，在后续推导中会多次用到。</p><p>在t时刻，LSTM的输出值为$h_t$。我们定义t时刻的误差项$\delta_t$为：</p><script type="math/tex; mode=display">\delta_t=\frac{\partial E}{\partial h_t}</script><p>注意，这里假设误差项是损失函数对输出值的导数，而不是对加权输入$net^l$的导数。因为LSTM有四个加权输入，分别对应$f_t、i_t、c_t、o_t$，我们希望往上一层传递一个误差项而不是四个。但我们仍然要定义出这四个加权输入，以及他们对应的误差项。</p><script type="math/tex; mode=display">net_{f,t}=W_f[h_{t-1},x_t]+b_f=W_{fh}h_{t-1}+W_{fx}x_t+b_f</script><script type="math/tex; mode=display">net_{i,t}=W_i[h_{t-1},x_t]+b_i=W_{ih}h_{t-1}+W_{ix}x_t+b_i</script><script type="math/tex; mode=display">net_{\tilde{c},t}=W_c\left[h_{t-1},x_t\right]+b_c=W_{ch}h_{t-1}+W_{cx}x_t+b_c</script><script type="math/tex; mode=display">net_{o,t}=W_o\left[h_{t-1},x_t\right]+b_o=W_{oh}h_{t-1}+W_{ox}x_t+b_o</script><script type="math/tex; mode=display">\delta_{f,t}=\frac{\partial E}{\partial net_{f,t}}</script><script type="math/tex; mode=display">\delta_{i,t}=\frac{\partial E}{\partial net_{i,t}}</script><script type="math/tex; mode=display">\delta_{\tilde{c},t}=\frac{\partial E}{\partial net_{c,t}}</script><script type="math/tex; mode=display">\delta_{o,t}=\frac{\partial E}{\partial net_{o,t}}</script><h3 id="4-1-误差项沿时间的反向传播"><a href="#4-1-误差项沿时间的反向传播" class="headerlink" title="4.1 误差项沿时间的反向传播"></a>4.1 误差项沿时间的反向传播</h3><p>沿时间反向传导误差项，就是要计算出$t-1$时刻的误差项$\delta_{t-1}$。</p><script type="math/tex; mode=display">\delta_{t-1}^{T}=\frac{\partial E}{\partial h_{t-1}}</script><script type="math/tex; mode=display">=\frac{\partial E}{\partial h_t}\frac{\partial h_t}{\partial h_{t-1}}</script><script type="math/tex; mode=display">=\delta_{t}^{T}\frac{\partial h_t}{\partial h_{t-1}}</script><p>我们知道，$\frac{\partial h_t}{\partial h_{t-1}}$是一个jacobian矩阵。如果隐藏层$h$的维度是N的话，那么它就是一个$N×N$矩阵。为了求出它，我们列出$h_t$的计算公式：</p><script type="math/tex; mode=display">c_t=f_t°c_{t-1}+i_t°\tilde{c}_t</script><script type="math/tex; mode=display">h_t=o_t°\tan\textrm{h}\left(c_t\right)</script><p>显然，$o_t、f_t、i_t、\tilde{c}_t$都是$h_{t-1}$的函数，那么，利用全导数公式可得：</p><h3 id="4-2-将误差项传递到上一层"><a href="#4-2-将误差项传递到上一层" class="headerlink" title="4.2 将误差项传递到上一层"></a>4.2 将误差项传递到上一层</h3><h3 id="4-3-权重梯度的计算"><a href="#4-3-权重梯度的计算" class="headerlink" title="4.3 权重梯度的计算"></a>4.3 权重梯度的计算</h3><h2 id="五、LSTM的变体—GRU（Gated-Recurrent-Unit）"><a href="#五、LSTM的变体—GRU（Gated-Recurrent-Unit）" class="headerlink" title="五、LSTM的变体—GRU（Gated Recurrent Unit）"></a>五、LSTM的变体—GRU（Gated Recurrent Unit）</h2><p>前面我们讲了一种最为普通的LSTM，事实上LSTM存在很多变体，许多论文中的LSTM都或多或少的不太一样。只要遵守几个关键点，就可以根据需求设计需要的Gated RNNS。在众多的LSTM变体中，GRU也许是最成功的一种。它对LSTM做了很多简化，同时却保持着和LSTM相同的效果。因此，GRU最近变得越来越流行。</p><p>GRU对LSTM做了两个大改动：</p><ul><li>1）将输入门、遗忘门、输出门变为两个门：更新门（Update Gate）$z_t$和重置门（Reset Gate）$r_t$。</li><li>2）将单元状态与输出合并为一个状态：$h$</li></ul><p>GRU的前向计算公式为：</p><script type="math/tex; mode=display">z_t=\sigma(W_z·[h_{t-1},x_t])</script><script type="math/tex; mode=display">r_t=\sigma(W_r·[h_{t-1},x_t])</script><script type="math/tex; mode=display">\tilde{h}_t=\tan\textrm{h}\left(W·\left[r_t°h_{t-1},x_t\right]\right)</script><script type="math/tex; mode=display">h=\left(1-z_t\right)°h_{t-1}+z_t°\tilde{h}_t</script><p>下图是GRU的示意图：<img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-25%20%E4%B8%8B%E5%8D%883.08.02.png" alt="屏幕快照 2017-04-25 下午3.08.02"><br>GRU的训练算法比LSTM相对也要简单一些</p><p>当然还有很多其他的变体，如<a href="ftp://ftp.idsia.ch/pub/juergen/TimeCount-IJCNN2000.pdf" target="_blank" rel="noopener"> Gers &amp; Schmidhuber (2000) </a>提出的LSTM变体增加了“peephole connection”；另一种变体使用coupled 遗忘和输入门对遗忘和需要的信息一同做出决定。<a href="https://arxiv.org/pdf/1508.03790v2.pdf" target="_blank" rel="noopener">Yao, et al. (2015)</a> 提出的Depth Gated RNN。还有用一些完全不同的观点来解决长期依赖的问题，如<a href="https://arxiv.org/pdf/1402.3511v1.pdf" target="_blank" rel="noopener">Koutnik, et al. (2014) </a>提出的Clockwork RNN。</p><p>但<a href="https://arxiv.org/pdf/1503.04069.pdf" target="_blank" rel="noopener">Greff, et al. (2015)</a>给出了流行变体的比较，结论是它们基本上是一样的。<a href="http://proceedings.mlr.press/v37/jozefowicz15.pdf" target="_blank" rel="noopener">Jozefowicz, et al. (2015) </a>则在超过一万种RNN架构上进行了测试，发现一些架构在某些任务上也取得了比LSTM更好的结果。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、长期依赖问题（Long-Term-Dependencies）&quot;&gt;&lt;a href=&quot;#一、长期依赖问题（Long-Term-Dependencies）&quot; class=&quot;headerlink&quot; title=&quot;一、长期依赖问题（Long-Term Dependencies）&quot;&gt;&lt;/a&gt;一、长期依赖问题（Long-Term Dependencies）&lt;/h2&gt;&lt;p&gt;循环神经网络（RNN）在实际应用中很难处理长距离依赖的问题。&lt;/p&gt;
&lt;p&gt;有的时候，我们仅仅需要知道先前的信息来完成预测任务。例如，我们有一个语言模型用来基于先前的词来预测下一个词，比如我们预测“the clouds are in the sky”最后的词的时候，我们不需要任何其他的上下文，很显然下一个词就是sky。在这种情况下，相关的信息与需要预测的词位置之间的间隔很小，而RNN可以学会使用较近距离的信息。&lt;/p&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="长短时记忆网络" scheme="http://yoursite.com/tags/%E9%95%BF%E7%9F%AD%E6%97%B6%E8%AE%B0%E5%BF%86%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>深度学习系列（4）：循环神经网络（RNN）</title>
    <link href="http://yoursite.com/2017/04/23/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%EF%BC%884%EF%BC%89%EF%BC%9A%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88RNN%EF%BC%89/"/>
    <id>http://yoursite.com/2017/04/23/深度学习系列（4）：循环神经网络（RNN）/</id>
    <published>2017-04-23T15:14:45.000Z</published>
    <updated>2017-12-26T10:33:53.349Z</updated>
    
    <content type="html"><![CDATA[<p>之前学习了全连接神经网络和卷积神经网络，以及它们的训练与应用。它们都只能单独的去处理单个的输入，且前后的输入之间毫无关系。但是，在一些任务中，我们需要更好的去处理序列的信息，即前后的输入之间存在关系。比如，在理解一整句话的过程中，孤立理解组成这句话的词是不够的，我们需要整体的处理由这些词连接起来的整个序列；当我们处理视频时，我们也不能单独地仅仅分析每一帧，而要分析这些帧连接起来的整个序列。这就引出了深度学习领域中另一类非常重要的神经网络：循环神经网络（Recurrent Neural Network）。</p><a id="more"></a><h2 id="一、语言模型"><a href="#一、语言模型" class="headerlink" title="一、语言模型"></a>一、语言模型</h2><p>RNN是在自然语言处理领域中最先使用的，如RNN可以为语言模型来建模。那么，何为语言模型？</p><p>自然语言从它产生开始，逐渐演变成一种上下文相关的信息表达和传递的方式，因此让计算机处理自然语言，一个基本的问题就是为自然语言这种上下文相关的特性建立数学模型。这个数学模型就是在自然语言处理中常说的统计语言模型（Statistical Language Model）。它最先由贾里尼克提出。</p><p>我们可以和电脑玩一个游戏，我们写出一个句子前面的一些词，然后，让电脑帮我们写下接下来的一个词，比如下面这句：</p><blockquote><p>我昨天上学迟到了，老师批评了____。</p></blockquote><p>我们给电脑展示了这句话前面这些词，然后让电脑写下接下来的一个词。在这个例子中，接下来的这个词最有可能是“我”，而不可能是“小明”，甚至是“吃饭”。<br>语言模型的出发点很简单：一个句子是否合理，就看看它的可能性大小如何。</p><p>语言模型有很多用处，比如在语音转文本（STT）的应用中，声学模型输出的结果，往往是若干个可能的候选词，这时候就需要语言模型来从这些候选词中选择一个最有可能的。当然，它同样也可以用在图像到文本的识别中（OCR技术）。</p><p>在使用RNN之前，语言模型主要是采用N-Gram。N可以是一个自然数，比如2或者3.它的含义是，假设一个词出现的概率只和前面N个词相关。我们以2-Gram为例。首先，对前面的一句话进行切词：</p><blockquote><p>我 昨天 上学 迟到 了 ， 老师 批评 了 ____。</p></blockquote><p>如果用2-Gram进行建模，那么电脑在预测时，只会看到前面的“了”，然后，电脑会在语料库中，搜索“了”后面最有可能的一个词。不管最后电脑选的是不是“我”，这个模型看起来并不是那么靠谱，因为“了”前面的一大堆实际上丝毫没起作用。如果是3-Gram模型呢，会搜索“批评了”后面最有可能的词，看齐俩感觉比2-Gram靠谱了不少，但还是远远不够的。因为这句话最关键的信息“我”，远在9个词之前！</p><p>似乎我们可以不断提升N的值，比如4-Gram、9-Gram·······。实际上，这个想法是没有实用性的。在实际应用中最多的是N=3的三元模型，更高阶的模型就很少使用了。主要有两个原因。首先，N元模型的大小（或者说空间复杂度）几乎是N的指数函数，即$O(|V|^N)$，这里$|V|$是一种语言词典的词汇量，一般在几万到几十万个。然后，使用N元模型的速度（或者说时间复杂度）也几乎是一个指数函数，即$O(|V|^{N-1})$。因此N不能太大。当N从1到2，再从2到3时，模型的效果上升显著。而当模型从3到4时，效果的提升就不是很显著了，而资源的耗费增加却非常快，所以，除非是不惜资源为了做到极致，很少有人使用四元以上的模型。Google的罗塞塔翻译系统和语言搜索系统，使用的是四元模型，该模型存储于500台以上的Google服务器中。</p><p>RNN就解决了N-Gram的缺陷，它在理论上可以往前看（往后看）任意多个词。</p><h2 id="二、基本循环神经网络"><a href="#二、基本循环神经网络" class="headerlink" title="二、基本循环神经网络"></a>二、基本循环神经网络</h2><p>开始前，我们先回顾一下，简单的MLP三层神经网络模型：<br><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-22%20%E4%B8%8B%E5%8D%885.06.05.png" alt="屏幕快照 2017-04-22 下午5.06.05"><br>其中x是一个向量，它表示输入层的值（这里面没有画出来表示神经元节点的圆圈）；s是一个向量，它表示隐藏层的值（这里隐藏层面画了一个节点，你也可以想象这一层其实是多个节点，节点数与向量s的维度相同）；U是输入层到隐藏层的权重矩阵；o也是一个向量，它表示输出层的值；V是隐藏层到输出层的权重矩阵。</p><p>再看下图中一个简单的循环神经网络图，它由输入层、一个隐藏层和一个输出层组成。我们可以看到，循环神经网络的隐藏层的值s不仅仅取决于当前这次的输入x，还取决于上一次隐藏层的值s。权重矩阵W就是隐藏层上一次的值作为这一次的输入的权重。<br><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-22%20%E4%B8%8B%E5%8D%885.11.21.png" alt="屏幕快照 2017-04-22 下午5.11.21"><br>如果我们把上面的图展开，循环神经网络也可以画成下面这个样子：<br><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-22%20%E4%B8%8B%E5%8D%885.22.35.png" alt="屏幕快照 2017-04-22 下午5.22.35"></p><p>现在看起来就清楚不少了，这个网络在t时刻接收到输入$X_t$之后，隐藏层的值是$S_t$，输出值是$o_t$。关键一点是，$s_t$的值不仅仅取决于$X_t$，还取决于$S_{t-1}$。我们可以使用下面的公式来表示循环神经网络的计算方法：</p><script type="math/tex; mode=display">o_t=g(Vs_t)$$$$s_t=f(Ux_t+Ws_{t-1})</script><p>式1是输出层的计算公式，输出层是一个全连接层，也就是它的每个节点都和隐藏层的每个节点相连。V是输出层的权重矩阵，g是激活函数。式2是隐藏层的计算公式，它是循环层。U是输入x的权重矩阵，W是上一次的值$s_{t-1}$作为这一次的输入的权重矩阵，f是激活函数。</p><p>从上面的公式可以看出，循环层和全连接层的区别就是多了一个权重矩阵W。</p><p>若反复把式2代入带式1，我们将得到：</p><script type="math/tex; mode=display">o_t=g(Vs_t)=g(Vf(Ux_t+Ws_{t-1}))</script><script type="math/tex; mode=display">=g(Vf(Ux_t+Wf(Ux_{t-1}+Ws_{t-2 })))</script><script type="math/tex; mode=display">=g(Vf(Ux_t+Wf(Ux_{t-1}+Wf(Ux_{t-2}+Ws_{t-3 }))))</script><p>从上面可以看出，循环神经网络的输出值$o_t$，是受前面历次输入值$x_{t}$、$x_{t-1}$、$x_{t-2} …$的影响的，这就是为什么循环神经网络可以往前看任意多个输入值的原因。</p><h2 id="三、双向循环神经网络"><a href="#三、双向循环神经网络" class="headerlink" title="三、双向循环神经网络"></a>三、双向循环神经网络</h2><p>对于语言模型来说，很多时候光看前面的词是不够的，比如下面这句话：</p><blockquote><p>我的手机坏了，我打算____一部新手机。</p></blockquote><p>可以想象，如果我们只看横线前面的词，手机坏了，那么我是打算修一修？换一部新的？还是大哭一场？这些都是无法确定的，但是如果我们也看到了后面的词是“一部新手机”，那么横线上的词填“买”的概率就大很多了。</p><p>而这个在单向循环神经网络是无法建模的，因此我们需要双向循环神经网络，如下图所示：<br><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-22%20%E4%B8%8B%E5%8D%885.54.21.png" alt="屏幕快照 2017-04-22 下午5.54.21"></p><p>我们先考虑$y-2$的计算，从上图可以看出，双向卷积神经网络的隐藏层要保存两个值，一个A参与正向计算，另一个$A’$参与反向计算。最终的输出值$y_2$取决于$A_2$和$A_2’$，其计算方法为：</p><script type="math/tex; mode=display">y_2=g(VA_2+V'A_2')</script><p>$A_2$和$A_2’$则分别计算：</p><script type="math/tex; mode=display">A_2=f(WA_1+Ux_2)</script><script type="math/tex; mode=display">A_2'=f(W'A_3'+U'x_2 )</script><p>现在，我们已经可以看出一般的规律：正向计算时，隐藏层的值$s_t$与$s_{t-1}$有关；反向计算时，隐藏层的值$s_t’$与$s_{t+1}’$有关；最终的输出取决于正向和反向计算的加和。现在，我们仿照式1和式2，写出双向循环神经网络的计算方法：</p><script type="math/tex; mode=display">o_t=g(Vs_t+V's_t')</script><script type="math/tex; mode=display">s_t=f(Ux_t+Ws_{t-1 })</script><script type="math/tex; mode=display">s_t'=f(U'x_t+W's_{t+1}')</script><p>从上面三个公式我们可以看到，正向计算和反向计算不共享权重，也就是说$U$和$U’$、$W$和$W’$、$V$和$V’$都是不同的权重矩阵。</p><h2 id="四、深度循环神经网络"><a href="#四、深度循环神经网络" class="headerlink" title="四、深度循环神经网络"></a>四、深度循环神经网络</h2><p>前面我们介绍的循环神经网络只有一个隐藏层，我们当然也可以堆叠两个以上的隐藏层，这样就得到了深度循环神经网络。如下图所示：</p><p><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-22%20%E4%B8%8B%E5%8D%886.11.33.png" alt="屏幕快照 2017-04-22 下午6.11.33"></p><p>我们把第$i$个隐藏层的值表示为$s_t^{(i)}、s_t^{‘(i)}$，则深度循环神经网络的计算方式可以表示为：</p><script type="math/tex; mode=display">o_t=g(V^{(i)}s_t^{(i)}+V^{'(i)}s_t^{'(i)})</script><script type="math/tex; mode=display">s_t^{(i)}=f(U^{(i)}s_t^{i-1}+W^{(i)})</script><script type="math/tex; mode=display">s_t^{'(i)}=f(U^{'(i)}s_t^{'(i-1)}+W^{'(i)}s_{t+1}')</script><script type="math/tex; mode=display">···</script><script type="math/tex; mode=display">s_t^{(1)}=f(U^{(1)}x_t+W^{(1)}s_{t-1})</script><script type="math/tex; mode=display">s_t^{'(1)}=f(U^{'(1)}x_t+W^{'(1)}s_{t+1}')</script><h2 id="五、循环神经网络的训练算法：BPTT"><a href="#五、循环神经网络的训练算法：BPTT" class="headerlink" title="五、循环神经网络的训练算法：BPTT"></a>五、循环神经网络的训练算法：BPTT</h2><p>BPTT算法是针对循环层的训练算法，它的基本原理和BP算法是一样的，也包含同样的三个步骤：</p><ul><li>1）前向计算每个神经元的输出值；</li><li>2）反向计算每个神经元的误差项$\delta_j$，它是误差函数E对神经元$j$的加权输入$net_j$的偏导数；</li><li>3）计算每个权重的梯度。</li><li>4）最后再用随机梯度下降算法更新权重。</li></ul><p>循环层如下图所示：</p><p><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-22%20%E4%B8%8B%E5%8D%889.01.00.png" alt="屏幕快照 2017-04-22 下午9.01.00"></p><h3 id="5-1-前向计算"><a href="#5-1-前向计算" class="headerlink" title="5.1 前向计算"></a>5.1 前向计算</h3><p>使用前面的式2对循环层进行前向计算：</p><script type="math/tex; mode=display">s_t=f(Ux_t+Ws_{t-1})</script><p>注意，上面的$s_t、x_t、s_{t-1}$都是向量，用黑体字表示；而$U、V$是矩阵，用大写字母表示。向量的下标表示时刻，例如，$s_t$表示在$t$时刻向量$s$的值。</p><p>我们假设输入向量x的维度是$m$，输出向量的维度是$n$，则矩阵$U$的维度是$n×m$，矩阵$W$的维度是$n×n$。下面是上式展开成矩阵的样子，看起来更直观一点：</p><script type="math/tex; mode=display">\left[\begin{array}{c}    s_{1}^{t}\\    s_{2}^{t}\\    ·\\    s_{n}^{t}\\\end{array}\right]=f\left(\left[\begin{matrix}    u_{11}&        u_{12}&        ··&        u_{1m}\\    u_{21}&        u_{22}&        ··&        u_{2m}\\    ·&        ·&        ·&        ·\\    u_{n1}&        u_{n2}&        ···&        u_{nm}\\\end{matrix}\right]\left[\begin{array}{c}    x_1\\    x_2\\    ···\\    x_m\\\end{array}\right]+\left[\begin{matrix}    w_{11}&        w_{12}&        ···&        w_{1n}\\    w_{21}&        w_{22}&        ···&        w_{2n}\\    ··&        ··&        ···&        ··\\    w_{n1}&        w_{n2}&        ···&        w_{nn}\\\end{matrix}\right]\left[\begin{array}{c}    s_{1}^{t-1}\\    s_{2}^{t-1}\\    ···\\    s_{n}^{t-1}\\\end{array}\right]\right)</script><p>在这里我们用手写体字母表示向量的一个元素，它的下标表示它是这个向量的第几个元素，它的上标表示第几个时刻。例如，$s_j^t$表示向量$s$的第$j$个元素在$t$时刻的值。$u_{ji}$表示输入层第$i$个神经元到循环层第$j$个神经元的权重。$w_{ji}$表示循环层第$t-1$时刻的第$i$个时刻的第$j$个神经元的权重。</p><h3 id="5-2-误差项的计算"><a href="#5-2-误差项的计算" class="headerlink" title="5.2 误差项的计算"></a>5.2 误差项的计算</h3><p>BTPP算法将第$l$层$t$时刻的误差项$\delta _t^l$值沿两个方向传播，一个方向是其传递到上一层网络，得到$\delta _t^{l-1}$，这部分只和权重矩阵$U$有关；另一个方向是将其沿着时间线传递到初始$t_1$时刻，得到$\delta_1^l$，这部分只和权重矩阵$W$有关。</p><p>我们用向量$net_j$表示神经元在$t$时刻的加权输入，因为：</p><script type="math/tex; mode=display">net_j=Ux_t+Ws_{t-1}$$$$s_{t-1}=f(net_{t-1})</script><p>因此：</p><script type="math/tex; mode=display">\frac{\partial net_t}{\partial net_{t-1}}=\frac{\partial net_t}{\partial s_{t-1}}\frac{\partial s_{t-1}}{\partial net_{t-1}}</script><p>我们用$a$表示列向量，用$a^T$表示行向量。上式的第一项是向量函数对向量求导，其结果为Jacobian矩阵：</p><script type="math/tex; mode=display">\frac{\partial net_t}{\partial s_{t-1}}=\left[\begin{matrix}    w_{11}&        w_{12}&        ···&        w_{1n}\\    w_{21}&        w_{22}&        ···&        w_{2n}\\    ···&        ···&        ···&        ···\\    w_{n1}&        w_{n2}&        ···&        w_{nn}\\\end{matrix}\right]=W</script><p>上式第二项也是一个jacobian矩阵：</p><script type="math/tex; mode=display">\frac{\partial s_{t-1}}{\partial net_{t-1}}=\left[\begin{matrix}    \frac{\partial s_{1}^{t-1}}{\partial net_{1}^{t-1}}&        \frac{\partial s_{1}^{t-1}}{\partial net_{2}^{t-1}}&        ···&        \frac{\partial s_{1}^{t-1}}{\partial net_{n}^{t-1}}\\    \frac{\partial s_{2}^{t-1}}{\partial net_{1}^{t-1}}&        \frac{\partial s_{2}^{t-1}}{\partial net_{2}^{t-1}}&        ···&        \frac{\partial s_{2}^{t-1}}{\partial net_{n}^{t-1}}\\    ···&        ···&        ···&        ···\\    \frac{\partial s_{n}^{t-1}}{\partial net_{1}^{t-1}}&        \frac{\partial s_{n}^{t-1}}{\partial net_{2}^{t-1}}&        ···&        \frac{\partial s_{n}^{t-1}}{\partial net_{n}^{t-1}}\\\end{matrix}\right]</script><script type="math/tex; mode=display">=\left[\begin{matrix}    f'\left(net_{1}^{t-1}\right)&        0&        ···&        0\\    0&        f'\left(net_{2}^{t-1}\right)&        0&        0\\    0&        0&        ···&        0\\    0&        0&        0&        f'\left(net_{n}^{t-1}\right)\\\end{matrix}\right]</script><script type="math/tex; mode=display">=diag\left[f'\left(net_{t-1}\right)\right]</script><p>最后，将俩项合在一起，可得：</p><script type="math/tex; mode=display">\frac{\partial net_t}{\partial net_{t-1}}=\frac{\partial net_t}{\partial s_{t-1}}\frac{\partial s_{t-1}}{\partial net_{t-1}}=W·diag\left[f'\left(net_{t-1}\right)\right]</script><p>上式描述了将$\delta$沿时间往前传递一个时刻的规律，有了这个规律，我们就可以求得任意时刻$k$的误差项$\delta_k$：</p><script type="math/tex; mode=display">\delta_{k}^{T}=\frac{\partial E}{\partial net_k}=\frac{\partial E}{\partial net_t}·\frac{\partial net_t}{\partial net_{t-1}}·\frac{\partial net_{t-1}}{\partial net_{t-2}}···\frac{\partial net_{k+1}}{\partial net_k}</script><script type="math/tex; mode=display">=\delta_{t}^{T}Wdiag\left[f'\left(net_{t-1}\right)\right]Wdiag\left[f'\left(net_{t-2}\right)\right]···Wdiag\left[f'\left(net_k\right)\right]</script><script type="math/tex; mode=display">=\delta_{t}^{T}\prod_{i=k}^{t-1}{Wdiag\left[f'\left(net_i\right)\right]}</script><p>这个就是将误差项沿着时间反向传播的算法。</p><p>循环层将误差项反向传递到上一层网络，与普通的全连接层是完全一样的，在此简要描述一下：<br>循环曾的加权输入$net^l$与上一层的加权输入$net^{l-1}$关系如下：</p><script type="math/tex; mode=display">net^l_t=Ua_t^{l-1}+Ws_{t-1}</script><script type="math/tex; mode=display">a_t^{l-1}=f^{l-1}(net_t^{l-1})</script><p>上式中$net_t^l$是第$l$层神经元的加权输入（假如第$l$是循环层）；$net_t^{l-1}$是$l-1$层神经元的加权输入；$a_t^{l-1}$是第$l-1$层神经元的输出；$f^{l-1}$是第$l-1$层的激活函数。</p><script type="math/tex; mode=display">\frac{\partial net_{t}^{l}}{\partial net_{t}^{l-1}}=\frac{\partial net_{t}^{l}}{\partial a_{t}^{l-1}}\frac{\partial a_{t}^{l-1}}{\partial net_{t}^{l-1}}=U ·diag\left[f'^{l-1}\left(net_{t}^{l-1}\right)\right]</script><p>所以</p><script type="math/tex; mode=display">\delta_{t}^{l-1}=\frac{\partial E}{\partial net_{t}^{l-1}}=\frac{\partial E}{\partial net_{t}^{l}}\frac{\partial net_{t}^{l}}{\partial net_{t}^{l-1}}</script><script type="math/tex; mode=display">=\delta_{t}^{l}·U·diag\left[f'^{l-1}\left(net_{t}^{l-1}\right)\right]</script><p>上式就是将误差项传递到上一层算法。</p><h3 id="5-3-权重梯度的计算"><a href="#5-3-权重梯度的计算" class="headerlink" title="5.3 权重梯度的计算"></a>5.3 权重梯度的计算</h3><p>接下来是BPTT算法的最后一步：计算每个权重的梯度。<br>首先我们计算误差函数$E$对权重矩阵$W$的梯度</p><script type="math/tex; mode=display">\frac{\partial E}{\partial W}</script><p><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-23%20%E4%B8%8A%E5%8D%8811.08.04.png" alt="屏幕快照 2017-04-23 上午11.08.04"></p><p>上图展示了我们到目前为止，在前两步中已经计算得到的量，包括每个时刻$t$循环层的输出值$s_t$，以及误差项$\delta_t$。</p><p>我们只要知道了任意一个时刻的误差项$\delta_t$，以及上一个时刻循环层的输出值$s_{t-1}$，就可以按照下面的公式求出权重矩阵在$t$时刻的梯度：</p><script type="math/tex; mode=display">\nabla_{w_t}E=\left[\begin{matrix}    \delta_{1}^{t}s_{1}^{t-1}&        \delta_{1}^{t}s_{2}^{t-1}&        ···&        \delta_{1}^{t}s_{n}^{t-1}\\    \delta_{2}^{t}s_{1}^{t-1}&        \delta_{2}^{t}s_{2}^{t-1}&        ···&        \delta_{2}^{t}s_{n}^{t-1}\\    ···&        ···&        ···&        ···\\    \delta_{n}^{t}s_{1}^{t-1}&        \delta_{n}^{t}s_{2}^{t-1}&        ···&        \delta_{n}^{t}s_{n}^{t-1}\\\end{matrix}\right]</script><p>上式中，$\delta_i^t$表示$t$时刻误差项向量的第$i$个分量；$s_i^{t-1}$表示$t-1$时刻循环层第$i$个神经元的输出值。</p><p>下面我们简单推导一下上式。</p><p>我们知道</p><script type="math/tex; mode=display">net_t=Ux_t+Ws_{t-1}</script><script type="math/tex; mode=display">\left[\begin{array}{c}    net_{1}^{t}\\    net_{2}^{t}\\    ·\\    net_{n}^{t}\\\end{array}\right]=Ux_t+\left[\begin{matrix}    w_{11}&        w_{12}&        ···&        w_{1n}\\    w_{21}&        w_{22}&        ···&        w_{2n}\\    ···&        ···&        ···&        ···\\    w_{n1}&        w_{n2}&        ···&        w_{nn}\\\end{matrix}\right]\left[\begin{array}{c}    s_{1}^{t-1}\\    s_{2}^{t-1}\\    ···\\    s_{n}^{t-1}\\\end{array}\right]</script><script type="math/tex; mode=display">=Ux_t+\left[\begin{array}{c}    w_{11}s_{1}^{t-1}+w_{12}s_{2}^{t-1}+···+w_{1n}s_{n}^{t-1}\\    w_{21}s_{1}^{t-1}+w_{22}s_{2}^{t-1}+···+w_{2n}s_{n}^{t-1}\\    ···\\    w_{n1}s_{1}^{t-1}+w_{n2}s_{2}^{t-1}+···+w_{nn}s_{n}^{t-1}\\\end{array}\right]</script><p>因为对$W$求导与$Ux_t$无关，我们不加考虑。现在，我们考虑对权重项$w_{ji}$求导。通过观察上式我们可以看到$w_{ji}$只与$net^t_j$有关，所以：</p><script type="math/tex; mode=display">\frac{\partial E}{\partial w_{ji}}=\frac{\partial E}{\partial net_{j}^{t}}\frac{\partial net_{j}^{t}}{\partial w_{ji}}=\delta_{j}^{t}s_{i}^{t-1}</script><p>按照这个规律就可以生成梯度矩阵$\nabla_{w_t}E$了。</p><p>我们已经求得权重矩阵$W$在$t$时刻的梯度$\nabla_{w_t}E$，最终的梯度$\nabla_{w_t}E$是各个时刻的梯度之和：</p><script type="math/tex; mode=display">=\left[\begin{matrix}    \delta_{1}^{t}s_{1}^{t-1}&        \delta_{1}^{t}s_{2}^{t-1}&        ···&        \delta_{1}^{t}s_{n}^{t-1}\\    \delta_{2}^{t}s_{1}^{t-1}&        \delta_{2}^{t}s_{2}^{t-1}&        ···&        \delta_{2}^{t}s_{n}^{t-1}\\    ···&        ···&        ···&        ···\\    \delta_{n}^{t}s_{1}^{t-1}&        \delta_{n}^{t}s_{2}^{t-1}&        ···&        \delta_{n}^{t}s_{n}^{t-1}\\\end{matrix}\right]+···+\left[\begin{matrix}    \delta_{1}^{1}s_{1}^{0}&        \delta_{1}^{1}s_{2}^{0}&        ···&        \delta_{1}^{1}s_{n}^{0}\\    \delta_{2}^{1}s_{1}^{0}&        \delta_{2}^{1}s_{2}^{0}&        ···&        \delta_{2}^{1}s_{n}^{0}\\    ···&        ···&        ···&        ···\\    \delta_{n}^{1}s_{1}^{0}&        \delta_{n}^{1}s_{2}^{0}&        ···&        \delta_{n}^{1}s_{n}^{0}\\\end{matrix}\right]</script><p>这就是计算循环曾权重矩阵$W$的梯度的公式。</p><p>前面介绍了权重梯度的计算方法，看上去比较直观。但为什么最终的梯度的是各个时刻的梯度之和呢？我们前面只是直接用了这个结论，实际上这里面是有道理的。</p><p>我们从这个式子开始：<script type="math/tex">net_t=Ux_t+Wf(net_{t-1})</script>因为$Ux_t$与$W$完全无关，我们把它看做常量。现在，考虑第一个式子加号右边的部分，因为$W$和$f(net_{t-1})$都是$W$的函数，所以，对其求偏导得到：</p><script type="math/tex; mode=display">\frac{\partial net_t}{\partial W}=\frac{\partial W}{\partial W}f\left(net_{t-1}\right)+W\frac{\partial f\left(net_{t-1}\right)}{\partial W}</script><p>我们最终需要计算的是</p><script type="math/tex; mode=display">\nabla_WE=\frac{\partial E}{\partial W}=\frac{\partial E}{\partial net_t}\frac{\partial net_t}{\partial W}=\delta_{t}^{T}\frac{\partial W}{\partial W}f\left(net_{t-1}\right)+\delta_{t}^{T}W\frac{\partial f\left(net_{t-1}\right)}{\partial W}</script><p>我们先计算加号左边的部分。$\frac{\partial W}{\partial W}$是矩阵对矩阵求导，其结果是一个四维张量（tensor），如下所示：</p><script type="math/tex; mode=display">\frac{\partial W}{\partial W}=\left[\begin{matrix}    \frac{\partial w_{11}}{\partial W}&        \frac{\partial w_{12}}{\partial W}&        ···&        \frac{\partial w_{1n}}{\partial W}\\    \frac{\partial w_{21}}{\partial W}&        \frac{\partial w_{22}}{\partial W}&        ···&        \frac{\partial w_{2n}}{\partial W}\\    ···&        ···&        ···&        ···\\    \frac{\partial w_{n1}}{\partial W}&        \frac{\partial w_{n2}}{\partial W}&        ···&        \frac{\partial w_{nn}}{\partial W}\\\end{matrix}\right]</script><script type="math/tex; mode=display">=\left[\begin{matrix}    \left[\begin{matrix}    \frac{\partial w_{11}}{\partial w_{11}}&        ···&        \frac{\partial w_{11}}{\partial w_{1n}}\\    ···&        ···&        ···\\    \frac{\partial w_{11}}{\partial w_{n1}}&        ···&        \frac{\partial w_{11}}{\partial w_{nn}}\\\end{matrix}\right]&        ···&        ···&        \left[\begin{matrix}    \frac{\partial w_{1n}}{\partial w_{11}}&        ···&        \frac{\partial w_{1n}}{\partial w_{1n}}\\    ···&        ···&        ···\\    \frac{\partial w_{1n}}{\partial w_{n1}}&        ···&        \frac{\partial w_{1n}}{\partial w_{nn}}\\\end{matrix}\right]\\    ···&        ···&        ···&        ···\\    ···&        ···&        ···&        ···\\    \left[\begin{matrix}    \frac{\partial w_{n1}}{\partial w_{11}}&        ···&        \frac{\partial w_{n1}}{\partial w_{1n}}\\    ···&        ···&        ···\\    \frac{\partial w_{n1}}{\partial w_{n1}}&        ···&        \frac{\partial w_{n1}}{\partial w_{nn}}\\\end{matrix}\right]&        ···&        ···&        \left[\begin{matrix}    \frac{\partial w_{nn}}{\partial w_{11}}&        ···&        \frac{\partial w_{nn}}{\partial w_{1n}}\\    ···&        ···&        ···\\    \frac{\partial w_{nn}}{\partial w_{n1}}&        ···&        \frac{\partial w_{nn}}{\partial w_{nn}}\\\end{matrix}\right]\\\end{matrix}\right]</script><script type="math/tex; mode=display">=\left[\begin{matrix}    \left[\begin{matrix}    1&        0&        ···&        0\\    0&        0&        ···&        0\\    ···&        ···&        ·&        ···\\    0&        0&        0&        0\\\end{matrix}\right]&        \left[\begin{matrix}    0&        1&        0&        0\\    0&        0&        ···&        0\\    ···&        ···&        ···&        0\\    0&        0&        ···&        0\\\end{matrix}\right]&        ···&        ···\\    ···&        ···&        ···&        ···\\    ···&        ···&        ···&        ···\\    ···&        ···&        ···&        ···\\\end{matrix}\right]</script><p>接下来，我们知道$s_{t-1=f(net_{t-1})}$，它是一个列向量。我们让上面的四维张量与这个向量相乘，得到了一个三维张量，再左乘行向量$\delta_t^T$，最终得到一个矩阵：</p><script type="math/tex; mode=display">\delta_{t}^{T}\frac{\partial W}{\partial W}f\left(net_{t-1}\right)=\delta_{t}^{T}\left[\begin{matrix}    \left[\begin{matrix}    1&        0&        ···&        0\\    0&        0&        ···&        0\\    ···&        ···&        ·&        ···\\    0&        0&        0&        0\\\end{matrix}\right]&        \left[\begin{matrix}    0&        1&        0&        0\\    0&        0&        ···&        0\\    ···&        ···&        ···&        0\\    0&        0&        ···&        0\\\end{matrix}\right]&        ···&        ···\\    ···&        ···&        ···&        ···\\    ···&        ···&        ···&        ···\\    ···&        ···&        ···&        ···\\\end{matrix}\right]\left[\begin{array}{c}    s_{1}^{t-1}\\    s_{2}^{t-1}\\    ···\\    s_{n}^{t-1}\\\end{array}\right]</script><script type="math/tex; mode=display">=\left[\begin{matrix}    \delta_{1}^{t}&        \delta_{2}^{t}&        ···&        \delta_{n}^{t}\\\end{matrix}\right]\left[\begin{matrix}    \left[\begin{array}{c}    s_{1}^{t-1}\\    0\\    ···\\    0\\\end{array}\right]&        \left[\begin{array}{c}    s_{2}^{t-1}\\    0\\    ···\\    0\\\end{array}\right]&        ···&        ···\\    ···&        ···&        ···&        ···\\    ···&        ···&        ···&        ···\\    ···&        ···&        ···&        ···\\\end{matrix}\right]</script><script type="math/tex; mode=display">=\left[\begin{matrix}    \delta_{1}^{t}s_{1}^{t-1}&        \delta_{1}^{t}s_{2}^{t-1}&        ···&        \delta_{1}^{t}s_{n}^{t-1}\\    \delta_{2}^{t}s_{1}^{t-1}&        \delta_{2}^{t}s_{2}^{t-1}&        ···&        \delta_{2}^{t}s_{n}^{t-1}\\    ···&        ···&        ···&        ···\\    \delta_{n}^{t}s_{1}^{t-1}&        \delta_{n}^{t}s_{2}^{t-1}&        ···&        \delta_{n}^{t}s_{n}^{t-1}\\\end{matrix}\right]</script><script type="math/tex; mode=display">=\nabla_{W_t}E</script><p>接下来，我们计算加号右边的部分：</p><script type="math/tex; mode=display">\delta_{t}^{T}W\frac{\partial f\left(net_{t-1}\right)}{\partial W}=\delta_{t}^{T}W\frac{\partial f\left(net_{t-1}\right)}{\partial net_{t-1}}\frac{\partial net_{t-1}}{\partial W}</script><script type="math/tex; mode=display">=\delta_{t}^{T}Wf'\left(net_{t-1}\right)\frac{\partial net_{t-1}}{\partial W}</script><script type="math/tex; mode=display">=\delta_{t}^{T}\frac{\partial net_t}{\partial net_{t-1}}\frac{\partial net_{t-1}}{\partial W}</script><script type="math/tex; mode=display">=\delta_{t-1}^{T}\frac{\partial net_{t-1}}{\partial W}</script><p>我们得到了如下递推公式：</p><script type="math/tex; mode=display">\nabla_WE=\frac{\partial E}{\partial W}=\nabla_{W_t}E+\delta_{t-1}^{T}\frac{\partial net_{t-1}}{\partial W}</script><script type="math/tex; mode=display">=\nabla_{W_t}E+\nabla_{W_{t-1}}E+\delta_{t-2}^{T}\frac{\partial net_{t-2}}{\partial W}</script><script type="math/tex; mode=display">=\nabla_{W_t}E+\nabla_{W_{t-2}}E+···+\nabla_{W_1}E</script><script type="math/tex; mode=display">=\sum_{k=1}^t{\nabla_{W_k}E}</script><p>与权重矩阵$W$类似，我们可以得到权重矩阵$U$的计算方法。</p><script type="math/tex; mode=display">\nabla_{U_t}E=\left[\begin{matrix}    \delta_{1}^{t}x_{1}^{t}&        \delta_{1}^{t}x_{2}^{t}&        ···&        \delta_{1}^{t}x_{m}^{t}\\    \delta_{2}^{t}x_{1}^{t}&        \delta_{2}^{t}x_{2}^{t}&        ···&        \delta_{2}^{t}x_{m}^{t}\\    ···&        ···&        ···&        ···\\    \delta_{n}^{t}x_{1}^{t}&        \delta_{n}^{t}x_{2}^{t}&        ···&        \delta_{n}^{t}x_{m}^{t}\\\end{matrix}\right]</script><p>它是误差函数在$t$时刻对权重矩阵$U$的梯度。和权重矩阵$W$一样，最终的梯度也是各个时刻的梯度之和：</p><script type="math/tex; mode=display">\nabla_UE=\sum_{i=1}^t{\nabla_{U_i}E}</script><p>具体地证明与上述类似。</p><h2 id="六、梯度爆炸与梯度消失"><a href="#六、梯度爆炸与梯度消失" class="headerlink" title="六、梯度爆炸与梯度消失"></a>六、梯度爆炸与梯度消失</h2><p>不幸的是，实践中前面介绍的集中RNNs并不能很好地处理较长的序列。一个主要的原因是，RNN在训练中很容易发生梯度爆炸和梯度消失，这导致训练时梯度不能再较长序列中一直传递下去，从而使RNN无法捕捉到长距离的影响。</p><p>为什么RNN会产生梯度爆炸和梯度消失问题呢？我们根据下式来分析。之前推导过程中得到：</p><script type="math/tex; mode=display">\delta_{k}^{T}=\delta_{t}^{T}\prod_{i=k}^{t-1}{Wdiag\left[f'\left(net_i\right)\right]}</script><script type="math/tex; mode=display">||\delta_{k}^{T}||\le ||\delta_{t}^{T}||\prod_{i=k}^{t-1}{||W||||diag\left[f'\left(net_i\right)\right]||}</script><script type="math/tex; mode=display">\le ||\delta_{t}^{T}||\left(\beta_W\beta_f\right)^{t-k}</script><p>上式的$\beta$定义为矩阵的模的上界。因为上式是一个指数函数，如果$t-k$很大的话（也就是向前看得很远的时候），会导致对应的误差项的值增长或缩小的非常快，这样就会导致相应的梯度爆炸和梯度消失问题（取决于$\beta$大于1还是小于1）。</p><p>通常来说，梯度爆炸更容易处理一些。因为梯度爆炸时，我们的程序会收到NaN的错误。我们也可以设置一个梯度阈值，当梯度超过这个阈值的时候可以直接截取。</p><p>梯度消失更难检测，而且也更难处理一些。总的来说，我们有三种方法应对梯度消失问题：</p><ul><li>1）合理的初始化权重值。初始化权重，使每个神经元尽可能不要取极大或极小值，以躲开梯度消失的区域。</li><li>2）使用ReLu代替sigmoid和tanh作为激活函数。</li><li>3）使用其他结构的RNNs，比如长短时记忆网络（LTSM）和Gated Recurrenr Unit（GRU），这是最流行的做法。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前学习了全连接神经网络和卷积神经网络，以及它们的训练与应用。它们都只能单独的去处理单个的输入，且前后的输入之间毫无关系。但是，在一些任务中，我们需要更好的去处理序列的信息，即前后的输入之间存在关系。比如，在理解一整句话的过程中，孤立理解组成这句话的词是不够的，我们需要整体的处理由这些词连接起来的整个序列；当我们处理视频时，我们也不能单独地仅仅分析每一帧，而要分析这些帧连接起来的整个序列。这就引出了深度学习领域中另一类非常重要的神经网络：循环神经网络（Recurrent Neural Network）。&lt;/p&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="循环神经网络" scheme="http://yoursite.com/tags/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>深度学习系列（3）：卷积神经网络（CNN）</title>
    <link href="http://yoursite.com/2017/04/21/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%EF%BC%883%EF%BC%89%EF%BC%9A%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>http://yoursite.com/2017/04/21/深度学习系列（3）：卷积神经网络/</id>
    <published>2017-04-21T15:14:45.000Z</published>
    <updated>2017-12-26T10:33:48.250Z</updated>
    
    <content type="html"><![CDATA[<p>本文将要介绍一种更适合图像、语音识别任务的神经网络结构——卷积神经网络(Convolutional Neural Network, CNN)。说卷积神经网络是最重要的一种神经网络也不为过，它在最近几年大放异彩，几乎所有图像、语音识别领域的重要突破都是卷积神经网络取得的。它在 2012 年崭露头角，Alex Krizhevsky 凭借它们赢得了那一年的 ImageNet 挑战赛（大体上相当于计算机视觉的年度奥林匹克），他把分类误差记录从 26% 降到了 15%，在当时震惊了世界。自那之后，大量公司开始将深度学习用作服务的核心。Facebook 将神经网络用于自动标注算法、谷歌将它用于图片搜索、亚马逊将它用于商品推荐、Pinterest 将它用于个性化主页推送、Instagram 将它用于搜索架构。打败李世石的AlphaGo也用到了这种网络。本文将详细介绍卷积神经网络的结构以及它的训练算法</p><a id="more"></a><h2 id="一、初识卷积神经网络"><a href="#一、初识卷积神经网络" class="headerlink" title="一、初识卷积神经网络"></a>一、初识卷积神经网络</h2><h3 id="1-1-全连接神经网络与卷积神经网络"><a href="#1-1-全连接神经网络与卷积神经网络" class="headerlink" title="1.1 全连接神经网络与卷积神经网络"></a>1.1 全连接神经网络与卷积神经网络</h3><p>全连接神经网络之所以不太适合图像识别任务，主要有三个方面的问题：</p><ul><li>1）<strong>参数数量太多：</strong>考虑一个输入为1000×1000像素的图片（100万像素，现在已经不能算大图了），输入层有100万个节点。假设第一个隐藏层有100个节点（这个数量并不多），那么仅这一层就有（1000×1000+1）×100=1亿 的参数，这实在是太多了！我们看到图像只扩大一点，参数数量就会多很多，因此其扩展性很差。显而易见，这种全连接方式效率低下，大量的参数也很快会导致过拟合。</li><li><p>2）<strong>没有利用像素之间的位置信息。</strong>对于图像识别任务来说，每个像素和其周围像素的联系是比较紧密的，和离得很远的像素的联系就比较小了。若一个神经元和上一层所有神经元相连，那么就相当于对于一个像素来说，把图像的所有像素都等同对待，这不符合实际情况。当我们完成每个连接权值的学习之后，最终可能会发现，有大量的权值，它们的值都是很小的也就是这些连接其实都是无关紧要的。努力学习大量并不重要的权值，这样的学习必将是非常低效的。比如下面这个喵星人：<img src="http://omu7tit09.bkt.clouddn.com/timg222.jpeg" alt="timg222"><br>我们的任务就是想识别这只猫，按照之前的做法就是把这幅图片转换成一个一维向量，然后作为神经网络的输入。对于人眼的物体识别来说，虽然对人眼识别物体的原理并没有研究明白，但绝不是通过把物体转换为一维向量再做识别的。一张图片必然存在着一定的位置关系，比如猫的鼻子下面有嘴巴、鼻子上面有眼睛，这些都是很明确的位置关系，但要是转换成了一维向量，这些位置关系就被掩盖了。</p></li><li><p>3）<strong>网络层数限制：</strong>我们知道网络层数越多，其表达能力越强，但是通过梯度下降方法训练深度全连接神经网络很困难，因为全连接神经网络的梯度很难传递超过三层。因此，我们不可能得到一个很深的全连接神经网络，也就限制了它的能力。</p></li></ul><p>那卷积神经网络是怎么解决全连接神经网络的这些问题的呢？主要有以下几个方面。</p><h3 id="1-2-激活函数——Relu"><a href="#1-2-激活函数——Relu" class="headerlink" title="1.2 激活函数——Relu"></a>1.2 激活函数——Relu</h3><p>最近几年卷积神经网络中，激活函数往往不选择sigmoid或者tanh函数，而是选择relu函数。relu函数的定义是：</p><script type="math/tex; mode=display">f\left(x\right)=\max\left(x,0\right)</script><p>Relu函数图像如下所示：<br><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-18%20%E4%B8%8B%E5%8D%885.30.02.png" alt="屏幕快照 2017-04-18 下午5.30.02"></p><p>Relu函数作为激活函数，有以下几大优势：</p><ul><li>1）<strong>速度快：</strong>采用sigmoid等函数，算激活函数时（指数运算），计算量大，反向传播求误差梯度时，求导涉及除法，计算量相对大。而Relu函数其实就是一个max（x,0），整个过程的计算量节省很多。</li><li><p>2）<strong>减轻梯度消失问题：</strong>回忆一下计算梯度的公式$\nabla =\sigma^,\delta x$。其中$\sigma ^,$是sigmoid函数的导数。在使用反向传播算法进行梯度计算时，没经过一层sigmoid神经元，梯度就要乘上一个$\sigma ^, $。从下图可以看出，$\sigma^,$函数最大值是$\frac{1}{4}$。因此，乘一个$\sigma ^,$会导致梯度越来越小，这对于深层网络的训练是个很大的问题。而Relu函数的导数是1，不会导致梯度变小。当然，激活函数仅仅是导致梯度减小的一个因素，但无论如何在这方面Relu的表现强于sigmoid。使用Relu激活函数可以让你训练更深的网络。<br><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-18%20%E4%B8%8B%E5%8D%886.09.58.png" alt="屏幕快照 2017-04-18 下午6.09.58"></p></li><li><p>3）通过对大脑的研究发现，大脑在工作的时候只有大约5%的神经元是激活的，而采用sigmoid激活函数的人工神经网络，其激活率大约是50%。有论文声称人工神经网络在15%~30%的激活率时是比较理想的。因为Relu函数在输入小于0的时候是完全不激活的，因此可以获得一个更低的激活率。</p></li></ul><h3 id="1-3-局部感受野（local-receptive-fields）"><a href="#1-3-局部感受野（local-receptive-fields）" class="headerlink" title="1.3 局部感受野（local receptive fields）"></a>1.3 局部感受野（local receptive fields）</h3><p>在之前的全连接神经网络中，一个样例的输入被转换为一个一维向量。但在一个卷积网络中，把输入看作是一个按照28×28排列的正方形，或者当有颜色通道的时候，比如28x28x3，就是宽高都是28，且有3个颜色通道。比如下图就代表了一个输入<img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-18%20%E4%B8%8B%E5%8D%886.38.29.png" alt="屏幕快照 2017-04-18 下午6.38.29"></p><p>然后，我们通常把输入像素连接到一个隐藏层的神经元，但和全连接神经网络那样每个输入都连接一个隐藏层神经元不同的是，这里我们只是把输入图像进行局部的连接。<br><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-18%20%E4%B8%8B%E5%8D%886.44.19.png" alt="屏幕快照 2017-04-18 下午6.44.19"><br>如此不断地重复，构建起第一个隐藏层。注意如果我们有一个28×28的输入图像，5×5的局部感受野，那么隐藏层中就会有24×24个神经元。这是因为在抵达抵达最右边或最底部的输入图像之前，我们只能把局部感受野向右或向下移动23个神经元。<img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-18%20%E4%B8%8B%E5%8D%886.52.03.png" alt="屏幕快照 2017-04-18 下午6.52.03"></p><p>如上图所示，把图中间的那个看作是可以“滑动的窗口”，他的作用是和输入相应的“感受域”下的像素做运算得到新的值。这个运算就是“卷积”运算了。图上面有详细的运算过程。实际上就是每个相应元素的值相乘，然后把得到的都加起来。这个窗口的本质是其中的数字和一个偏置构成的，通常就把这个窗口叫做滤波器或者卷积核。上图是对于一个颜色通道的输入做卷积操作，但通常是三个颜色通道。中间那个“窗口”是可以滑动的，每次的滑动步长可以人为指定。</p><h3 id="1-4-共享权值与偏置（Shared-weights-and-biases）"><a href="#1-4-共享权值与偏置（Shared-weights-and-biases）" class="headerlink" title="1.4 共享权值与偏置（Shared weights and biases）"></a>1.4 共享权值与偏置（Shared weights and biases）</h3><p>权值共享是指在一个模型的多个函数中使用相同的参数。 在传统的神经网络中，当计算一层的输出时，权值矩阵的每一个元素只使用一次， 当它乘以输入的一个元素后就再也不会用到了。而在卷积神经网络中，我们对24×24的隐藏层神经元的每一个使用相同的权重和偏置，这样可以很好地使用图像的平移不变性（例如稍稍移动一副猫的图像，它仍然是一副猫的图像）。因为这个原因，我们有时候把输入层到隐藏层的映射称为一个特征映射。把定义特征映射的权重称为共享权重，把以这种方式定义特征映射的偏置称为共享偏置。共享权值和偏置通常被称为一个卷积核或者滤波器。共享权值和偏置有一个很大的优点就是，它大大较少了参与卷积网络的参数，它的平移不变性将会使训练更快，有助于我们使用卷积层建立深度网络。</p><h3 id="1-5-池化（pooling）"><a href="#1-5-池化（pooling）" class="headerlink" title="1.5 池化（pooling）"></a>1.5 池化（pooling）</h3><p>在连续的卷积层之间会周期性地插入一个池化层。经过池化层前后，发生的变化如下图所示：<br><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-18%20%E4%B8%8B%E5%8D%887.35.49.png" alt="屏幕快照 2017-04-18 下午7.35.49"><br>它的作用是逐渐降低数据体的空间尺寸，这样的话就能减少网络中参数的数量，使得计算资源耗费变少，也能有效控制过拟合。上图是一个MAX Pooling的过程，对输入数据体的每一个深度切片独立进行操作，改变它的空间尺寸。最常见的形式是汇聚层使用尺寸2x2的滤波器，以步长为2来对每个深度切片进行降采样，将其中75%的激活信息都丢掉。每个MAX操作是从4个数字中取最大值（也就是在深度切片中某个2x2的区域）。深度保持不变。<br><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-18%20%E4%B8%8B%E5%8D%887.36.16.png" alt="屏幕快照 2017-04-18 下午7.36.16"></p><h2 id="二、卷积神经网络的层"><a href="#二、卷积神经网络的层" class="headerlink" title="二、卷积神经网络的层"></a>二、卷积神经网络的层</h2><p>首先，让我们对卷积神经网络有一个感性的认识，下图就是一个卷积神经网络的示意图：<img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-18%20%E4%B8%8B%E5%8D%887.42.43.png" alt="屏幕快照 2017-04-18 下午7.42.43"><br>如上图所示，一个神经网络由若干卷积层（CONV）、Pooling层（POOL）、全连接层（FC）组成。你可以构建各种不同的卷积神经网络，它的常用架构模式为：</p><script type="math/tex; mode=display">INPUT\rightarrow\left[\left[CONV\right]\times N\rightarrow POOL\right]\times M\rightarrow\left[FC\right]\times K</script><p>也就是N个卷积层叠加，然后叠加一个Pooling层（可选），重复这个结构M次，最后叠加K个全连接层。</p><p>对于上图来说，该卷积神经网络的架构为：</p><script type="math/tex; mode=display">INPUT\rightarrow\left[\left[CONV\right]\times 1\rightarrow POOL\right]\times 2\rightarrow\left[FC\right]\times 2</script><p>也就是$N=1,M=2,K=2$</p><p>从中我们可以发现卷积神经网络和全连接神经网络的层结构有很大不同。全连接网络每层的神经元是按照一维排列的，也就是排成一条线的样子；而卷积神经网络每层的神经元是按照三维排列的，也就是排成一个长方体的样子，有宽度、高度和深度。</p><p>我们看到输入层的宽度和高度对应于输入图像的宽度和高度，而他的深度为1。接着第一个卷积层对这幅图像进行了卷积操作，得到了三个Feature Map。实际上这个卷积层包含三个Filter，也就是三套参数，每个Filter都可以把原始输入图像卷积得到一个Feature Map，三个Filter就可以得到三个Feature Map。至于一个卷积层可以有多少个Filter，那是可以自由设定的。也就是说，卷积层的Filter个数也是一个超参数。我们可以把Feature Map可以看做是通过卷积变换提取到的图像特征，三个Filter就对原始图像提取出三组不同的特征，也就是得到了三个Feature Map，也称做三个通道(channel)。</p><p>在第一个卷积层之后，Pooling层对三个Feature Map做了下采样，得到了三个更小的Feature Map。接着，是第二个卷积层，它有5个Filter。每个Fitler都把前面下采样之后的3个Feature Map卷积在一起，得到一个新的Feature Map。这样，5个Filter就得到了5个Feature Map。接着，是第二个Pooling，继续对5个Feature Map进行下采样，得到了5个更小的Feature Map。</p><p>最后两层是全连接层。第一个全连接层的每个神经元，和上一层5个Feature Map中的每个神经元相连，第二个全连接层(也就是输出层)的每个神经元，则和第一个全连接层的每个神经元相连，这样得到了整个网络的输出。</p><p>至此，我们对卷积神经网络有了最基本的感性认识。接下来，我们将介绍卷积神经网络中各种层的计算和训练。</p><h3 id="2-1-卷积层"><a href="#2-1-卷积层" class="headerlink" title="2.1 卷积层"></a>2.1 卷积层</h3><p>卷积层的参数是一些可学习的滤波器集合（卷积核）构成，滤波器的宽度和高度一般不大，深度与其输入数据保持一致。见下图：<br><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-18%20%E4%B8%8B%E5%8D%888.13.51.png" alt="屏幕快照 2017-04-18 下午8.13.51"><br><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-18%20%E4%B8%8B%E5%8D%888.15.18.png" alt="屏幕快照 2017-04-18 下午8.15.18"><br><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-18%20%E4%B8%8B%E5%8D%888.16.30.png" alt="屏幕快照 2017-04-18 下午8.16.30"><br><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-18%20%E4%B8%8B%E5%8D%888.17.17.png" alt="屏幕快照 2017-04-18 下午8.17.17"><br>在上面的过程中，原图像是32×32×3的图像，我们有一个滤波器（卷积核）为5×5×3，5×5的宽高相比起32×32来说，不怎么大，深度3和输入数据保持一致。一个卷积核在原图像上滑动，可以生成一个activation map，这里有6个不同的卷积核，得到的6个不同的activation map分别表示诸如边缘特征、形状特征等特征图，将这些activation map映射在深度方向上层叠起来就生成了输出数据。所以在用了6个过滤器（卷积层）之后，我们可以得到28×28×6的激活图。对各个activation map的直观感受可以看下图，其中每一个activation map代表着不同层次的特征。<br><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-18%20%E4%B8%8B%E5%8D%888.26.51.png" alt="屏幕快照 2017-04-18 下午8.26.51"></p><h4 id="2-1-1-卷积层输出值的计算"><a href="#2-1-1-卷积层输出值的计算" class="headerlink" title="2.1.1 卷积层输出值的计算"></a>2.1.1 卷积层输出值的计算</h4><p>我们使用一个简单的例子来讲述如何计算卷积，然后，抽象出卷积层的一些重要概念和计算方法。</p><p>假设有一个5×5的图像，使用一个3×3的滤波器进行卷积，想得到3×3的Feature Map，如下所示：<img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-18%20%E4%B8%8B%E5%8D%888.41.38.png" alt="屏幕快照 2017-04-18 下午8.41.38"><br>为了清楚地描述卷积的计算过程，我们首先对图像的每个像素进行编号，用$x_{i,j}$表示图像的第$i$行第$j$列元素；对filter的每个权重进行编号，用$w_{m,n}$表示第$m$行第$n$列权重，用$w_b$表示filter的偏置项；对Feature Map的每个元素进行编号，用$a_{i,j}$表示Feature Map的第$i$行第$j$列元素；用$f$表示激活函数（此处使用Relu函数作为激活函数）。然后使用下列公式计算卷积：</p><script type="math/tex; mode=display">a_{i,j}=f\left(\sum_{m=0}^2{\sum_{n=0}^2{w_{m,n}x_{m+i,n+j}}}+w_b\right)</script><p>例如，对于Feature Map的左上角元素$a_{0,0}$来说，其卷积计算方法为：</p><script type="math/tex; mode=display">a_{0,0}=f\left(\sum_{m=0}^2{\sum_{n=0}^2{w_{m,n}x_{m+0,n+0}}}+w_b\right)=Relu\left(4\right)=4</script><p>按照这个公式可以依次计算出Feature Map中所有的值，下面的动画显示了整个Feature Map的计算过程：<br><img src="http://upload-images.jianshu.io/upload_images/2256672-19110dee0c54c0b2.gif" alt=""><br>上面的计算过程中，步幅（stride）为1。当然步幅可以设为大于1的数。例如，当步幅为2时，Feature Map计算如下：<br><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-18%20%E4%B8%8B%E5%8D%888.57.29.png" alt="屏幕快照 2017-04-18 下午8.57.29"><br>这里我们可以看到，当把步幅设置为2时，Feature Map就变成了2×2了。这说明图像大小、步幅和卷积后的Feature Map大小是有关系的。我们设卷积前的图像宽度为$N$，步幅为$S$，filter的边长为$F$，卷积后Feature Map宽度为$N_f$，如图所示<img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-18%20%E4%B8%8B%E5%8D%889.02.40.png" alt="屏幕快照 2017-04-18 下午9.02.40"><br>则它们之间的关系为：</p><script type="math/tex; mode=display">N_f=\frac{N-F}{S}+1</script><p>但是这样持续卷积运算下去会出现一些问题，比如下图：<br><img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-18%20%E4%B8%8B%E5%8D%889.08.18.png" alt="屏幕快照 2017-04-18 下午9.08.18"></p><p>每经过一个filter，得到的激活图就会小一些，要是经过好几个，会导致最后消失殆尽。所以我们通过零填充（zero padding）的方法在原始图像周围补上几圈0，将补上的圈数设为$P$，则改写我们之前的关系式为：</p><script type="math/tex; mode=display">N_f=\frac{N+2P-F}{S}+1</script><p>这里$P$乘以2是加了一圈之后两侧都加了1。例如上方那幅图中，$N=5$，$F=3$，$S=1$，我们想保持卷积前后的尺寸保持不变，即$N_f=N=5$，则零填充的$P$为：</p><script type="math/tex; mode=display">P=\frac{(N_f-1)S+F-N}{2}=\frac{(5-1)×1+3-5}{2}=1</script><p>到此我们讲了深度为1的卷积层的计算方法，如果深度大于1怎么计算呢？其实也是类似的。如果卷积前的图像深度为$D$，那么相应的filter的深度也必须为$D$。我们扩展一些之前的式子，得到深度为$D$的卷积计算公式：</p><script type="math/tex; mode=display">a_{i,j}=f\left(\sum_{d=0}^{D-1}{\sum_{m=0}^{M-1}{\sum_{n=0}^{N-1}{w_{d,m,n}x_{d,m+i,n+j}}}}+w_b\right)</script><p>该式中，$D$为深度；$w_{d,m,n }$表示filter的第d层第m行第n列的权重；$a_{d,i,j }$表示图像的第d层第i行第j列像素。<br>我们前面还曾提到，每个卷积层可以有多个filterr。每个filter和原始图像进行卷积之后，都可以得到一个Feature Map。因此，卷积后Feature Map的深度和卷积层的filter个数是相同的。</p><p>下面的动画显示了包含两个filter的卷积层的计算。我们可以看到7×7×3的输入，经过两个3×3×3filter的卷积，其步幅为2，得到了3×3×2的输出，另外我们也会看到下图的Zero Padding是1，也就是在输入元素的周围补了一圈0。Zero Padding对图像边缘部分的特征提取是很有帮助的。<img src="http://upload-images.jianshu.io/upload_images/2256672-958f31b01695b085.gif" alt=""></p><p>以上就是卷积层的计算方法。这里面体现了局部连接和权值共享：每层神经元只和上一层部分神经元相连（卷积计算规则），且filter的权值对于上一层所有神经元都是一样的。对于包含两个3×3×3的filter的卷积层来说，其参数数量仅有$(3×3×3+1)×2=56$个，且参数数量与上一层神经元个数无关。与全连接神经网络相比，其参数数量大大减少了。</p><h4 id="2-1-2-用卷积公式来表达卷积层计算"><a href="#2-1-2-用卷积公式来表达卷积层计算" class="headerlink" title="2.1.2 用卷积公式来表达卷积层计算"></a>2.1.2 用卷积公式来表达卷积层计算</h4><p>之前计算卷积层输出的式子很繁冗，最好可以简化一下</p><h3 id="2-2-池化层（Pooling-layer）"><a href="#2-2-池化层（Pooling-layer）" class="headerlink" title="2.2  池化层（Pooling layer）"></a>2.2  池化层（Pooling layer）</h3><p>Pooling层的主要作用就是通过下采样，去掉Feature Map中不重要的样本，进一步减少参数数量，降低了计算成本，而且可以控制过拟合（overfitting）。池化层并不会对Feature map的深度有影响，即还是会保持原来的深度。<img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-18%20%E4%B8%8B%E5%8D%889.50.46.png" alt="屏幕快照 2017-04-18 下午9.50.46"></p><p>Pooling的方法很多，最常用的是Max Pooling，它实际上就是在$n×n$的样本中取最大值，作为采样后的样本值。下图是2×2 Max Pooling：<img src="http://omu7tit09.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-18%20%E4%B8%8B%E5%8D%889.49.10.png" alt="屏幕快照 2017-04-18 下午9.49.10"></p><p>此外，还有平均池化（average pooling）和L2-norm池化。平均汇聚历史上比较常用，但是现在已经很少使用了。因为实践证明，最大汇聚的效果比平均汇聚要好。池化层背后的直观推理是：一旦我们知道了原始输入中一个特定的特征，它与其他特征的相对位置就比它的绝对位置更重要。</p><p>很多人不喜欢汇聚操作，认为可以不使用它。比如在Striving for Simplicity: The All Convolutional Net一文中，提出使用一种只有重复的卷积层组成的结构，抛弃池化层。通过在卷积层中使用更大的步长来降低数据体的尺寸。有发现认为，在训练一个良好的生成模型时，弃用池化层也是很重要的。比如变化自编码器（VAEs：variational autoencoders）和生成性对抗网络（GANs：generative adversarial networks）。现在看起来，未来的卷积网络结构中，无池化层的结构不太可能扮演重要的角色。</p><h3 id="2-3-归一化层"><a href="#2-3-归一化层" class="headerlink" title="2.3 归一化层"></a>2.3 归一化层</h3><p>在卷积神经网络的结构中，提出了很多不同类型的归一化层，有时候是为了实现在生物大脑中观测到的抑制机制。但是这些层渐渐都不再流行，因为实践证明它们的效果即使存在，也是极其有限的。</p><h3 id="2-4-全连接层"><a href="#2-4-全连接层" class="headerlink" title="2.4 全连接层"></a>2.4 全连接层</h3><p>全连接层输出值的计算经网络和全连接神经网络是一样的，这里就不再赘述了。</p><h2 id="三、卷积神经网络的训练"><a href="#三、卷积神经网络的训练" class="headerlink" title="三、卷积神经网络的训练"></a>三、卷积神经网络的训练</h2><p>和全连接神经网络相比，卷积神经网络的训练要复杂一些。但训练的原理是一样的：利用链式求导计算损失函数对每个权重的偏导数（梯度），然后根据梯度下降公式更新权值。训练算法依然是反向传播算法。</p><p>我们知道神经网络和反向传播那一节中介绍的反向传播算法，它的整个算法分为三个基本步骤：</p><ul><li>1）前向计算每个神经元的输出值$a_j$（$j$表示网络的第$j$个神经元，以下同）；</li><li>2）反向计算每个神经元的误差项$\delta_j$，$\delta_j$在有的文献中也叫作敏感度（sensitivity）。它实际上是网络的损失函数$E_d$对神经元加权输出$net_j$的偏导数，即$\delta_j=\frac{\partial E_d}{\partial net_j}$；</li><li>3）计算每个神经元连接权重$w_{ij}$的梯度（$w_{ij}$表示从神经元$i$连接到神经元$j$的权重，公式为$\frac{\partial E_d}{\partial w_{ji}}=a_i\delta_j$）,其中，$a_i$表示神经元$i$的输出。</li><li>4）根据梯度下降法更新每个权重即可</li></ul><p>对于卷积神经网络，由于涉及到局部连接、下采样等操作，影响到了第二部误差项$\delta$的具体计算方法，而权值共享影响了第三步权重$w$的梯度的计算方法。接下来，我们分别介绍卷积层和池化层的训练算法。</p><h3 id="3-1-卷积层的训练"><a href="#3-1-卷积层的训练" class="headerlink" title="3.1 卷积层的训练"></a>3.1 卷积层的训练</h3><h3 id="3-2-Pooling层的训练"><a href="#3-2-Pooling层的训练" class="headerlink" title="3.2 Pooling层的训练"></a>3.2 Pooling层的训练</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将要介绍一种更适合图像、语音识别任务的神经网络结构——卷积神经网络(Convolutional Neural Network, CNN)。说卷积神经网络是最重要的一种神经网络也不为过，它在最近几年大放异彩，几乎所有图像、语音识别领域的重要突破都是卷积神经网络取得的。它在 2012 年崭露头角，Alex Krizhevsky 凭借它们赢得了那一年的 ImageNet 挑战赛（大体上相当于计算机视觉的年度奥林匹克），他把分类误差记录从 26% 降到了 15%，在当时震惊了世界。自那之后，大量公司开始将深度学习用作服务的核心。Facebook 将神经网络用于自动标注算法、谷歌将它用于图片搜索、亚马逊将它用于商品推荐、Pinterest 将它用于个性化主页推送、Instagram 将它用于搜索架构。打败李世石的AlphaGo也用到了这种网络。本文将详细介绍卷积神经网络的结构以及它的训练算法&lt;/p&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="卷积神经网络" scheme="http://yoursite.com/tags/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
